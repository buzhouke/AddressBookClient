{"version":3,"file":"dist/js/vendors~main~mobile.js","sources":["webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@popperjs/core/lib/utils/getOppositeVariationPlacement.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/rxjs/_esm5/internal/util/isFunction.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@popperjs/core/lib/modifiers/preventOverflow.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@fluentui/dom-utilities/lib/portalContainsElement.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/style-value-types/dist/es/complex/filter.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@fluentui/merge-styles/lib/styleToClassName.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/timers-browserify/main.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@tiptap/extension-paragraph/dist/index.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/prosemirror-schema-list/dist/index.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@fluentui/react-hooks/lib/useUnmount.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@babel/runtime/helpers/toPrimitive.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/popmotion/dist/es/utils/mix-color.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@popperjs/core/lib/utils/getFreshSideObject.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/prosemirror-tables/dist/index.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@popperjs/core/lib/utils/within.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@babel/runtime/helpers/esm/toArray.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@popperjs/core/lib/modifiers/arrow.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@popperjs/core/lib/dom-utils/getClippingRect.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/rxjs/_esm5/internal/symbol/rxSubscriber.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@popperjs/core/lib/dom-utils/getViewportRect.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/rxjs/node_modules/tslib/tslib.es6.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/ieee754/index.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/react-modal-sheet/dist/react-modal-sheet.esm.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@fluentui/date-time-utilities/lib/dateGrid/isRestrictedDate.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@tiptap/extension-code/dist/index.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@popperjs/core/lib/modifiers/flip.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@popperjs/core/lib/utils/getAltAxis.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/react-reactive-var/dist/index.es.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@fluentui/merge-styles/lib/extractStyleParts.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@popperjs/core/lib/dom-utils/getBoundingClientRect.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@popperjs/core/lib/dom-utils/getCompositeRect.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/framesync/dist/es/create-render-step.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@tiptap/extension-table-header/dist/index.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@popperjs/core/lib/dom-utils/getParentNode.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@babel/runtime/helpers/esm/typeof.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@fluentui/style-utilities/lib/styles/getPlaceholderStyles.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@babel/runtime/helpers/esm/iterableToArray.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@fluentui/foundation-legacy/lib/utilities.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@fluentui/react-hooks/lib/useBoolean.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@fluentui/dom-utilities/lib/getVirtualParent.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/popmotion/dist/es/animations/utils/elapsed.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@tiptap/pm/state/dist/index.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/popmotion/dist/es/animations/inertia.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/clsx/dist/clsx.m.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@fluentui/react-window-provider/lib/WindowProvider.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@fluentui/date-time-utilities/lib/dateValues/dateValues.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/prosemirror-transform/dist/index.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@griffel/react/RendererContext.esm.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@fluentui/date-time-utilities/lib/dateGrid/findAvailableDate.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@babel/runtime/helpers/esm/inherits.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/react-merge-refs/dist/react-merge-refs.esm.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@griffel/react/insertionFactory.esm.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/style-value-types/dist/es/color/hsla.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@react-aria/overlays/dist/module.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@fluentui/merge-styles/lib/fontFace.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@babel/runtime/helpers/esm/classCallCheck.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@fluentui/react-focus/lib/components/FocusZone/FocusZone.types.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@fluentui/style-utilities/lib/styles/getFocusStyle.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@fluentui/theme/lib/mergeThemes.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/popmotion/dist/es/animations/utils/detect-animation-from-options.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/react-i18next/dist/es/utils.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@griffel/core/mergeClasses.esm.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@internationalized/number/dist/module.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/bowser/es5.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@tiptap/extension-color/dist/index.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@griffel/core/runtime/utils/normalizeCSSBucketEntry.esm.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@babel/runtime/helpers/esm/inheritsLoose.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@tiptap/extension-bold/dist/index.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@fluentui/react-portal-compat-context/lib/PortalCompatContext.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/popmotion/dist/es/animations/index.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@griffel/core/devtools/react-render-tracker/stackTrace.esm.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@tiptap/pm/commands/dist/index.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@fluentui/dom-utilities/lib/findElementRecursive.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@fluentui/style-utilities/lib/styles/CommonStyles.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/rxjs/_esm5/internal/util/toSubscriber.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@popperjs/core/lib/dom-utils/getComputedStyle.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/tslib/tslib.es6.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/popmotion/dist/es/utils/mix.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@babel/runtime/helpers/esm/toPropertyKey.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/popmotion/dist/es/utils/is-point-3d.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/prosemirror-state/dist/index.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/rxjs/_esm5/internal/Subscriber.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@fluentui/merge-styles/lib/concatStyleSets.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@fluentui/react-hooks/lib/useId.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/react/index.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@react-aria/ssr/dist/module.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@fluentui/react-hooks/lib/useAsync.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/rxjs/_esm5/internal/util/UnsubscriptionError.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@popperjs/core/lib/modifiers/applyStyles.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/rxjs/_esm5/internal/util/isObject.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/process/browser.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@tiptap/extension-list-item/dist/index.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@fluentui/style-utilities/lib/utilities/buildClassMap.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@tiptap/extension-gapcursor/dist/index.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@popperjs/core/lib/utils/getBasePlacement.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@fluentui/style-utilities/lib/utilities/icons.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/buffer/index.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/i18next-resources-to-backend/dist/umd/i18nextResourcesToBackend.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@fluentui/react-file-type-icons/lib/FileTypeIconMap.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@fluentui/dom-utilities/lib/elementContains.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/react-router/index.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@fluentui/merge-styles/lib/shadowConfig.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/rxjs/_esm5/internal/Observable.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@fluentui/date-time-utilities/lib/dateFormatting/dateFormatting.defaults.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@tiptap/extension-document/dist/index.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@fluentui/theme/lib/fonts/createFontStyles.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/style-value-types/dist/es/numbers/units.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/uuid/dist/esm-browser/v4.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@tiptap/pm/keymap/dist/index.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@tiptap/extension-underline/dist/index.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@tiptap/extension-table/dist/index.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@babel/runtime/helpers/toPropertyKey.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@fluentui/dom-utilities/lib/getActiveElement.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/rxjs/_esm5/internal/operators/map.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@fluentui/merge-styles/lib/cloneCSSStyleSheet.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@react-aria/utils/dist/module.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@griffel/core/devtools/store.esm.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@babel/runtime/helpers/defineProperty.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/popmotion/dist/es/animations/generators/keyframes.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/popmotion/dist/es/utils/pipe.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@griffel/react/__styles.esm.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/style-value-types/dist/es/color/index.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@tiptap/extension-placeholder/dist/index.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/rxjs/_esm5/internal/Subscription.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/rxjs/_esm5/internal/BehaviorSubject.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@popperjs/core/lib/utils/computeAutoPlacement.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@fluentui/merge-styles/lib/mergeStyleSets.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@griffel/core/devtools/isDevToolsEnabled.esm.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@fluentui/react-hooks/lib/useTarget.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@babel/runtime/helpers/esm/createClass.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@fluentui/date-time-utilities/lib/dateMath/dateMath.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@tiptap/extension-mention/dist/index.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@tiptap/pm/tables/dist/index.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@popperjs/core/lib/dom-utils/getDocumentRect.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@popperjs/core/lib/dom-utils/isTableElement.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/prosemirror-history/dist/index.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/style-value-types/dist/es/complex/index.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@popperjs/core/lib/utils/math.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@popperjs/core/lib/dom-utils/getDocumentElement.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@tiptap/extension-text-style/dist/index.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/style-value-types/dist/es/color/utils.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@griffel/core/constants.esm.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@fluentui/date-time-utilities/lib/dateGrid/isContiguous.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@tiptap/extension-code-block/dist/index.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/uuid/dist/esm-browser/validate.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@fluentui/theme/lib/effects/DefaultEffects.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@fluentui/merge-styles/lib/mergeStyles.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/uuid/dist/esm-browser/rng.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@tiptap/extension-strike/dist/index.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/popmotion/dist/es/animations/generators/spring.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@fluentui/theme/lib/effects/FluentDepths.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@emotion/hash/dist/emotion-hash.esm.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@tiptap/pm/gapcursor/dist/index.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/isarray/index.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@popperjs/core/lib/enums.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@fluentui/dom-utilities/lib/isVirtualElement.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@griffel/core/runtime/utils/hashSequence.esm.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@fluentui/set-version/lib/setVersion.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@griffel/core/devtools/injectDevTools.esm.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/history/index.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/prosemirror-commands/dist/index.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/w3c-keyname/index.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@babel/runtime/helpers/typeof.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@popperjs/core/lib/utils/userAgent.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/tippy.js/dist/tippy.esm.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@fluentui/react-hooks/lib/useWarnings.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@popperjs/core/lib/utils/computeOffsets.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/react-i18next/dist/es/useTranslation.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@fluentui/react-hooks/lib/useControllableValue.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/rope-sequence/dist/index.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@react-aria/interactions/dist/module.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@popperjs/core/lib/popper.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@tiptap/pm/history/dist/index.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@babel/runtime/helpers/iterableToArrayLimit.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@fluentui/style-utilities/lib/styles/GeneralStyles.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@tiptap/extension-horizontal-rule/dist/index.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/popmotion/dist/es/utils/progress.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@popperjs/core/lib/utils/expandToHashMap.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@fluentui/react-hooks/lib/useSetTimeout.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@tiptap/suggestion/dist/index.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@tiptap/react/dist/index.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@babel/runtime/helpers/classCallCheck.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@popperjs/core/lib/modifiers/popperOffsets.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@popperjs/core/lib/dom-utils/contains.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@popperjs/core/lib/dom-utils/getOffsetParent.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@popperjs/core/lib/utils/getMainAxisFromPlacement.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@fluentui/foundation-legacy/lib/createComponent.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@popperjs/core/lib/modifiers/computeStyles.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@fluentui/react-file-type-icons/lib/initializeFileTypeIcons.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@babel/runtime/helpers/createClass.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@fluentui/style-utilities/lib/styles/theme.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@griffel/react/TextDirectionContext.esm.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@fluentui/react-focus/lib/components/FocusZone/FocusZone.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@fluentui/merge-styles/lib/tokenizeWithParentheses.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@react-aria/focus/dist/module.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@fluentui/merge-styles/lib/concatStyleSetsWithProps.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/popmotion/dist/es/easing/utils.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@popperjs/core/lib/dom-utils/getNodeScroll.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@popperjs/core/lib/dom-utils/getWindowScrollBarX.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@fluentui/merge-styles/lib/getVendorSettings.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@fluentui/merge-styles/lib/transforms/prefixRules.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/framesync/dist/es/index.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@griffel/core/devtools/getDebugTree.esm.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@popperjs/core/lib/dom-utils/listScrollParents.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@tiptap/extension-italic/dist/index.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/popmotion/dist/es/utils/inc.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/uuid/dist/esm-browser/stringify.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/popmotion/dist/es/utils/clamp.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@tiptap/extension-bubble-menu/dist/index.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@fluentui/react-hooks/lib/useForceUpdate.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@tiptap/extension-ordered-list/dist/index.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/style-value-types/dist/es/color/rgba.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/hey-listen/dist/hey-listen.es.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@fluentui/style-utilities/lib/styles/zIndexes.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@fluentui/dom-utilities/lib/getEventTarget.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@griffel/core/renderer/createDOMRenderer.esm.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@fluentui/theme/lib/colors/DefaultPalette.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@babel/runtime/helpers/esm/extends.js","webpack:///(webpack)/buildin/harmony-module.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/react/cjs/react.development.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/base64-js/index.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@fluentui/style-utilities/lib/styles/getGlobalClassNames.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@babel/runtime/helpers/slicedToArray.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@tiptap/pm/dropcursor/dist/index.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@popperjs/core/lib/dom-utils/getLayoutRect.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/popmotion/dist/es/utils/velocity-per-second.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/popmotion/dist/es/utils/distance.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@popperjs/core/lib/dom-utils/isScrollParent.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@fluentui/dom-utilities/lib/setPortalAttribute.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@fluentui/theme/lib/fonts/FluentFonts.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/react-zoom-pan-pinch/dist/index.esm.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@popperjs/core/lib/modifiers/eventListeners.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@fluentui/merge-styles/lib/StyleOptionsState.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@babel/runtime/helpers/nonIterableRest.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/popmotion/dist/es/easing/index.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@popperjs/core/lib/dom-utils/instanceOf.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/rxjs/_esm5/internal/Subject.js","webpack:///(webpack)/buildin/global.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@fluentui/theme/lib/motion/AnimationStyles.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/uuid/dist/esm-browser/native.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/popmotion/dist/es/easing/cubic-bezier.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@tiptap/extension-floating-menu/dist/index.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/setimmediate/setImmediate.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@popperjs/core/lib/utils/mergePaddingObject.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@tiptap/extension-hard-break/dist/index.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@tiptap/pm/model/dist/index.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@tiptap/extension-text/dist/index.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@griffel/core/renderer/safeInsertRule.esm.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/rxjs/_esm5/internal/util/ObjectUnsubscribedError.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@react-aria/visually-hidden/dist/module.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@fluentui/theme/lib/fonts/DefaultFontStyles.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@tiptap/pm/schema-list/dist/index.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/orderedmap/dist/index.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/rxjs/_esm5/internal/SubjectSubscription.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/uuid/dist/esm-browser/regex.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@babel/runtime/helpers/arrayLikeToArray.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@popperjs/core/lib/dom-utils/getWindowScroll.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@fluentui/theme/lib/createTheme.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@fluentui/theme/lib/motion/FluentMotion.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@fluentui/merge-styles/lib/transforms/rtlifyRules.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/prosemirror-keymap/dist/index.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/popmotion/dist/es/utils/is-point.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/rxjs/_esm5/internal/util/identity.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/popmotion/dist/es/utils/interpolate.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/jwt-decode/build/jwt-decode.esm.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@fluentui/theme/lib/utilities/makeSemanticColors.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/popmotion/dist/es/utils/mix-complex.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@popperjs/core/lib/dom-utils/getNodeName.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/rxjs/_esm5/internal/config.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@babel/runtime/helpers/esm/nonIterableRest.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@fluentui/react-hooks/lib/usePrevious.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@tiptap/extension-blockquote/dist/index.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@fluentui/react-hooks/lib/useRefEffect.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@internationalized/string/dist/module.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@fluentui/dom-utilities/lib/getParent.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@griffel/core/insertionFactory.esm.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@fluentui/merge-styles/lib/Stylesheet.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/rxjs/_esm5/internal/Observer.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@griffel/core/devtools/getSourceURLfromError.esm.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/rxjs/_esm5/internal/operators/distinctUntilChanged.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@tiptap/extension-history/dist/index.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@tiptap/extension-table-cell/dist/index.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@fluentui/react-hooks/lib/useConst.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@griffel/core/__styles.esm.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@fluentui/date-time-utilities/lib/dateGrid/isBeforeMinDate.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/object-assign/index.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@popperjs/core/lib/dom-utils/getWindow.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@griffel/core/runtime/reduceToClassNameForSlots.esm.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@tiptap/extension-table-row/dist/index.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@fluentui/style-utilities/lib/styles/hiddenContentStyle.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@fluentui/set-version/lib/index.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@fluentui/theme/lib/spacing/DefaultSpacing.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@popperjs/core/lib/utils/rectToClientRect.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@fluentui/react-hooks/lib/useOnEvent.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@popperjs/core/lib/utils/getOppositePlacement.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@fluentui/style-utilities/lib/index.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/framesync/dist/es/on-next-frame.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@fluentui/react-hooks/lib/useMergedRefs.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@popperjs/core/lib/dom-utils/getScrollParent.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/prosemirror-dropcursor/dist/index.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@fluentui/merge-styles/lib/transforms/provideUnits.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@popperjs/core/lib/modifiers/hide.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@babel/runtime/helpers/arrayWithHoles.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@popperjs/core/lib/createPopper.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@fluentui/merge-styles/lib/ShadowDomStylesheet.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/style-value-types/dist/es/utils.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/prosemirror-gapcursor/dist/index.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@fluentui/style-utilities/lib/cdn.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@react-aria/i18n/dist/real-module.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/rxjs/_esm5/internal/util/pipe.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@fluentui/merge-styles/lib/transforms/kebabRules.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@fluentui/dom-utilities/lib/setVirtualParent.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@griffel/core/renderer/rehydrateRendererCache.esm.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@babel/runtime/helpers/esm/toPrimitive.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@griffel/core/devtools/utils.esm.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/rxjs/_esm5/internal/symbol/observable.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@fluentui/style-utilities/lib/version.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@griffel/react/useInsertionEffect.esm.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@tiptap/extension-dropcursor/dist/index.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@popperjs/core/lib/utils/mergeByName.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@tiptap/extension-heading/dist/index.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@tiptap/extension-bullet-list/dist/index.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@fluentui/date-time-utilities/lib/dateValues/timeConstants.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/react-i18next/dist/es/context.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/rxjs/_esm5/internal/util/isArray.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@popperjs/core/lib/dom-utils/getHTMLElementScroll.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@tiptap/pm/view/dist/index.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@popperjs/core/lib/utils/detectOverflow.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@fluentui/date-time-utilities/lib/dateGrid/getBoundedDateRange.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@griffel/core/renderer/createIsomorphicStyleSheet.esm.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@fluentui/dom-utilities/lib/elementContainsAttribute.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@popperjs/core/lib/utils/debounce.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/style-value-types/dist/es/color/hex.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@fluentui/react-hooks/lib/useEventCallback.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@fluentui/merge-styles/lib/keyframes.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@fluentui/date-time-utilities/lib/dateGrid/isAfterMaxDate.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@tiptap/pm/transform/dist/index.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/popmotion/dist/es/animations/utils/find-spring.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@popperjs/core/lib/modifiers/offset.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@popperjs/core/lib/utils/getVariation.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@fluentui/foundation-legacy/lib/slots.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/popmotion/dist/es/animations/generators/decay.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@popperjs/core/lib/dom-utils/isLayoutViewport.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@griffel/core/renderer/getStyleSheetForBucket.esm.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@fluentui/date-time-utilities/lib/dateGrid/getDayGrid.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/style-value-types/dist/es/numbers/index.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/rxjs/_esm5/internal/util/canReportError.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@fluentui/date-time-utilities/lib/dateGrid/getDateRangeTypeToUse.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@griffel/react/utils/canUseDOM.esm.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@fluentui/style-utilities/lib/classNames/AnimationClassNames.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/rxjs/_esm5/internal/operators/filter.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/rxjs/_esm5/internal/util/hostReportError.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@popperjs/core/lib/utils/orderModifiers.js","webpack:///C:/Users/wangweiwei/source/repos/address-book/Source/Clients/node_modules/@babel/runtime/helpers/esm/defineProperty.js"],"sourcesContent":["var hash = {\n  start: 'end',\n  end: 'start'\n};\nexport default function getOppositeVariationPlacement(placement) {\n  return placement.replace(/start|end/g, function (matched) {\n    return hash[matched];\n  });\n}","/** PURE_IMPORTS_START  PURE_IMPORTS_END */\nexport function isFunction(x) {\n    return typeof x === 'function';\n}\n//# sourceMappingURL=isFunction.js.map\n","import { top, left, right, bottom, start } from \"../enums.js\";\nimport getBasePlacement from \"../utils/getBasePlacement.js\";\nimport getMainAxisFromPlacement from \"../utils/getMainAxisFromPlacement.js\";\nimport getAltAxis from \"../utils/getAltAxis.js\";\nimport { within, withinMaxClamp } from \"../utils/within.js\";\nimport getLayoutRect from \"../dom-utils/getLayoutRect.js\";\nimport getOffsetParent from \"../dom-utils/getOffsetParent.js\";\nimport detectOverflow from \"../utils/detectOverflow.js\";\nimport getVariation from \"../utils/getVariation.js\";\nimport getFreshSideObject from \"../utils/getFreshSideObject.js\";\nimport { min as mathMin, max as mathMax } from \"../utils/math.js\";\n\nfunction preventOverflow(_ref) {\n  var state = _ref.state,\n      options = _ref.options,\n      name = _ref.name;\n  var _options$mainAxis = options.mainAxis,\n      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,\n      _options$altAxis = options.altAxis,\n      checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,\n      boundary = options.boundary,\n      rootBoundary = options.rootBoundary,\n      altBoundary = options.altBoundary,\n      padding = options.padding,\n      _options$tether = options.tether,\n      tether = _options$tether === void 0 ? true : _options$tether,\n      _options$tetherOffset = options.tetherOffset,\n      tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;\n  var overflow = detectOverflow(state, {\n    boundary: boundary,\n    rootBoundary: rootBoundary,\n    padding: padding,\n    altBoundary: altBoundary\n  });\n  var basePlacement = getBasePlacement(state.placement);\n  var variation = getVariation(state.placement);\n  var isBasePlacement = !variation;\n  var mainAxis = getMainAxisFromPlacement(basePlacement);\n  var altAxis = getAltAxis(mainAxis);\n  var popperOffsets = state.modifiersData.popperOffsets;\n  var referenceRect = state.rects.reference;\n  var popperRect = state.rects.popper;\n  var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign({}, state.rects, {\n    placement: state.placement\n  })) : tetherOffset;\n  var normalizedTetherOffsetValue = typeof tetherOffsetValue === 'number' ? {\n    mainAxis: tetherOffsetValue,\n    altAxis: tetherOffsetValue\n  } : Object.assign({\n    mainAxis: 0,\n    altAxis: 0\n  }, tetherOffsetValue);\n  var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;\n  var data = {\n    x: 0,\n    y: 0\n  };\n\n  if (!popperOffsets) {\n    return;\n  }\n\n  if (checkMainAxis) {\n    var _offsetModifierState$;\n\n    var mainSide = mainAxis === 'y' ? top : left;\n    var altSide = mainAxis === 'y' ? bottom : right;\n    var len = mainAxis === 'y' ? 'height' : 'width';\n    var offset = popperOffsets[mainAxis];\n    var min = offset + overflow[mainSide];\n    var max = offset - overflow[altSide];\n    var additive = tether ? -popperRect[len] / 2 : 0;\n    var minLen = variation === start ? referenceRect[len] : popperRect[len];\n    var maxLen = variation === start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go\n    // outside the reference bounds\n\n    var arrowElement = state.elements.arrow;\n    var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {\n      width: 0,\n      height: 0\n    };\n    var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : getFreshSideObject();\n    var arrowPaddingMin = arrowPaddingObject[mainSide];\n    var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want\n    // to include its full size in the calculation. If the reference is small\n    // and near the edge of a boundary, the popper can overflow even if the\n    // reference is not overflowing as well (e.g. virtual elements with no\n    // width or height)\n\n    var arrowLen = within(0, referenceRect[len], arrowRect[len]);\n    var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;\n    var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;\n    var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);\n    var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;\n    var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;\n    var tetherMin = offset + minOffset - offsetModifierValue - clientOffset;\n    var tetherMax = offset + maxOffset - offsetModifierValue;\n    var preventedOffset = within(tether ? mathMin(min, tetherMin) : min, offset, tether ? mathMax(max, tetherMax) : max);\n    popperOffsets[mainAxis] = preventedOffset;\n    data[mainAxis] = preventedOffset - offset;\n  }\n\n  if (checkAltAxis) {\n    var _offsetModifierState$2;\n\n    var _mainSide = mainAxis === 'x' ? top : left;\n\n    var _altSide = mainAxis === 'x' ? bottom : right;\n\n    var _offset = popperOffsets[altAxis];\n\n    var _len = altAxis === 'y' ? 'height' : 'width';\n\n    var _min = _offset + overflow[_mainSide];\n\n    var _max = _offset - overflow[_altSide];\n\n    var isOriginSide = [top, left].indexOf(basePlacement) !== -1;\n\n    var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;\n\n    var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;\n\n    var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;\n\n    var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);\n\n    popperOffsets[altAxis] = _preventedOffset;\n    data[altAxis] = _preventedOffset - _offset;\n  }\n\n  state.modifiersData[name] = data;\n} // eslint-disable-next-line import/no-unused-modules\n\n\nexport default {\n  name: 'preventOverflow',\n  enabled: true,\n  phase: 'main',\n  fn: preventOverflow,\n  requiresIfExists: ['offset']\n};","import { findElementRecursive } from './findElementRecursive';\nimport { DATA_PORTAL_ATTRIBUTE } from './setPortalAttribute';\n/**\n * Determine whether a target is within a portal from perspective of root or optional parent.\n * This function only works against portal components that use the setPortalAttribute function.\n * If both parent and child are within the same portal this function will return false.\n * @param target - Element to query portal containment status of.\n * @param parent - Optional parent perspective. Search for containing portal stops at parent\n * (or root if parent is undefined or invalid.)\n */\nexport function portalContainsElement(target, parent, doc) {\n    var elementMatch = findElementRecursive(target, function (testElement) { return parent === testElement || testElement.hasAttribute(DATA_PORTAL_ATTRIBUTE); }, doc);\n    return elementMatch !== null && elementMatch.hasAttribute(DATA_PORTAL_ATTRIBUTE);\n}\n//# sourceMappingURL=portalContainsElement.js.map","import { __assign } from 'tslib';\nimport { complex } from './index.js';\nimport { floatRegex } from '../utils.js';\n\nvar maxDefaults = new Set(['brightness', 'contrast', 'saturate', 'opacity']);\nfunction applyDefaultFilter(v) {\n    var _a = v.slice(0, -1).split('('), name = _a[0], value = _a[1];\n    if (name === 'drop-shadow')\n        return v;\n    var number = (value.match(floatRegex) || [])[0];\n    if (!number)\n        return v;\n    var unit = value.replace(number, '');\n    var defaultValue = maxDefaults.has(name) ? 1 : 0;\n    if (number !== value)\n        defaultValue *= 100;\n    return name + '(' + defaultValue + unit + ')';\n}\nvar functionRegex = /([a-z-]*)\\(.*?\\)/g;\nvar filter = __assign(__assign({}, complex), { getAnimatableNone: function (v) {\n        var functions = v.match(functionRegex);\n        return functions ? functions.map(applyDefaultFilter).join(' ') : v;\n    } });\n\nexport { filter };\n","import { __spreadArray } from \"tslib\";\nimport { Stylesheet } from './Stylesheet';\nimport { kebabRules } from './transforms/kebabRules';\nimport { prefixRules } from './transforms/prefixRules';\nimport { provideUnits } from './transforms/provideUnits';\nimport { rtlifyRules } from './transforms/rtlifyRules';\nimport { tokenizeWithParentheses } from './tokenizeWithParentheses';\nvar DISPLAY_NAME = 'displayName';\nfunction getDisplayName(rules) {\n    var rootStyle = rules && rules['&'];\n    return rootStyle ? rootStyle.displayName : undefined;\n}\nvar globalSelectorRegExp = /\\:global\\((.+?)\\)/g;\n/**\n * Finds comma separated selectors in a :global() e.g. \":global(.class1, .class2, .class3)\"\n * and wraps them each in their own global \":global(.class1), :global(.class2), :global(.class3)\"\n *\n * @param selectorWithGlobals The selector to process\n * @returns The updated selector\n */\nfunction expandCommaSeparatedGlobals(selectorWithGlobals) {\n    // We the selector does not have a :global() we can shortcut\n    if (!globalSelectorRegExp.test(selectorWithGlobals)) {\n        return selectorWithGlobals;\n    }\n    var replacementInfo = [];\n    var findGlobal = /\\:global\\((.+?)\\)/g;\n    var match = null;\n    // Create a result list for global selectors so we can replace them.\n    while ((match = findGlobal.exec(selectorWithGlobals))) {\n        // Only if the found selector is a comma separated list we'll process it.\n        if (match[1].indexOf(',') > -1) {\n            replacementInfo.push([\n                match.index,\n                match.index + match[0].length,\n                // Wrap each of the found selectors in :global()\n                match[1]\n                    .split(',')\n                    .map(function (v) { return \":global(\".concat(v.trim(), \")\"); })\n                    .join(', '),\n            ]);\n        }\n    }\n    // Replace the found selectors with their wrapped variants in reverse order\n    return replacementInfo\n        .reverse()\n        .reduce(function (selector, _a) {\n        var matchIndex = _a[0], matchEndIndex = _a[1], replacement = _a[2];\n        var prefix = selector.slice(0, matchIndex);\n        var suffix = selector.slice(matchEndIndex);\n        return prefix + replacement + suffix;\n    }, selectorWithGlobals);\n}\nfunction isSelector(potentialSelector) {\n    return potentialSelector.indexOf(':global(') >= 0 || potentialSelector.indexOf(':') === 0;\n}\nfunction expandSelector(newSelector, currentSelector) {\n    if (newSelector.indexOf(':global(') >= 0) {\n        return newSelector.replace(globalSelectorRegExp, '$1');\n    }\n    else if (newSelector.indexOf(':host(') === 0) {\n        return newSelector;\n    }\n    else if (newSelector.indexOf(':') === 0) {\n        return currentSelector + newSelector;\n    }\n    else if (newSelector.indexOf('&') < 0) {\n        return currentSelector + ' ' + newSelector;\n    }\n    return newSelector;\n}\nfunction extractSelector(currentSelector, rules, selector, value, stylesheet) {\n    if (rules === void 0) { rules = { __order: [] }; }\n    if (selector.indexOf('@') === 0) {\n        selector = selector + '{' + currentSelector;\n        extractRules([value], rules, selector, stylesheet);\n    }\n    else if (selector.indexOf(',') > -1) {\n        expandCommaSeparatedGlobals(selector)\n            .split(',')\n            .map(function (s) { return s.trim(); })\n            .forEach(function (separatedSelector) {\n            return extractRules([value], rules, expandSelector(separatedSelector, currentSelector), stylesheet);\n        });\n    }\n    else {\n        extractRules([value], rules, expandSelector(selector, currentSelector), stylesheet);\n    }\n}\nfunction extractRules(args, rules, currentSelector, stylesheet) {\n    if (rules === void 0) { rules = { __order: [] }; }\n    if (currentSelector === void 0) { currentSelector = '&'; }\n    var currentRules = rules[currentSelector];\n    if (!currentRules) {\n        currentRules = {};\n        rules[currentSelector] = currentRules;\n        rules.__order.push(currentSelector);\n    }\n    for (var _i = 0, args_1 = args; _i < args_1.length; _i++) {\n        var arg = args_1[_i];\n        // If the arg is a string, we need to look up the class map and merge.\n        if (typeof arg === 'string') {\n            var expandedRules = stylesheet.argsFromClassName(arg);\n            if (expandedRules) {\n                extractRules(expandedRules, rules, currentSelector, stylesheet);\n            }\n            // Else if the arg is an array, we need to recurse in.\n        }\n        else if (Array.isArray(arg)) {\n            extractRules(arg, rules, currentSelector, stylesheet);\n        }\n        else {\n            for (var prop in arg) {\n                if (arg.hasOwnProperty(prop)) {\n                    var propValue = arg[prop];\n                    if (prop === 'selectors') {\n                        // every child is a selector.\n                        var selectors = arg.selectors;\n                        for (var newSelector in selectors) {\n                            if (selectors.hasOwnProperty(newSelector)) {\n                                extractSelector(currentSelector, rules, newSelector, selectors[newSelector], stylesheet);\n                            }\n                        }\n                    }\n                    else if (typeof propValue === 'object' || isSelector(prop)) {\n                        // prop is a selector.\n                        if (propValue !== null && propValue !== undefined) {\n                            extractSelector(currentSelector, rules, prop, propValue, stylesheet);\n                        }\n                    }\n                    else {\n                        if (propValue !== undefined) {\n                            // Else, add the rule to the currentSelector.\n                            if (prop === 'margin' || prop === 'padding') {\n                                expandQuads(currentRules, prop, propValue);\n                            }\n                            else {\n                                currentRules[prop] = propValue;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return rules;\n}\nfunction expandQuads(currentRules, name, value) {\n    var parts = typeof value === 'string' ? tokenizeWithParentheses(value) : [value];\n    if (parts.length === 0) {\n        parts.push(value);\n    }\n    if (parts[parts.length - 1] === '!important') {\n        // Remove !important from parts, and append it to each part individually\n        parts = parts.slice(0, -1).map(function (p) { return p + ' !important'; });\n    }\n    currentRules[name + 'Top'] = parts[0];\n    currentRules[name + 'Right'] = parts[1] || parts[0];\n    currentRules[name + 'Bottom'] = parts[2] || parts[0];\n    currentRules[name + 'Left'] = parts[3] || parts[1] || parts[0];\n}\nfunction getKeyForRules(options, rules) {\n    var serialized = [options.rtl ? 'rtl' : 'ltr'];\n    var hasProps = false;\n    for (var _i = 0, _a = rules.__order; _i < _a.length; _i++) {\n        var selector = _a[_i];\n        serialized.push(selector);\n        var rulesForSelector = rules[selector];\n        for (var propName in rulesForSelector) {\n            if (rulesForSelector.hasOwnProperty(propName) && rulesForSelector[propName] !== undefined) {\n                hasProps = true;\n                serialized.push(propName, rulesForSelector[propName]);\n            }\n        }\n    }\n    return hasProps ? serialized.join('') : undefined;\n}\nfunction repeatString(target, count) {\n    if (count <= 0) {\n        return '';\n    }\n    if (count === 1) {\n        return target;\n    }\n    return target + repeatString(target, count - 1);\n}\nexport function serializeRuleEntries(options, ruleEntries) {\n    if (!ruleEntries) {\n        return '';\n    }\n    var allEntries = [];\n    for (var entry in ruleEntries) {\n        if (ruleEntries.hasOwnProperty(entry) && entry !== DISPLAY_NAME && ruleEntries[entry] !== undefined) {\n            allEntries.push(entry, ruleEntries[entry]);\n        }\n    }\n    // Apply transforms.\n    for (var i = 0; i < allEntries.length; i += 2) {\n        kebabRules(allEntries, i);\n        provideUnits(allEntries, i);\n        rtlifyRules(options, allEntries, i);\n        prefixRules(allEntries, i);\n    }\n    // Apply punctuation.\n    for (var i = 1; i < allEntries.length; i += 4) {\n        allEntries.splice(i, 1, ':', allEntries[i], ';');\n    }\n    return allEntries.join('');\n}\nexport function styleToRegistration(options) {\n    var _a;\n    var args = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        args[_i - 1] = arguments[_i];\n    }\n    var stylesheet = (_a = options.stylesheet) !== null && _a !== void 0 ? _a : Stylesheet.getInstance(options.shadowConfig);\n    var rules = extractRules(args, undefined, undefined, stylesheet);\n    var key = getKeyForRules(options, rules);\n    if (key) {\n        var registration = {\n            className: stylesheet.classNameFromKey(key),\n            key: key,\n            args: args,\n        };\n        if (!registration.className) {\n            registration.className = stylesheet.getClassName(getDisplayName(rules));\n            var rulesToInsert = [];\n            for (var _b = 0, _c = rules.__order; _b < _c.length; _b++) {\n                var selector = _c[_b];\n                rulesToInsert.push(selector, serializeRuleEntries(options, rules[selector]));\n            }\n            registration.rulesToInsert = rulesToInsert;\n        }\n        return registration;\n    }\n    return undefined;\n}\n/**\n * Insert style to stylesheet.\n * @param registration Style registration.\n * @param specificityMultiplier Number of times classname selector is repeated in the css rule.\n * This is to increase css specificity in case it's needed. Default to 1.\n */\nexport function applyRegistration(registration, specificityMultiplier, shadowConfig, sheet) {\n    if (specificityMultiplier === void 0) { specificityMultiplier = 1; }\n    var stylesheet = sheet !== null && sheet !== void 0 ? sheet : Stylesheet.getInstance(shadowConfig);\n    var className = registration.className, key = registration.key, args = registration.args, rulesToInsert = registration.rulesToInsert;\n    if (rulesToInsert) {\n        // rulesToInsert is an ordered array of selector/rule pairs.\n        for (var i = 0; i < rulesToInsert.length; i += 2) {\n            var rules = rulesToInsert[i + 1];\n            if (rules) {\n                var selector = rulesToInsert[i];\n                selector = selector.replace(/&/g, repeatString(\".\".concat(registration.className), specificityMultiplier));\n                // Insert. Note if a media query, we must close the query with a final bracket.\n                var processedRule = \"\".concat(selector, \"{\").concat(rules, \"}\").concat(selector.indexOf('@') === 0 ? '}' : '');\n                stylesheet.insertRule(processedRule);\n            }\n        }\n        stylesheet.cacheClassName(className, key, args, rulesToInsert);\n    }\n}\nexport function styleToClassName(options) {\n    var args = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        args[_i - 1] = arguments[_i];\n    }\n    var registration = styleToRegistration.apply(void 0, __spreadArray([options], args, false));\n    if (registration) {\n        applyRegistration(registration, options.specificityMultiplier, options.shadowConfig, options.stylesheet);\n        return registration.className;\n    }\n    return '';\n}\n//# sourceMappingURL=styleToClassName.js.map","var scope = (typeof global !== \"undefined\" && global) ||\n            (typeof self !== \"undefined\" && self) ||\n            window;\nvar apply = Function.prototype.apply;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(scope, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// setimmediate attaches itself to the global object\nrequire(\"setimmediate\");\n// On some exotic environments, it's not clear which object `setimmediate` was\n// able to install onto.  Search each possibility in the same order as the\n// `setimmediate` library.\nexports.setImmediate = (typeof self !== \"undefined\" && self.setImmediate) ||\n                       (typeof global !== \"undefined\" && global.setImmediate) ||\n                       (this && this.setImmediate);\nexports.clearImmediate = (typeof self !== \"undefined\" && self.clearImmediate) ||\n                         (typeof global !== \"undefined\" && global.clearImmediate) ||\n                         (this && this.clearImmediate);\n","import { Node, mergeAttributes } from '@tiptap/core';\n\n/**\n * This extension allows you to create paragraphs.\n * @see https://www.tiptap.dev/api/nodes/paragraph\n */\nconst Paragraph = Node.create({\n    name: 'paragraph',\n    priority: 1000,\n    addOptions() {\n        return {\n            HTMLAttributes: {},\n        };\n    },\n    group: 'block',\n    content: 'inline*',\n    parseHTML() {\n        return [\n            { tag: 'p' },\n        ];\n    },\n    renderHTML({ HTMLAttributes }) {\n        return ['p', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];\n    },\n    addCommands() {\n        return {\n            setParagraph: () => ({ commands }) => {\n                return commands.setNode(this.name);\n            },\n        };\n    },\n    addKeyboardShortcuts() {\n        return {\n            'Mod-Alt-0': () => this.editor.commands.setParagraph(),\n        };\n    },\n});\n\nexport { Paragraph, Paragraph as default };\n//# sourceMappingURL=index.js.map\n","import { findWrapping, ReplaceAroundStep, canSplit, liftTarget, canJoin } from 'prosemirror-transform';\nimport { NodeRange, Fragment, Slice } from 'prosemirror-model';\nimport { Selection } from 'prosemirror-state';\n\nconst olDOM = [\"ol\", 0], ulDOM = [\"ul\", 0], liDOM = [\"li\", 0];\n/**\nAn ordered list [node spec](https://prosemirror.net/docs/ref/#model.NodeSpec). Has a single\nattribute, `order`, which determines the number at which the list\nstarts counting, and defaults to 1. Represented as an `<ol>`\nelement.\n*/\nconst orderedList = {\n    attrs: { order: { default: 1, validate: \"number\" } },\n    parseDOM: [{ tag: \"ol\", getAttrs(dom) {\n                return { order: dom.hasAttribute(\"start\") ? +dom.getAttribute(\"start\") : 1 };\n            } }],\n    toDOM(node) {\n        return node.attrs.order == 1 ? olDOM : [\"ol\", { start: node.attrs.order }, 0];\n    }\n};\n/**\nA bullet list node spec, represented in the DOM as `<ul>`.\n*/\nconst bulletList = {\n    parseDOM: [{ tag: \"ul\" }],\n    toDOM() { return ulDOM; }\n};\n/**\nA list item (`<li>`) spec.\n*/\nconst listItem = {\n    parseDOM: [{ tag: \"li\" }],\n    toDOM() { return liDOM; },\n    defining: true\n};\nfunction add(obj, props) {\n    let copy = {};\n    for (let prop in obj)\n        copy[prop] = obj[prop];\n    for (let prop in props)\n        copy[prop] = props[prop];\n    return copy;\n}\n/**\nConvenience function for adding list-related node types to a map\nspecifying the nodes for a schema. Adds\n[`orderedList`](https://prosemirror.net/docs/ref/#schema-list.orderedList) as `\"ordered_list\"`,\n[`bulletList`](https://prosemirror.net/docs/ref/#schema-list.bulletList) as `\"bullet_list\"`, and\n[`listItem`](https://prosemirror.net/docs/ref/#schema-list.listItem) as `\"list_item\"`.\n\n`itemContent` determines the content expression for the list items.\nIf you want the commands defined in this module to apply to your\nlist structure, it should have a shape like `\"paragraph block*\"` or\n`\"paragraph (ordered_list | bullet_list)*\"`. `listGroup` can be\ngiven to assign a group name to the list node types, for example\n`\"block\"`.\n*/\nfunction addListNodes(nodes, itemContent, listGroup) {\n    return nodes.append({\n        ordered_list: add(orderedList, { content: \"list_item+\", group: listGroup }),\n        bullet_list: add(bulletList, { content: \"list_item+\", group: listGroup }),\n        list_item: add(listItem, { content: itemContent })\n    });\n}\n/**\nReturns a command function that wraps the selection in a list with\nthe given type an attributes. If `dispatch` is null, only return a\nvalue to indicate whether this is possible, but don't actually\nperform the change.\n*/\nfunction wrapInList(listType, attrs = null) {\n    return function (state, dispatch) {\n        let { $from, $to } = state.selection;\n        let range = $from.blockRange($to), doJoin = false, outerRange = range;\n        if (!range)\n            return false;\n        // This is at the top of an existing list item\n        if (range.depth >= 2 && $from.node(range.depth - 1).type.compatibleContent(listType) && range.startIndex == 0) {\n            // Don't do anything if this is the top of the list\n            if ($from.index(range.depth - 1) == 0)\n                return false;\n            let $insert = state.doc.resolve(range.start - 2);\n            outerRange = new NodeRange($insert, $insert, range.depth);\n            if (range.endIndex < range.parent.childCount)\n                range = new NodeRange($from, state.doc.resolve($to.end(range.depth)), range.depth);\n            doJoin = true;\n        }\n        let wrap = findWrapping(outerRange, listType, attrs, range);\n        if (!wrap)\n            return false;\n        if (dispatch)\n            dispatch(doWrapInList(state.tr, range, wrap, doJoin, listType).scrollIntoView());\n        return true;\n    };\n}\nfunction doWrapInList(tr, range, wrappers, joinBefore, listType) {\n    let content = Fragment.empty;\n    for (let i = wrappers.length - 1; i >= 0; i--)\n        content = Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content));\n    tr.step(new ReplaceAroundStep(range.start - (joinBefore ? 2 : 0), range.end, range.start, range.end, new Slice(content, 0, 0), wrappers.length, true));\n    let found = 0;\n    for (let i = 0; i < wrappers.length; i++)\n        if (wrappers[i].type == listType)\n            found = i + 1;\n    let splitDepth = wrappers.length - found;\n    let splitPos = range.start + wrappers.length - (joinBefore ? 2 : 0), parent = range.parent;\n    for (let i = range.startIndex, e = range.endIndex, first = true; i < e; i++, first = false) {\n        if (!first && canSplit(tr.doc, splitPos, splitDepth)) {\n            tr.split(splitPos, splitDepth);\n            splitPos += 2 * splitDepth;\n        }\n        splitPos += parent.child(i).nodeSize;\n    }\n    return tr;\n}\n/**\nBuild a command that splits a non-empty textblock at the top level\nof a list item by also splitting that list item.\n*/\nfunction splitListItem(itemType, itemAttrs) {\n    return function (state, dispatch) {\n        let { $from, $to, node } = state.selection;\n        if ((node && node.isBlock) || $from.depth < 2 || !$from.sameParent($to))\n            return false;\n        let grandParent = $from.node(-1);\n        if (grandParent.type != itemType)\n            return false;\n        if ($from.parent.content.size == 0 && $from.node(-1).childCount == $from.indexAfter(-1)) {\n            // In an empty block. If this is a nested list, the wrapping\n            // list item should be split. Otherwise, bail out and let next\n            // command handle lifting.\n            if ($from.depth == 3 || $from.node(-3).type != itemType ||\n                $from.index(-2) != $from.node(-2).childCount - 1)\n                return false;\n            if (dispatch) {\n                let wrap = Fragment.empty;\n                let depthBefore = $from.index(-1) ? 1 : $from.index(-2) ? 2 : 3;\n                // Build a fragment containing empty versions of the structure\n                // from the outer list item to the parent node of the cursor\n                for (let d = $from.depth - depthBefore; d >= $from.depth - 3; d--)\n                    wrap = Fragment.from($from.node(d).copy(wrap));\n                let depthAfter = $from.indexAfter(-1) < $from.node(-2).childCount ? 1\n                    : $from.indexAfter(-2) < $from.node(-3).childCount ? 2 : 3;\n                // Add a second list item with an empty default start node\n                wrap = wrap.append(Fragment.from(itemType.createAndFill()));\n                let start = $from.before($from.depth - (depthBefore - 1));\n                let tr = state.tr.replace(start, $from.after(-depthAfter), new Slice(wrap, 4 - depthBefore, 0));\n                let sel = -1;\n                tr.doc.nodesBetween(start, tr.doc.content.size, (node, pos) => {\n                    if (sel > -1)\n                        return false;\n                    if (node.isTextblock && node.content.size == 0)\n                        sel = pos + 1;\n                });\n                if (sel > -1)\n                    tr.setSelection(Selection.near(tr.doc.resolve(sel)));\n                dispatch(tr.scrollIntoView());\n            }\n            return true;\n        }\n        let nextType = $to.pos == $from.end() ? grandParent.contentMatchAt(0).defaultType : null;\n        let tr = state.tr.delete($from.pos, $to.pos);\n        let types = nextType ? [itemAttrs ? { type: itemType, attrs: itemAttrs } : null, { type: nextType }] : undefined;\n        if (!canSplit(tr.doc, $from.pos, 2, types))\n            return false;\n        if (dispatch)\n            dispatch(tr.split($from.pos, 2, types).scrollIntoView());\n        return true;\n    };\n}\n/**\nActs like [`splitListItem`](https://prosemirror.net/docs/ref/#schema-list.splitListItem), but\nwithout resetting the set of active marks at the cursor.\n*/\nfunction splitListItemKeepMarks(itemType, itemAttrs) {\n    let split = splitListItem(itemType, itemAttrs);\n    return (state, dispatch) => {\n        return split(state, dispatch && (tr => {\n            let marks = state.storedMarks || (state.selection.$to.parentOffset && state.selection.$from.marks());\n            if (marks)\n                tr.ensureMarks(marks);\n            dispatch(tr);\n        }));\n    };\n}\n/**\nCreate a command to lift the list item around the selection up into\na wrapping list.\n*/\nfunction liftListItem(itemType) {\n    return function (state, dispatch) {\n        let { $from, $to } = state.selection;\n        let range = $from.blockRange($to, node => node.childCount > 0 && node.firstChild.type == itemType);\n        if (!range)\n            return false;\n        if (!dispatch)\n            return true;\n        if ($from.node(range.depth - 1).type == itemType) // Inside a parent list\n            return liftToOuterList(state, dispatch, itemType, range);\n        else // Outer list node\n            return liftOutOfList(state, dispatch, range);\n    };\n}\nfunction liftToOuterList(state, dispatch, itemType, range) {\n    let tr = state.tr, end = range.end, endOfList = range.$to.end(range.depth);\n    if (end < endOfList) {\n        // There are siblings after the lifted items, which must become\n        // children of the last item\n        tr.step(new ReplaceAroundStep(end - 1, endOfList, end, endOfList, new Slice(Fragment.from(itemType.create(null, range.parent.copy())), 1, 0), 1, true));\n        range = new NodeRange(tr.doc.resolve(range.$from.pos), tr.doc.resolve(endOfList), range.depth);\n    }\n    const target = liftTarget(range);\n    if (target == null)\n        return false;\n    tr.lift(range, target);\n    let after = tr.mapping.map(end, -1) - 1;\n    if (canJoin(tr.doc, after))\n        tr.join(after);\n    dispatch(tr.scrollIntoView());\n    return true;\n}\nfunction liftOutOfList(state, dispatch, range) {\n    let tr = state.tr, list = range.parent;\n    // Merge the list items into a single big item\n    for (let pos = range.end, i = range.endIndex - 1, e = range.startIndex; i > e; i--) {\n        pos -= list.child(i).nodeSize;\n        tr.delete(pos - 1, pos + 1);\n    }\n    let $start = tr.doc.resolve(range.start), item = $start.nodeAfter;\n    if (tr.mapping.map(range.end) != range.start + $start.nodeAfter.nodeSize)\n        return false;\n    let atStart = range.startIndex == 0, atEnd = range.endIndex == list.childCount;\n    let parent = $start.node(-1), indexBefore = $start.index(-1);\n    if (!parent.canReplace(indexBefore + (atStart ? 0 : 1), indexBefore + 1, item.content.append(atEnd ? Fragment.empty : Fragment.from(list))))\n        return false;\n    let start = $start.pos, end = start + item.nodeSize;\n    // Strip off the surrounding list. At the sides where we're not at\n    // the end of the list, the existing list is closed. At sides where\n    // this is the end, it is overwritten to its end.\n    tr.step(new ReplaceAroundStep(start - (atStart ? 1 : 0), end + (atEnd ? 1 : 0), start + 1, end - 1, new Slice((atStart ? Fragment.empty : Fragment.from(list.copy(Fragment.empty)))\n        .append(atEnd ? Fragment.empty : Fragment.from(list.copy(Fragment.empty))), atStart ? 0 : 1, atEnd ? 0 : 1), atStart ? 0 : 1));\n    dispatch(tr.scrollIntoView());\n    return true;\n}\n/**\nCreate a command to sink the list item around the selection down\ninto an inner list.\n*/\nfunction sinkListItem(itemType) {\n    return function (state, dispatch) {\n        let { $from, $to } = state.selection;\n        let range = $from.blockRange($to, node => node.childCount > 0 && node.firstChild.type == itemType);\n        if (!range)\n            return false;\n        let startIndex = range.startIndex;\n        if (startIndex == 0)\n            return false;\n        let parent = range.parent, nodeBefore = parent.child(startIndex - 1);\n        if (nodeBefore.type != itemType)\n            return false;\n        if (dispatch) {\n            let nestedBefore = nodeBefore.lastChild && nodeBefore.lastChild.type == parent.type;\n            let inner = Fragment.from(nestedBefore ? itemType.create() : null);\n            let slice = new Slice(Fragment.from(itemType.create(null, Fragment.from(parent.type.create(null, inner)))), nestedBefore ? 3 : 1, 0);\n            let before = range.start, after = range.end;\n            dispatch(state.tr.step(new ReplaceAroundStep(before - (nestedBefore ? 3 : 1), after, before, after, slice, 1, true))\n                .scrollIntoView());\n        }\n        return true;\n    };\n}\n\nexport { addListNodes, bulletList, liftListItem, listItem, orderedList, sinkListItem, splitListItem, splitListItemKeepMarks, wrapInList };\n","import * as React from 'react';\n/**\n * Hook which synchronously executes a callback when the component is about to unmount.\n *\n * @param callback - Function to call during unmount.\n */\nexport var useUnmount = function (callback) {\n    var unmountRef = React.useRef(callback);\n    unmountRef.current = callback;\n    React.useEffect(function () { return function () {\n        var _a;\n        (_a = unmountRef.current) === null || _a === void 0 ? void 0 : _a.call(unmountRef);\n    }; }, []);\n};\n//# sourceMappingURL=useUnmount.js.map","var _typeof = require(\"./typeof.js\")[\"default\"];\nfunction _toPrimitive(input, hint) {\n  if (_typeof(input) !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (_typeof(res) !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}\nmodule.exports = _toPrimitive, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","import { __assign } from 'tslib';\nimport { mix } from './mix.js';\nimport { hex, rgba, hsla } from 'style-value-types';\nimport { invariant } from 'hey-listen';\n\nvar mixLinearColor = function (from, to, v) {\n    var fromExpo = from * from;\n    var toExpo = to * to;\n    return Math.sqrt(Math.max(0, v * (toExpo - fromExpo) + fromExpo));\n};\nvar colorTypes = [hex, rgba, hsla];\nvar getColorType = function (v) {\n    return colorTypes.find(function (type) { return type.test(v); });\n};\nvar notAnimatable = function (color) {\n    return \"'\" + color + \"' is not an animatable color. Use the equivalent color code instead.\";\n};\nvar mixColor = function (from, to) {\n    var fromColorType = getColorType(from);\n    var toColorType = getColorType(to);\n    invariant(!!fromColorType, notAnimatable(from));\n    invariant(!!toColorType, notAnimatable(to));\n    invariant(fromColorType.transform === toColorType.transform, \"Both colors must be hex/RGBA, OR both must be HSLA.\");\n    var fromColor = fromColorType.parse(from);\n    var toColor = toColorType.parse(to);\n    var blended = __assign({}, fromColor);\n    var mixFunc = fromColorType === hsla ? mix : mixLinearColor;\n    return function (v) {\n        for (var key in blended) {\n            if (key !== \"alpha\") {\n                blended[key] = mixFunc(fromColor[key], toColor[key], v);\n            }\n        }\n        blended.alpha = mix(fromColor.alpha, toColor.alpha, v);\n        return fromColorType.transform(blended);\n    };\n};\n\nexport { mixColor, mixLinearColor };\n","export default function getFreshSideObject() {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0\n  };\n}","// src/index.ts\nimport { Plugin as Plugin2 } from \"prosemirror-state\";\n\n// src/cellselection.ts\nimport { Fragment, Slice } from \"prosemirror-model\";\nimport {\n  NodeSelection as NodeSelection2,\n  Selection,\n  SelectionRange,\n  TextSelection\n} from \"prosemirror-state\";\nimport { Decoration, DecorationSet } from \"prosemirror-view\";\n\n// src/tablemap.ts\nvar readFromCache;\nvar addToCache;\nif (typeof WeakMap != \"undefined\") {\n  let cache = /* @__PURE__ */ new WeakMap();\n  readFromCache = (key) => cache.get(key);\n  addToCache = (key, value) => {\n    cache.set(key, value);\n    return value;\n  };\n} else {\n  const cache = [];\n  const cacheSize = 10;\n  let cachePos = 0;\n  readFromCache = (key) => {\n    for (let i = 0; i < cache.length; i += 2)\n      if (cache[i] == key)\n        return cache[i + 1];\n  };\n  addToCache = (key, value) => {\n    if (cachePos == cacheSize)\n      cachePos = 0;\n    cache[cachePos++] = key;\n    return cache[cachePos++] = value;\n  };\n}\nvar TableMap = class {\n  constructor(width, height, map, problems) {\n    this.width = width;\n    this.height = height;\n    this.map = map;\n    this.problems = problems;\n  }\n  // Find the dimensions of the cell at the given position.\n  findCell(pos) {\n    for (let i = 0; i < this.map.length; i++) {\n      const curPos = this.map[i];\n      if (curPos != pos)\n        continue;\n      const left = i % this.width;\n      const top = i / this.width | 0;\n      let right = left + 1;\n      let bottom = top + 1;\n      for (let j = 1; right < this.width && this.map[i + j] == curPos; j++) {\n        right++;\n      }\n      for (let j = 1; bottom < this.height && this.map[i + this.width * j] == curPos; j++) {\n        bottom++;\n      }\n      return { left, top, right, bottom };\n    }\n    throw new RangeError(`No cell with offset ${pos} found`);\n  }\n  // Find the left side of the cell at the given position.\n  colCount(pos) {\n    for (let i = 0; i < this.map.length; i++) {\n      if (this.map[i] == pos) {\n        return i % this.width;\n      }\n    }\n    throw new RangeError(`No cell with offset ${pos} found`);\n  }\n  // Find the next cell in the given direction, starting from the cell\n  // at `pos`, if any.\n  nextCell(pos, axis, dir) {\n    const { left, right, top, bottom } = this.findCell(pos);\n    if (axis == \"horiz\") {\n      if (dir < 0 ? left == 0 : right == this.width)\n        return null;\n      return this.map[top * this.width + (dir < 0 ? left - 1 : right)];\n    } else {\n      if (dir < 0 ? top == 0 : bottom == this.height)\n        return null;\n      return this.map[left + this.width * (dir < 0 ? top - 1 : bottom)];\n    }\n  }\n  // Get the rectangle spanning the two given cells.\n  rectBetween(a, b) {\n    const {\n      left: leftA,\n      right: rightA,\n      top: topA,\n      bottom: bottomA\n    } = this.findCell(a);\n    const {\n      left: leftB,\n      right: rightB,\n      top: topB,\n      bottom: bottomB\n    } = this.findCell(b);\n    return {\n      left: Math.min(leftA, leftB),\n      top: Math.min(topA, topB),\n      right: Math.max(rightA, rightB),\n      bottom: Math.max(bottomA, bottomB)\n    };\n  }\n  // Return the position of all cells that have the top left corner in\n  // the given rectangle.\n  cellsInRect(rect) {\n    const result = [];\n    const seen = {};\n    for (let row = rect.top; row < rect.bottom; row++) {\n      for (let col = rect.left; col < rect.right; col++) {\n        const index = row * this.width + col;\n        const pos = this.map[index];\n        if (seen[pos])\n          continue;\n        seen[pos] = true;\n        if (col == rect.left && col && this.map[index - 1] == pos || row == rect.top && row && this.map[index - this.width] == pos) {\n          continue;\n        }\n        result.push(pos);\n      }\n    }\n    return result;\n  }\n  // Return the position at which the cell at the given row and column\n  // starts, or would start, if a cell started there.\n  positionAt(row, col, table) {\n    for (let i = 0, rowStart = 0; ; i++) {\n      const rowEnd = rowStart + table.child(i).nodeSize;\n      if (i == row) {\n        let index = col + row * this.width;\n        const rowEndIndex = (row + 1) * this.width;\n        while (index < rowEndIndex && this.map[index] < rowStart)\n          index++;\n        return index == rowEndIndex ? rowEnd - 1 : this.map[index];\n      }\n      rowStart = rowEnd;\n    }\n  }\n  // Find the table map for the given table node.\n  static get(table) {\n    return readFromCache(table) || addToCache(table, computeMap(table));\n  }\n};\nfunction computeMap(table) {\n  if (table.type.spec.tableRole != \"table\")\n    throw new RangeError(\"Not a table node: \" + table.type.name);\n  const width = findWidth(table), height = table.childCount;\n  const map = [];\n  let mapPos = 0;\n  let problems = null;\n  const colWidths = [];\n  for (let i = 0, e = width * height; i < e; i++)\n    map[i] = 0;\n  for (let row = 0, pos = 0; row < height; row++) {\n    const rowNode = table.child(row);\n    pos++;\n    for (let i = 0; ; i++) {\n      while (mapPos < map.length && map[mapPos] != 0)\n        mapPos++;\n      if (i == rowNode.childCount)\n        break;\n      const cellNode = rowNode.child(i);\n      const { colspan, rowspan, colwidth } = cellNode.attrs;\n      for (let h = 0; h < rowspan; h++) {\n        if (h + row >= height) {\n          (problems || (problems = [])).push({\n            type: \"overlong_rowspan\",\n            pos,\n            n: rowspan - h\n          });\n          break;\n        }\n        const start = mapPos + h * width;\n        for (let w = 0; w < colspan; w++) {\n          if (map[start + w] == 0)\n            map[start + w] = pos;\n          else\n            (problems || (problems = [])).push({\n              type: \"collision\",\n              row,\n              pos,\n              n: colspan - w\n            });\n          const colW = colwidth && colwidth[w];\n          if (colW) {\n            const widthIndex = (start + w) % width * 2, prev = colWidths[widthIndex];\n            if (prev == null || prev != colW && colWidths[widthIndex + 1] == 1) {\n              colWidths[widthIndex] = colW;\n              colWidths[widthIndex + 1] = 1;\n            } else if (prev == colW) {\n              colWidths[widthIndex + 1]++;\n            }\n          }\n        }\n      }\n      mapPos += colspan;\n      pos += cellNode.nodeSize;\n    }\n    const expectedPos = (row + 1) * width;\n    let missing = 0;\n    while (mapPos < expectedPos)\n      if (map[mapPos++] == 0)\n        missing++;\n    if (missing)\n      (problems || (problems = [])).push({ type: \"missing\", row, n: missing });\n    pos++;\n  }\n  const tableMap = new TableMap(width, height, map, problems);\n  let badWidths = false;\n  for (let i = 0; !badWidths && i < colWidths.length; i += 2)\n    if (colWidths[i] != null && colWidths[i + 1] < height)\n      badWidths = true;\n  if (badWidths)\n    findBadColWidths(tableMap, colWidths, table);\n  return tableMap;\n}\nfunction findWidth(table) {\n  let width = -1;\n  let hasRowSpan = false;\n  for (let row = 0; row < table.childCount; row++) {\n    const rowNode = table.child(row);\n    let rowWidth = 0;\n    if (hasRowSpan)\n      for (let j = 0; j < row; j++) {\n        const prevRow = table.child(j);\n        for (let i = 0; i < prevRow.childCount; i++) {\n          const cell = prevRow.child(i);\n          if (j + cell.attrs.rowspan > row)\n            rowWidth += cell.attrs.colspan;\n        }\n      }\n    for (let i = 0; i < rowNode.childCount; i++) {\n      const cell = rowNode.child(i);\n      rowWidth += cell.attrs.colspan;\n      if (cell.attrs.rowspan > 1)\n        hasRowSpan = true;\n    }\n    if (width == -1)\n      width = rowWidth;\n    else if (width != rowWidth)\n      width = Math.max(width, rowWidth);\n  }\n  return width;\n}\nfunction findBadColWidths(map, colWidths, table) {\n  if (!map.problems)\n    map.problems = [];\n  const seen = {};\n  for (let i = 0; i < map.map.length; i++) {\n    const pos = map.map[i];\n    if (seen[pos])\n      continue;\n    seen[pos] = true;\n    const node = table.nodeAt(pos);\n    if (!node) {\n      throw new RangeError(`No cell with offset ${pos} found`);\n    }\n    let updated = null;\n    const attrs = node.attrs;\n    for (let j = 0; j < attrs.colspan; j++) {\n      const col = (i + j) % map.width;\n      const colWidth = colWidths[col * 2];\n      if (colWidth != null && (!attrs.colwidth || attrs.colwidth[j] != colWidth))\n        (updated || (updated = freshColWidth(attrs)))[j] = colWidth;\n    }\n    if (updated)\n      map.problems.unshift({\n        type: \"colwidth mismatch\",\n        pos,\n        colwidth: updated\n      });\n  }\n}\nfunction freshColWidth(attrs) {\n  if (attrs.colwidth)\n    return attrs.colwidth.slice();\n  const result = [];\n  for (let i = 0; i < attrs.colspan; i++)\n    result.push(0);\n  return result;\n}\n\n// src/util.ts\nimport { PluginKey } from \"prosemirror-state\";\n\n// src/schema.ts\nfunction getCellAttrs(dom, extraAttrs) {\n  if (typeof dom === \"string\") {\n    return {};\n  }\n  const widthAttr = dom.getAttribute(\"data-colwidth\");\n  const widths = widthAttr && /^\\d+(,\\d+)*$/.test(widthAttr) ? widthAttr.split(\",\").map((s) => Number(s)) : null;\n  const colspan = Number(dom.getAttribute(\"colspan\") || 1);\n  const result = {\n    colspan,\n    rowspan: Number(dom.getAttribute(\"rowspan\") || 1),\n    colwidth: widths && widths.length == colspan ? widths : null\n  };\n  for (const prop in extraAttrs) {\n    const getter = extraAttrs[prop].getFromDOM;\n    const value = getter && getter(dom);\n    if (value != null) {\n      result[prop] = value;\n    }\n  }\n  return result;\n}\nfunction setCellAttrs(node, extraAttrs) {\n  const attrs = {};\n  if (node.attrs.colspan != 1)\n    attrs.colspan = node.attrs.colspan;\n  if (node.attrs.rowspan != 1)\n    attrs.rowspan = node.attrs.rowspan;\n  if (node.attrs.colwidth)\n    attrs[\"data-colwidth\"] = node.attrs.colwidth.join(\",\");\n  for (const prop in extraAttrs) {\n    const setter = extraAttrs[prop].setDOMAttr;\n    if (setter)\n      setter(node.attrs[prop], attrs);\n  }\n  return attrs;\n}\nfunction tableNodes(options) {\n  const extraAttrs = options.cellAttributes || {};\n  const cellAttrs = {\n    colspan: { default: 1 },\n    rowspan: { default: 1 },\n    colwidth: { default: null }\n  };\n  for (const prop in extraAttrs)\n    cellAttrs[prop] = { default: extraAttrs[prop].default };\n  return {\n    table: {\n      content: \"table_row+\",\n      tableRole: \"table\",\n      isolating: true,\n      group: options.tableGroup,\n      parseDOM: [{ tag: \"table\" }],\n      toDOM() {\n        return [\"table\", [\"tbody\", 0]];\n      }\n    },\n    table_row: {\n      content: \"(table_cell | table_header)*\",\n      tableRole: \"row\",\n      parseDOM: [{ tag: \"tr\" }],\n      toDOM() {\n        return [\"tr\", 0];\n      }\n    },\n    table_cell: {\n      content: options.cellContent,\n      attrs: cellAttrs,\n      tableRole: \"cell\",\n      isolating: true,\n      parseDOM: [\n        { tag: \"td\", getAttrs: (dom) => getCellAttrs(dom, extraAttrs) }\n      ],\n      toDOM(node) {\n        return [\"td\", setCellAttrs(node, extraAttrs), 0];\n      }\n    },\n    table_header: {\n      content: options.cellContent,\n      attrs: cellAttrs,\n      tableRole: \"header_cell\",\n      isolating: true,\n      parseDOM: [\n        { tag: \"th\", getAttrs: (dom) => getCellAttrs(dom, extraAttrs) }\n      ],\n      toDOM(node) {\n        return [\"th\", setCellAttrs(node, extraAttrs), 0];\n      }\n    }\n  };\n}\nfunction tableNodeTypes(schema) {\n  let result = schema.cached.tableNodeTypes;\n  if (!result) {\n    result = schema.cached.tableNodeTypes = {};\n    for (const name in schema.nodes) {\n      const type = schema.nodes[name], role = type.spec.tableRole;\n      if (role)\n        result[role] = type;\n    }\n  }\n  return result;\n}\n\n// src/util.ts\nvar tableEditingKey = new PluginKey(\"selectingCells\");\nfunction cellAround($pos) {\n  for (let d = $pos.depth - 1; d > 0; d--)\n    if ($pos.node(d).type.spec.tableRole == \"row\")\n      return $pos.node(0).resolve($pos.before(d + 1));\n  return null;\n}\nfunction cellWrapping($pos) {\n  for (let d = $pos.depth; d > 0; d--) {\n    const role = $pos.node(d).type.spec.tableRole;\n    if (role === \"cell\" || role === \"header_cell\")\n      return $pos.node(d);\n  }\n  return null;\n}\nfunction isInTable(state) {\n  const $head = state.selection.$head;\n  for (let d = $head.depth; d > 0; d--)\n    if ($head.node(d).type.spec.tableRole == \"row\")\n      return true;\n  return false;\n}\nfunction selectionCell(state) {\n  const sel = state.selection;\n  if (\"$anchorCell\" in sel && sel.$anchorCell) {\n    return sel.$anchorCell.pos > sel.$headCell.pos ? sel.$anchorCell : sel.$headCell;\n  } else if (\"node\" in sel && sel.node && sel.node.type.spec.tableRole == \"cell\") {\n    return sel.$anchor;\n  }\n  const $cell = cellAround(sel.$head) || cellNear(sel.$head);\n  if ($cell) {\n    return $cell;\n  }\n  throw new RangeError(`No cell found around position ${sel.head}`);\n}\nfunction cellNear($pos) {\n  for (let after = $pos.nodeAfter, pos = $pos.pos; after; after = after.firstChild, pos++) {\n    const role = after.type.spec.tableRole;\n    if (role == \"cell\" || role == \"header_cell\")\n      return $pos.doc.resolve(pos);\n  }\n  for (let before = $pos.nodeBefore, pos = $pos.pos; before; before = before.lastChild, pos--) {\n    const role = before.type.spec.tableRole;\n    if (role == \"cell\" || role == \"header_cell\")\n      return $pos.doc.resolve(pos - before.nodeSize);\n  }\n}\nfunction pointsAtCell($pos) {\n  return $pos.parent.type.spec.tableRole == \"row\" && !!$pos.nodeAfter;\n}\nfunction moveCellForward($pos) {\n  return $pos.node(0).resolve($pos.pos + $pos.nodeAfter.nodeSize);\n}\nfunction inSameTable($cellA, $cellB) {\n  return $cellA.depth == $cellB.depth && $cellA.pos >= $cellB.start(-1) && $cellA.pos <= $cellB.end(-1);\n}\nfunction findCell($pos) {\n  return TableMap.get($pos.node(-1)).findCell($pos.pos - $pos.start(-1));\n}\nfunction colCount($pos) {\n  return TableMap.get($pos.node(-1)).colCount($pos.pos - $pos.start(-1));\n}\nfunction nextCell($pos, axis, dir) {\n  const table = $pos.node(-1);\n  const map = TableMap.get(table);\n  const tableStart = $pos.start(-1);\n  const moved = map.nextCell($pos.pos - tableStart, axis, dir);\n  return moved == null ? null : $pos.node(0).resolve(tableStart + moved);\n}\nfunction removeColSpan(attrs, pos, n = 1) {\n  const result = { ...attrs, colspan: attrs.colspan - n };\n  if (result.colwidth) {\n    result.colwidth = result.colwidth.slice();\n    result.colwidth.splice(pos, n);\n    if (!result.colwidth.some((w) => w > 0))\n      result.colwidth = null;\n  }\n  return result;\n}\nfunction addColSpan(attrs, pos, n = 1) {\n  const result = { ...attrs, colspan: attrs.colspan + n };\n  if (result.colwidth) {\n    result.colwidth = result.colwidth.slice();\n    for (let i = 0; i < n; i++)\n      result.colwidth.splice(pos, 0, 0);\n  }\n  return result;\n}\nfunction columnIsHeader(map, table, col) {\n  const headerCell = tableNodeTypes(table.type.schema).header_cell;\n  for (let row = 0; row < map.height; row++)\n    if (table.nodeAt(map.map[col + row * map.width]).type != headerCell)\n      return false;\n  return true;\n}\n\n// src/cellselection.ts\nvar CellSelection = class _CellSelection extends Selection {\n  // A table selection is identified by its anchor and head cells. The\n  // positions given to this constructor should point _before_ two\n  // cells in the same table. They may be the same, to select a single\n  // cell.\n  constructor($anchorCell, $headCell = $anchorCell) {\n    const table = $anchorCell.node(-1);\n    const map = TableMap.get(table);\n    const tableStart = $anchorCell.start(-1);\n    const rect = map.rectBetween(\n      $anchorCell.pos - tableStart,\n      $headCell.pos - tableStart\n    );\n    const doc = $anchorCell.node(0);\n    const cells = map.cellsInRect(rect).filter((p) => p != $headCell.pos - tableStart);\n    cells.unshift($headCell.pos - tableStart);\n    const ranges = cells.map((pos) => {\n      const cell = table.nodeAt(pos);\n      if (!cell) {\n        throw RangeError(`No cell with offset ${pos} found`);\n      }\n      const from = tableStart + pos + 1;\n      return new SelectionRange(\n        doc.resolve(from),\n        doc.resolve(from + cell.content.size)\n      );\n    });\n    super(ranges[0].$from, ranges[0].$to, ranges);\n    this.$anchorCell = $anchorCell;\n    this.$headCell = $headCell;\n  }\n  map(doc, mapping) {\n    const $anchorCell = doc.resolve(mapping.map(this.$anchorCell.pos));\n    const $headCell = doc.resolve(mapping.map(this.$headCell.pos));\n    if (pointsAtCell($anchorCell) && pointsAtCell($headCell) && inSameTable($anchorCell, $headCell)) {\n      const tableChanged = this.$anchorCell.node(-1) != $anchorCell.node(-1);\n      if (tableChanged && this.isRowSelection())\n        return _CellSelection.rowSelection($anchorCell, $headCell);\n      else if (tableChanged && this.isColSelection())\n        return _CellSelection.colSelection($anchorCell, $headCell);\n      else\n        return new _CellSelection($anchorCell, $headCell);\n    }\n    return TextSelection.between($anchorCell, $headCell);\n  }\n  // Returns a rectangular slice of table rows containing the selected\n  // cells.\n  content() {\n    const table = this.$anchorCell.node(-1);\n    const map = TableMap.get(table);\n    const tableStart = this.$anchorCell.start(-1);\n    const rect = map.rectBetween(\n      this.$anchorCell.pos - tableStart,\n      this.$headCell.pos - tableStart\n    );\n    const seen = {};\n    const rows = [];\n    for (let row = rect.top; row < rect.bottom; row++) {\n      const rowContent = [];\n      for (let index = row * map.width + rect.left, col = rect.left; col < rect.right; col++, index++) {\n        const pos = map.map[index];\n        if (seen[pos])\n          continue;\n        seen[pos] = true;\n        const cellRect = map.findCell(pos);\n        let cell = table.nodeAt(pos);\n        if (!cell) {\n          throw RangeError(`No cell with offset ${pos} found`);\n        }\n        const extraLeft = rect.left - cellRect.left;\n        const extraRight = cellRect.right - rect.right;\n        if (extraLeft > 0 || extraRight > 0) {\n          let attrs = cell.attrs;\n          if (extraLeft > 0) {\n            attrs = removeColSpan(attrs, 0, extraLeft);\n          }\n          if (extraRight > 0) {\n            attrs = removeColSpan(\n              attrs,\n              attrs.colspan - extraRight,\n              extraRight\n            );\n          }\n          if (cellRect.left < rect.left) {\n            cell = cell.type.createAndFill(attrs);\n            if (!cell) {\n              throw RangeError(\n                `Could not create cell with attrs ${JSON.stringify(attrs)}`\n              );\n            }\n          } else {\n            cell = cell.type.create(attrs, cell.content);\n          }\n        }\n        if (cellRect.top < rect.top || cellRect.bottom > rect.bottom) {\n          const attrs = {\n            ...cell.attrs,\n            rowspan: Math.min(cellRect.bottom, rect.bottom) - Math.max(cellRect.top, rect.top)\n          };\n          if (cellRect.top < rect.top) {\n            cell = cell.type.createAndFill(attrs);\n          } else {\n            cell = cell.type.create(attrs, cell.content);\n          }\n        }\n        rowContent.push(cell);\n      }\n      rows.push(table.child(row).copy(Fragment.from(rowContent)));\n    }\n    const fragment = this.isColSelection() && this.isRowSelection() ? table : rows;\n    return new Slice(Fragment.from(fragment), 1, 1);\n  }\n  replace(tr, content = Slice.empty) {\n    const mapFrom = tr.steps.length, ranges = this.ranges;\n    for (let i = 0; i < ranges.length; i++) {\n      const { $from, $to } = ranges[i], mapping = tr.mapping.slice(mapFrom);\n      tr.replace(\n        mapping.map($from.pos),\n        mapping.map($to.pos),\n        i ? Slice.empty : content\n      );\n    }\n    const sel = Selection.findFrom(\n      tr.doc.resolve(tr.mapping.slice(mapFrom).map(this.to)),\n      -1\n    );\n    if (sel)\n      tr.setSelection(sel);\n  }\n  replaceWith(tr, node) {\n    this.replace(tr, new Slice(Fragment.from(node), 0, 0));\n  }\n  forEachCell(f) {\n    const table = this.$anchorCell.node(-1);\n    const map = TableMap.get(table);\n    const tableStart = this.$anchorCell.start(-1);\n    const cells = map.cellsInRect(\n      map.rectBetween(\n        this.$anchorCell.pos - tableStart,\n        this.$headCell.pos - tableStart\n      )\n    );\n    for (let i = 0; i < cells.length; i++) {\n      f(table.nodeAt(cells[i]), tableStart + cells[i]);\n    }\n  }\n  // True if this selection goes all the way from the top to the\n  // bottom of the table.\n  isColSelection() {\n    const anchorTop = this.$anchorCell.index(-1);\n    const headTop = this.$headCell.index(-1);\n    if (Math.min(anchorTop, headTop) > 0)\n      return false;\n    const anchorBottom = anchorTop + this.$anchorCell.nodeAfter.attrs.rowspan;\n    const headBottom = headTop + this.$headCell.nodeAfter.attrs.rowspan;\n    return Math.max(anchorBottom, headBottom) == this.$headCell.node(-1).childCount;\n  }\n  // Returns the smallest column selection that covers the given anchor\n  // and head cell.\n  static colSelection($anchorCell, $headCell = $anchorCell) {\n    const table = $anchorCell.node(-1);\n    const map = TableMap.get(table);\n    const tableStart = $anchorCell.start(-1);\n    const anchorRect = map.findCell($anchorCell.pos - tableStart);\n    const headRect = map.findCell($headCell.pos - tableStart);\n    const doc = $anchorCell.node(0);\n    if (anchorRect.top <= headRect.top) {\n      if (anchorRect.top > 0)\n        $anchorCell = doc.resolve(tableStart + map.map[anchorRect.left]);\n      if (headRect.bottom < map.height)\n        $headCell = doc.resolve(\n          tableStart + map.map[map.width * (map.height - 1) + headRect.right - 1]\n        );\n    } else {\n      if (headRect.top > 0)\n        $headCell = doc.resolve(tableStart + map.map[headRect.left]);\n      if (anchorRect.bottom < map.height)\n        $anchorCell = doc.resolve(\n          tableStart + map.map[map.width * (map.height - 1) + anchorRect.right - 1]\n        );\n    }\n    return new _CellSelection($anchorCell, $headCell);\n  }\n  // True if this selection goes all the way from the left to the\n  // right of the table.\n  isRowSelection() {\n    const table = this.$anchorCell.node(-1);\n    const map = TableMap.get(table);\n    const tableStart = this.$anchorCell.start(-1);\n    const anchorLeft = map.colCount(this.$anchorCell.pos - tableStart);\n    const headLeft = map.colCount(this.$headCell.pos - tableStart);\n    if (Math.min(anchorLeft, headLeft) > 0)\n      return false;\n    const anchorRight = anchorLeft + this.$anchorCell.nodeAfter.attrs.colspan;\n    const headRight = headLeft + this.$headCell.nodeAfter.attrs.colspan;\n    return Math.max(anchorRight, headRight) == map.width;\n  }\n  eq(other) {\n    return other instanceof _CellSelection && other.$anchorCell.pos == this.$anchorCell.pos && other.$headCell.pos == this.$headCell.pos;\n  }\n  // Returns the smallest row selection that covers the given anchor\n  // and head cell.\n  static rowSelection($anchorCell, $headCell = $anchorCell) {\n    const table = $anchorCell.node(-1);\n    const map = TableMap.get(table);\n    const tableStart = $anchorCell.start(-1);\n    const anchorRect = map.findCell($anchorCell.pos - tableStart);\n    const headRect = map.findCell($headCell.pos - tableStart);\n    const doc = $anchorCell.node(0);\n    if (anchorRect.left <= headRect.left) {\n      if (anchorRect.left > 0)\n        $anchorCell = doc.resolve(\n          tableStart + map.map[anchorRect.top * map.width]\n        );\n      if (headRect.right < map.width)\n        $headCell = doc.resolve(\n          tableStart + map.map[map.width * (headRect.top + 1) - 1]\n        );\n    } else {\n      if (headRect.left > 0)\n        $headCell = doc.resolve(tableStart + map.map[headRect.top * map.width]);\n      if (anchorRect.right < map.width)\n        $anchorCell = doc.resolve(\n          tableStart + map.map[map.width * (anchorRect.top + 1) - 1]\n        );\n    }\n    return new _CellSelection($anchorCell, $headCell);\n  }\n  toJSON() {\n    return {\n      type: \"cell\",\n      anchor: this.$anchorCell.pos,\n      head: this.$headCell.pos\n    };\n  }\n  static fromJSON(doc, json) {\n    return new _CellSelection(doc.resolve(json.anchor), doc.resolve(json.head));\n  }\n  static create(doc, anchorCell, headCell = anchorCell) {\n    return new _CellSelection(doc.resolve(anchorCell), doc.resolve(headCell));\n  }\n  getBookmark() {\n    return new CellBookmark(this.$anchorCell.pos, this.$headCell.pos);\n  }\n};\nCellSelection.prototype.visible = false;\nSelection.jsonID(\"cell\", CellSelection);\nvar CellBookmark = class _CellBookmark {\n  constructor(anchor, head) {\n    this.anchor = anchor;\n    this.head = head;\n  }\n  map(mapping) {\n    return new _CellBookmark(mapping.map(this.anchor), mapping.map(this.head));\n  }\n  resolve(doc) {\n    const $anchorCell = doc.resolve(this.anchor), $headCell = doc.resolve(this.head);\n    if ($anchorCell.parent.type.spec.tableRole == \"row\" && $headCell.parent.type.spec.tableRole == \"row\" && $anchorCell.index() < $anchorCell.parent.childCount && $headCell.index() < $headCell.parent.childCount && inSameTable($anchorCell, $headCell))\n      return new CellSelection($anchorCell, $headCell);\n    else\n      return Selection.near($headCell, 1);\n  }\n};\nfunction drawCellSelection(state) {\n  if (!(state.selection instanceof CellSelection))\n    return null;\n  const cells = [];\n  state.selection.forEachCell((node, pos) => {\n    cells.push(\n      Decoration.node(pos, pos + node.nodeSize, { class: \"selectedCell\" })\n    );\n  });\n  return DecorationSet.create(state.doc, cells);\n}\nfunction isCellBoundarySelection({ $from, $to }) {\n  if ($from.pos == $to.pos || $from.pos < $from.pos - 6)\n    return false;\n  let afterFrom = $from.pos;\n  let beforeTo = $to.pos;\n  let depth = $from.depth;\n  for (; depth >= 0; depth--, afterFrom++)\n    if ($from.after(depth + 1) < $from.end(depth))\n      break;\n  for (let d = $to.depth; d >= 0; d--, beforeTo--)\n    if ($to.before(d + 1) > $to.start(d))\n      break;\n  return afterFrom == beforeTo && /row|table/.test($from.node(depth).type.spec.tableRole);\n}\nfunction isTextSelectionAcrossCells({ $from, $to }) {\n  let fromCellBoundaryNode;\n  let toCellBoundaryNode;\n  for (let i = $from.depth; i > 0; i--) {\n    const node = $from.node(i);\n    if (node.type.spec.tableRole === \"cell\" || node.type.spec.tableRole === \"header_cell\") {\n      fromCellBoundaryNode = node;\n      break;\n    }\n  }\n  for (let i = $to.depth; i > 0; i--) {\n    const node = $to.node(i);\n    if (node.type.spec.tableRole === \"cell\" || node.type.spec.tableRole === \"header_cell\") {\n      toCellBoundaryNode = node;\n      break;\n    }\n  }\n  return fromCellBoundaryNode !== toCellBoundaryNode && $to.parentOffset === 0;\n}\nfunction normalizeSelection(state, tr, allowTableNodeSelection) {\n  const sel = (tr || state).selection;\n  const doc = (tr || state).doc;\n  let normalize;\n  let role;\n  if (sel instanceof NodeSelection2 && (role = sel.node.type.spec.tableRole)) {\n    if (role == \"cell\" || role == \"header_cell\") {\n      normalize = CellSelection.create(doc, sel.from);\n    } else if (role == \"row\") {\n      const $cell = doc.resolve(sel.from + 1);\n      normalize = CellSelection.rowSelection($cell, $cell);\n    } else if (!allowTableNodeSelection) {\n      const map = TableMap.get(sel.node);\n      const start = sel.from + 1;\n      const lastCell = start + map.map[map.width * map.height - 1];\n      normalize = CellSelection.create(doc, start + 1, lastCell);\n    }\n  } else if (sel instanceof TextSelection && isCellBoundarySelection(sel)) {\n    normalize = TextSelection.create(doc, sel.from);\n  } else if (sel instanceof TextSelection && isTextSelectionAcrossCells(sel)) {\n    normalize = TextSelection.create(doc, sel.$from.start(), sel.$from.end());\n  }\n  if (normalize)\n    (tr || (tr = state.tr)).setSelection(normalize);\n  return tr;\n}\n\n// src/fixtables.ts\nimport { PluginKey as PluginKey2 } from \"prosemirror-state\";\nvar fixTablesKey = new PluginKey2(\"fix-tables\");\nfunction changedDescendants(old, cur, offset, f) {\n  const oldSize = old.childCount, curSize = cur.childCount;\n  outer:\n    for (let i = 0, j = 0; i < curSize; i++) {\n      const child = cur.child(i);\n      for (let scan = j, e = Math.min(oldSize, i + 3); scan < e; scan++) {\n        if (old.child(scan) == child) {\n          j = scan + 1;\n          offset += child.nodeSize;\n          continue outer;\n        }\n      }\n      f(child, offset);\n      if (j < oldSize && old.child(j).sameMarkup(child))\n        changedDescendants(old.child(j), child, offset + 1, f);\n      else\n        child.nodesBetween(0, child.content.size, f, offset + 1);\n      offset += child.nodeSize;\n    }\n}\nfunction fixTables(state, oldState) {\n  let tr;\n  const check = (node, pos) => {\n    if (node.type.spec.tableRole == \"table\")\n      tr = fixTable(state, node, pos, tr);\n  };\n  if (!oldState)\n    state.doc.descendants(check);\n  else if (oldState.doc != state.doc)\n    changedDescendants(oldState.doc, state.doc, 0, check);\n  return tr;\n}\nfunction fixTable(state, table, tablePos, tr) {\n  const map = TableMap.get(table);\n  if (!map.problems)\n    return tr;\n  if (!tr)\n    tr = state.tr;\n  const mustAdd = [];\n  for (let i = 0; i < map.height; i++)\n    mustAdd.push(0);\n  for (let i = 0; i < map.problems.length; i++) {\n    const prob = map.problems[i];\n    if (prob.type == \"collision\") {\n      const cell = table.nodeAt(prob.pos);\n      if (!cell)\n        continue;\n      const attrs = cell.attrs;\n      for (let j = 0; j < attrs.rowspan; j++)\n        mustAdd[prob.row + j] += prob.n;\n      tr.setNodeMarkup(\n        tr.mapping.map(tablePos + 1 + prob.pos),\n        null,\n        removeColSpan(attrs, attrs.colspan - prob.n, prob.n)\n      );\n    } else if (prob.type == \"missing\") {\n      mustAdd[prob.row] += prob.n;\n    } else if (prob.type == \"overlong_rowspan\") {\n      const cell = table.nodeAt(prob.pos);\n      if (!cell)\n        continue;\n      tr.setNodeMarkup(tr.mapping.map(tablePos + 1 + prob.pos), null, {\n        ...cell.attrs,\n        rowspan: cell.attrs.rowspan - prob.n\n      });\n    } else if (prob.type == \"colwidth mismatch\") {\n      const cell = table.nodeAt(prob.pos);\n      if (!cell)\n        continue;\n      tr.setNodeMarkup(tr.mapping.map(tablePos + 1 + prob.pos), null, {\n        ...cell.attrs,\n        colwidth: prob.colwidth\n      });\n    }\n  }\n  let first, last;\n  for (let i = 0; i < mustAdd.length; i++)\n    if (mustAdd[i]) {\n      if (first == null)\n        first = i;\n      last = i;\n    }\n  for (let i = 0, pos = tablePos + 1; i < map.height; i++) {\n    const row = table.child(i);\n    const end = pos + row.nodeSize;\n    const add = mustAdd[i];\n    if (add > 0) {\n      let role = \"cell\";\n      if (row.firstChild) {\n        role = row.firstChild.type.spec.tableRole;\n      }\n      const nodes = [];\n      for (let j = 0; j < add; j++) {\n        const node = tableNodeTypes(state.schema)[role].createAndFill();\n        if (node)\n          nodes.push(node);\n      }\n      const side = (i == 0 || first == i - 1) && last == i ? pos + 1 : end - 1;\n      tr.insert(tr.mapping.map(side), nodes);\n    }\n    pos = end;\n  }\n  return tr.setMeta(fixTablesKey, { fixTables: true });\n}\n\n// src/input.ts\nimport { Fragment as Fragment3, Slice as Slice3 } from \"prosemirror-model\";\nimport {\n  Selection as Selection2,\n  TextSelection as TextSelection2\n} from \"prosemirror-state\";\nimport { keydownHandler } from \"prosemirror-keymap\";\n\n// src/copypaste.ts\nimport { Fragment as Fragment2, Slice as Slice2 } from \"prosemirror-model\";\nimport { Transform } from \"prosemirror-transform\";\nfunction pastedCells(slice) {\n  if (!slice.size)\n    return null;\n  let { content, openStart, openEnd } = slice;\n  while (content.childCount == 1 && (openStart > 0 && openEnd > 0 || content.child(0).type.spec.tableRole == \"table\")) {\n    openStart--;\n    openEnd--;\n    content = content.child(0).content;\n  }\n  const first = content.child(0);\n  const role = first.type.spec.tableRole;\n  const schema = first.type.schema, rows = [];\n  if (role == \"row\") {\n    for (let i = 0; i < content.childCount; i++) {\n      let cells = content.child(i).content;\n      const left = i ? 0 : Math.max(0, openStart - 1);\n      const right = i < content.childCount - 1 ? 0 : Math.max(0, openEnd - 1);\n      if (left || right)\n        cells = fitSlice(\n          tableNodeTypes(schema).row,\n          new Slice2(cells, left, right)\n        ).content;\n      rows.push(cells);\n    }\n  } else if (role == \"cell\" || role == \"header_cell\") {\n    rows.push(\n      openStart || openEnd ? fitSlice(\n        tableNodeTypes(schema).row,\n        new Slice2(content, openStart, openEnd)\n      ).content : content\n    );\n  } else {\n    return null;\n  }\n  return ensureRectangular(schema, rows);\n}\nfunction ensureRectangular(schema, rows) {\n  const widths = [];\n  for (let i = 0; i < rows.length; i++) {\n    const row = rows[i];\n    for (let j = row.childCount - 1; j >= 0; j--) {\n      const { rowspan, colspan } = row.child(j).attrs;\n      for (let r = i; r < i + rowspan; r++)\n        widths[r] = (widths[r] || 0) + colspan;\n    }\n  }\n  let width = 0;\n  for (let r = 0; r < widths.length; r++)\n    width = Math.max(width, widths[r]);\n  for (let r = 0; r < widths.length; r++) {\n    if (r >= rows.length)\n      rows.push(Fragment2.empty);\n    if (widths[r] < width) {\n      const empty = tableNodeTypes(schema).cell.createAndFill();\n      const cells = [];\n      for (let i = widths[r]; i < width; i++) {\n        cells.push(empty);\n      }\n      rows[r] = rows[r].append(Fragment2.from(cells));\n    }\n  }\n  return { height: rows.length, width, rows };\n}\nfunction fitSlice(nodeType, slice) {\n  const node = nodeType.createAndFill();\n  const tr = new Transform(node).replace(0, node.content.size, slice);\n  return tr.doc;\n}\nfunction clipCells({ width, height, rows }, newWidth, newHeight) {\n  if (width != newWidth) {\n    const added = [];\n    const newRows = [];\n    for (let row = 0; row < rows.length; row++) {\n      const frag = rows[row], cells = [];\n      for (let col = added[row] || 0, i = 0; col < newWidth; i++) {\n        let cell = frag.child(i % frag.childCount);\n        if (col + cell.attrs.colspan > newWidth)\n          cell = cell.type.createChecked(\n            removeColSpan(\n              cell.attrs,\n              cell.attrs.colspan,\n              col + cell.attrs.colspan - newWidth\n            ),\n            cell.content\n          );\n        cells.push(cell);\n        col += cell.attrs.colspan;\n        for (let j = 1; j < cell.attrs.rowspan; j++)\n          added[row + j] = (added[row + j] || 0) + cell.attrs.colspan;\n      }\n      newRows.push(Fragment2.from(cells));\n    }\n    rows = newRows;\n    width = newWidth;\n  }\n  if (height != newHeight) {\n    const newRows = [];\n    for (let row = 0, i = 0; row < newHeight; row++, i++) {\n      const cells = [], source = rows[i % height];\n      for (let j = 0; j < source.childCount; j++) {\n        let cell = source.child(j);\n        if (row + cell.attrs.rowspan > newHeight)\n          cell = cell.type.create(\n            {\n              ...cell.attrs,\n              rowspan: Math.max(1, newHeight - cell.attrs.rowspan)\n            },\n            cell.content\n          );\n        cells.push(cell);\n      }\n      newRows.push(Fragment2.from(cells));\n    }\n    rows = newRows;\n    height = newHeight;\n  }\n  return { width, height, rows };\n}\nfunction growTable(tr, map, table, start, width, height, mapFrom) {\n  const schema = tr.doc.type.schema;\n  const types = tableNodeTypes(schema);\n  let empty;\n  let emptyHead;\n  if (width > map.width) {\n    for (let row = 0, rowEnd = 0; row < map.height; row++) {\n      const rowNode = table.child(row);\n      rowEnd += rowNode.nodeSize;\n      const cells = [];\n      let add;\n      if (rowNode.lastChild == null || rowNode.lastChild.type == types.cell)\n        add = empty || (empty = types.cell.createAndFill());\n      else\n        add = emptyHead || (emptyHead = types.header_cell.createAndFill());\n      for (let i = map.width; i < width; i++)\n        cells.push(add);\n      tr.insert(tr.mapping.slice(mapFrom).map(rowEnd - 1 + start), cells);\n    }\n  }\n  if (height > map.height) {\n    const cells = [];\n    for (let i = 0, start2 = (map.height - 1) * map.width; i < Math.max(map.width, width); i++) {\n      const header = i >= map.width ? false : table.nodeAt(map.map[start2 + i]).type == types.header_cell;\n      cells.push(\n        header ? emptyHead || (emptyHead = types.header_cell.createAndFill()) : empty || (empty = types.cell.createAndFill())\n      );\n    }\n    const emptyRow = types.row.create(null, Fragment2.from(cells)), rows = [];\n    for (let i = map.height; i < height; i++)\n      rows.push(emptyRow);\n    tr.insert(tr.mapping.slice(mapFrom).map(start + table.nodeSize - 2), rows);\n  }\n  return !!(empty || emptyHead);\n}\nfunction isolateHorizontal(tr, map, table, start, left, right, top, mapFrom) {\n  if (top == 0 || top == map.height)\n    return false;\n  let found = false;\n  for (let col = left; col < right; col++) {\n    const index = top * map.width + col, pos = map.map[index];\n    if (map.map[index - map.width] == pos) {\n      found = true;\n      const cell = table.nodeAt(pos);\n      const { top: cellTop, left: cellLeft } = map.findCell(pos);\n      tr.setNodeMarkup(tr.mapping.slice(mapFrom).map(pos + start), null, {\n        ...cell.attrs,\n        rowspan: top - cellTop\n      });\n      tr.insert(\n        tr.mapping.slice(mapFrom).map(map.positionAt(top, cellLeft, table)),\n        cell.type.createAndFill({\n          ...cell.attrs,\n          rowspan: cellTop + cell.attrs.rowspan - top\n        })\n      );\n      col += cell.attrs.colspan - 1;\n    }\n  }\n  return found;\n}\nfunction isolateVertical(tr, map, table, start, top, bottom, left, mapFrom) {\n  if (left == 0 || left == map.width)\n    return false;\n  let found = false;\n  for (let row = top; row < bottom; row++) {\n    const index = row * map.width + left, pos = map.map[index];\n    if (map.map[index - 1] == pos) {\n      found = true;\n      const cell = table.nodeAt(pos);\n      const cellLeft = map.colCount(pos);\n      const updatePos = tr.mapping.slice(mapFrom).map(pos + start);\n      tr.setNodeMarkup(\n        updatePos,\n        null,\n        removeColSpan(\n          cell.attrs,\n          left - cellLeft,\n          cell.attrs.colspan - (left - cellLeft)\n        )\n      );\n      tr.insert(\n        updatePos + cell.nodeSize,\n        cell.type.createAndFill(\n          removeColSpan(cell.attrs, 0, left - cellLeft)\n        )\n      );\n      row += cell.attrs.rowspan - 1;\n    }\n  }\n  return found;\n}\nfunction insertCells(state, dispatch, tableStart, rect, cells) {\n  let table = tableStart ? state.doc.nodeAt(tableStart - 1) : state.doc;\n  if (!table) {\n    throw new Error(\"No table found\");\n  }\n  let map = TableMap.get(table);\n  const { top, left } = rect;\n  const right = left + cells.width, bottom = top + cells.height;\n  const tr = state.tr;\n  let mapFrom = 0;\n  function recomp() {\n    table = tableStart ? tr.doc.nodeAt(tableStart - 1) : tr.doc;\n    if (!table) {\n      throw new Error(\"No table found\");\n    }\n    map = TableMap.get(table);\n    mapFrom = tr.mapping.maps.length;\n  }\n  if (growTable(tr, map, table, tableStart, right, bottom, mapFrom))\n    recomp();\n  if (isolateHorizontal(tr, map, table, tableStart, left, right, top, mapFrom))\n    recomp();\n  if (isolateHorizontal(tr, map, table, tableStart, left, right, bottom, mapFrom))\n    recomp();\n  if (isolateVertical(tr, map, table, tableStart, top, bottom, left, mapFrom))\n    recomp();\n  if (isolateVertical(tr, map, table, tableStart, top, bottom, right, mapFrom))\n    recomp();\n  for (let row = top; row < bottom; row++) {\n    const from = map.positionAt(row, left, table), to = map.positionAt(row, right, table);\n    tr.replace(\n      tr.mapping.slice(mapFrom).map(from + tableStart),\n      tr.mapping.slice(mapFrom).map(to + tableStart),\n      new Slice2(cells.rows[row - top], 0, 0)\n    );\n  }\n  recomp();\n  tr.setSelection(\n    new CellSelection(\n      tr.doc.resolve(tableStart + map.positionAt(top, left, table)),\n      tr.doc.resolve(tableStart + map.positionAt(bottom - 1, right - 1, table))\n    )\n  );\n  dispatch(tr);\n}\n\n// src/input.ts\nvar handleKeyDown = keydownHandler({\n  ArrowLeft: arrow(\"horiz\", -1),\n  ArrowRight: arrow(\"horiz\", 1),\n  ArrowUp: arrow(\"vert\", -1),\n  ArrowDown: arrow(\"vert\", 1),\n  \"Shift-ArrowLeft\": shiftArrow(\"horiz\", -1),\n  \"Shift-ArrowRight\": shiftArrow(\"horiz\", 1),\n  \"Shift-ArrowUp\": shiftArrow(\"vert\", -1),\n  \"Shift-ArrowDown\": shiftArrow(\"vert\", 1),\n  Backspace: deleteCellSelection,\n  \"Mod-Backspace\": deleteCellSelection,\n  Delete: deleteCellSelection,\n  \"Mod-Delete\": deleteCellSelection\n});\nfunction maybeSetSelection(state, dispatch, selection) {\n  if (selection.eq(state.selection))\n    return false;\n  if (dispatch)\n    dispatch(state.tr.setSelection(selection).scrollIntoView());\n  return true;\n}\nfunction arrow(axis, dir) {\n  return (state, dispatch, view) => {\n    if (!view)\n      return false;\n    const sel = state.selection;\n    if (sel instanceof CellSelection) {\n      return maybeSetSelection(\n        state,\n        dispatch,\n        Selection2.near(sel.$headCell, dir)\n      );\n    }\n    if (axis != \"horiz\" && !sel.empty)\n      return false;\n    const end = atEndOfCell(view, axis, dir);\n    if (end == null)\n      return false;\n    if (axis == \"horiz\") {\n      return maybeSetSelection(\n        state,\n        dispatch,\n        Selection2.near(state.doc.resolve(sel.head + dir), dir)\n      );\n    } else {\n      const $cell = state.doc.resolve(end);\n      const $next = nextCell($cell, axis, dir);\n      let newSel;\n      if ($next)\n        newSel = Selection2.near($next, 1);\n      else if (dir < 0)\n        newSel = Selection2.near(state.doc.resolve($cell.before(-1)), -1);\n      else\n        newSel = Selection2.near(state.doc.resolve($cell.after(-1)), 1);\n      return maybeSetSelection(state, dispatch, newSel);\n    }\n  };\n}\nfunction shiftArrow(axis, dir) {\n  return (state, dispatch, view) => {\n    if (!view)\n      return false;\n    const sel = state.selection;\n    let cellSel;\n    if (sel instanceof CellSelection) {\n      cellSel = sel;\n    } else {\n      const end = atEndOfCell(view, axis, dir);\n      if (end == null)\n        return false;\n      cellSel = new CellSelection(state.doc.resolve(end));\n    }\n    const $head = nextCell(cellSel.$headCell, axis, dir);\n    if (!$head)\n      return false;\n    return maybeSetSelection(\n      state,\n      dispatch,\n      new CellSelection(cellSel.$anchorCell, $head)\n    );\n  };\n}\nfunction deleteCellSelection(state, dispatch) {\n  const sel = state.selection;\n  if (!(sel instanceof CellSelection))\n    return false;\n  if (dispatch) {\n    const tr = state.tr;\n    const baseContent = tableNodeTypes(state.schema).cell.createAndFill().content;\n    sel.forEachCell((cell, pos) => {\n      if (!cell.content.eq(baseContent))\n        tr.replace(\n          tr.mapping.map(pos + 1),\n          tr.mapping.map(pos + cell.nodeSize - 1),\n          new Slice3(baseContent, 0, 0)\n        );\n    });\n    if (tr.docChanged)\n      dispatch(tr);\n  }\n  return true;\n}\nfunction handleTripleClick(view, pos) {\n  const doc = view.state.doc, $cell = cellAround(doc.resolve(pos));\n  if (!$cell)\n    return false;\n  view.dispatch(view.state.tr.setSelection(new CellSelection($cell)));\n  return true;\n}\nfunction handlePaste(view, _, slice) {\n  if (!isInTable(view.state))\n    return false;\n  let cells = pastedCells(slice);\n  const sel = view.state.selection;\n  if (sel instanceof CellSelection) {\n    if (!cells)\n      cells = {\n        width: 1,\n        height: 1,\n        rows: [\n          Fragment3.from(\n            fitSlice(tableNodeTypes(view.state.schema).cell, slice)\n          )\n        ]\n      };\n    const table = sel.$anchorCell.node(-1);\n    const start = sel.$anchorCell.start(-1);\n    const rect = TableMap.get(table).rectBetween(\n      sel.$anchorCell.pos - start,\n      sel.$headCell.pos - start\n    );\n    cells = clipCells(cells, rect.right - rect.left, rect.bottom - rect.top);\n    insertCells(view.state, view.dispatch, start, rect, cells);\n    return true;\n  } else if (cells) {\n    const $cell = selectionCell(view.state);\n    const start = $cell.start(-1);\n    insertCells(\n      view.state,\n      view.dispatch,\n      start,\n      TableMap.get($cell.node(-1)).findCell($cell.pos - start),\n      cells\n    );\n    return true;\n  } else {\n    return false;\n  }\n}\nfunction handleMouseDown(view, startEvent) {\n  var _a;\n  if (startEvent.ctrlKey || startEvent.metaKey)\n    return;\n  const startDOMCell = domInCell(view, startEvent.target);\n  let $anchor;\n  if (startEvent.shiftKey && view.state.selection instanceof CellSelection) {\n    setCellSelection(view.state.selection.$anchorCell, startEvent);\n    startEvent.preventDefault();\n  } else if (startEvent.shiftKey && startDOMCell && ($anchor = cellAround(view.state.selection.$anchor)) != null && ((_a = cellUnderMouse(view, startEvent)) == null ? void 0 : _a.pos) != $anchor.pos) {\n    setCellSelection($anchor, startEvent);\n    startEvent.preventDefault();\n  } else if (!startDOMCell) {\n    return;\n  }\n  function setCellSelection($anchor2, event) {\n    let $head = cellUnderMouse(view, event);\n    const starting = tableEditingKey.getState(view.state) == null;\n    if (!$head || !inSameTable($anchor2, $head)) {\n      if (starting)\n        $head = $anchor2;\n      else\n        return;\n    }\n    const selection = new CellSelection($anchor2, $head);\n    if (starting || !view.state.selection.eq(selection)) {\n      const tr = view.state.tr.setSelection(selection);\n      if (starting)\n        tr.setMeta(tableEditingKey, $anchor2.pos);\n      view.dispatch(tr);\n    }\n  }\n  function stop() {\n    view.root.removeEventListener(\"mouseup\", stop);\n    view.root.removeEventListener(\"dragstart\", stop);\n    view.root.removeEventListener(\"mousemove\", move);\n    if (tableEditingKey.getState(view.state) != null)\n      view.dispatch(view.state.tr.setMeta(tableEditingKey, -1));\n  }\n  function move(_event) {\n    const event = _event;\n    const anchor = tableEditingKey.getState(view.state);\n    let $anchor2;\n    if (anchor != null) {\n      $anchor2 = view.state.doc.resolve(anchor);\n    } else if (domInCell(view, event.target) != startDOMCell) {\n      $anchor2 = cellUnderMouse(view, startEvent);\n      if (!$anchor2)\n        return stop();\n    }\n    if ($anchor2)\n      setCellSelection($anchor2, event);\n  }\n  view.root.addEventListener(\"mouseup\", stop);\n  view.root.addEventListener(\"dragstart\", stop);\n  view.root.addEventListener(\"mousemove\", move);\n}\nfunction atEndOfCell(view, axis, dir) {\n  if (!(view.state.selection instanceof TextSelection2))\n    return null;\n  const { $head } = view.state.selection;\n  for (let d = $head.depth - 1; d >= 0; d--) {\n    const parent = $head.node(d), index = dir < 0 ? $head.index(d) : $head.indexAfter(d);\n    if (index != (dir < 0 ? 0 : parent.childCount))\n      return null;\n    if (parent.type.spec.tableRole == \"cell\" || parent.type.spec.tableRole == \"header_cell\") {\n      const cellPos = $head.before(d);\n      const dirStr = axis == \"vert\" ? dir > 0 ? \"down\" : \"up\" : dir > 0 ? \"right\" : \"left\";\n      return view.endOfTextblock(dirStr) ? cellPos : null;\n    }\n  }\n  return null;\n}\nfunction domInCell(view, dom) {\n  for (; dom && dom != view.dom; dom = dom.parentNode) {\n    if (dom.nodeName == \"TD\" || dom.nodeName == \"TH\") {\n      return dom;\n    }\n  }\n  return null;\n}\nfunction cellUnderMouse(view, event) {\n  const mousePos = view.posAtCoords({\n    left: event.clientX,\n    top: event.clientY\n  });\n  if (!mousePos)\n    return null;\n  return mousePos ? cellAround(view.state.doc.resolve(mousePos.pos)) : null;\n}\n\n// src/columnresizing.ts\nimport { Plugin, PluginKey as PluginKey3 } from \"prosemirror-state\";\nimport {\n  Decoration as Decoration2,\n  DecorationSet as DecorationSet2\n} from \"prosemirror-view\";\n\n// src/tableview.ts\nvar TableView = class {\n  constructor(node, cellMinWidth) {\n    this.node = node;\n    this.cellMinWidth = cellMinWidth;\n    this.dom = document.createElement(\"div\");\n    this.dom.className = \"tableWrapper\";\n    this.table = this.dom.appendChild(document.createElement(\"table\"));\n    this.colgroup = this.table.appendChild(document.createElement(\"colgroup\"));\n    updateColumnsOnResize(node, this.colgroup, this.table, cellMinWidth);\n    this.contentDOM = this.table.appendChild(document.createElement(\"tbody\"));\n  }\n  update(node) {\n    if (node.type != this.node.type)\n      return false;\n    this.node = node;\n    updateColumnsOnResize(node, this.colgroup, this.table, this.cellMinWidth);\n    return true;\n  }\n  ignoreMutation(record) {\n    return record.type == \"attributes\" && (record.target == this.table || this.colgroup.contains(record.target));\n  }\n};\nfunction updateColumnsOnResize(node, colgroup, table, cellMinWidth, overrideCol, overrideValue) {\n  var _a;\n  let totalWidth = 0;\n  let fixedWidth = true;\n  let nextDOM = colgroup.firstChild;\n  const row = node.firstChild;\n  if (!row)\n    return;\n  for (let i = 0, col = 0; i < row.childCount; i++) {\n    const { colspan, colwidth } = row.child(i).attrs;\n    for (let j = 0; j < colspan; j++, col++) {\n      const hasWidth = overrideCol == col ? overrideValue : colwidth && colwidth[j];\n      const cssWidth = hasWidth ? hasWidth + \"px\" : \"\";\n      totalWidth += hasWidth || cellMinWidth;\n      if (!hasWidth)\n        fixedWidth = false;\n      if (!nextDOM) {\n        colgroup.appendChild(document.createElement(\"col\")).style.width = cssWidth;\n      } else {\n        if (nextDOM.style.width != cssWidth)\n          nextDOM.style.width = cssWidth;\n        nextDOM = nextDOM.nextSibling;\n      }\n    }\n  }\n  while (nextDOM) {\n    const after = nextDOM.nextSibling;\n    (_a = nextDOM.parentNode) == null ? void 0 : _a.removeChild(nextDOM);\n    nextDOM = after;\n  }\n  if (fixedWidth) {\n    table.style.width = totalWidth + \"px\";\n    table.style.minWidth = \"\";\n  } else {\n    table.style.width = \"\";\n    table.style.minWidth = totalWidth + \"px\";\n  }\n}\n\n// src/columnresizing.ts\nvar columnResizingPluginKey = new PluginKey3(\n  \"tableColumnResizing\"\n);\nfunction columnResizing({\n  handleWidth = 5,\n  cellMinWidth = 25,\n  View = TableView,\n  lastColumnResizable = true\n} = {}) {\n  const plugin = new Plugin({\n    key: columnResizingPluginKey,\n    state: {\n      init(_, state) {\n        var _a, _b;\n        const nodeViews = (_b = (_a = plugin.spec) == null ? void 0 : _a.props) == null ? void 0 : _b.nodeViews;\n        const tableName = tableNodeTypes(state.schema).table.name;\n        if (View && nodeViews) {\n          nodeViews[tableName] = (node, view) => {\n            return new View(node, cellMinWidth, view);\n          };\n        }\n        return new ResizeState(-1, false);\n      },\n      apply(tr, prev) {\n        return prev.apply(tr);\n      }\n    },\n    props: {\n      attributes: (state) => {\n        const pluginState = columnResizingPluginKey.getState(state);\n        return pluginState && pluginState.activeHandle > -1 ? { class: \"resize-cursor\" } : {};\n      },\n      handleDOMEvents: {\n        mousemove: (view, event) => {\n          handleMouseMove(\n            view,\n            event,\n            handleWidth,\n            cellMinWidth,\n            lastColumnResizable\n          );\n        },\n        mouseleave: (view) => {\n          handleMouseLeave(view);\n        },\n        mousedown: (view, event) => {\n          handleMouseDown2(view, event, cellMinWidth);\n        }\n      },\n      decorations: (state) => {\n        const pluginState = columnResizingPluginKey.getState(state);\n        if (pluginState && pluginState.activeHandle > -1) {\n          return handleDecorations(state, pluginState.activeHandle);\n        }\n      },\n      nodeViews: {}\n    }\n  });\n  return plugin;\n}\nvar ResizeState = class _ResizeState {\n  constructor(activeHandle, dragging) {\n    this.activeHandle = activeHandle;\n    this.dragging = dragging;\n  }\n  apply(tr) {\n    const state = this;\n    const action = tr.getMeta(columnResizingPluginKey);\n    if (action && action.setHandle != null)\n      return new _ResizeState(action.setHandle, false);\n    if (action && action.setDragging !== void 0)\n      return new _ResizeState(state.activeHandle, action.setDragging);\n    if (state.activeHandle > -1 && tr.docChanged) {\n      let handle = tr.mapping.map(state.activeHandle, -1);\n      if (!pointsAtCell(tr.doc.resolve(handle))) {\n        handle = -1;\n      }\n      return new _ResizeState(handle, state.dragging);\n    }\n    return state;\n  }\n};\nfunction handleMouseMove(view, event, handleWidth, cellMinWidth, lastColumnResizable) {\n  const pluginState = columnResizingPluginKey.getState(view.state);\n  if (!pluginState)\n    return;\n  if (!pluginState.dragging) {\n    const target = domCellAround(event.target);\n    let cell = -1;\n    if (target) {\n      const { left, right } = target.getBoundingClientRect();\n      if (event.clientX - left <= handleWidth)\n        cell = edgeCell(view, event, \"left\", handleWidth);\n      else if (right - event.clientX <= handleWidth)\n        cell = edgeCell(view, event, \"right\", handleWidth);\n    }\n    if (cell != pluginState.activeHandle) {\n      if (!lastColumnResizable && cell !== -1) {\n        const $cell = view.state.doc.resolve(cell);\n        const table = $cell.node(-1);\n        const map = TableMap.get(table);\n        const tableStart = $cell.start(-1);\n        const col = map.colCount($cell.pos - tableStart) + $cell.nodeAfter.attrs.colspan - 1;\n        if (col == map.width - 1) {\n          return;\n        }\n      }\n      updateHandle(view, cell);\n    }\n  }\n}\nfunction handleMouseLeave(view) {\n  const pluginState = columnResizingPluginKey.getState(view.state);\n  if (pluginState && pluginState.activeHandle > -1 && !pluginState.dragging)\n    updateHandle(view, -1);\n}\nfunction handleMouseDown2(view, event, cellMinWidth) {\n  var _a;\n  const win = (_a = view.dom.ownerDocument.defaultView) != null ? _a : window;\n  const pluginState = columnResizingPluginKey.getState(view.state);\n  if (!pluginState || pluginState.activeHandle == -1 || pluginState.dragging)\n    return false;\n  const cell = view.state.doc.nodeAt(pluginState.activeHandle);\n  const width = currentColWidth(view, pluginState.activeHandle, cell.attrs);\n  view.dispatch(\n    view.state.tr.setMeta(columnResizingPluginKey, {\n      setDragging: { startX: event.clientX, startWidth: width }\n    })\n  );\n  function finish(event2) {\n    win.removeEventListener(\"mouseup\", finish);\n    win.removeEventListener(\"mousemove\", move);\n    const pluginState2 = columnResizingPluginKey.getState(view.state);\n    if (pluginState2 == null ? void 0 : pluginState2.dragging) {\n      updateColumnWidth(\n        view,\n        pluginState2.activeHandle,\n        draggedWidth(pluginState2.dragging, event2, cellMinWidth)\n      );\n      view.dispatch(\n        view.state.tr.setMeta(columnResizingPluginKey, { setDragging: null })\n      );\n    }\n  }\n  function move(event2) {\n    if (!event2.which)\n      return finish(event2);\n    const pluginState2 = columnResizingPluginKey.getState(view.state);\n    if (!pluginState2)\n      return;\n    if (pluginState2.dragging) {\n      const dragged = draggedWidth(pluginState2.dragging, event2, cellMinWidth);\n      displayColumnWidth(view, pluginState2.activeHandle, dragged, cellMinWidth);\n    }\n  }\n  win.addEventListener(\"mouseup\", finish);\n  win.addEventListener(\"mousemove\", move);\n  event.preventDefault();\n  return true;\n}\nfunction currentColWidth(view, cellPos, { colspan, colwidth }) {\n  const width = colwidth && colwidth[colwidth.length - 1];\n  if (width)\n    return width;\n  const dom = view.domAtPos(cellPos);\n  const node = dom.node.childNodes[dom.offset];\n  let domWidth = node.offsetWidth, parts = colspan;\n  if (colwidth) {\n    for (let i = 0; i < colspan; i++)\n      if (colwidth[i]) {\n        domWidth -= colwidth[i];\n        parts--;\n      }\n  }\n  return domWidth / parts;\n}\nfunction domCellAround(target) {\n  while (target && target.nodeName != \"TD\" && target.nodeName != \"TH\")\n    target = target.classList && target.classList.contains(\"ProseMirror\") ? null : target.parentNode;\n  return target;\n}\nfunction edgeCell(view, event, side, handleWidth) {\n  const offset = side == \"right\" ? -handleWidth : handleWidth;\n  const found = view.posAtCoords({\n    left: event.clientX + offset,\n    top: event.clientY\n  });\n  if (!found)\n    return -1;\n  const { pos } = found;\n  const $cell = cellAround(view.state.doc.resolve(pos));\n  if (!$cell)\n    return -1;\n  if (side == \"right\")\n    return $cell.pos;\n  const map = TableMap.get($cell.node(-1)), start = $cell.start(-1);\n  const index = map.map.indexOf($cell.pos - start);\n  return index % map.width == 0 ? -1 : start + map.map[index - 1];\n}\nfunction draggedWidth(dragging, event, cellMinWidth) {\n  const offset = event.clientX - dragging.startX;\n  return Math.max(cellMinWidth, dragging.startWidth + offset);\n}\nfunction updateHandle(view, value) {\n  view.dispatch(\n    view.state.tr.setMeta(columnResizingPluginKey, { setHandle: value })\n  );\n}\nfunction updateColumnWidth(view, cell, width) {\n  const $cell = view.state.doc.resolve(cell);\n  const table = $cell.node(-1), map = TableMap.get(table), start = $cell.start(-1);\n  const col = map.colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan - 1;\n  const tr = view.state.tr;\n  for (let row = 0; row < map.height; row++) {\n    const mapIndex = row * map.width + col;\n    if (row && map.map[mapIndex] == map.map[mapIndex - map.width])\n      continue;\n    const pos = map.map[mapIndex];\n    const attrs = table.nodeAt(pos).attrs;\n    const index = attrs.colspan == 1 ? 0 : col - map.colCount(pos);\n    if (attrs.colwidth && attrs.colwidth[index] == width)\n      continue;\n    const colwidth = attrs.colwidth ? attrs.colwidth.slice() : zeroes(attrs.colspan);\n    colwidth[index] = width;\n    tr.setNodeMarkup(start + pos, null, { ...attrs, colwidth });\n  }\n  if (tr.docChanged)\n    view.dispatch(tr);\n}\nfunction displayColumnWidth(view, cell, width, cellMinWidth) {\n  const $cell = view.state.doc.resolve(cell);\n  const table = $cell.node(-1), start = $cell.start(-1);\n  const col = TableMap.get(table).colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan - 1;\n  let dom = view.domAtPos($cell.start(-1)).node;\n  while (dom && dom.nodeName != \"TABLE\") {\n    dom = dom.parentNode;\n  }\n  if (!dom)\n    return;\n  updateColumnsOnResize(\n    table,\n    dom.firstChild,\n    dom,\n    cellMinWidth,\n    col,\n    width\n  );\n}\nfunction zeroes(n) {\n  return Array(n).fill(0);\n}\nfunction handleDecorations(state, cell) {\n  const decorations = [];\n  const $cell = state.doc.resolve(cell);\n  const table = $cell.node(-1);\n  if (!table) {\n    return DecorationSet2.empty;\n  }\n  const map = TableMap.get(table);\n  const start = $cell.start(-1);\n  const col = map.colCount($cell.pos - start) + $cell.nodeAfter.attrs.colspan - 1;\n  for (let row = 0; row < map.height; row++) {\n    const index = col + row * map.width;\n    if ((col == map.width - 1 || map.map[index] != map.map[index + 1]) && (row == 0 || map.map[index] != map.map[index - map.width])) {\n      const cellPos = map.map[index];\n      const pos = start + cellPos + table.nodeAt(cellPos).nodeSize - 1;\n      const dom = document.createElement(\"div\");\n      dom.className = \"column-resize-handle\";\n      decorations.push(Decoration2.widget(pos, dom));\n    }\n  }\n  return DecorationSet2.create(state.doc, decorations);\n}\n\n// src/commands.ts\nimport { Fragment as Fragment4 } from \"prosemirror-model\";\nimport {\n  TextSelection as TextSelection3\n} from \"prosemirror-state\";\nfunction selectedRect(state) {\n  const sel = state.selection;\n  const $pos = selectionCell(state);\n  const table = $pos.node(-1);\n  const tableStart = $pos.start(-1);\n  const map = TableMap.get(table);\n  const rect = sel instanceof CellSelection ? map.rectBetween(\n    sel.$anchorCell.pos - tableStart,\n    sel.$headCell.pos - tableStart\n  ) : map.findCell($pos.pos - tableStart);\n  return { ...rect, tableStart, map, table };\n}\nfunction addColumn(tr, { map, tableStart, table }, col) {\n  let refColumn = col > 0 ? -1 : 0;\n  if (columnIsHeader(map, table, col + refColumn)) {\n    refColumn = col == 0 || col == map.width ? null : 0;\n  }\n  for (let row = 0; row < map.height; row++) {\n    const index = row * map.width + col;\n    if (col > 0 && col < map.width && map.map[index - 1] == map.map[index]) {\n      const pos = map.map[index];\n      const cell = table.nodeAt(pos);\n      tr.setNodeMarkup(\n        tr.mapping.map(tableStart + pos),\n        null,\n        addColSpan(cell.attrs, col - map.colCount(pos))\n      );\n      row += cell.attrs.rowspan - 1;\n    } else {\n      const type = refColumn == null ? tableNodeTypes(table.type.schema).cell : table.nodeAt(map.map[index + refColumn]).type;\n      const pos = map.positionAt(row, col, table);\n      tr.insert(tr.mapping.map(tableStart + pos), type.createAndFill());\n    }\n  }\n  return tr;\n}\nfunction addColumnBefore(state, dispatch) {\n  if (!isInTable(state))\n    return false;\n  if (dispatch) {\n    const rect = selectedRect(state);\n    dispatch(addColumn(state.tr, rect, rect.left));\n  }\n  return true;\n}\nfunction addColumnAfter(state, dispatch) {\n  if (!isInTable(state))\n    return false;\n  if (dispatch) {\n    const rect = selectedRect(state);\n    dispatch(addColumn(state.tr, rect, rect.right));\n  }\n  return true;\n}\nfunction removeColumn(tr, { map, table, tableStart }, col) {\n  const mapStart = tr.mapping.maps.length;\n  for (let row = 0; row < map.height; ) {\n    const index = row * map.width + col;\n    const pos = map.map[index];\n    const cell = table.nodeAt(pos);\n    const attrs = cell.attrs;\n    if (col > 0 && map.map[index - 1] == pos || col < map.width - 1 && map.map[index + 1] == pos) {\n      tr.setNodeMarkup(\n        tr.mapping.slice(mapStart).map(tableStart + pos),\n        null,\n        removeColSpan(attrs, col - map.colCount(pos))\n      );\n    } else {\n      const start = tr.mapping.slice(mapStart).map(tableStart + pos);\n      tr.delete(start, start + cell.nodeSize);\n    }\n    row += attrs.rowspan;\n  }\n}\nfunction deleteColumn(state, dispatch) {\n  if (!isInTable(state))\n    return false;\n  if (dispatch) {\n    const rect = selectedRect(state);\n    const tr = state.tr;\n    if (rect.left == 0 && rect.right == rect.map.width)\n      return false;\n    for (let i = rect.right - 1; ; i--) {\n      removeColumn(tr, rect, i);\n      if (i == rect.left)\n        break;\n      const table = rect.tableStart ? tr.doc.nodeAt(rect.tableStart - 1) : tr.doc;\n      if (!table) {\n        throw RangeError(\"No table found\");\n      }\n      rect.table = table;\n      rect.map = TableMap.get(table);\n    }\n    dispatch(tr);\n  }\n  return true;\n}\nfunction rowIsHeader(map, table, row) {\n  var _a;\n  const headerCell = tableNodeTypes(table.type.schema).header_cell;\n  for (let col = 0; col < map.width; col++)\n    if (((_a = table.nodeAt(map.map[col + row * map.width])) == null ? void 0 : _a.type) != headerCell)\n      return false;\n  return true;\n}\nfunction addRow(tr, { map, tableStart, table }, row) {\n  var _a;\n  let rowPos = tableStart;\n  for (let i = 0; i < row; i++)\n    rowPos += table.child(i).nodeSize;\n  const cells = [];\n  let refRow = row > 0 ? -1 : 0;\n  if (rowIsHeader(map, table, row + refRow))\n    refRow = row == 0 || row == map.height ? null : 0;\n  for (let col = 0, index = map.width * row; col < map.width; col++, index++) {\n    if (row > 0 && row < map.height && map.map[index] == map.map[index - map.width]) {\n      const pos = map.map[index];\n      const attrs = table.nodeAt(pos).attrs;\n      tr.setNodeMarkup(tableStart + pos, null, {\n        ...attrs,\n        rowspan: attrs.rowspan + 1\n      });\n      col += attrs.colspan - 1;\n    } else {\n      const type = refRow == null ? tableNodeTypes(table.type.schema).cell : (_a = table.nodeAt(map.map[index + refRow * map.width])) == null ? void 0 : _a.type;\n      const node = type == null ? void 0 : type.createAndFill();\n      if (node)\n        cells.push(node);\n    }\n  }\n  tr.insert(rowPos, tableNodeTypes(table.type.schema).row.create(null, cells));\n  return tr;\n}\nfunction addRowBefore(state, dispatch) {\n  if (!isInTable(state))\n    return false;\n  if (dispatch) {\n    const rect = selectedRect(state);\n    dispatch(addRow(state.tr, rect, rect.top));\n  }\n  return true;\n}\nfunction addRowAfter(state, dispatch) {\n  if (!isInTable(state))\n    return false;\n  if (dispatch) {\n    const rect = selectedRect(state);\n    dispatch(addRow(state.tr, rect, rect.bottom));\n  }\n  return true;\n}\nfunction removeRow(tr, { map, table, tableStart }, row) {\n  let rowPos = 0;\n  for (let i = 0; i < row; i++)\n    rowPos += table.child(i).nodeSize;\n  const nextRow = rowPos + table.child(row).nodeSize;\n  const mapFrom = tr.mapping.maps.length;\n  tr.delete(rowPos + tableStart, nextRow + tableStart);\n  const seen = /* @__PURE__ */ new Set();\n  for (let col = 0, index = row * map.width; col < map.width; col++, index++) {\n    const pos = map.map[index];\n    if (seen.has(pos))\n      continue;\n    seen.add(pos);\n    if (row > 0 && pos == map.map[index - map.width]) {\n      const attrs = table.nodeAt(pos).attrs;\n      tr.setNodeMarkup(tr.mapping.slice(mapFrom).map(pos + tableStart), null, {\n        ...attrs,\n        rowspan: attrs.rowspan - 1\n      });\n      col += attrs.colspan - 1;\n    } else if (row < map.height && pos == map.map[index + map.width]) {\n      const cell = table.nodeAt(pos);\n      const attrs = cell.attrs;\n      const copy = cell.type.create(\n        { ...attrs, rowspan: cell.attrs.rowspan - 1 },\n        cell.content\n      );\n      const newPos = map.positionAt(row + 1, col, table);\n      tr.insert(tr.mapping.slice(mapFrom).map(tableStart + newPos), copy);\n      col += attrs.colspan - 1;\n    }\n  }\n}\nfunction deleteRow(state, dispatch) {\n  if (!isInTable(state))\n    return false;\n  if (dispatch) {\n    const rect = selectedRect(state), tr = state.tr;\n    if (rect.top == 0 && rect.bottom == rect.map.height)\n      return false;\n    for (let i = rect.bottom - 1; ; i--) {\n      removeRow(tr, rect, i);\n      if (i == rect.top)\n        break;\n      const table = rect.tableStart ? tr.doc.nodeAt(rect.tableStart - 1) : tr.doc;\n      if (!table) {\n        throw RangeError(\"No table found\");\n      }\n      rect.table = table;\n      rect.map = TableMap.get(rect.table);\n    }\n    dispatch(tr);\n  }\n  return true;\n}\nfunction isEmpty(cell) {\n  const c = cell.content;\n  return c.childCount == 1 && c.child(0).isTextblock && c.child(0).childCount == 0;\n}\nfunction cellsOverlapRectangle({ width, height, map }, rect) {\n  let indexTop = rect.top * width + rect.left, indexLeft = indexTop;\n  let indexBottom = (rect.bottom - 1) * width + rect.left, indexRight = indexTop + (rect.right - rect.left - 1);\n  for (let i = rect.top; i < rect.bottom; i++) {\n    if (rect.left > 0 && map[indexLeft] == map[indexLeft - 1] || rect.right < width && map[indexRight] == map[indexRight + 1])\n      return true;\n    indexLeft += width;\n    indexRight += width;\n  }\n  for (let i = rect.left; i < rect.right; i++) {\n    if (rect.top > 0 && map[indexTop] == map[indexTop - width] || rect.bottom < height && map[indexBottom] == map[indexBottom + width])\n      return true;\n    indexTop++;\n    indexBottom++;\n  }\n  return false;\n}\nfunction mergeCells(state, dispatch) {\n  const sel = state.selection;\n  if (!(sel instanceof CellSelection) || sel.$anchorCell.pos == sel.$headCell.pos)\n    return false;\n  const rect = selectedRect(state), { map } = rect;\n  if (cellsOverlapRectangle(map, rect))\n    return false;\n  if (dispatch) {\n    const tr = state.tr;\n    const seen = {};\n    let content = Fragment4.empty;\n    let mergedPos;\n    let mergedCell;\n    for (let row = rect.top; row < rect.bottom; row++) {\n      for (let col = rect.left; col < rect.right; col++) {\n        const cellPos = map.map[row * map.width + col];\n        const cell = rect.table.nodeAt(cellPos);\n        if (seen[cellPos] || !cell)\n          continue;\n        seen[cellPos] = true;\n        if (mergedPos == null) {\n          mergedPos = cellPos;\n          mergedCell = cell;\n        } else {\n          if (!isEmpty(cell))\n            content = content.append(cell.content);\n          const mapped = tr.mapping.map(cellPos + rect.tableStart);\n          tr.delete(mapped, mapped + cell.nodeSize);\n        }\n      }\n    }\n    if (mergedPos == null || mergedCell == null) {\n      return true;\n    }\n    tr.setNodeMarkup(mergedPos + rect.tableStart, null, {\n      ...addColSpan(\n        mergedCell.attrs,\n        mergedCell.attrs.colspan,\n        rect.right - rect.left - mergedCell.attrs.colspan\n      ),\n      rowspan: rect.bottom - rect.top\n    });\n    if (content.size) {\n      const end = mergedPos + 1 + mergedCell.content.size;\n      const start = isEmpty(mergedCell) ? mergedPos + 1 : end;\n      tr.replaceWith(start + rect.tableStart, end + rect.tableStart, content);\n    }\n    tr.setSelection(\n      new CellSelection(tr.doc.resolve(mergedPos + rect.tableStart))\n    );\n    dispatch(tr);\n  }\n  return true;\n}\nfunction splitCell(state, dispatch) {\n  const nodeTypes = tableNodeTypes(state.schema);\n  return splitCellWithType(({ node }) => {\n    return nodeTypes[node.type.spec.tableRole];\n  })(state, dispatch);\n}\nfunction splitCellWithType(getCellType) {\n  return (state, dispatch) => {\n    var _a;\n    const sel = state.selection;\n    let cellNode;\n    let cellPos;\n    if (!(sel instanceof CellSelection)) {\n      cellNode = cellWrapping(sel.$from);\n      if (!cellNode)\n        return false;\n      cellPos = (_a = cellAround(sel.$from)) == null ? void 0 : _a.pos;\n    } else {\n      if (sel.$anchorCell.pos != sel.$headCell.pos)\n        return false;\n      cellNode = sel.$anchorCell.nodeAfter;\n      cellPos = sel.$anchorCell.pos;\n    }\n    if (cellNode == null || cellPos == null) {\n      return false;\n    }\n    if (cellNode.attrs.colspan == 1 && cellNode.attrs.rowspan == 1) {\n      return false;\n    }\n    if (dispatch) {\n      let baseAttrs = cellNode.attrs;\n      const attrs = [];\n      const colwidth = baseAttrs.colwidth;\n      if (baseAttrs.rowspan > 1)\n        baseAttrs = { ...baseAttrs, rowspan: 1 };\n      if (baseAttrs.colspan > 1)\n        baseAttrs = { ...baseAttrs, colspan: 1 };\n      const rect = selectedRect(state), tr = state.tr;\n      for (let i = 0; i < rect.right - rect.left; i++)\n        attrs.push(\n          colwidth ? {\n            ...baseAttrs,\n            colwidth: colwidth && colwidth[i] ? [colwidth[i]] : null\n          } : baseAttrs\n        );\n      let lastCell;\n      for (let row = rect.top; row < rect.bottom; row++) {\n        let pos = rect.map.positionAt(row, rect.left, rect.table);\n        if (row == rect.top)\n          pos += cellNode.nodeSize;\n        for (let col = rect.left, i = 0; col < rect.right; col++, i++) {\n          if (col == rect.left && row == rect.top)\n            continue;\n          tr.insert(\n            lastCell = tr.mapping.map(pos + rect.tableStart, 1),\n            getCellType({ node: cellNode, row, col }).createAndFill(attrs[i])\n          );\n        }\n      }\n      tr.setNodeMarkup(\n        cellPos,\n        getCellType({ node: cellNode, row: rect.top, col: rect.left }),\n        attrs[0]\n      );\n      if (sel instanceof CellSelection)\n        tr.setSelection(\n          new CellSelection(\n            tr.doc.resolve(sel.$anchorCell.pos),\n            lastCell ? tr.doc.resolve(lastCell) : void 0\n          )\n        );\n      dispatch(tr);\n    }\n    return true;\n  };\n}\nfunction setCellAttr(name, value) {\n  return function(state, dispatch) {\n    if (!isInTable(state))\n      return false;\n    const $cell = selectionCell(state);\n    if ($cell.nodeAfter.attrs[name] === value)\n      return false;\n    if (dispatch) {\n      const tr = state.tr;\n      if (state.selection instanceof CellSelection)\n        state.selection.forEachCell((node, pos) => {\n          if (node.attrs[name] !== value)\n            tr.setNodeMarkup(pos, null, {\n              ...node.attrs,\n              [name]: value\n            });\n        });\n      else\n        tr.setNodeMarkup($cell.pos, null, {\n          ...$cell.nodeAfter.attrs,\n          [name]: value\n        });\n      dispatch(tr);\n    }\n    return true;\n  };\n}\nfunction deprecated_toggleHeader(type) {\n  return function(state, dispatch) {\n    if (!isInTable(state))\n      return false;\n    if (dispatch) {\n      const types = tableNodeTypes(state.schema);\n      const rect = selectedRect(state), tr = state.tr;\n      const cells = rect.map.cellsInRect(\n        type == \"column\" ? {\n          left: rect.left,\n          top: 0,\n          right: rect.right,\n          bottom: rect.map.height\n        } : type == \"row\" ? {\n          left: 0,\n          top: rect.top,\n          right: rect.map.width,\n          bottom: rect.bottom\n        } : rect\n      );\n      const nodes = cells.map((pos) => rect.table.nodeAt(pos));\n      for (let i = 0; i < cells.length; i++)\n        if (nodes[i].type == types.header_cell)\n          tr.setNodeMarkup(\n            rect.tableStart + cells[i],\n            types.cell,\n            nodes[i].attrs\n          );\n      if (tr.steps.length == 0)\n        for (let i = 0; i < cells.length; i++)\n          tr.setNodeMarkup(\n            rect.tableStart + cells[i],\n            types.header_cell,\n            nodes[i].attrs\n          );\n      dispatch(tr);\n    }\n    return true;\n  };\n}\nfunction isHeaderEnabledByType(type, rect, types) {\n  const cellPositions = rect.map.cellsInRect({\n    left: 0,\n    top: 0,\n    right: type == \"row\" ? rect.map.width : 1,\n    bottom: type == \"column\" ? rect.map.height : 1\n  });\n  for (let i = 0; i < cellPositions.length; i++) {\n    const cell = rect.table.nodeAt(cellPositions[i]);\n    if (cell && cell.type !== types.header_cell) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction toggleHeader(type, options) {\n  options = options || { useDeprecatedLogic: false };\n  if (options.useDeprecatedLogic)\n    return deprecated_toggleHeader(type);\n  return function(state, dispatch) {\n    if (!isInTable(state))\n      return false;\n    if (dispatch) {\n      const types = tableNodeTypes(state.schema);\n      const rect = selectedRect(state), tr = state.tr;\n      const isHeaderRowEnabled = isHeaderEnabledByType(\"row\", rect, types);\n      const isHeaderColumnEnabled = isHeaderEnabledByType(\n        \"column\",\n        rect,\n        types\n      );\n      const isHeaderEnabled = type === \"column\" ? isHeaderRowEnabled : type === \"row\" ? isHeaderColumnEnabled : false;\n      const selectionStartsAt = isHeaderEnabled ? 1 : 0;\n      const cellsRect = type == \"column\" ? {\n        left: 0,\n        top: selectionStartsAt,\n        right: 1,\n        bottom: rect.map.height\n      } : type == \"row\" ? {\n        left: selectionStartsAt,\n        top: 0,\n        right: rect.map.width,\n        bottom: 1\n      } : rect;\n      const newType = type == \"column\" ? isHeaderColumnEnabled ? types.cell : types.header_cell : type == \"row\" ? isHeaderRowEnabled ? types.cell : types.header_cell : types.cell;\n      rect.map.cellsInRect(cellsRect).forEach((relativeCellPos) => {\n        const cellPos = relativeCellPos + rect.tableStart;\n        const cell = tr.doc.nodeAt(cellPos);\n        if (cell) {\n          tr.setNodeMarkup(cellPos, newType, cell.attrs);\n        }\n      });\n      dispatch(tr);\n    }\n    return true;\n  };\n}\nvar toggleHeaderRow = toggleHeader(\"row\", {\n  useDeprecatedLogic: true\n});\nvar toggleHeaderColumn = toggleHeader(\"column\", {\n  useDeprecatedLogic: true\n});\nvar toggleHeaderCell = toggleHeader(\"cell\", {\n  useDeprecatedLogic: true\n});\nfunction findNextCell($cell, dir) {\n  if (dir < 0) {\n    const before = $cell.nodeBefore;\n    if (before)\n      return $cell.pos - before.nodeSize;\n    for (let row = $cell.index(-1) - 1, rowEnd = $cell.before(); row >= 0; row--) {\n      const rowNode = $cell.node(-1).child(row);\n      const lastChild = rowNode.lastChild;\n      if (lastChild) {\n        return rowEnd - 1 - lastChild.nodeSize;\n      }\n      rowEnd -= rowNode.nodeSize;\n    }\n  } else {\n    if ($cell.index() < $cell.parent.childCount - 1) {\n      return $cell.pos + $cell.nodeAfter.nodeSize;\n    }\n    const table = $cell.node(-1);\n    for (let row = $cell.indexAfter(-1), rowStart = $cell.after(); row < table.childCount; row++) {\n      const rowNode = table.child(row);\n      if (rowNode.childCount)\n        return rowStart + 1;\n      rowStart += rowNode.nodeSize;\n    }\n  }\n  return null;\n}\nfunction goToNextCell(direction) {\n  return function(state, dispatch) {\n    if (!isInTable(state))\n      return false;\n    const cell = findNextCell(selectionCell(state), direction);\n    if (cell == null)\n      return false;\n    if (dispatch) {\n      const $cell = state.doc.resolve(cell);\n      dispatch(\n        state.tr.setSelection(TextSelection3.between($cell, moveCellForward($cell))).scrollIntoView()\n      );\n    }\n    return true;\n  };\n}\nfunction deleteTable(state, dispatch) {\n  const $pos = state.selection.$anchor;\n  for (let d = $pos.depth; d > 0; d--) {\n    const node = $pos.node(d);\n    if (node.type.spec.tableRole == \"table\") {\n      if (dispatch)\n        dispatch(\n          state.tr.delete($pos.before(d), $pos.after(d)).scrollIntoView()\n        );\n      return true;\n    }\n  }\n  return false;\n}\n\n// src/index.ts\nfunction tableEditing({\n  allowTableNodeSelection = false\n} = {}) {\n  return new Plugin2({\n    key: tableEditingKey,\n    // This piece of state is used to remember when a mouse-drag\n    // cell-selection is happening, so that it can continue even as\n    // transactions (which might move its anchor cell) come in.\n    state: {\n      init() {\n        return null;\n      },\n      apply(tr, cur) {\n        const set = tr.getMeta(tableEditingKey);\n        if (set != null)\n          return set == -1 ? null : set;\n        if (cur == null || !tr.docChanged)\n          return cur;\n        const { deleted, pos } = tr.mapping.mapResult(cur);\n        return deleted ? null : pos;\n      }\n    },\n    props: {\n      decorations: drawCellSelection,\n      handleDOMEvents: {\n        mousedown: handleMouseDown\n      },\n      createSelectionBetween(view) {\n        return tableEditingKey.getState(view.state) != null ? view.state.selection : null;\n      },\n      handleTripleClick,\n      handleKeyDown,\n      handlePaste\n    },\n    appendTransaction(_, oldState, state) {\n      return normalizeSelection(\n        state,\n        fixTables(state, oldState),\n        allowTableNodeSelection\n      );\n    }\n  });\n}\nexport {\n  CellBookmark,\n  CellSelection,\n  ResizeState,\n  TableMap,\n  TableView,\n  clipCells as __clipCells,\n  insertCells as __insertCells,\n  pastedCells as __pastedCells,\n  addColSpan,\n  addColumn,\n  addColumnAfter,\n  addColumnBefore,\n  addRow,\n  addRowAfter,\n  addRowBefore,\n  cellAround,\n  colCount,\n  columnIsHeader,\n  columnResizing,\n  columnResizingPluginKey,\n  deleteColumn,\n  deleteRow,\n  deleteTable,\n  findCell,\n  fixTables,\n  fixTablesKey,\n  goToNextCell,\n  handlePaste,\n  inSameTable,\n  isInTable,\n  mergeCells,\n  moveCellForward,\n  nextCell,\n  pointsAtCell,\n  removeColSpan,\n  removeColumn,\n  removeRow,\n  rowIsHeader,\n  selectedRect,\n  selectionCell,\n  setCellAttr,\n  splitCell,\n  splitCellWithType,\n  tableEditing,\n  tableEditingKey,\n  tableNodeTypes,\n  tableNodes,\n  toggleHeader,\n  toggleHeaderCell,\n  toggleHeaderColumn,\n  toggleHeaderRow,\n  updateColumnsOnResize\n};\n","import { max as mathMax, min as mathMin } from \"./math.js\";\nexport function within(min, value, max) {\n  return mathMax(min, mathMin(value, max));\n}\nexport function withinMaxClamp(min, value, max) {\n  var v = within(min, value, max);\n  return v > max ? max : v;\n}","import arrayWithHoles from \"./arrayWithHoles.js\";\nimport iterableToArray from \"./iterableToArray.js\";\nimport unsupportedIterableToArray from \"./unsupportedIterableToArray.js\";\nimport nonIterableRest from \"./nonIterableRest.js\";\nexport default function _toArray(arr) {\n  return arrayWithHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableRest();\n}","import getBasePlacement from \"../utils/getBasePlacement.js\";\nimport getLayoutRect from \"../dom-utils/getLayoutRect.js\";\nimport contains from \"../dom-utils/contains.js\";\nimport getOffsetParent from \"../dom-utils/getOffsetParent.js\";\nimport getMainAxisFromPlacement from \"../utils/getMainAxisFromPlacement.js\";\nimport { within } from \"../utils/within.js\";\nimport mergePaddingObject from \"../utils/mergePaddingObject.js\";\nimport expandToHashMap from \"../utils/expandToHashMap.js\";\nimport { left, right, basePlacements, top, bottom } from \"../enums.js\"; // eslint-disable-next-line import/no-unused-modules\n\nvar toPaddingObject = function toPaddingObject(padding, state) {\n  padding = typeof padding === 'function' ? padding(Object.assign({}, state.rects, {\n    placement: state.placement\n  })) : padding;\n  return mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));\n};\n\nfunction arrow(_ref) {\n  var _state$modifiersData$;\n\n  var state = _ref.state,\n      name = _ref.name,\n      options = _ref.options;\n  var arrowElement = state.elements.arrow;\n  var popperOffsets = state.modifiersData.popperOffsets;\n  var basePlacement = getBasePlacement(state.placement);\n  var axis = getMainAxisFromPlacement(basePlacement);\n  var isVertical = [left, right].indexOf(basePlacement) >= 0;\n  var len = isVertical ? 'height' : 'width';\n\n  if (!arrowElement || !popperOffsets) {\n    return;\n  }\n\n  var paddingObject = toPaddingObject(options.padding, state);\n  var arrowRect = getLayoutRect(arrowElement);\n  var minProp = axis === 'y' ? top : left;\n  var maxProp = axis === 'y' ? bottom : right;\n  var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];\n  var startDiff = popperOffsets[axis] - state.rects.reference[axis];\n  var arrowOffsetParent = getOffsetParent(arrowElement);\n  var clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;\n  var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is\n  // outside of the popper bounds\n\n  var min = paddingObject[minProp];\n  var max = clientSize - arrowRect[len] - paddingObject[maxProp];\n  var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;\n  var offset = within(min, center, max); // Prevents breaking syntax highlighting...\n\n  var axisProp = axis;\n  state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);\n}\n\nfunction effect(_ref2) {\n  var state = _ref2.state,\n      options = _ref2.options;\n  var _options$element = options.element,\n      arrowElement = _options$element === void 0 ? '[data-popper-arrow]' : _options$element;\n\n  if (arrowElement == null) {\n    return;\n  } // CSS selector\n\n\n  if (typeof arrowElement === 'string') {\n    arrowElement = state.elements.popper.querySelector(arrowElement);\n\n    if (!arrowElement) {\n      return;\n    }\n  }\n\n  if (!contains(state.elements.popper, arrowElement)) {\n    return;\n  }\n\n  state.elements.arrow = arrowElement;\n} // eslint-disable-next-line import/no-unused-modules\n\n\nexport default {\n  name: 'arrow',\n  enabled: true,\n  phase: 'main',\n  fn: arrow,\n  effect: effect,\n  requires: ['popperOffsets'],\n  requiresIfExists: ['preventOverflow']\n};","import { viewport } from \"../enums.js\";\nimport getViewportRect from \"./getViewportRect.js\";\nimport getDocumentRect from \"./getDocumentRect.js\";\nimport listScrollParents from \"./listScrollParents.js\";\nimport getOffsetParent from \"./getOffsetParent.js\";\nimport getDocumentElement from \"./getDocumentElement.js\";\nimport getComputedStyle from \"./getComputedStyle.js\";\nimport { isElement, isHTMLElement } from \"./instanceOf.js\";\nimport getBoundingClientRect from \"./getBoundingClientRect.js\";\nimport getParentNode from \"./getParentNode.js\";\nimport contains from \"./contains.js\";\nimport getNodeName from \"./getNodeName.js\";\nimport rectToClientRect from \"../utils/rectToClientRect.js\";\nimport { max, min } from \"../utils/math.js\";\n\nfunction getInnerBoundingClientRect(element, strategy) {\n  var rect = getBoundingClientRect(element, false, strategy === 'fixed');\n  rect.top = rect.top + element.clientTop;\n  rect.left = rect.left + element.clientLeft;\n  rect.bottom = rect.top + element.clientHeight;\n  rect.right = rect.left + element.clientWidth;\n  rect.width = element.clientWidth;\n  rect.height = element.clientHeight;\n  rect.x = rect.left;\n  rect.y = rect.top;\n  return rect;\n}\n\nfunction getClientRectFromMixedType(element, clippingParent, strategy) {\n  return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));\n} // A \"clipping parent\" is an overflowable container with the characteristic of\n// clipping (or hiding) overflowing elements with a position different from\n// `initial`\n\n\nfunction getClippingParents(element) {\n  var clippingParents = listScrollParents(getParentNode(element));\n  var canEscapeClipping = ['absolute', 'fixed'].indexOf(getComputedStyle(element).position) >= 0;\n  var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;\n\n  if (!isElement(clipperElement)) {\n    return [];\n  } // $FlowFixMe[incompatible-return]: https://github.com/facebook/flow/issues/1414\n\n\n  return clippingParents.filter(function (clippingParent) {\n    return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== 'body';\n  });\n} // Gets the maximum area that the element is visible in due to any number of\n// clipping parents\n\n\nexport default function getClippingRect(element, boundary, rootBoundary, strategy) {\n  var mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);\n  var clippingParents = [].concat(mainClippingParents, [rootBoundary]);\n  var firstClippingParent = clippingParents[0];\n  var clippingRect = clippingParents.reduce(function (accRect, clippingParent) {\n    var rect = getClientRectFromMixedType(element, clippingParent, strategy);\n    accRect.top = max(rect.top, accRect.top);\n    accRect.right = min(rect.right, accRect.right);\n    accRect.bottom = min(rect.bottom, accRect.bottom);\n    accRect.left = max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromMixedType(element, firstClippingParent, strategy));\n  clippingRect.width = clippingRect.right - clippingRect.left;\n  clippingRect.height = clippingRect.bottom - clippingRect.top;\n  clippingRect.x = clippingRect.left;\n  clippingRect.y = clippingRect.top;\n  return clippingRect;\n}","/** PURE_IMPORTS_START  PURE_IMPORTS_END */\nexport var rxSubscriber = /*@__PURE__*/ (function () {\n    return typeof Symbol === 'function'\n        ? /*@__PURE__*/ Symbol('rxSubscriber')\n        : '@@rxSubscriber_' + /*@__PURE__*/ Math.random();\n})();\nexport var $$rxSubscriber = rxSubscriber;\n//# sourceMappingURL=rxSubscriber.js.map\n","import getWindow from \"./getWindow.js\";\nimport getDocumentElement from \"./getDocumentElement.js\";\nimport getWindowScrollBarX from \"./getWindowScrollBarX.js\";\nimport isLayoutViewport from \"./isLayoutViewport.js\";\nexport default function getViewportRect(element, strategy) {\n  var win = getWindow(element);\n  var html = getDocumentElement(element);\n  var visualViewport = win.visualViewport;\n  var width = html.clientWidth;\n  var height = html.clientHeight;\n  var x = 0;\n  var y = 0;\n\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    var layoutViewport = isLayoutViewport();\n\n    if (layoutViewport || !layoutViewport && strategy === 'fixed') {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n\n  return {\n    width: width,\n    height: height,\n    x: x + getWindowScrollBarX(element),\n    y: y\n  };\n}","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __createBinding(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n","import { useCallback, useEffect, useLayoutEffect, useRef, useState, createContext, useContext, forwardRef, useImperativeHandle, useMemo, createElement, Children, cloneElement } from 'react';\nimport { createPortal } from 'react-dom';\nimport { usePreventScroll } from '@react-aria/overlays';\nimport { useMotionValue, useReducedMotion, animate, AnimatePresence, motion, useTransform } from 'framer-motion';\nimport mergeRefs from 'react-merge-refs';\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nvar MAX_HEIGHT = 'calc(100% - env(safe-area-inset-top) - 34px)';\nvar IS_SSR = typeof window === 'undefined';\nvar DEFAULT_SPRING_CONFIG = {\n  stiffness: 300,\n  damping: 30,\n  mass: 0.2\n};\nvar DRAG_CLOSE_THRESHOLD = 0.6;\nvar DRAG_VELOCITY_THRESHOLD = 500;\n\nfunction getClosest(nums, goal) {\n  return nums.reduce(function (prev, curr) {\n    return Math.abs(curr - goal) < Math.abs(prev - goal) ? curr : prev;\n  });\n}\nvar highlightId = 'react-modal-sheet-highlight';\nfunction applyRootStyles(rootId) {\n  var body = document.querySelector('body');\n  var root = document.querySelector(\"#\" + rootId);\n\n  if (root) {\n    var p = 24;\n    var h = window.innerHeight;\n    var s = (h - p) / h;\n    body.style.backgroundColor = '#000';\n    root.style.overflow = 'hidden';\n    root.style.willChange = 'transform';\n    root.style.transition = 'transform 200ms linear';\n    root.style.transform = \"translateY(calc(env(safe-area-inset-top) + \" + p / 2 + \"px)) scale(\" + s + \")\"; // prettier-ignore\n\n    root.style.borderTopRightRadius = '10px';\n    root.style.borderTopLeftRadius = '10px'; // Add highlighed overlay to emphasize the modality effect\n\n    var highlight = document.createElement('div');\n    highlight.setAttribute('aria-hidden', 'true');\n    highlight.id = highlightId;\n    highlight.style.position = 'absolute';\n    highlight.style.top = '0px';\n    highlight.style.left = '0px';\n    highlight.style.bottom = '0px';\n    highlight.style.right = '0px';\n    highlight.style.opacity = '0';\n    highlight.style.transition = 'opacity 200ms linear';\n    highlight.style.backgroundColor = 'rgba(150, 150, 150, 0.1)';\n    root.appendChild(highlight);\n    requestAnimationFrame(function () {\n      return highlight.style.opacity = '1';\n    });\n  }\n}\nfunction cleanupRootStyles(rootId) {\n  var body = document.querySelector('body');\n  var root = document.getElementById(rootId);\n  var highlight = document.getElementById(highlightId);\n\n  function onTransitionEnd() {\n    var _highlight$parentNode;\n\n    root.style.removeProperty('overflow');\n    root.style.removeProperty('will-change');\n    root.style.removeProperty('transition');\n    body.style.removeProperty('background-color');\n    root.removeEventListener('transitionend', onTransitionEnd);\n    (_highlight$parentNode = highlight.parentNode) == null ? void 0 : _highlight$parentNode.removeChild(highlight);\n  }\n\n  if (root && highlight) {\n    // Start animating back\n    root.style.removeProperty('border-top-right-radius');\n    root.style.removeProperty('border-top-left-radius');\n    root.style.removeProperty('transform');\n    highlight.style.opacity = '0'; // Remove temp properties after animation is finished\n\n    root.addEventListener('transitionend', onTransitionEnd);\n  }\n}\nfunction inDescendingOrder(arr) {\n  for (var i = 0; i < arr.length; i++) {\n    if (arr[i + 1] > arr[i]) return false;\n  }\n\n  return true;\n}\nfunction validateSnapTo(_ref) {\n  var snapTo = _ref.snapTo,\n      sheetHeight = _ref.sheetHeight;\n\n  if (snapTo < 0) {\n    console.warn(\"Snap point is out of bounds. Sheet height is \" + sheetHeight + \" but snap point is \" + (sheetHeight + Math.abs(snapTo)) + \".\");\n  }\n\n  return Math.max(Math.round(snapTo), 0);\n}\n\nvar useIsomorphicLayoutEffect = IS_SSR ? useEffect : useLayoutEffect;\nvar useModalEffect = function useModalEffect(isOpen, rootId) {\n  var prevOpen = usePrevious(isOpen); // Automatically apply the iOS modal effect to the body when sheet opens/closes\n\n  useEffect(function () {\n    if (rootId && !prevOpen && isOpen) {\n      applyRootStyles(rootId);\n    } else if (rootId && !isOpen && prevOpen) {\n      cleanupRootStyles(rootId);\n    }\n  }, [isOpen, prevOpen]); // eslint-disable-line\n  // Make sure to cleanup modal styles on unmount\n\n  useEffect(function () {\n    return function () {\n      if (rootId && isOpen) cleanupRootStyles(rootId);\n    };\n  }, [isOpen]); // eslint-disable-line\n};\nvar useEventCallbacks = function useEventCallbacks(isOpen, callbacks) {\n  var prevOpen = usePrevious(isOpen);\n  var didOpen = useRef(false); // Because of AnimatePrecence we don't have access to latest isOpen value\n  // so we need to read and write to a ref to determine if we are\n  // opening or closing the sheet\n\n  var handleAnimationComplete = useCallback(function () {\n    if (!didOpen.current) {\n      callbacks.current.onOpenEnd == null ? void 0 : callbacks.current.onOpenEnd();\n      didOpen.current = true;\n    } else {\n      callbacks.current.onCloseEnd == null ? void 0 : callbacks.current.onCloseEnd();\n      didOpen.current = false;\n    }\n  }, [isOpen, prevOpen]); // eslint-disable-line\n\n  useEffect(function () {\n    if (!prevOpen && isOpen) {\n      callbacks.current.onOpenStart == null ? void 0 : callbacks.current.onOpenStart();\n    } else if (!isOpen && prevOpen) {\n      callbacks.current.onCloseStart == null ? void 0 : callbacks.current.onCloseStart();\n    }\n  }, [isOpen, prevOpen]); // eslint-disable-line\n\n  return {\n    handleAnimationComplete: handleAnimationComplete\n  };\n};\nfunction useWindowHeight() {\n  var _React$useState = useState(0),\n      windowHeight = _React$useState[0],\n      setWindowHeight = _React$useState[1];\n\n  useIsomorphicLayoutEffect(function () {\n    var updateHeight = function updateHeight() {\n      return setWindowHeight(window.innerHeight);\n    };\n\n    window.addEventListener('resize', updateHeight);\n    updateHeight();\n    return function () {\n      return window.removeEventListener('resize', updateHeight);\n    };\n  }, []);\n  return windowHeight;\n}\nfunction usePrevious(state) {\n  var ref = useRef();\n  useEffect(function () {\n    ref.current = state;\n  });\n  return ref.current;\n} // Userland version of the `useEvent` React hook:\n// RFC: https://github.com/reactjs/rfcs/blob/useevent/text/0000-useevent.md\n\nfunction useEvent(handler) {\n  var handlerRef = useRef();\n  useIsomorphicLayoutEffect(function () {\n    handlerRef.current = handler;\n  });\n  return useCallback(function () {\n    var fn = handlerRef.current;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return fn == null ? void 0 : fn.apply(void 0, args);\n  }, []);\n}\n\nvar SheetContext = /*#__PURE__*/createContext(undefined);\nvar useSheetContext = function useSheetContext() {\n  var context = useContext(SheetContext);\n  if (!context) throw Error('Sheet context error');\n  return context;\n};\n\nvar styles = {\n  wrapper: {\n    position: 'fixed',\n    top: 0,\n    bottom: 0,\n    left: 0,\n    right: 0,\n    zIndex: 9999999,\n    overflow: 'hidden',\n    pointerEvents: 'none'\n  },\n  backdrop: {\n    zIndex: 1,\n    position: 'fixed',\n    top: 0,\n    left: 0,\n    width: '100%',\n    height: '100%',\n    backgroundColor: 'rgba(51, 51, 51, 0.5)',\n    touchAction: 'none'\n  },\n  container: {\n    zIndex: 2,\n    position: 'absolute',\n    left: 0,\n    bottom: 0,\n    width: '100%',\n    backgroundColor: '#fff',\n    borderTopRightRadius: '8px',\n    borderTopLeftRadius: '8px',\n    boxShadow: '0px -2px 16px rgba(0, 0, 0, 0.3)',\n    display: 'flex',\n    flexDirection: 'column',\n    pointerEvents: 'auto'\n  },\n  headerWrapper: {\n    width: '100%'\n  },\n  header: {\n    height: '40px',\n    width: '100%',\n    position: 'relative',\n    display: 'flex',\n    alignItems: 'center',\n    justifyContent: 'center'\n  },\n  indicator: {\n    width: '18px',\n    height: '4px',\n    borderRadius: '99px',\n    backgroundColor: '#ddd'\n  },\n  content: {\n    flex: 1,\n    overflow: 'auto',\n    position: 'relative'\n  }\n};\n\nvar Sheet = /*#__PURE__*/forwardRef(function (_ref, ref) {\n  var onOpenStart = _ref.onOpenStart,\n      onOpenEnd = _ref.onOpenEnd,\n      onClose = _ref.onClose,\n      onCloseStart = _ref.onCloseStart,\n      onCloseEnd = _ref.onCloseEnd,\n      onSnap = _ref.onSnap,\n      children = _ref.children,\n      isOpen = _ref.isOpen,\n      snapPoints = _ref.snapPoints,\n      rootId = _ref.rootId,\n      mountPoint = _ref.mountPoint,\n      style = _ref.style,\n      _ref$detent = _ref.detent,\n      detent = _ref$detent === void 0 ? 'full-height' : _ref$detent,\n      _ref$initialSnap = _ref.initialSnap,\n      initialSnap = _ref$initialSnap === void 0 ? 0 : _ref$initialSnap,\n      _ref$springConfig = _ref.springConfig,\n      springConfig = _ref$springConfig === void 0 ? DEFAULT_SPRING_CONFIG : _ref$springConfig,\n      _ref$disableDrag = _ref.disableDrag,\n      disableDrag = _ref$disableDrag === void 0 ? false : _ref$disableDrag,\n      _ref$prefersReducedMo = _ref.prefersReducedMotion,\n      prefersReducedMotion = _ref$prefersReducedMo === void 0 ? false : _ref$prefersReducedMo,\n      rest = _objectWithoutPropertiesLoose(_ref, [\"onOpenStart\", \"onOpenEnd\", \"onClose\", \"onCloseStart\", \"onCloseEnd\", \"onSnap\", \"children\", \"isOpen\", \"snapPoints\", \"rootId\", \"mountPoint\", \"style\", \"detent\", \"initialSnap\", \"springConfig\", \"disableDrag\", \"prefersReducedMotion\"]);\n\n  var sheetRef = useRef(null);\n  var indicatorRotation = useMotionValue(0);\n  var windowHeight = useWindowHeight();\n  var shouldReduceMotion = useReducedMotion();\n  var reduceMotion = Boolean(prefersReducedMotion || shouldReduceMotion);\n  var animationOptions = reduceMotion ? {\n    type: 'tween',\n    duration: 0.01\n  } : _extends({\n    type: 'spring'\n  }, springConfig); // NOTE: the inital value for `y` doesn't matter since it is overwritten by\n  // the value driven by the `AnimatePresence` component when the sheet is opened\n  // and after that it is driven by the gestures and/or snapping\n\n  var y = useMotionValue(0); // Keep the callback fns up-to-date so that they can be accessed inside\n  // the effect without including them to the dependencies array\n\n  var callbacks = useRef({\n    onOpenStart: onOpenStart,\n    onOpenEnd: onOpenEnd,\n    onCloseStart: onCloseStart,\n    onCloseEnd: onCloseEnd\n  });\n  useIsomorphicLayoutEffect(function () {\n    callbacks.current = {\n      onOpenStart: onOpenStart,\n      onOpenEnd: onOpenEnd,\n      onCloseStart: onCloseStart,\n      onCloseEnd: onCloseEnd\n    };\n  });\n\n  if (snapPoints) {\n    // Convert negative / percentage snap points to absolute values\n    snapPoints = snapPoints.map(function (point) {\n      // Percentage values e.g. between 0.0 and 1.0\n      if (point > 0 && point <= 1) return Math.round(point * windowHeight);\n      return point < 0 ? windowHeight + point : point; // negative values\n    });\n    console.assert(inDescendingOrder(snapPoints) || windowHeight === 0, \"Snap points need to be in descending order got: [\" + snapPoints + \"]\");\n  }\n\n  var onDrag = useEvent(function (_, _ref2) {\n    var delta = _ref2.delta;\n    // Update drag indicator rotation based on drag velocity\n    var velocity = y.getVelocity();\n    if (velocity > 0) indicatorRotation.set(10);\n    if (velocity < 0) indicatorRotation.set(-10); // Make sure user cannot drag beyond the top of the sheet\n\n    y.set(Math.max(y.get() + delta.y, 0));\n  });\n  var onDragEnd = useEvent(function (_, _ref3) {\n    var velocity = _ref3.velocity;\n\n    if (velocity.y > DRAG_VELOCITY_THRESHOLD) {\n      // User flicked the sheet down\n      onClose();\n    } else {\n      var sheetEl = sheetRef.current;\n      var sheetHeight = sheetEl.getBoundingClientRect().height;\n      var currentY = y.get();\n      var snapTo = 0;\n\n      if (snapPoints) {\n        var snapToValues = snapPoints.map(function (p) {\n          return sheetHeight - p;\n        }).filter(function (p) {\n          return p >= 0;\n        }); // negative values can occur with `content-height` detent\n        // Allow snapping to the top of the sheet if detent is set to `content-height`\n\n        if (detent === 'content-height' && !snapToValues.includes(0)) {\n          snapToValues.unshift(0);\n        } // Get the closest snap point\n\n\n        snapTo = getClosest(snapToValues, currentY);\n      } else if (currentY / sheetHeight > DRAG_CLOSE_THRESHOLD) {\n        // Close if dragged over enough far\n        snapTo = sheetHeight;\n      }\n\n      snapTo = validateSnapTo({\n        snapTo: snapTo,\n        sheetHeight: sheetHeight\n      }); // Update the spring value so that the sheet is animated to the snap point\n\n      animate(y, snapTo, animationOptions);\n\n      if (snapPoints && onSnap) {\n        var snapValue = Math.abs(Math.round(snapPoints[0] - snapTo));\n        var snapIndex = snapPoints.indexOf(getClosest(snapPoints, snapValue)); // prettier-ignore\n\n        onSnap(snapIndex);\n      }\n\n      if (snapTo >= sheetHeight) onClose();\n    } // Reset indicator rotation after dragging\n\n\n    indicatorRotation.set(0);\n  }); // Trigger onSnap callback when sheet is opened or closed\n\n  useEffect(function () {\n    if (!snapPoints || !onSnap) return;\n    var snapIndex = isOpen ? initialSnap : snapPoints.length - 1;\n    onSnap(snapIndex);\n  }, [isOpen]); // eslint-disable-line\n\n  useImperativeHandle(ref, function () {\n    return {\n      y: y,\n      snapTo: function snapTo(snapIndex) {\n        var sheetEl = sheetRef.current;\n\n        if (snapPoints && snapPoints[snapIndex] !== undefined && sheetEl !== null) {\n          var sheetHeight = sheetEl.getBoundingClientRect().height;\n          var snapPoint = snapPoints[snapIndex];\n          var snapTo = validateSnapTo({\n            snapTo: sheetHeight - snapPoint,\n            sheetHeight: sheetHeight\n          });\n          animate(y, snapTo, animationOptions);\n          if (onSnap) onSnap(snapIndex);\n          if (snapTo >= sheetHeight) onClose();\n        }\n      }\n    };\n  });\n  useModalEffect(isOpen, rootId); // Framer Motion should handle body scroll locking but it's not working\n  // properly on iOS. Scroll locking from React Aria seems to work much better.\n\n  usePreventScroll({\n    isDisabled: !isOpen\n  });\n  var dragProps = useMemo(function () {\n    var dragProps = {\n      drag: 'y',\n      dragElastic: 0,\n      dragConstraints: {\n        top: 0,\n        bottom: 0\n      },\n      dragMomentum: false,\n      onDrag: onDrag,\n      onDragEnd: onDragEnd\n    };\n    return disableDrag ? undefined : dragProps;\n  }, [disableDrag]); // eslint-disable-line\n\n  var context = {\n    y: y,\n    sheetRef: sheetRef,\n    isOpen: isOpen,\n    initialSnap: initialSnap,\n    snapPoints: snapPoints,\n    detent: detent,\n    indicatorRotation: indicatorRotation,\n    callbacks: callbacks,\n    dragProps: dragProps,\n    windowHeight: windowHeight,\n    animationOptions: animationOptions,\n    reduceMotion: reduceMotion\n  };\n  var sheet = createElement(SheetContext.Provider, {\n    value: context\n  }, createElement(\"div\", Object.assign({}, rest, {\n    ref: ref,\n    style: _extends({}, styles.wrapper, style)\n  }), createElement(AnimatePresence, null, isOpen ? Children.map(children, function (child, i) {\n    return cloneElement(child, {\n      key: \"sheet-child-\" + i\n    });\n  }) : null)));\n  if (IS_SSR) return sheet;\n  return createPortal(sheet, mountPoint != null ? mountPoint : document.body);\n});\n\nvar SheetContainer = /*#__PURE__*/forwardRef(function (_ref, ref) {\n  var children = _ref.children,\n      _ref$style = _ref.style,\n      style = _ref$style === void 0 ? {} : _ref$style,\n      rest = _objectWithoutPropertiesLoose(_ref, [\"children\", \"style\"]);\n\n  var _useSheetContext = useSheetContext(),\n      y = _useSheetContext.y,\n      isOpen = _useSheetContext.isOpen,\n      callbacks = _useSheetContext.callbacks,\n      snapPoints = _useSheetContext.snapPoints,\n      _useSheetContext$init = _useSheetContext.initialSnap,\n      initialSnap = _useSheetContext$init === void 0 ? 0 : _useSheetContext$init,\n      sheetRef = _useSheetContext.sheetRef,\n      windowHeight = _useSheetContext.windowHeight,\n      detent = _useSheetContext.detent,\n      animationOptions = _useSheetContext.animationOptions,\n      reduceMotion = _useSheetContext.reduceMotion;\n\n  var _useEventCallbacks = useEventCallbacks(isOpen, callbacks),\n      handleAnimationComplete = _useEventCallbacks.handleAnimationComplete;\n\n  var initialY = snapPoints ? snapPoints[0] - snapPoints[initialSnap] : 0;\n  var maxSnapHeight = snapPoints ? snapPoints[0] : null;\n  var height = maxSnapHeight !== null ? \"min(\" + maxSnapHeight + \"px, \" + MAX_HEIGHT + \")\" : MAX_HEIGHT;\n  return createElement(motion.div, Object.assign({}, rest, {\n    ref: mergeRefs([sheetRef, ref]),\n    className: \"react-modal-sheet-container\",\n    style: _extends({}, styles.container, style, detent === 'full-height' && {\n      height: height\n    }, detent === 'content-height' && {\n      maxHeight: height\n    }, {\n      y: y\n    }),\n    initial: reduceMotion ? false : {\n      y: windowHeight\n    },\n    animate: {\n      y: initialY,\n      transition: animationOptions\n    },\n    exit: {\n      y: windowHeight,\n      transition: animationOptions\n    },\n    onAnimationComplete: handleAnimationComplete\n  }), children);\n});\n\nvar SheetContent = /*#__PURE__*/forwardRef(function (_ref, ref) {\n  var children = _ref.children,\n      style = _ref.style,\n      disableDrag = _ref.disableDrag,\n      rest = _objectWithoutPropertiesLoose(_ref, [\"children\", \"style\", \"disableDrag\"]);\n\n  var _useSheetContext = useSheetContext(),\n      dragProps = _useSheetContext.dragProps;\n\n  var _dragProps = disableDrag ? undefined : dragProps;\n\n  return createElement(motion.div, Object.assign({}, rest, {\n    ref: ref,\n    className: \"react-modal-sheet-content\",\n    style: _extends({}, styles.content, style)\n  }, _dragProps), children);\n});\n\nvar SheetHeader = /*#__PURE__*/forwardRef(function (_ref, ref) {\n  var children = _ref.children,\n      style = _ref.style,\n      disableDrag = _ref.disableDrag,\n      rest = _objectWithoutPropertiesLoose(_ref, [\"children\", \"style\", \"disableDrag\"]);\n\n  var _useSheetContext = useSheetContext(),\n      indicatorRotation = _useSheetContext.indicatorRotation,\n      dragProps = _useSheetContext.dragProps;\n\n  var _dragProps = disableDrag ? undefined : dragProps;\n\n  var indicator1Transform = useTransform(indicatorRotation, function (r) {\n    return \"translateX(2px) rotate(\" + r + \"deg)\";\n  });\n  var indicator2Transform = useTransform(indicatorRotation, function (r) {\n    return \"translateX(-2px) rotate(\" + -1 * r + \"deg)\";\n  });\n  return createElement(motion.div, Object.assign({}, rest, {\n    ref: ref,\n    style: _extends({}, styles.headerWrapper, style)\n  }, _dragProps), children || createElement(\"div\", {\n    className: \"react-modal-sheet-header\",\n    style: styles.header\n  }, createElement(motion.span, {\n    className: \"react-modal-sheet-drag-indicator\",\n    style: _extends({}, styles.indicator, {\n      transform: indicator1Transform\n    })\n  }), createElement(motion.span, {\n    className: \"react-modal-sheet-drag-indicator\",\n    style: _extends({}, styles.indicator, {\n      transform: indicator2Transform\n    })\n  })));\n});\n\nvar isClickable = function isClickable(props) {\n  return !!props.onClick || !!props.onTap;\n};\n\nvar SheetBackdrop = /*#__PURE__*/forwardRef(function (_ref, ref) {\n  var _ref$style = _ref.style,\n      style = _ref$style === void 0 ? {} : _ref$style,\n      rest = _objectWithoutPropertiesLoose(_ref, [\"style\"]);\n\n  var Comp = isClickable(rest) ? motion.button : motion.div;\n  var pointerEvents = isClickable(rest) ? 'auto' : 'none';\n  return createElement(Comp, Object.assign({}, rest, {\n    ref: ref,\n    className: \"react-modal-sheet-backdrop\",\n    style: _extends({}, styles.backdrop, style, {\n      pointerEvents: pointerEvents\n    }),\n    initial: {\n      opacity: 0\n    },\n    animate: {\n      opacity: 1\n    },\n    exit: {\n      opacity: 0\n    }\n  }));\n});\n\nvar _SheetCompound = Sheet;\n_SheetCompound.Container = SheetContainer;\n_SheetCompound.Header = SheetHeader;\n_SheetCompound.Content = SheetContent;\n_SheetCompound.Backdrop = SheetBackdrop;\n\nexport default _SheetCompound;\n//# sourceMappingURL=react-modal-sheet.esm.js.map\n","import { compareDates } from '../dateMath/dateMath';\nimport { isBeforeMinDate } from './isBeforeMinDate';\nimport { isAfterMaxDate } from './isAfterMaxDate';\n/**\n * Checks if `date` falls into the restricted `options`\n * @param date - date to check\n * @param options - restriction options (min date, max date and list of restricted dates)\n */\nexport var isRestrictedDate = function (date, options) {\n    var restrictedDates = options.restrictedDates, minDate = options.minDate, maxDate = options.maxDate;\n    if (!restrictedDates && !minDate && !maxDate) {\n        return false;\n    }\n    var inRestrictedDates = restrictedDates && restrictedDates.some(function (rd) { return compareDates(rd, date); });\n    return inRestrictedDates || isBeforeMinDate(date, options) || isAfterMaxDate(date, options);\n};\n//# sourceMappingURL=isRestrictedDate.js.map","import { Mark, mergeAttributes, markInputRule, markPasteRule } from '@tiptap/core';\n\n/**\n * Matches inline code.\n */\nconst inputRegex = /(?:^|\\s)(`(?!\\s+`)((?:[^`]+))`(?!\\s+`))$/;\n/**\n * Matches inline code while pasting.\n */\nconst pasteRegex = /(?:^|\\s)(`(?!\\s+`)((?:[^`]+))`(?!\\s+`))/g;\n/**\n * This extension allows you to mark text as inline code.\n * @see https://tiptap.dev/api/marks/code\n */\nconst Code = Mark.create({\n    name: 'code',\n    addOptions() {\n        return {\n            HTMLAttributes: {},\n        };\n    },\n    excludes: '_',\n    code: true,\n    exitable: true,\n    parseHTML() {\n        return [\n            { tag: 'code' },\n        ];\n    },\n    renderHTML({ HTMLAttributes }) {\n        return ['code', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];\n    },\n    addCommands() {\n        return {\n            setCode: () => ({ commands }) => {\n                return commands.setMark(this.name);\n            },\n            toggleCode: () => ({ commands }) => {\n                return commands.toggleMark(this.name);\n            },\n            unsetCode: () => ({ commands }) => {\n                return commands.unsetMark(this.name);\n            },\n        };\n    },\n    addKeyboardShortcuts() {\n        return {\n            'Mod-e': () => this.editor.commands.toggleCode(),\n        };\n    },\n    addInputRules() {\n        return [\n            markInputRule({\n                find: inputRegex,\n                type: this.type,\n            }),\n        ];\n    },\n    addPasteRules() {\n        return [\n            markPasteRule({\n                find: pasteRegex,\n                type: this.type,\n            }),\n        ];\n    },\n});\n\nexport { Code, Code as default, inputRegex, pasteRegex };\n//# sourceMappingURL=index.js.map\n","import getOppositePlacement from \"../utils/getOppositePlacement.js\";\nimport getBasePlacement from \"../utils/getBasePlacement.js\";\nimport getOppositeVariationPlacement from \"../utils/getOppositeVariationPlacement.js\";\nimport detectOverflow from \"../utils/detectOverflow.js\";\nimport computeAutoPlacement from \"../utils/computeAutoPlacement.js\";\nimport { bottom, top, start, right, left, auto } from \"../enums.js\";\nimport getVariation from \"../utils/getVariation.js\"; // eslint-disable-next-line import/no-unused-modules\n\nfunction getExpandedFallbackPlacements(placement) {\n  if (getBasePlacement(placement) === auto) {\n    return [];\n  }\n\n  var oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];\n}\n\nfunction flip(_ref) {\n  var state = _ref.state,\n      options = _ref.options,\n      name = _ref.name;\n\n  if (state.modifiersData[name]._skip) {\n    return;\n  }\n\n  var _options$mainAxis = options.mainAxis,\n      checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,\n      _options$altAxis = options.altAxis,\n      checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,\n      specifiedFallbackPlacements = options.fallbackPlacements,\n      padding = options.padding,\n      boundary = options.boundary,\n      rootBoundary = options.rootBoundary,\n      altBoundary = options.altBoundary,\n      _options$flipVariatio = options.flipVariations,\n      flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,\n      allowedAutoPlacements = options.allowedAutoPlacements;\n  var preferredPlacement = state.options.placement;\n  var basePlacement = getBasePlacement(preferredPlacement);\n  var isBasePlacement = basePlacement === preferredPlacement;\n  var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));\n  var placements = [preferredPlacement].concat(fallbackPlacements).reduce(function (acc, placement) {\n    return acc.concat(getBasePlacement(placement) === auto ? computeAutoPlacement(state, {\n      placement: placement,\n      boundary: boundary,\n      rootBoundary: rootBoundary,\n      padding: padding,\n      flipVariations: flipVariations,\n      allowedAutoPlacements: allowedAutoPlacements\n    }) : placement);\n  }, []);\n  var referenceRect = state.rects.reference;\n  var popperRect = state.rects.popper;\n  var checksMap = new Map();\n  var makeFallbackChecks = true;\n  var firstFittingPlacement = placements[0];\n\n  for (var i = 0; i < placements.length; i++) {\n    var placement = placements[i];\n\n    var _basePlacement = getBasePlacement(placement);\n\n    var isStartVariation = getVariation(placement) === start;\n    var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;\n    var len = isVertical ? 'width' : 'height';\n    var overflow = detectOverflow(state, {\n      placement: placement,\n      boundary: boundary,\n      rootBoundary: rootBoundary,\n      altBoundary: altBoundary,\n      padding: padding\n    });\n    var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;\n\n    if (referenceRect[len] > popperRect[len]) {\n      mainVariationSide = getOppositePlacement(mainVariationSide);\n    }\n\n    var altVariationSide = getOppositePlacement(mainVariationSide);\n    var checks = [];\n\n    if (checkMainAxis) {\n      checks.push(overflow[_basePlacement] <= 0);\n    }\n\n    if (checkAltAxis) {\n      checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);\n    }\n\n    if (checks.every(function (check) {\n      return check;\n    })) {\n      firstFittingPlacement = placement;\n      makeFallbackChecks = false;\n      break;\n    }\n\n    checksMap.set(placement, checks);\n  }\n\n  if (makeFallbackChecks) {\n    // `2` may be desired in some cases  research later\n    var numberOfChecks = flipVariations ? 3 : 1;\n\n    var _loop = function _loop(_i) {\n      var fittingPlacement = placements.find(function (placement) {\n        var checks = checksMap.get(placement);\n\n        if (checks) {\n          return checks.slice(0, _i).every(function (check) {\n            return check;\n          });\n        }\n      });\n\n      if (fittingPlacement) {\n        firstFittingPlacement = fittingPlacement;\n        return \"break\";\n      }\n    };\n\n    for (var _i = numberOfChecks; _i > 0; _i--) {\n      var _ret = _loop(_i);\n\n      if (_ret === \"break\") break;\n    }\n  }\n\n  if (state.placement !== firstFittingPlacement) {\n    state.modifiersData[name]._skip = true;\n    state.placement = firstFittingPlacement;\n    state.reset = true;\n  }\n} // eslint-disable-next-line import/no-unused-modules\n\n\nexport default {\n  name: 'flip',\n  enabled: true,\n  phase: 'main',\n  fn: flip,\n  requiresIfExists: ['offset'],\n  data: {\n    _skip: false\n  }\n};","export default function getAltAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}","import { useReducer, useEffect } from 'react';\n\nvar makeVar = function (initialValue, equalsFunc) {\n    var value = initialValue;\n    var subscribers = new Set();\n    var reactiveVar = function (newValue) {\n        if (newValue !== undefined) {\n            var nextValue = value;\n            var valueChanged = void 0;\n            if (newValue instanceof Function) {\n                nextValue = newValue(value);\n            }\n            else {\n                nextValue = newValue;\n            }\n            valueChanged = equalsFunc ? !equalsFunc(nextValue, value) : nextValue !== value;\n            value = nextValue;\n            if (valueChanged) {\n                subscribers.forEach(function (handler) { return handler(value); });\n            }\n        }\n        return value;\n    };\n    reactiveVar.subscribe = function (handler) {\n        subscribers.add(handler);\n        return function () { return subscribers.delete(handler); };\n    };\n    reactiveVar.unsubscribe = function (handler) {\n        subscribers.delete(handler);\n    };\n    return reactiveVar;\n};\nvar useReactiveVar = function (reactiveVar) {\n    var handler = useReducer(function (x) { return x + 1; }, 0)[1];\n    useEffect(function () {\n        reactiveVar.subscribe(handler);\n        return function () {\n            reactiveVar.unsubscribe(handler);\n        };\n    }, []);\n    return reactiveVar();\n};\n\nexport { makeVar, useReactiveVar };\n//# sourceMappingURL=index.es.js.map\n","import { isShadowConfig } from './shadowConfig';\n/**\n * Separates the classes and style objects. Any classes that are pre-registered\n * args are auto expanded into objects.\n */\nexport function extractStyleParts(sheet) {\n    var args = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        args[_i - 1] = arguments[_i];\n    }\n    var classes = [];\n    var objects = [];\n    var stylesheet = sheet;\n    function _processArgs(argsList) {\n        for (var _i = 0, argsList_1 = argsList; _i < argsList_1.length; _i++) {\n            var arg = argsList_1[_i];\n            if (arg && !isShadowConfig(arg)) {\n                if (typeof arg === 'string') {\n                    if (arg.indexOf(' ') >= 0) {\n                        _processArgs(arg.split(' '));\n                    }\n                    else {\n                        var translatedArgs = stylesheet.argsFromClassName(arg);\n                        if (translatedArgs) {\n                            _processArgs(translatedArgs);\n                        }\n                        else {\n                            // Avoid adding the same class twice.\n                            if (classes.indexOf(arg) === -1) {\n                                classes.push(arg);\n                            }\n                        }\n                    }\n                }\n                else if (Array.isArray(arg)) {\n                    _processArgs(arg);\n                }\n                else if (typeof arg === 'object') {\n                    objects.push(arg);\n                }\n            }\n        }\n    }\n    _processArgs(args);\n    return {\n        classes: classes,\n        objects: objects,\n    };\n}\n//# sourceMappingURL=extractStyleParts.js.map","import { isElement, isHTMLElement } from \"./instanceOf.js\";\nimport { round } from \"../utils/math.js\";\nimport getWindow from \"./getWindow.js\";\nimport isLayoutViewport from \"./isLayoutViewport.js\";\nexport default function getBoundingClientRect(element, includeScale, isFixedStrategy) {\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n\n  var clientRect = element.getBoundingClientRect();\n  var scaleX = 1;\n  var scaleY = 1;\n\n  if (includeScale && isHTMLElement(element)) {\n    scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;\n    scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;\n  }\n\n  var _ref = isElement(element) ? getWindow(element) : window,\n      visualViewport = _ref.visualViewport;\n\n  var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;\n  var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;\n  var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;\n  var width = clientRect.width / scaleX;\n  var height = clientRect.height / scaleY;\n  return {\n    width: width,\n    height: height,\n    top: y,\n    right: x + width,\n    bottom: y + height,\n    left: x,\n    x: x,\n    y: y\n  };\n}","import getBoundingClientRect from \"./getBoundingClientRect.js\";\nimport getNodeScroll from \"./getNodeScroll.js\";\nimport getNodeName from \"./getNodeName.js\";\nimport { isHTMLElement } from \"./instanceOf.js\";\nimport getWindowScrollBarX from \"./getWindowScrollBarX.js\";\nimport getDocumentElement from \"./getDocumentElement.js\";\nimport isScrollParent from \"./isScrollParent.js\";\nimport { round } from \"../utils/math.js\";\n\nfunction isElementScaled(element) {\n  var rect = element.getBoundingClientRect();\n  var scaleX = round(rect.width) / element.offsetWidth || 1;\n  var scaleY = round(rect.height) / element.offsetHeight || 1;\n  return scaleX !== 1 || scaleY !== 1;\n} // Returns the composite rect of an element relative to its offsetParent.\n// Composite means it takes into account transforms as well as layout.\n\n\nexport default function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {\n  if (isFixed === void 0) {\n    isFixed = false;\n  }\n\n  var isOffsetParentAnElement = isHTMLElement(offsetParent);\n  var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);\n  var documentElement = getDocumentElement(offsetParent);\n  var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);\n  var scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  var offsets = {\n    x: 0,\n    y: 0\n  };\n\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== 'body' || // https://github.com/popperjs/popper-core/issues/1078\n    isScrollParent(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n\n    if (isHTMLElement(offsetParent)) {\n      offsets = getBoundingClientRect(offsetParent, true);\n      offsets.x += offsetParent.clientLeft;\n      offsets.y += offsetParent.clientTop;\n    } else if (documentElement) {\n      offsets.x = getWindowScrollBarX(documentElement);\n    }\n  }\n\n  return {\n    x: rect.left + scroll.scrollLeft - offsets.x,\n    y: rect.top + scroll.scrollTop - offsets.y,\n    width: rect.width,\n    height: rect.height\n  };\n}","function createRenderStep(runNextFrame) {\n    var toRun = [];\n    var toRunNextFrame = [];\n    var numToRun = 0;\n    var isProcessing = false;\n    var toKeepAlive = new WeakSet();\n    var step = {\n        schedule: function (callback, keepAlive, immediate) {\n            if (keepAlive === void 0) { keepAlive = false; }\n            if (immediate === void 0) { immediate = false; }\n            var addToCurrentFrame = immediate && isProcessing;\n            var buffer = addToCurrentFrame ? toRun : toRunNextFrame;\n            if (keepAlive)\n                toKeepAlive.add(callback);\n            if (buffer.indexOf(callback) === -1) {\n                buffer.push(callback);\n                if (addToCurrentFrame && isProcessing)\n                    numToRun = toRun.length;\n            }\n            return callback;\n        },\n        cancel: function (callback) {\n            var index = toRunNextFrame.indexOf(callback);\n            if (index !== -1)\n                toRunNextFrame.splice(index, 1);\n            toKeepAlive.delete(callback);\n        },\n        process: function (frameData) {\n            var _a;\n            isProcessing = true;\n            _a = [toRunNextFrame, toRun], toRun = _a[0], toRunNextFrame = _a[1];\n            toRunNextFrame.length = 0;\n            numToRun = toRun.length;\n            if (numToRun) {\n                for (var i = 0; i < numToRun; i++) {\n                    var callback = toRun[i];\n                    callback(frameData);\n                    if (toKeepAlive.has(callback)) {\n                        step.schedule(callback);\n                        runNextFrame();\n                    }\n                }\n            }\n            isProcessing = false;\n        },\n    };\n    return step;\n}\n\nexport { createRenderStep };\n","import { Node, mergeAttributes } from '@tiptap/core';\n\n/**\n * This extension allows you to create table headers.\n * @see https://www.tiptap.dev/api/nodes/table-header\n */\nconst TableHeader = Node.create({\n    name: 'tableHeader',\n    addOptions() {\n        return {\n            HTMLAttributes: {},\n        };\n    },\n    content: 'block+',\n    addAttributes() {\n        return {\n            colspan: {\n                default: 1,\n            },\n            rowspan: {\n                default: 1,\n            },\n            colwidth: {\n                default: null,\n                parseHTML: element => {\n                    const colwidth = element.getAttribute('colwidth');\n                    const value = colwidth\n                        ? [parseInt(colwidth, 10)]\n                        : null;\n                    return value;\n                },\n            },\n        };\n    },\n    tableRole: 'header_cell',\n    isolating: true,\n    parseHTML() {\n        return [\n            { tag: 'th' },\n        ];\n    },\n    renderHTML({ HTMLAttributes }) {\n        return ['th', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];\n    },\n});\n\nexport { TableHeader, TableHeader as default };\n//# sourceMappingURL=index.js.map\n","import getNodeName from \"./getNodeName.js\";\nimport getDocumentElement from \"./getDocumentElement.js\";\nimport { isShadowRoot } from \"./instanceOf.js\";\nexport default function getParentNode(element) {\n  if (getNodeName(element) === 'html') {\n    return element;\n  }\n\n  return (// this is a quicker (but less type safe) way to save quite some bytes from the bundle\n    // $FlowFixMe[incompatible-return]\n    // $FlowFixMe[prop-missing]\n    element.assignedSlot || // step into the shadow DOM of the parent of a slotted node\n    element.parentNode || ( // DOM Element detected\n    isShadowRoot(element) ? element.host : null) || // ShadowRoot detected\n    // $FlowFixMe[incompatible-call]: HTMLElement is a Node\n    getDocumentElement(element) // fallback\n\n  );\n}","export default function _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, _typeof(o);\n}","/**\n * Generates placeholder style for each of the browsers supported by `@fluentui/react`.\n * @param styles - The style to use.\n * @returns The placeholder style object for each browser depending on the placeholder directive it uses.\n */\nexport function getPlaceholderStyles(styles) {\n    return {\n        selectors: {\n            '::placeholder': styles,\n            ':-ms-input-placeholder': styles,\n            '::-ms-input-placeholder': styles, // Edge\n        },\n    };\n}\n//# sourceMappingURL=getPlaceholderStyles.js.map","export default function _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}","import { __assign } from 'tslib';\nexport var assign = __assign;\n//# sourceMappingURL=utilities.js.map","import * as React from 'react';\nimport { useConst } from './useConst';\n/**\n * Hook to store a value and generate callbacks for setting the value to true or false.\n * The identity of the callbacks will always stay the same.\n *\n * @param initialState - Initial value\n * @returns Array with the current value and an object containing the updater callbacks.\n */\nexport function useBoolean(initialState) {\n    var _a = React.useState(initialState), value = _a[0], setValue = _a[1];\n    var setTrue = useConst(function () { return function () {\n        setValue(true);\n    }; });\n    var setFalse = useConst(function () { return function () {\n        setValue(false);\n    }; });\n    var toggle = useConst(function () { return function () {\n        setValue(function (currentValue) { return !currentValue; });\n    }; });\n    return [value, { setTrue: setTrue, setFalse: setFalse, toggle: toggle }];\n}\n//# sourceMappingURL=useBoolean.js.map","import { isVirtualElement } from './isVirtualElement';\n/**\n * Gets the virtual parent given the child element, if it exists.\n *\n * @public\n */\nexport function getVirtualParent(child) {\n    var parent;\n    if (child && isVirtualElement(child)) {\n        parent = child._virtual.parent;\n    }\n    return parent;\n}\n//# sourceMappingURL=getVirtualParent.js.map","function loopElapsed(elapsed, duration, delay) {\n    if (delay === void 0) { delay = 0; }\n    return elapsed - duration - delay;\n}\nfunction reverseElapsed(elapsed, duration, delay, isForwardPlayback) {\n    if (delay === void 0) { delay = 0; }\n    if (isForwardPlayback === void 0) { isForwardPlayback = true; }\n    return isForwardPlayback\n        ? loopElapsed(duration + -elapsed, duration, delay)\n        : duration - (elapsed - duration) + delay;\n}\nfunction hasRepeatDelayElapsed(elapsed, duration, delay, isForwardPlayback) {\n    return isForwardPlayback ? elapsed >= duration + delay : elapsed <= -delay;\n}\n\nexport { hasRepeatDelayElapsed, loopElapsed, reverseElapsed };\n","// state/index.ts\nexport * from \"prosemirror-state\";\n","import { __assign } from 'tslib';\nimport { animate } from './index.js';\nimport { velocityPerSecond } from '../utils/velocity-per-second.js';\nimport { getFrameData } from 'framesync';\n\nfunction inertia(_a) {\n    var _b = _a.from, from = _b === void 0 ? 0 : _b, _c = _a.velocity, velocity = _c === void 0 ? 0 : _c, min = _a.min, max = _a.max, _d = _a.power, power = _d === void 0 ? 0.8 : _d, _e = _a.timeConstant, timeConstant = _e === void 0 ? 750 : _e, _f = _a.bounceStiffness, bounceStiffness = _f === void 0 ? 500 : _f, _g = _a.bounceDamping, bounceDamping = _g === void 0 ? 10 : _g, _h = _a.restDelta, restDelta = _h === void 0 ? 1 : _h, modifyTarget = _a.modifyTarget, driver = _a.driver, onUpdate = _a.onUpdate, onComplete = _a.onComplete;\n    var currentAnimation;\n    function isOutOfBounds(v) {\n        return (min !== undefined && v < min) || (max !== undefined && v > max);\n    }\n    function boundaryNearest(v) {\n        if (min === undefined)\n            return max;\n        if (max === undefined)\n            return min;\n        return Math.abs(min - v) < Math.abs(max - v) ? min : max;\n    }\n    function startAnimation(options) {\n        currentAnimation === null || currentAnimation === void 0 ? void 0 : currentAnimation.stop();\n        currentAnimation = animate(__assign(__assign({}, options), { driver: driver, onUpdate: function (v) {\n                var _a;\n                onUpdate === null || onUpdate === void 0 ? void 0 : onUpdate(v);\n                (_a = options.onUpdate) === null || _a === void 0 ? void 0 : _a.call(options, v);\n            }, onComplete: onComplete }));\n    }\n    function startSpring(options) {\n        startAnimation(__assign({ type: \"spring\", stiffness: bounceStiffness, damping: bounceDamping, restDelta: restDelta }, options));\n    }\n    if (isOutOfBounds(from)) {\n        startSpring({ from: from, velocity: velocity, to: boundaryNearest(from) });\n    }\n    else {\n        var target = power * velocity + from;\n        if (typeof modifyTarget !== \"undefined\")\n            target = modifyTarget(target);\n        var boundary_1 = boundaryNearest(target);\n        var heading_1 = boundary_1 === min ? -1 : 1;\n        var prev_1;\n        var current_1;\n        var checkBoundary = function (v) {\n            prev_1 = current_1;\n            current_1 = v;\n            velocity = velocityPerSecond(v - prev_1, getFrameData().delta);\n            if ((heading_1 === 1 && v > boundary_1) ||\n                (heading_1 === -1 && v < boundary_1)) {\n                startSpring({ from: v, to: boundary_1, velocity: velocity });\n            }\n        };\n        startAnimation({\n            type: \"decay\",\n            from: from,\n            velocity: velocity,\n            timeConstant: timeConstant,\n            power: power,\n            restDelta: restDelta,\n            modifyTarget: modifyTarget,\n            onUpdate: isOutOfBounds(target) ? checkBoundary : undefined,\n        });\n    }\n    return {\n        stop: function () { return currentAnimation === null || currentAnimation === void 0 ? void 0 : currentAnimation.stop(); },\n    };\n}\n\nexport { inertia };\n","function r(e){var t,f,n=\"\";if(\"string\"==typeof e||\"number\"==typeof e)n+=e;else if(\"object\"==typeof e)if(Array.isArray(e))for(t=0;t<e.length;t++)e[t]&&(f=r(e[t]))&&(n&&(n+=\" \"),n+=f);else for(t in e)e[t]&&(n&&(n+=\" \"),n+=t);return n}export function clsx(){for(var e,t,f=0,n=\"\";f<arguments.length;)(e=arguments[f++])&&(t=r(e))&&(n&&(n+=\" \"),n+=t);return n}export default clsx;","import * as React from 'react';\n/**\n * Context for providing the window.\n */\n// eslint-disable-next-line @fluentui/no-context-default-value\nexport var WindowContext = React.createContext({\n    // eslint-disable-next-line no-restricted-globals\n    window: typeof window === 'object' ? window : undefined,\n});\n/**\n * Hook to access the window object. This can be overridden contextually using the `WindowProvider`.\n */\nexport var useWindow = function () { return React.useContext(WindowContext).window; };\n/**\n * Hook to access the document object. This can be overridden contextually using the `WindowProvider`.\n */\nexport var useDocument = function () { var _a; return (_a = React.useContext(WindowContext).window) === null || _a === void 0 ? void 0 : _a.document; };\n/**\n * Component to provide the window object contextually. This is useful when rendering content to an element\n * contained within a child window or iframe element, where event handlers and styling must be projected\n * to an alternative window or document.\n */\nexport var WindowProvider = function (props) {\n    return React.createElement(WindowContext.Provider, { value: props }, props.children);\n};\n//# sourceMappingURL=WindowProvider.js.map","/**\n * The days of the week\n * {@docCategory DateTimeUtilities}\n */\nexport var DayOfWeek;\n(function (DayOfWeek) {\n    DayOfWeek[DayOfWeek[\"Sunday\"] = 0] = \"Sunday\";\n    DayOfWeek[DayOfWeek[\"Monday\"] = 1] = \"Monday\";\n    DayOfWeek[DayOfWeek[\"Tuesday\"] = 2] = \"Tuesday\";\n    DayOfWeek[DayOfWeek[\"Wednesday\"] = 3] = \"Wednesday\";\n    DayOfWeek[DayOfWeek[\"Thursday\"] = 4] = \"Thursday\";\n    DayOfWeek[DayOfWeek[\"Friday\"] = 5] = \"Friday\";\n    DayOfWeek[DayOfWeek[\"Saturday\"] = 6] = \"Saturday\";\n})(DayOfWeek || (DayOfWeek = {}));\n/**\n * The months\n * {@docCategory DateTimeUtilities}\n */\nexport var MonthOfYear;\n(function (MonthOfYear) {\n    MonthOfYear[MonthOfYear[\"January\"] = 0] = \"January\";\n    MonthOfYear[MonthOfYear[\"February\"] = 1] = \"February\";\n    MonthOfYear[MonthOfYear[\"March\"] = 2] = \"March\";\n    MonthOfYear[MonthOfYear[\"April\"] = 3] = \"April\";\n    MonthOfYear[MonthOfYear[\"May\"] = 4] = \"May\";\n    MonthOfYear[MonthOfYear[\"June\"] = 5] = \"June\";\n    MonthOfYear[MonthOfYear[\"July\"] = 6] = \"July\";\n    MonthOfYear[MonthOfYear[\"August\"] = 7] = \"August\";\n    MonthOfYear[MonthOfYear[\"September\"] = 8] = \"September\";\n    MonthOfYear[MonthOfYear[\"October\"] = 9] = \"October\";\n    MonthOfYear[MonthOfYear[\"November\"] = 10] = \"November\";\n    MonthOfYear[MonthOfYear[\"December\"] = 11] = \"December\";\n})(MonthOfYear || (MonthOfYear = {}));\n/**\n * First week of the year settings types\n * {@docCategory DateTimeUtilities}\n */\nexport var FirstWeekOfYear;\n(function (FirstWeekOfYear) {\n    FirstWeekOfYear[FirstWeekOfYear[\"FirstDay\"] = 0] = \"FirstDay\";\n    FirstWeekOfYear[FirstWeekOfYear[\"FirstFullWeek\"] = 1] = \"FirstFullWeek\";\n    FirstWeekOfYear[FirstWeekOfYear[\"FirstFourDayWeek\"] = 2] = \"FirstFourDayWeek\";\n})(FirstWeekOfYear || (FirstWeekOfYear = {}));\n/**\n * The supported date range types\n * {@docCategory DateTimeUtilities}\n */\nexport var DateRangeType;\n(function (DateRangeType) {\n    DateRangeType[DateRangeType[\"Day\"] = 0] = \"Day\";\n    DateRangeType[DateRangeType[\"Week\"] = 1] = \"Week\";\n    DateRangeType[DateRangeType[\"Month\"] = 2] = \"Month\";\n    DateRangeType[DateRangeType[\"WorkWeek\"] = 3] = \"WorkWeek\";\n})(DateRangeType || (DateRangeType = {}));\nexport var DAYS_IN_WEEK = 7;\n//# sourceMappingURL=dateValues.js.map","import { ReplaceError, Slice, Fragment, MarkType, Mark } from 'prosemirror-model';\n\n// Recovery values encode a range index and an offset. They are\n// represented as numbers, because tons of them will be created when\n// mapping, for example, a large number of decorations. The number's\n// lower 16 bits provide the index, the remaining bits the offset.\n//\n// Note: We intentionally don't use bit shift operators to en- and\n// decode these, since those clip to 32 bits, which we might in rare\n// cases want to overflow. A 64-bit float can represent 48-bit\n// integers precisely.\nconst lower16 = 0xffff;\nconst factor16 = Math.pow(2, 16);\nfunction makeRecover(index, offset) { return index + offset * factor16; }\nfunction recoverIndex(value) { return value & lower16; }\nfunction recoverOffset(value) { return (value - (value & lower16)) / factor16; }\nconst DEL_BEFORE = 1, DEL_AFTER = 2, DEL_ACROSS = 4, DEL_SIDE = 8;\n/**\nAn object representing a mapped position with extra\ninformation.\n*/\nclass MapResult {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    The mapped version of the position.\n    */\n    pos, \n    /**\n    @internal\n    */\n    delInfo, \n    /**\n    @internal\n    */\n    recover) {\n        this.pos = pos;\n        this.delInfo = delInfo;\n        this.recover = recover;\n    }\n    /**\n    Tells you whether the position was deleted, that is, whether the\n    step removed the token on the side queried (via the `assoc`)\n    argument from the document.\n    */\n    get deleted() { return (this.delInfo & DEL_SIDE) > 0; }\n    /**\n    Tells you whether the token before the mapped position was deleted.\n    */\n    get deletedBefore() { return (this.delInfo & (DEL_BEFORE | DEL_ACROSS)) > 0; }\n    /**\n    True when the token after the mapped position was deleted.\n    */\n    get deletedAfter() { return (this.delInfo & (DEL_AFTER | DEL_ACROSS)) > 0; }\n    /**\n    Tells whether any of the steps mapped through deletes across the\n    position (including both the token before and after the\n    position).\n    */\n    get deletedAcross() { return (this.delInfo & DEL_ACROSS) > 0; }\n}\n/**\nA map describing the deletions and insertions made by a step, which\ncan be used to find the correspondence between positions in the\npre-step version of a document and the same position in the\npost-step version.\n*/\nclass StepMap {\n    /**\n    Create a position map. The modifications to the document are\n    represented as an array of numbers, in which each group of three\n    represents a modified chunk as `[start, oldSize, newSize]`.\n    */\n    constructor(\n    /**\n    @internal\n    */\n    ranges, \n    /**\n    @internal\n    */\n    inverted = false) {\n        this.ranges = ranges;\n        this.inverted = inverted;\n        if (!ranges.length && StepMap.empty)\n            return StepMap.empty;\n    }\n    /**\n    @internal\n    */\n    recover(value) {\n        let diff = 0, index = recoverIndex(value);\n        if (!this.inverted)\n            for (let i = 0; i < index; i++)\n                diff += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1];\n        return this.ranges[index * 3] + diff + recoverOffset(value);\n    }\n    mapResult(pos, assoc = 1) { return this._map(pos, assoc, false); }\n    map(pos, assoc = 1) { return this._map(pos, assoc, true); }\n    /**\n    @internal\n    */\n    _map(pos, assoc, simple) {\n        let diff = 0, oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;\n        for (let i = 0; i < this.ranges.length; i += 3) {\n            let start = this.ranges[i] - (this.inverted ? diff : 0);\n            if (start > pos)\n                break;\n            let oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex], end = start + oldSize;\n            if (pos <= end) {\n                let side = !oldSize ? assoc : pos == start ? -1 : pos == end ? 1 : assoc;\n                let result = start + diff + (side < 0 ? 0 : newSize);\n                if (simple)\n                    return result;\n                let recover = pos == (assoc < 0 ? start : end) ? null : makeRecover(i / 3, pos - start);\n                let del = pos == start ? DEL_AFTER : pos == end ? DEL_BEFORE : DEL_ACROSS;\n                if (assoc < 0 ? pos != start : pos != end)\n                    del |= DEL_SIDE;\n                return new MapResult(result, del, recover);\n            }\n            diff += newSize - oldSize;\n        }\n        return simple ? pos + diff : new MapResult(pos + diff, 0, null);\n    }\n    /**\n    @internal\n    */\n    touches(pos, recover) {\n        let diff = 0, index = recoverIndex(recover);\n        let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;\n        for (let i = 0; i < this.ranges.length; i += 3) {\n            let start = this.ranges[i] - (this.inverted ? diff : 0);\n            if (start > pos)\n                break;\n            let oldSize = this.ranges[i + oldIndex], end = start + oldSize;\n            if (pos <= end && i == index * 3)\n                return true;\n            diff += this.ranges[i + newIndex] - oldSize;\n        }\n        return false;\n    }\n    /**\n    Calls the given function on each of the changed ranges included in\n    this map.\n    */\n    forEach(f) {\n        let oldIndex = this.inverted ? 2 : 1, newIndex = this.inverted ? 1 : 2;\n        for (let i = 0, diff = 0; i < this.ranges.length; i += 3) {\n            let start = this.ranges[i], oldStart = start - (this.inverted ? diff : 0), newStart = start + (this.inverted ? 0 : diff);\n            let oldSize = this.ranges[i + oldIndex], newSize = this.ranges[i + newIndex];\n            f(oldStart, oldStart + oldSize, newStart, newStart + newSize);\n            diff += newSize - oldSize;\n        }\n    }\n    /**\n    Create an inverted version of this map. The result can be used to\n    map positions in the post-step document to the pre-step document.\n    */\n    invert() {\n        return new StepMap(this.ranges, !this.inverted);\n    }\n    /**\n    @internal\n    */\n    toString() {\n        return (this.inverted ? \"-\" : \"\") + JSON.stringify(this.ranges);\n    }\n    /**\n    Create a map that moves all positions by offset `n` (which may be\n    negative). This can be useful when applying steps meant for a\n    sub-document to a larger document, or vice-versa.\n    */\n    static offset(n) {\n        return n == 0 ? StepMap.empty : new StepMap(n < 0 ? [0, -n, 0] : [0, 0, n]);\n    }\n}\n/**\nA StepMap that contains no changed ranges.\n*/\nStepMap.empty = new StepMap([]);\n/**\nA mapping represents a pipeline of zero or more [step\nmaps](https://prosemirror.net/docs/ref/#transform.StepMap). It has special provisions for losslessly\nhandling mapping positions through a series of steps in which some\nsteps are inverted versions of earlier steps. (This comes up when\n[rebasing](/docs/guide/#transform.rebasing) steps for\ncollaboration or history management.)\n*/\nclass Mapping {\n    /**\n    Create a new mapping with the given position maps.\n    */\n    constructor(\n    /**\n    The step maps in this mapping.\n    */\n    maps = [], \n    /**\n    @internal\n    */\n    mirror, \n    /**\n    The starting position in the `maps` array, used when `map` or\n    `mapResult` is called.\n    */\n    from = 0, \n    /**\n    The end position in the `maps` array.\n    */\n    to = maps.length) {\n        this.maps = maps;\n        this.mirror = mirror;\n        this.from = from;\n        this.to = to;\n    }\n    /**\n    Create a mapping that maps only through a part of this one.\n    */\n    slice(from = 0, to = this.maps.length) {\n        return new Mapping(this.maps, this.mirror, from, to);\n    }\n    /**\n    @internal\n    */\n    copy() {\n        return new Mapping(this.maps.slice(), this.mirror && this.mirror.slice(), this.from, this.to);\n    }\n    /**\n    Add a step map to the end of this mapping. If `mirrors` is\n    given, it should be the index of the step map that is the mirror\n    image of this one.\n    */\n    appendMap(map, mirrors) {\n        this.to = this.maps.push(map);\n        if (mirrors != null)\n            this.setMirror(this.maps.length - 1, mirrors);\n    }\n    /**\n    Add all the step maps in a given mapping to this one (preserving\n    mirroring information).\n    */\n    appendMapping(mapping) {\n        for (let i = 0, startSize = this.maps.length; i < mapping.maps.length; i++) {\n            let mirr = mapping.getMirror(i);\n            this.appendMap(mapping.maps[i], mirr != null && mirr < i ? startSize + mirr : undefined);\n        }\n    }\n    /**\n    Finds the offset of the step map that mirrors the map at the\n    given offset, in this mapping (as per the second argument to\n    `appendMap`).\n    */\n    getMirror(n) {\n        if (this.mirror)\n            for (let i = 0; i < this.mirror.length; i++)\n                if (this.mirror[i] == n)\n                    return this.mirror[i + (i % 2 ? -1 : 1)];\n    }\n    /**\n    @internal\n    */\n    setMirror(n, m) {\n        if (!this.mirror)\n            this.mirror = [];\n        this.mirror.push(n, m);\n    }\n    /**\n    Append the inverse of the given mapping to this one.\n    */\n    appendMappingInverted(mapping) {\n        for (let i = mapping.maps.length - 1, totalSize = this.maps.length + mapping.maps.length; i >= 0; i--) {\n            let mirr = mapping.getMirror(i);\n            this.appendMap(mapping.maps[i].invert(), mirr != null && mirr > i ? totalSize - mirr - 1 : undefined);\n        }\n    }\n    /**\n    Create an inverted version of this mapping.\n    */\n    invert() {\n        let inverse = new Mapping;\n        inverse.appendMappingInverted(this);\n        return inverse;\n    }\n    /**\n    Map a position through this mapping.\n    */\n    map(pos, assoc = 1) {\n        if (this.mirror)\n            return this._map(pos, assoc, true);\n        for (let i = this.from; i < this.to; i++)\n            pos = this.maps[i].map(pos, assoc);\n        return pos;\n    }\n    /**\n    Map a position through this mapping, returning a mapping\n    result.\n    */\n    mapResult(pos, assoc = 1) { return this._map(pos, assoc, false); }\n    /**\n    @internal\n    */\n    _map(pos, assoc, simple) {\n        let delInfo = 0;\n        for (let i = this.from; i < this.to; i++) {\n            let map = this.maps[i], result = map.mapResult(pos, assoc);\n            if (result.recover != null) {\n                let corr = this.getMirror(i);\n                if (corr != null && corr > i && corr < this.to) {\n                    i = corr;\n                    pos = this.maps[corr].recover(result.recover);\n                    continue;\n                }\n            }\n            delInfo |= result.delInfo;\n            pos = result.pos;\n        }\n        return simple ? pos : new MapResult(pos, delInfo, null);\n    }\n}\n\nconst stepsByID = Object.create(null);\n/**\nA step object represents an atomic change. It generally applies\nonly to the document it was created for, since the positions\nstored in it will only make sense for that document.\n\nNew steps are defined by creating classes that extend `Step`,\noverriding the `apply`, `invert`, `map`, `getMap` and `fromJSON`\nmethods, and registering your class with a unique\nJSON-serialization identifier using\n[`Step.jsonID`](https://prosemirror.net/docs/ref/#transform.Step^jsonID).\n*/\nclass Step {\n    /**\n    Get the step map that represents the changes made by this step,\n    and which can be used to transform between positions in the old\n    and the new document.\n    */\n    getMap() { return StepMap.empty; }\n    /**\n    Try to merge this step with another one, to be applied directly\n    after it. Returns the merged step when possible, null if the\n    steps can't be merged.\n    */\n    merge(other) { return null; }\n    /**\n    Deserialize a step from its JSON representation. Will call\n    through to the step class' own implementation of this method.\n    */\n    static fromJSON(schema, json) {\n        if (!json || !json.stepType)\n            throw new RangeError(\"Invalid input for Step.fromJSON\");\n        let type = stepsByID[json.stepType];\n        if (!type)\n            throw new RangeError(`No step type ${json.stepType} defined`);\n        return type.fromJSON(schema, json);\n    }\n    /**\n    To be able to serialize steps to JSON, each step needs a string\n    ID to attach to its JSON representation. Use this method to\n    register an ID for your step classes. Try to pick something\n    that's unlikely to clash with steps from other modules.\n    */\n    static jsonID(id, stepClass) {\n        if (id in stepsByID)\n            throw new RangeError(\"Duplicate use of step JSON ID \" + id);\n        stepsByID[id] = stepClass;\n        stepClass.prototype.jsonID = id;\n        return stepClass;\n    }\n}\n/**\nThe result of [applying](https://prosemirror.net/docs/ref/#transform.Step.apply) a step. Contains either a\nnew document or a failure value.\n*/\nclass StepResult {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    The transformed document, if successful.\n    */\n    doc, \n    /**\n    The failure message, if unsuccessful.\n    */\n    failed) {\n        this.doc = doc;\n        this.failed = failed;\n    }\n    /**\n    Create a successful step result.\n    */\n    static ok(doc) { return new StepResult(doc, null); }\n    /**\n    Create a failed step result.\n    */\n    static fail(message) { return new StepResult(null, message); }\n    /**\n    Call [`Node.replace`](https://prosemirror.net/docs/ref/#model.Node.replace) with the given\n    arguments. Create a successful result if it succeeds, and a\n    failed one if it throws a `ReplaceError`.\n    */\n    static fromReplace(doc, from, to, slice) {\n        try {\n            return StepResult.ok(doc.replace(from, to, slice));\n        }\n        catch (e) {\n            if (e instanceof ReplaceError)\n                return StepResult.fail(e.message);\n            throw e;\n        }\n    }\n}\n\nfunction mapFragment(fragment, f, parent) {\n    let mapped = [];\n    for (let i = 0; i < fragment.childCount; i++) {\n        let child = fragment.child(i);\n        if (child.content.size)\n            child = child.copy(mapFragment(child.content, f, child));\n        if (child.isInline)\n            child = f(child, parent, i);\n        mapped.push(child);\n    }\n    return Fragment.fromArray(mapped);\n}\n/**\nAdd a mark to all inline content between two positions.\n*/\nclass AddMarkStep extends Step {\n    /**\n    Create a mark step.\n    */\n    constructor(\n    /**\n    The start of the marked range.\n    */\n    from, \n    /**\n    The end of the marked range.\n    */\n    to, \n    /**\n    The mark to add.\n    */\n    mark) {\n        super();\n        this.from = from;\n        this.to = to;\n        this.mark = mark;\n    }\n    apply(doc) {\n        let oldSlice = doc.slice(this.from, this.to), $from = doc.resolve(this.from);\n        let parent = $from.node($from.sharedDepth(this.to));\n        let slice = new Slice(mapFragment(oldSlice.content, (node, parent) => {\n            if (!node.isAtom || !parent.type.allowsMarkType(this.mark.type))\n                return node;\n            return node.mark(this.mark.addToSet(node.marks));\n        }, parent), oldSlice.openStart, oldSlice.openEnd);\n        return StepResult.fromReplace(doc, this.from, this.to, slice);\n    }\n    invert() {\n        return new RemoveMarkStep(this.from, this.to, this.mark);\n    }\n    map(mapping) {\n        let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);\n        if (from.deleted && to.deleted || from.pos >= to.pos)\n            return null;\n        return new AddMarkStep(from.pos, to.pos, this.mark);\n    }\n    merge(other) {\n        if (other instanceof AddMarkStep &&\n            other.mark.eq(this.mark) &&\n            this.from <= other.to && this.to >= other.from)\n            return new AddMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);\n        return null;\n    }\n    toJSON() {\n        return { stepType: \"addMark\", mark: this.mark.toJSON(),\n            from: this.from, to: this.to };\n    }\n    /**\n    @internal\n    */\n    static fromJSON(schema, json) {\n        if (typeof json.from != \"number\" || typeof json.to != \"number\")\n            throw new RangeError(\"Invalid input for AddMarkStep.fromJSON\");\n        return new AddMarkStep(json.from, json.to, schema.markFromJSON(json.mark));\n    }\n}\nStep.jsonID(\"addMark\", AddMarkStep);\n/**\nRemove a mark from all inline content between two positions.\n*/\nclass RemoveMarkStep extends Step {\n    /**\n    Create a mark-removing step.\n    */\n    constructor(\n    /**\n    The start of the unmarked range.\n    */\n    from, \n    /**\n    The end of the unmarked range.\n    */\n    to, \n    /**\n    The mark to remove.\n    */\n    mark) {\n        super();\n        this.from = from;\n        this.to = to;\n        this.mark = mark;\n    }\n    apply(doc) {\n        let oldSlice = doc.slice(this.from, this.to);\n        let slice = new Slice(mapFragment(oldSlice.content, node => {\n            return node.mark(this.mark.removeFromSet(node.marks));\n        }, doc), oldSlice.openStart, oldSlice.openEnd);\n        return StepResult.fromReplace(doc, this.from, this.to, slice);\n    }\n    invert() {\n        return new AddMarkStep(this.from, this.to, this.mark);\n    }\n    map(mapping) {\n        let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);\n        if (from.deleted && to.deleted || from.pos >= to.pos)\n            return null;\n        return new RemoveMarkStep(from.pos, to.pos, this.mark);\n    }\n    merge(other) {\n        if (other instanceof RemoveMarkStep &&\n            other.mark.eq(this.mark) &&\n            this.from <= other.to && this.to >= other.from)\n            return new RemoveMarkStep(Math.min(this.from, other.from), Math.max(this.to, other.to), this.mark);\n        return null;\n    }\n    toJSON() {\n        return { stepType: \"removeMark\", mark: this.mark.toJSON(),\n            from: this.from, to: this.to };\n    }\n    /**\n    @internal\n    */\n    static fromJSON(schema, json) {\n        if (typeof json.from != \"number\" || typeof json.to != \"number\")\n            throw new RangeError(\"Invalid input for RemoveMarkStep.fromJSON\");\n        return new RemoveMarkStep(json.from, json.to, schema.markFromJSON(json.mark));\n    }\n}\nStep.jsonID(\"removeMark\", RemoveMarkStep);\n/**\nAdd a mark to a specific node.\n*/\nclass AddNodeMarkStep extends Step {\n    /**\n    Create a node mark step.\n    */\n    constructor(\n    /**\n    The position of the target node.\n    */\n    pos, \n    /**\n    The mark to add.\n    */\n    mark) {\n        super();\n        this.pos = pos;\n        this.mark = mark;\n    }\n    apply(doc) {\n        let node = doc.nodeAt(this.pos);\n        if (!node)\n            return StepResult.fail(\"No node at mark step's position\");\n        let updated = node.type.create(node.attrs, null, this.mark.addToSet(node.marks));\n        return StepResult.fromReplace(doc, this.pos, this.pos + 1, new Slice(Fragment.from(updated), 0, node.isLeaf ? 0 : 1));\n    }\n    invert(doc) {\n        let node = doc.nodeAt(this.pos);\n        if (node) {\n            let newSet = this.mark.addToSet(node.marks);\n            if (newSet.length == node.marks.length) {\n                for (let i = 0; i < node.marks.length; i++)\n                    if (!node.marks[i].isInSet(newSet))\n                        return new AddNodeMarkStep(this.pos, node.marks[i]);\n                return new AddNodeMarkStep(this.pos, this.mark);\n            }\n        }\n        return new RemoveNodeMarkStep(this.pos, this.mark);\n    }\n    map(mapping) {\n        let pos = mapping.mapResult(this.pos, 1);\n        return pos.deletedAfter ? null : new AddNodeMarkStep(pos.pos, this.mark);\n    }\n    toJSON() {\n        return { stepType: \"addNodeMark\", pos: this.pos, mark: this.mark.toJSON() };\n    }\n    /**\n    @internal\n    */\n    static fromJSON(schema, json) {\n        if (typeof json.pos != \"number\")\n            throw new RangeError(\"Invalid input for AddNodeMarkStep.fromJSON\");\n        return new AddNodeMarkStep(json.pos, schema.markFromJSON(json.mark));\n    }\n}\nStep.jsonID(\"addNodeMark\", AddNodeMarkStep);\n/**\nRemove a mark from a specific node.\n*/\nclass RemoveNodeMarkStep extends Step {\n    /**\n    Create a mark-removing step.\n    */\n    constructor(\n    /**\n    The position of the target node.\n    */\n    pos, \n    /**\n    The mark to remove.\n    */\n    mark) {\n        super();\n        this.pos = pos;\n        this.mark = mark;\n    }\n    apply(doc) {\n        let node = doc.nodeAt(this.pos);\n        if (!node)\n            return StepResult.fail(\"No node at mark step's position\");\n        let updated = node.type.create(node.attrs, null, this.mark.removeFromSet(node.marks));\n        return StepResult.fromReplace(doc, this.pos, this.pos + 1, new Slice(Fragment.from(updated), 0, node.isLeaf ? 0 : 1));\n    }\n    invert(doc) {\n        let node = doc.nodeAt(this.pos);\n        if (!node || !this.mark.isInSet(node.marks))\n            return this;\n        return new AddNodeMarkStep(this.pos, this.mark);\n    }\n    map(mapping) {\n        let pos = mapping.mapResult(this.pos, 1);\n        return pos.deletedAfter ? null : new RemoveNodeMarkStep(pos.pos, this.mark);\n    }\n    toJSON() {\n        return { stepType: \"removeNodeMark\", pos: this.pos, mark: this.mark.toJSON() };\n    }\n    /**\n    @internal\n    */\n    static fromJSON(schema, json) {\n        if (typeof json.pos != \"number\")\n            throw new RangeError(\"Invalid input for RemoveNodeMarkStep.fromJSON\");\n        return new RemoveNodeMarkStep(json.pos, schema.markFromJSON(json.mark));\n    }\n}\nStep.jsonID(\"removeNodeMark\", RemoveNodeMarkStep);\n\n/**\nReplace a part of the document with a slice of new content.\n*/\nclass ReplaceStep extends Step {\n    /**\n    The given `slice` should fit the 'gap' between `from` and\n    `to`the depths must line up, and the surrounding nodes must be\n    able to be joined with the open sides of the slice. When\n    `structure` is true, the step will fail if the content between\n    from and to is not just a sequence of closing and then opening\n    tokens (this is to guard against rebased replace steps\n    overwriting something they weren't supposed to).\n    */\n    constructor(\n    /**\n    The start position of the replaced range.\n    */\n    from, \n    /**\n    The end position of the replaced range.\n    */\n    to, \n    /**\n    The slice to insert.\n    */\n    slice, \n    /**\n    @internal\n    */\n    structure = false) {\n        super();\n        this.from = from;\n        this.to = to;\n        this.slice = slice;\n        this.structure = structure;\n    }\n    apply(doc) {\n        if (this.structure && contentBetween(doc, this.from, this.to))\n            return StepResult.fail(\"Structure replace would overwrite content\");\n        return StepResult.fromReplace(doc, this.from, this.to, this.slice);\n    }\n    getMap() {\n        return new StepMap([this.from, this.to - this.from, this.slice.size]);\n    }\n    invert(doc) {\n        return new ReplaceStep(this.from, this.from + this.slice.size, doc.slice(this.from, this.to));\n    }\n    map(mapping) {\n        let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);\n        if (from.deletedAcross && to.deletedAcross)\n            return null;\n        return new ReplaceStep(from.pos, Math.max(from.pos, to.pos), this.slice);\n    }\n    merge(other) {\n        if (!(other instanceof ReplaceStep) || other.structure || this.structure)\n            return null;\n        if (this.from + this.slice.size == other.from && !this.slice.openEnd && !other.slice.openStart) {\n            let slice = this.slice.size + other.slice.size == 0 ? Slice.empty\n                : new Slice(this.slice.content.append(other.slice.content), this.slice.openStart, other.slice.openEnd);\n            return new ReplaceStep(this.from, this.to + (other.to - other.from), slice, this.structure);\n        }\n        else if (other.to == this.from && !this.slice.openStart && !other.slice.openEnd) {\n            let slice = this.slice.size + other.slice.size == 0 ? Slice.empty\n                : new Slice(other.slice.content.append(this.slice.content), other.slice.openStart, this.slice.openEnd);\n            return new ReplaceStep(other.from, this.to, slice, this.structure);\n        }\n        else {\n            return null;\n        }\n    }\n    toJSON() {\n        let json = { stepType: \"replace\", from: this.from, to: this.to };\n        if (this.slice.size)\n            json.slice = this.slice.toJSON();\n        if (this.structure)\n            json.structure = true;\n        return json;\n    }\n    /**\n    @internal\n    */\n    static fromJSON(schema, json) {\n        if (typeof json.from != \"number\" || typeof json.to != \"number\")\n            throw new RangeError(\"Invalid input for ReplaceStep.fromJSON\");\n        return new ReplaceStep(json.from, json.to, Slice.fromJSON(schema, json.slice), !!json.structure);\n    }\n}\nStep.jsonID(\"replace\", ReplaceStep);\n/**\nReplace a part of the document with a slice of content, but\npreserve a range of the replaced content by moving it into the\nslice.\n*/\nclass ReplaceAroundStep extends Step {\n    /**\n    Create a replace-around step with the given range and gap.\n    `insert` should be the point in the slice into which the content\n    of the gap should be moved. `structure` has the same meaning as\n    it has in the [`ReplaceStep`](https://prosemirror.net/docs/ref/#transform.ReplaceStep) class.\n    */\n    constructor(\n    /**\n    The start position of the replaced range.\n    */\n    from, \n    /**\n    The end position of the replaced range.\n    */\n    to, \n    /**\n    The start of preserved range.\n    */\n    gapFrom, \n    /**\n    The end of preserved range.\n    */\n    gapTo, \n    /**\n    The slice to insert.\n    */\n    slice, \n    /**\n    The position in the slice where the preserved range should be\n    inserted.\n    */\n    insert, \n    /**\n    @internal\n    */\n    structure = false) {\n        super();\n        this.from = from;\n        this.to = to;\n        this.gapFrom = gapFrom;\n        this.gapTo = gapTo;\n        this.slice = slice;\n        this.insert = insert;\n        this.structure = structure;\n    }\n    apply(doc) {\n        if (this.structure && (contentBetween(doc, this.from, this.gapFrom) ||\n            contentBetween(doc, this.gapTo, this.to)))\n            return StepResult.fail(\"Structure gap-replace would overwrite content\");\n        let gap = doc.slice(this.gapFrom, this.gapTo);\n        if (gap.openStart || gap.openEnd)\n            return StepResult.fail(\"Gap is not a flat range\");\n        let inserted = this.slice.insertAt(this.insert, gap.content);\n        if (!inserted)\n            return StepResult.fail(\"Content does not fit in gap\");\n        return StepResult.fromReplace(doc, this.from, this.to, inserted);\n    }\n    getMap() {\n        return new StepMap([this.from, this.gapFrom - this.from, this.insert,\n            this.gapTo, this.to - this.gapTo, this.slice.size - this.insert]);\n    }\n    invert(doc) {\n        let gap = this.gapTo - this.gapFrom;\n        return new ReplaceAroundStep(this.from, this.from + this.slice.size + gap, this.from + this.insert, this.from + this.insert + gap, doc.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);\n    }\n    map(mapping) {\n        let from = mapping.mapResult(this.from, 1), to = mapping.mapResult(this.to, -1);\n        let gapFrom = this.from == this.gapFrom ? from.pos : mapping.map(this.gapFrom, -1);\n        let gapTo = this.to == this.gapTo ? to.pos : mapping.map(this.gapTo, 1);\n        if ((from.deletedAcross && to.deletedAcross) || gapFrom < from.pos || gapTo > to.pos)\n            return null;\n        return new ReplaceAroundStep(from.pos, to.pos, gapFrom, gapTo, this.slice, this.insert, this.structure);\n    }\n    toJSON() {\n        let json = { stepType: \"replaceAround\", from: this.from, to: this.to,\n            gapFrom: this.gapFrom, gapTo: this.gapTo, insert: this.insert };\n        if (this.slice.size)\n            json.slice = this.slice.toJSON();\n        if (this.structure)\n            json.structure = true;\n        return json;\n    }\n    /**\n    @internal\n    */\n    static fromJSON(schema, json) {\n        if (typeof json.from != \"number\" || typeof json.to != \"number\" ||\n            typeof json.gapFrom != \"number\" || typeof json.gapTo != \"number\" || typeof json.insert != \"number\")\n            throw new RangeError(\"Invalid input for ReplaceAroundStep.fromJSON\");\n        return new ReplaceAroundStep(json.from, json.to, json.gapFrom, json.gapTo, Slice.fromJSON(schema, json.slice), json.insert, !!json.structure);\n    }\n}\nStep.jsonID(\"replaceAround\", ReplaceAroundStep);\nfunction contentBetween(doc, from, to) {\n    let $from = doc.resolve(from), dist = to - from, depth = $from.depth;\n    while (dist > 0 && depth > 0 && $from.indexAfter(depth) == $from.node(depth).childCount) {\n        depth--;\n        dist--;\n    }\n    if (dist > 0) {\n        let next = $from.node(depth).maybeChild($from.indexAfter(depth));\n        while (dist > 0) {\n            if (!next || next.isLeaf)\n                return true;\n            next = next.firstChild;\n            dist--;\n        }\n    }\n    return false;\n}\n\nfunction addMark(tr, from, to, mark) {\n    let removed = [], added = [];\n    let removing, adding;\n    tr.doc.nodesBetween(from, to, (node, pos, parent) => {\n        if (!node.isInline)\n            return;\n        let marks = node.marks;\n        if (!mark.isInSet(marks) && parent.type.allowsMarkType(mark.type)) {\n            let start = Math.max(pos, from), end = Math.min(pos + node.nodeSize, to);\n            let newSet = mark.addToSet(marks);\n            for (let i = 0; i < marks.length; i++) {\n                if (!marks[i].isInSet(newSet)) {\n                    if (removing && removing.to == start && removing.mark.eq(marks[i]))\n                        removing.to = end;\n                    else\n                        removed.push(removing = new RemoveMarkStep(start, end, marks[i]));\n                }\n            }\n            if (adding && adding.to == start)\n                adding.to = end;\n            else\n                added.push(adding = new AddMarkStep(start, end, mark));\n        }\n    });\n    removed.forEach(s => tr.step(s));\n    added.forEach(s => tr.step(s));\n}\nfunction removeMark(tr, from, to, mark) {\n    let matched = [], step = 0;\n    tr.doc.nodesBetween(from, to, (node, pos) => {\n        if (!node.isInline)\n            return;\n        step++;\n        let toRemove = null;\n        if (mark instanceof MarkType) {\n            let set = node.marks, found;\n            while (found = mark.isInSet(set)) {\n                (toRemove || (toRemove = [])).push(found);\n                set = found.removeFromSet(set);\n            }\n        }\n        else if (mark) {\n            if (mark.isInSet(node.marks))\n                toRemove = [mark];\n        }\n        else {\n            toRemove = node.marks;\n        }\n        if (toRemove && toRemove.length) {\n            let end = Math.min(pos + node.nodeSize, to);\n            for (let i = 0; i < toRemove.length; i++) {\n                let style = toRemove[i], found;\n                for (let j = 0; j < matched.length; j++) {\n                    let m = matched[j];\n                    if (m.step == step - 1 && style.eq(matched[j].style))\n                        found = m;\n                }\n                if (found) {\n                    found.to = end;\n                    found.step = step;\n                }\n                else {\n                    matched.push({ style, from: Math.max(pos, from), to: end, step });\n                }\n            }\n        }\n    });\n    matched.forEach(m => tr.step(new RemoveMarkStep(m.from, m.to, m.style)));\n}\nfunction clearIncompatible(tr, pos, parentType, match = parentType.contentMatch, clearNewlines = true) {\n    let node = tr.doc.nodeAt(pos);\n    let replSteps = [], cur = pos + 1;\n    for (let i = 0; i < node.childCount; i++) {\n        let child = node.child(i), end = cur + child.nodeSize;\n        let allowed = match.matchType(child.type);\n        if (!allowed) {\n            replSteps.push(new ReplaceStep(cur, end, Slice.empty));\n        }\n        else {\n            match = allowed;\n            for (let j = 0; j < child.marks.length; j++)\n                if (!parentType.allowsMarkType(child.marks[j].type))\n                    tr.step(new RemoveMarkStep(cur, end, child.marks[j]));\n            if (clearNewlines && child.isText && parentType.whitespace != \"pre\") {\n                let m, newline = /\\r?\\n|\\r/g, slice;\n                while (m = newline.exec(child.text)) {\n                    if (!slice)\n                        slice = new Slice(Fragment.from(parentType.schema.text(\" \", parentType.allowedMarks(child.marks))), 0, 0);\n                    replSteps.push(new ReplaceStep(cur + m.index, cur + m.index + m[0].length, slice));\n                }\n            }\n        }\n        cur = end;\n    }\n    if (!match.validEnd) {\n        let fill = match.fillBefore(Fragment.empty, true);\n        tr.replace(cur, cur, new Slice(fill, 0, 0));\n    }\n    for (let i = replSteps.length - 1; i >= 0; i--)\n        tr.step(replSteps[i]);\n}\n\nfunction canCut(node, start, end) {\n    return (start == 0 || node.canReplace(start, node.childCount)) &&\n        (end == node.childCount || node.canReplace(0, end));\n}\n/**\nTry to find a target depth to which the content in the given range\ncan be lifted. Will not go across\n[isolating](https://prosemirror.net/docs/ref/#model.NodeSpec.isolating) parent nodes.\n*/\nfunction liftTarget(range) {\n    let parent = range.parent;\n    let content = parent.content.cutByIndex(range.startIndex, range.endIndex);\n    for (let depth = range.depth;; --depth) {\n        let node = range.$from.node(depth);\n        let index = range.$from.index(depth), endIndex = range.$to.indexAfter(depth);\n        if (depth < range.depth && node.canReplace(index, endIndex, content))\n            return depth;\n        if (depth == 0 || node.type.spec.isolating || !canCut(node, index, endIndex))\n            break;\n    }\n    return null;\n}\nfunction lift(tr, range, target) {\n    let { $from, $to, depth } = range;\n    let gapStart = $from.before(depth + 1), gapEnd = $to.after(depth + 1);\n    let start = gapStart, end = gapEnd;\n    let before = Fragment.empty, openStart = 0;\n    for (let d = depth, splitting = false; d > target; d--)\n        if (splitting || $from.index(d) > 0) {\n            splitting = true;\n            before = Fragment.from($from.node(d).copy(before));\n            openStart++;\n        }\n        else {\n            start--;\n        }\n    let after = Fragment.empty, openEnd = 0;\n    for (let d = depth, splitting = false; d > target; d--)\n        if (splitting || $to.after(d + 1) < $to.end(d)) {\n            splitting = true;\n            after = Fragment.from($to.node(d).copy(after));\n            openEnd++;\n        }\n        else {\n            end++;\n        }\n    tr.step(new ReplaceAroundStep(start, end, gapStart, gapEnd, new Slice(before.append(after), openStart, openEnd), before.size - openStart, true));\n}\n/**\nTry to find a valid way to wrap the content in the given range in a\nnode of the given type. May introduce extra nodes around and inside\nthe wrapper node, if necessary. Returns null if no valid wrapping\ncould be found. When `innerRange` is given, that range's content is\nused as the content to fit into the wrapping, instead of the\ncontent of `range`.\n*/\nfunction findWrapping(range, nodeType, attrs = null, innerRange = range) {\n    let around = findWrappingOutside(range, nodeType);\n    let inner = around && findWrappingInside(innerRange, nodeType);\n    if (!inner)\n        return null;\n    return around.map(withAttrs)\n        .concat({ type: nodeType, attrs }).concat(inner.map(withAttrs));\n}\nfunction withAttrs(type) { return { type, attrs: null }; }\nfunction findWrappingOutside(range, type) {\n    let { parent, startIndex, endIndex } = range;\n    let around = parent.contentMatchAt(startIndex).findWrapping(type);\n    if (!around)\n        return null;\n    let outer = around.length ? around[0] : type;\n    return parent.canReplaceWith(startIndex, endIndex, outer) ? around : null;\n}\nfunction findWrappingInside(range, type) {\n    let { parent, startIndex, endIndex } = range;\n    let inner = parent.child(startIndex);\n    let inside = type.contentMatch.findWrapping(inner.type);\n    if (!inside)\n        return null;\n    let lastType = inside.length ? inside[inside.length - 1] : type;\n    let innerMatch = lastType.contentMatch;\n    for (let i = startIndex; innerMatch && i < endIndex; i++)\n        innerMatch = innerMatch.matchType(parent.child(i).type);\n    if (!innerMatch || !innerMatch.validEnd)\n        return null;\n    return inside;\n}\nfunction wrap(tr, range, wrappers) {\n    let content = Fragment.empty;\n    for (let i = wrappers.length - 1; i >= 0; i--) {\n        if (content.size) {\n            let match = wrappers[i].type.contentMatch.matchFragment(content);\n            if (!match || !match.validEnd)\n                throw new RangeError(\"Wrapper type given to Transform.wrap does not form valid content of its parent wrapper\");\n        }\n        content = Fragment.from(wrappers[i].type.create(wrappers[i].attrs, content));\n    }\n    let start = range.start, end = range.end;\n    tr.step(new ReplaceAroundStep(start, end, start, end, new Slice(content, 0, 0), wrappers.length, true));\n}\nfunction setBlockType(tr, from, to, type, attrs) {\n    if (!type.isTextblock)\n        throw new RangeError(\"Type given to setBlockType should be a textblock\");\n    let mapFrom = tr.steps.length;\n    tr.doc.nodesBetween(from, to, (node, pos) => {\n        if (node.isTextblock && !node.hasMarkup(type, attrs) && canChangeType(tr.doc, tr.mapping.slice(mapFrom).map(pos), type)) {\n            let convertNewlines = null;\n            if (type.schema.linebreakReplacement) {\n                let pre = type.whitespace == \"pre\", supportLinebreak = !!type.contentMatch.matchType(type.schema.linebreakReplacement);\n                if (pre && !supportLinebreak)\n                    convertNewlines = false;\n                else if (!pre && supportLinebreak)\n                    convertNewlines = true;\n            }\n            // Ensure all markup that isn't allowed in the new node type is cleared\n            if (convertNewlines === false)\n                replaceLinebreaks(tr, node, pos, mapFrom);\n            clearIncompatible(tr, tr.mapping.slice(mapFrom).map(pos, 1), type, undefined, convertNewlines === null);\n            let mapping = tr.mapping.slice(mapFrom);\n            let startM = mapping.map(pos, 1), endM = mapping.map(pos + node.nodeSize, 1);\n            tr.step(new ReplaceAroundStep(startM, endM, startM + 1, endM - 1, new Slice(Fragment.from(type.create(attrs, null, node.marks)), 0, 0), 1, true));\n            if (convertNewlines === true)\n                replaceNewlines(tr, node, pos, mapFrom);\n            return false;\n        }\n    });\n}\nfunction replaceNewlines(tr, node, pos, mapFrom) {\n    node.forEach((child, offset) => {\n        if (child.isText) {\n            let m, newline = /\\r?\\n|\\r/g;\n            while (m = newline.exec(child.text)) {\n                let start = tr.mapping.slice(mapFrom).map(pos + 1 + offset + m.index);\n                tr.replaceWith(start, start + 1, node.type.schema.linebreakReplacement.create());\n            }\n        }\n    });\n}\nfunction replaceLinebreaks(tr, node, pos, mapFrom) {\n    node.forEach((child, offset) => {\n        if (child.type == child.type.schema.linebreakReplacement) {\n            let start = tr.mapping.slice(mapFrom).map(pos + 1 + offset);\n            tr.replaceWith(start, start + 1, node.type.schema.text(\"\\n\"));\n        }\n    });\n}\nfunction canChangeType(doc, pos, type) {\n    let $pos = doc.resolve(pos), index = $pos.index();\n    return $pos.parent.canReplaceWith(index, index + 1, type);\n}\n/**\nChange the type, attributes, and/or marks of the node at `pos`.\nWhen `type` isn't given, the existing node type is preserved,\n*/\nfunction setNodeMarkup(tr, pos, type, attrs, marks) {\n    let node = tr.doc.nodeAt(pos);\n    if (!node)\n        throw new RangeError(\"No node at given position\");\n    if (!type)\n        type = node.type;\n    let newNode = type.create(attrs, null, marks || node.marks);\n    if (node.isLeaf)\n        return tr.replaceWith(pos, pos + node.nodeSize, newNode);\n    if (!type.validContent(node.content))\n        throw new RangeError(\"Invalid content for node type \" + type.name);\n    tr.step(new ReplaceAroundStep(pos, pos + node.nodeSize, pos + 1, pos + node.nodeSize - 1, new Slice(Fragment.from(newNode), 0, 0), 1, true));\n}\n/**\nCheck whether splitting at the given position is allowed.\n*/\nfunction canSplit(doc, pos, depth = 1, typesAfter) {\n    let $pos = doc.resolve(pos), base = $pos.depth - depth;\n    let innerType = (typesAfter && typesAfter[typesAfter.length - 1]) || $pos.parent;\n    if (base < 0 || $pos.parent.type.spec.isolating ||\n        !$pos.parent.canReplace($pos.index(), $pos.parent.childCount) ||\n        !innerType.type.validContent($pos.parent.content.cutByIndex($pos.index(), $pos.parent.childCount)))\n        return false;\n    for (let d = $pos.depth - 1, i = depth - 2; d > base; d--, i--) {\n        let node = $pos.node(d), index = $pos.index(d);\n        if (node.type.spec.isolating)\n            return false;\n        let rest = node.content.cutByIndex(index, node.childCount);\n        let overrideChild = typesAfter && typesAfter[i + 1];\n        if (overrideChild)\n            rest = rest.replaceChild(0, overrideChild.type.create(overrideChild.attrs));\n        let after = (typesAfter && typesAfter[i]) || node;\n        if (!node.canReplace(index + 1, node.childCount) || !after.type.validContent(rest))\n            return false;\n    }\n    let index = $pos.indexAfter(base);\n    let baseType = typesAfter && typesAfter[0];\n    return $pos.node(base).canReplaceWith(index, index, baseType ? baseType.type : $pos.node(base + 1).type);\n}\nfunction split(tr, pos, depth = 1, typesAfter) {\n    let $pos = tr.doc.resolve(pos), before = Fragment.empty, after = Fragment.empty;\n    for (let d = $pos.depth, e = $pos.depth - depth, i = depth - 1; d > e; d--, i--) {\n        before = Fragment.from($pos.node(d).copy(before));\n        let typeAfter = typesAfter && typesAfter[i];\n        after = Fragment.from(typeAfter ? typeAfter.type.create(typeAfter.attrs, after) : $pos.node(d).copy(after));\n    }\n    tr.step(new ReplaceStep(pos, pos, new Slice(before.append(after), depth, depth), true));\n}\n/**\nTest whether the blocks before and after a given position can be\njoined.\n*/\nfunction canJoin(doc, pos) {\n    let $pos = doc.resolve(pos), index = $pos.index();\n    return joinable($pos.nodeBefore, $pos.nodeAfter) &&\n        $pos.parent.canReplace(index, index + 1);\n}\nfunction joinable(a, b) {\n    return !!(a && b && !a.isLeaf && a.canAppend(b));\n}\n/**\nFind an ancestor of the given position that can be joined to the\nblock before (or after if `dir` is positive). Returns the joinable\npoint, if any.\n*/\nfunction joinPoint(doc, pos, dir = -1) {\n    let $pos = doc.resolve(pos);\n    for (let d = $pos.depth;; d--) {\n        let before, after, index = $pos.index(d);\n        if (d == $pos.depth) {\n            before = $pos.nodeBefore;\n            after = $pos.nodeAfter;\n        }\n        else if (dir > 0) {\n            before = $pos.node(d + 1);\n            index++;\n            after = $pos.node(d).maybeChild(index);\n        }\n        else {\n            before = $pos.node(d).maybeChild(index - 1);\n            after = $pos.node(d + 1);\n        }\n        if (before && !before.isTextblock && joinable(before, after) &&\n            $pos.node(d).canReplace(index, index + 1))\n            return pos;\n        if (d == 0)\n            break;\n        pos = dir < 0 ? $pos.before(d) : $pos.after(d);\n    }\n}\nfunction join(tr, pos, depth) {\n    let step = new ReplaceStep(pos - depth, pos + depth, Slice.empty, true);\n    tr.step(step);\n}\n/**\nTry to find a point where a node of the given type can be inserted\nnear `pos`, by searching up the node hierarchy when `pos` itself\nisn't a valid place but is at the start or end of a node. Return\nnull if no position was found.\n*/\nfunction insertPoint(doc, pos, nodeType) {\n    let $pos = doc.resolve(pos);\n    if ($pos.parent.canReplaceWith($pos.index(), $pos.index(), nodeType))\n        return pos;\n    if ($pos.parentOffset == 0)\n        for (let d = $pos.depth - 1; d >= 0; d--) {\n            let index = $pos.index(d);\n            if ($pos.node(d).canReplaceWith(index, index, nodeType))\n                return $pos.before(d + 1);\n            if (index > 0)\n                return null;\n        }\n    if ($pos.parentOffset == $pos.parent.content.size)\n        for (let d = $pos.depth - 1; d >= 0; d--) {\n            let index = $pos.indexAfter(d);\n            if ($pos.node(d).canReplaceWith(index, index, nodeType))\n                return $pos.after(d + 1);\n            if (index < $pos.node(d).childCount)\n                return null;\n        }\n    return null;\n}\n/**\nFinds a position at or around the given position where the given\nslice can be inserted. Will look at parent nodes' nearest boundary\nand try there, even if the original position wasn't directly at the\nstart or end of that node. Returns null when no position was found.\n*/\nfunction dropPoint(doc, pos, slice) {\n    let $pos = doc.resolve(pos);\n    if (!slice.content.size)\n        return pos;\n    let content = slice.content;\n    for (let i = 0; i < slice.openStart; i++)\n        content = content.firstChild.content;\n    for (let pass = 1; pass <= (slice.openStart == 0 && slice.size ? 2 : 1); pass++) {\n        for (let d = $pos.depth; d >= 0; d--) {\n            let bias = d == $pos.depth ? 0 : $pos.pos <= ($pos.start(d + 1) + $pos.end(d + 1)) / 2 ? -1 : 1;\n            let insertPos = $pos.index(d) + (bias > 0 ? 1 : 0);\n            let parent = $pos.node(d), fits = false;\n            if (pass == 1) {\n                fits = parent.canReplace(insertPos, insertPos, content);\n            }\n            else {\n                let wrapping = parent.contentMatchAt(insertPos).findWrapping(content.firstChild.type);\n                fits = wrapping && parent.canReplaceWith(insertPos, insertPos, wrapping[0]);\n            }\n            if (fits)\n                return bias == 0 ? $pos.pos : bias < 0 ? $pos.before(d + 1) : $pos.after(d + 1);\n        }\n    }\n    return null;\n}\n\n/**\nFit a slice into a given position in the document, producing a\n[step](https://prosemirror.net/docs/ref/#transform.Step) that inserts it. Will return null if\nthere's no meaningful way to insert the slice here, or inserting it\nwould be a no-op (an empty slice over an empty range).\n*/\nfunction replaceStep(doc, from, to = from, slice = Slice.empty) {\n    if (from == to && !slice.size)\n        return null;\n    let $from = doc.resolve(from), $to = doc.resolve(to);\n    // Optimization -- avoid work if it's obvious that it's not needed.\n    if (fitsTrivially($from, $to, slice))\n        return new ReplaceStep(from, to, slice);\n    return new Fitter($from, $to, slice).fit();\n}\nfunction fitsTrivially($from, $to, slice) {\n    return !slice.openStart && !slice.openEnd && $from.start() == $to.start() &&\n        $from.parent.canReplace($from.index(), $to.index(), slice.content);\n}\n// Algorithm for 'placing' the elements of a slice into a gap:\n//\n// We consider the content of each node that is open to the left to be\n// independently placeable. I.e. in <p(\"foo\"), p(\"bar\")>, when the\n// paragraph on the left is open, \"foo\" can be placed (somewhere on\n// the left side of the replacement gap) independently from p(\"bar\").\n//\n// This class tracks the state of the placement progress in the\n// following properties:\n//\n//  - `frontier` holds a stack of `{type, match}` objects that\n//    represent the open side of the replacement. It starts at\n//    `$from`, then moves forward as content is placed, and is finally\n//    reconciled with `$to`.\n//\n//  - `unplaced` is a slice that represents the content that hasn't\n//    been placed yet.\n//\n//  - `placed` is a fragment of placed content. Its open-start value\n//    is implicit in `$from`, and its open-end value in `frontier`.\nclass Fitter {\n    constructor($from, $to, unplaced) {\n        this.$from = $from;\n        this.$to = $to;\n        this.unplaced = unplaced;\n        this.frontier = [];\n        this.placed = Fragment.empty;\n        for (let i = 0; i <= $from.depth; i++) {\n            let node = $from.node(i);\n            this.frontier.push({\n                type: node.type,\n                match: node.contentMatchAt($from.indexAfter(i))\n            });\n        }\n        for (let i = $from.depth; i > 0; i--)\n            this.placed = Fragment.from($from.node(i).copy(this.placed));\n    }\n    get depth() { return this.frontier.length - 1; }\n    fit() {\n        // As long as there's unplaced content, try to place some of it.\n        // If that fails, either increase the open score of the unplaced\n        // slice, or drop nodes from it, and then try again.\n        while (this.unplaced.size) {\n            let fit = this.findFittable();\n            if (fit)\n                this.placeNodes(fit);\n            else\n                this.openMore() || this.dropNode();\n        }\n        // When there's inline content directly after the frontier _and_\n        // directly after `this.$to`, we must generate a `ReplaceAround`\n        // step that pulls that content into the node after the frontier.\n        // That means the fitting must be done to the end of the textblock\n        // node after `this.$to`, not `this.$to` itself.\n        let moveInline = this.mustMoveInline(), placedSize = this.placed.size - this.depth - this.$from.depth;\n        let $from = this.$from, $to = this.close(moveInline < 0 ? this.$to : $from.doc.resolve(moveInline));\n        if (!$to)\n            return null;\n        // If closing to `$to` succeeded, create a step\n        let content = this.placed, openStart = $from.depth, openEnd = $to.depth;\n        while (openStart && openEnd && content.childCount == 1) { // Normalize by dropping open parent nodes\n            content = content.firstChild.content;\n            openStart--;\n            openEnd--;\n        }\n        let slice = new Slice(content, openStart, openEnd);\n        if (moveInline > -1)\n            return new ReplaceAroundStep($from.pos, moveInline, this.$to.pos, this.$to.end(), slice, placedSize);\n        if (slice.size || $from.pos != this.$to.pos) // Don't generate no-op steps\n            return new ReplaceStep($from.pos, $to.pos, slice);\n        return null;\n    }\n    // Find a position on the start spine of `this.unplaced` that has\n    // content that can be moved somewhere on the frontier. Returns two\n    // depths, one for the slice and one for the frontier.\n    findFittable() {\n        let startDepth = this.unplaced.openStart;\n        for (let cur = this.unplaced.content, d = 0, openEnd = this.unplaced.openEnd; d < startDepth; d++) {\n            let node = cur.firstChild;\n            if (cur.childCount > 1)\n                openEnd = 0;\n            if (node.type.spec.isolating && openEnd <= d) {\n                startDepth = d;\n                break;\n            }\n            cur = node.content;\n        }\n        // Only try wrapping nodes (pass 2) after finding a place without\n        // wrapping failed.\n        for (let pass = 1; pass <= 2; pass++) {\n            for (let sliceDepth = pass == 1 ? startDepth : this.unplaced.openStart; sliceDepth >= 0; sliceDepth--) {\n                let fragment, parent = null;\n                if (sliceDepth) {\n                    parent = contentAt(this.unplaced.content, sliceDepth - 1).firstChild;\n                    fragment = parent.content;\n                }\n                else {\n                    fragment = this.unplaced.content;\n                }\n                let first = fragment.firstChild;\n                for (let frontierDepth = this.depth; frontierDepth >= 0; frontierDepth--) {\n                    let { type, match } = this.frontier[frontierDepth], wrap, inject = null;\n                    // In pass 1, if the next node matches, or there is no next\n                    // node but the parents look compatible, we've found a\n                    // place.\n                    if (pass == 1 && (first ? match.matchType(first.type) || (inject = match.fillBefore(Fragment.from(first), false))\n                        : parent && type.compatibleContent(parent.type)))\n                        return { sliceDepth, frontierDepth, parent, inject };\n                    // In pass 2, look for a set of wrapping nodes that make\n                    // `first` fit here.\n                    else if (pass == 2 && first && (wrap = match.findWrapping(first.type)))\n                        return { sliceDepth, frontierDepth, parent, wrap };\n                    // Don't continue looking further up if the parent node\n                    // would fit here.\n                    if (parent && match.matchType(parent.type))\n                        break;\n                }\n            }\n        }\n    }\n    openMore() {\n        let { content, openStart, openEnd } = this.unplaced;\n        let inner = contentAt(content, openStart);\n        if (!inner.childCount || inner.firstChild.isLeaf)\n            return false;\n        this.unplaced = new Slice(content, openStart + 1, Math.max(openEnd, inner.size + openStart >= content.size - openEnd ? openStart + 1 : 0));\n        return true;\n    }\n    dropNode() {\n        let { content, openStart, openEnd } = this.unplaced;\n        let inner = contentAt(content, openStart);\n        if (inner.childCount <= 1 && openStart > 0) {\n            let openAtEnd = content.size - openStart <= openStart + inner.size;\n            this.unplaced = new Slice(dropFromFragment(content, openStart - 1, 1), openStart - 1, openAtEnd ? openStart - 1 : openEnd);\n        }\n        else {\n            this.unplaced = new Slice(dropFromFragment(content, openStart, 1), openStart, openEnd);\n        }\n    }\n    // Move content from the unplaced slice at `sliceDepth` to the\n    // frontier node at `frontierDepth`. Close that frontier node when\n    // applicable.\n    placeNodes({ sliceDepth, frontierDepth, parent, inject, wrap }) {\n        while (this.depth > frontierDepth)\n            this.closeFrontierNode();\n        if (wrap)\n            for (let i = 0; i < wrap.length; i++)\n                this.openFrontierNode(wrap[i]);\n        let slice = this.unplaced, fragment = parent ? parent.content : slice.content;\n        let openStart = slice.openStart - sliceDepth;\n        let taken = 0, add = [];\n        let { match, type } = this.frontier[frontierDepth];\n        if (inject) {\n            for (let i = 0; i < inject.childCount; i++)\n                add.push(inject.child(i));\n            match = match.matchFragment(inject);\n        }\n        // Computes the amount of (end) open nodes at the end of the\n        // fragment. When 0, the parent is open, but no more. When\n        // negative, nothing is open.\n        let openEndCount = (fragment.size + sliceDepth) - (slice.content.size - slice.openEnd);\n        // Scan over the fragment, fitting as many child nodes as\n        // possible.\n        while (taken < fragment.childCount) {\n            let next = fragment.child(taken), matches = match.matchType(next.type);\n            if (!matches)\n                break;\n            taken++;\n            if (taken > 1 || openStart == 0 || next.content.size) { // Drop empty open nodes\n                match = matches;\n                add.push(closeNodeStart(next.mark(type.allowedMarks(next.marks)), taken == 1 ? openStart : 0, taken == fragment.childCount ? openEndCount : -1));\n            }\n        }\n        let toEnd = taken == fragment.childCount;\n        if (!toEnd)\n            openEndCount = -1;\n        this.placed = addToFragment(this.placed, frontierDepth, Fragment.from(add));\n        this.frontier[frontierDepth].match = match;\n        // If the parent types match, and the entire node was moved, and\n        // it's not open, close this frontier node right away.\n        if (toEnd && openEndCount < 0 && parent && parent.type == this.frontier[this.depth].type && this.frontier.length > 1)\n            this.closeFrontierNode();\n        // Add new frontier nodes for any open nodes at the end.\n        for (let i = 0, cur = fragment; i < openEndCount; i++) {\n            let node = cur.lastChild;\n            this.frontier.push({ type: node.type, match: node.contentMatchAt(node.childCount) });\n            cur = node.content;\n        }\n        // Update `this.unplaced`. Drop the entire node from which we\n        // placed it we got to its end, otherwise just drop the placed\n        // nodes.\n        this.unplaced = !toEnd ? new Slice(dropFromFragment(slice.content, sliceDepth, taken), slice.openStart, slice.openEnd)\n            : sliceDepth == 0 ? Slice.empty\n                : new Slice(dropFromFragment(slice.content, sliceDepth - 1, 1), sliceDepth - 1, openEndCount < 0 ? slice.openEnd : sliceDepth - 1);\n    }\n    mustMoveInline() {\n        if (!this.$to.parent.isTextblock)\n            return -1;\n        let top = this.frontier[this.depth], level;\n        if (!top.type.isTextblock || !contentAfterFits(this.$to, this.$to.depth, top.type, top.match, false) ||\n            (this.$to.depth == this.depth && (level = this.findCloseLevel(this.$to)) && level.depth == this.depth))\n            return -1;\n        let { depth } = this.$to, after = this.$to.after(depth);\n        while (depth > 1 && after == this.$to.end(--depth))\n            ++after;\n        return after;\n    }\n    findCloseLevel($to) {\n        scan: for (let i = Math.min(this.depth, $to.depth); i >= 0; i--) {\n            let { match, type } = this.frontier[i];\n            let dropInner = i < $to.depth && $to.end(i + 1) == $to.pos + ($to.depth - (i + 1));\n            let fit = contentAfterFits($to, i, type, match, dropInner);\n            if (!fit)\n                continue;\n            for (let d = i - 1; d >= 0; d--) {\n                let { match, type } = this.frontier[d];\n                let matches = contentAfterFits($to, d, type, match, true);\n                if (!matches || matches.childCount)\n                    continue scan;\n            }\n            return { depth: i, fit, move: dropInner ? $to.doc.resolve($to.after(i + 1)) : $to };\n        }\n    }\n    close($to) {\n        let close = this.findCloseLevel($to);\n        if (!close)\n            return null;\n        while (this.depth > close.depth)\n            this.closeFrontierNode();\n        if (close.fit.childCount)\n            this.placed = addToFragment(this.placed, close.depth, close.fit);\n        $to = close.move;\n        for (let d = close.depth + 1; d <= $to.depth; d++) {\n            let node = $to.node(d), add = node.type.contentMatch.fillBefore(node.content, true, $to.index(d));\n            this.openFrontierNode(node.type, node.attrs, add);\n        }\n        return $to;\n    }\n    openFrontierNode(type, attrs = null, content) {\n        let top = this.frontier[this.depth];\n        top.match = top.match.matchType(type);\n        this.placed = addToFragment(this.placed, this.depth, Fragment.from(type.create(attrs, content)));\n        this.frontier.push({ type, match: type.contentMatch });\n    }\n    closeFrontierNode() {\n        let open = this.frontier.pop();\n        let add = open.match.fillBefore(Fragment.empty, true);\n        if (add.childCount)\n            this.placed = addToFragment(this.placed, this.frontier.length, add);\n    }\n}\nfunction dropFromFragment(fragment, depth, count) {\n    if (depth == 0)\n        return fragment.cutByIndex(count, fragment.childCount);\n    return fragment.replaceChild(0, fragment.firstChild.copy(dropFromFragment(fragment.firstChild.content, depth - 1, count)));\n}\nfunction addToFragment(fragment, depth, content) {\n    if (depth == 0)\n        return fragment.append(content);\n    return fragment.replaceChild(fragment.childCount - 1, fragment.lastChild.copy(addToFragment(fragment.lastChild.content, depth - 1, content)));\n}\nfunction contentAt(fragment, depth) {\n    for (let i = 0; i < depth; i++)\n        fragment = fragment.firstChild.content;\n    return fragment;\n}\nfunction closeNodeStart(node, openStart, openEnd) {\n    if (openStart <= 0)\n        return node;\n    let frag = node.content;\n    if (openStart > 1)\n        frag = frag.replaceChild(0, closeNodeStart(frag.firstChild, openStart - 1, frag.childCount == 1 ? openEnd - 1 : 0));\n    if (openStart > 0) {\n        frag = node.type.contentMatch.fillBefore(frag).append(frag);\n        if (openEnd <= 0)\n            frag = frag.append(node.type.contentMatch.matchFragment(frag).fillBefore(Fragment.empty, true));\n    }\n    return node.copy(frag);\n}\nfunction contentAfterFits($to, depth, type, match, open) {\n    let node = $to.node(depth), index = open ? $to.indexAfter(depth) : $to.index(depth);\n    if (index == node.childCount && !type.compatibleContent(node.type))\n        return null;\n    let fit = match.fillBefore(node.content, true, index);\n    return fit && !invalidMarks(type, node.content, index) ? fit : null;\n}\nfunction invalidMarks(type, fragment, start) {\n    for (let i = start; i < fragment.childCount; i++)\n        if (!type.allowsMarks(fragment.child(i).marks))\n            return true;\n    return false;\n}\nfunction definesContent(type) {\n    return type.spec.defining || type.spec.definingForContent;\n}\nfunction replaceRange(tr, from, to, slice) {\n    if (!slice.size)\n        return tr.deleteRange(from, to);\n    let $from = tr.doc.resolve(from), $to = tr.doc.resolve(to);\n    if (fitsTrivially($from, $to, slice))\n        return tr.step(new ReplaceStep(from, to, slice));\n    let targetDepths = coveredDepths($from, tr.doc.resolve(to));\n    // Can't replace the whole document, so remove 0 if it's present\n    if (targetDepths[targetDepths.length - 1] == 0)\n        targetDepths.pop();\n    // Negative numbers represent not expansion over the whole node at\n    // that depth, but replacing from $from.before(-D) to $to.pos.\n    let preferredTarget = -($from.depth + 1);\n    targetDepths.unshift(preferredTarget);\n    // This loop picks a preferred target depth, if one of the covering\n    // depths is not outside of a defining node, and adds negative\n    // depths for any depth that has $from at its start and does not\n    // cross a defining node.\n    for (let d = $from.depth, pos = $from.pos - 1; d > 0; d--, pos--) {\n        let spec = $from.node(d).type.spec;\n        if (spec.defining || spec.definingAsContext || spec.isolating)\n            break;\n        if (targetDepths.indexOf(d) > -1)\n            preferredTarget = d;\n        else if ($from.before(d) == pos)\n            targetDepths.splice(1, 0, -d);\n    }\n    // Try to fit each possible depth of the slice into each possible\n    // target depth, starting with the preferred depths.\n    let preferredTargetIndex = targetDepths.indexOf(preferredTarget);\n    let leftNodes = [], preferredDepth = slice.openStart;\n    for (let content = slice.content, i = 0;; i++) {\n        let node = content.firstChild;\n        leftNodes.push(node);\n        if (i == slice.openStart)\n            break;\n        content = node.content;\n    }\n    // Back up preferredDepth to cover defining textblocks directly\n    // above it, possibly skipping a non-defining textblock.\n    for (let d = preferredDepth - 1; d >= 0; d--) {\n        let leftNode = leftNodes[d], def = definesContent(leftNode.type);\n        if (def && !leftNode.sameMarkup($from.node(Math.abs(preferredTarget) - 1)))\n            preferredDepth = d;\n        else if (def || !leftNode.type.isTextblock)\n            break;\n    }\n    for (let j = slice.openStart; j >= 0; j--) {\n        let openDepth = (j + preferredDepth + 1) % (slice.openStart + 1);\n        let insert = leftNodes[openDepth];\n        if (!insert)\n            continue;\n        for (let i = 0; i < targetDepths.length; i++) {\n            // Loop over possible expansion levels, starting with the\n            // preferred one\n            let targetDepth = targetDepths[(i + preferredTargetIndex) % targetDepths.length], expand = true;\n            if (targetDepth < 0) {\n                expand = false;\n                targetDepth = -targetDepth;\n            }\n            let parent = $from.node(targetDepth - 1), index = $from.index(targetDepth - 1);\n            if (parent.canReplaceWith(index, index, insert.type, insert.marks))\n                return tr.replace($from.before(targetDepth), expand ? $to.after(targetDepth) : to, new Slice(closeFragment(slice.content, 0, slice.openStart, openDepth), openDepth, slice.openEnd));\n        }\n    }\n    let startSteps = tr.steps.length;\n    for (let i = targetDepths.length - 1; i >= 0; i--) {\n        tr.replace(from, to, slice);\n        if (tr.steps.length > startSteps)\n            break;\n        let depth = targetDepths[i];\n        if (depth < 0)\n            continue;\n        from = $from.before(depth);\n        to = $to.after(depth);\n    }\n}\nfunction closeFragment(fragment, depth, oldOpen, newOpen, parent) {\n    if (depth < oldOpen) {\n        let first = fragment.firstChild;\n        fragment = fragment.replaceChild(0, first.copy(closeFragment(first.content, depth + 1, oldOpen, newOpen, first)));\n    }\n    if (depth > newOpen) {\n        let match = parent.contentMatchAt(0);\n        let start = match.fillBefore(fragment).append(fragment);\n        fragment = start.append(match.matchFragment(start).fillBefore(Fragment.empty, true));\n    }\n    return fragment;\n}\nfunction replaceRangeWith(tr, from, to, node) {\n    if (!node.isInline && from == to && tr.doc.resolve(from).parent.content.size) {\n        let point = insertPoint(tr.doc, from, node.type);\n        if (point != null)\n            from = to = point;\n    }\n    tr.replaceRange(from, to, new Slice(Fragment.from(node), 0, 0));\n}\nfunction deleteRange(tr, from, to) {\n    let $from = tr.doc.resolve(from), $to = tr.doc.resolve(to);\n    let covered = coveredDepths($from, $to);\n    for (let i = 0; i < covered.length; i++) {\n        let depth = covered[i], last = i == covered.length - 1;\n        if ((last && depth == 0) || $from.node(depth).type.contentMatch.validEnd)\n            return tr.delete($from.start(depth), $to.end(depth));\n        if (depth > 0 && (last || $from.node(depth - 1).canReplace($from.index(depth - 1), $to.indexAfter(depth - 1))))\n            return tr.delete($from.before(depth), $to.after(depth));\n    }\n    for (let d = 1; d <= $from.depth && d <= $to.depth; d++) {\n        if (from - $from.start(d) == $from.depth - d && to > $from.end(d) && $to.end(d) - to != $to.depth - d)\n            return tr.delete($from.before(d), to);\n    }\n    tr.delete(from, to);\n}\n// Returns an array of all depths for which $from - $to spans the\n// whole content of the nodes at that depth.\nfunction coveredDepths($from, $to) {\n    let result = [], minDepth = Math.min($from.depth, $to.depth);\n    for (let d = minDepth; d >= 0; d--) {\n        let start = $from.start(d);\n        if (start < $from.pos - ($from.depth - d) ||\n            $to.end(d) > $to.pos + ($to.depth - d) ||\n            $from.node(d).type.spec.isolating ||\n            $to.node(d).type.spec.isolating)\n            break;\n        if (start == $to.start(d) ||\n            (d == $from.depth && d == $to.depth && $from.parent.inlineContent && $to.parent.inlineContent &&\n                d && $to.start(d - 1) == start - 1))\n            result.push(d);\n    }\n    return result;\n}\n\n/**\nUpdate an attribute in a specific node.\n*/\nclass AttrStep extends Step {\n    /**\n    Construct an attribute step.\n    */\n    constructor(\n    /**\n    The position of the target node.\n    */\n    pos, \n    /**\n    The attribute to set.\n    */\n    attr, \n    // The attribute's new value.\n    value) {\n        super();\n        this.pos = pos;\n        this.attr = attr;\n        this.value = value;\n    }\n    apply(doc) {\n        let node = doc.nodeAt(this.pos);\n        if (!node)\n            return StepResult.fail(\"No node at attribute step's position\");\n        let attrs = Object.create(null);\n        for (let name in node.attrs)\n            attrs[name] = node.attrs[name];\n        attrs[this.attr] = this.value;\n        let updated = node.type.create(attrs, null, node.marks);\n        return StepResult.fromReplace(doc, this.pos, this.pos + 1, new Slice(Fragment.from(updated), 0, node.isLeaf ? 0 : 1));\n    }\n    getMap() {\n        return StepMap.empty;\n    }\n    invert(doc) {\n        return new AttrStep(this.pos, this.attr, doc.nodeAt(this.pos).attrs[this.attr]);\n    }\n    map(mapping) {\n        let pos = mapping.mapResult(this.pos, 1);\n        return pos.deletedAfter ? null : new AttrStep(pos.pos, this.attr, this.value);\n    }\n    toJSON() {\n        return { stepType: \"attr\", pos: this.pos, attr: this.attr, value: this.value };\n    }\n    static fromJSON(schema, json) {\n        if (typeof json.pos != \"number\" || typeof json.attr != \"string\")\n            throw new RangeError(\"Invalid input for AttrStep.fromJSON\");\n        return new AttrStep(json.pos, json.attr, json.value);\n    }\n}\nStep.jsonID(\"attr\", AttrStep);\n/**\nUpdate an attribute in the doc node.\n*/\nclass DocAttrStep extends Step {\n    /**\n    Construct an attribute step.\n    */\n    constructor(\n    /**\n    The attribute to set.\n    */\n    attr, \n    // The attribute's new value.\n    value) {\n        super();\n        this.attr = attr;\n        this.value = value;\n    }\n    apply(doc) {\n        let attrs = Object.create(null);\n        for (let name in doc.attrs)\n            attrs[name] = doc.attrs[name];\n        attrs[this.attr] = this.value;\n        let updated = doc.type.create(attrs, doc.content, doc.marks);\n        return StepResult.ok(updated);\n    }\n    getMap() {\n        return StepMap.empty;\n    }\n    invert(doc) {\n        return new DocAttrStep(this.attr, doc.attrs[this.attr]);\n    }\n    map(mapping) {\n        return this;\n    }\n    toJSON() {\n        return { stepType: \"docAttr\", attr: this.attr, value: this.value };\n    }\n    static fromJSON(schema, json) {\n        if (typeof json.attr != \"string\")\n            throw new RangeError(\"Invalid input for DocAttrStep.fromJSON\");\n        return new DocAttrStep(json.attr, json.value);\n    }\n}\nStep.jsonID(\"docAttr\", DocAttrStep);\n\n/**\n@internal\n*/\nlet TransformError = class extends Error {\n};\nTransformError = function TransformError(message) {\n    let err = Error.call(this, message);\n    err.__proto__ = TransformError.prototype;\n    return err;\n};\nTransformError.prototype = Object.create(Error.prototype);\nTransformError.prototype.constructor = TransformError;\nTransformError.prototype.name = \"TransformError\";\n/**\nAbstraction to build up and track an array of\n[steps](https://prosemirror.net/docs/ref/#transform.Step) representing a document transformation.\n\nMost transforming methods return the `Transform` object itself, so\nthat they can be chained.\n*/\nclass Transform {\n    /**\n    Create a transform that starts with the given document.\n    */\n    constructor(\n    /**\n    The current document (the result of applying the steps in the\n    transform).\n    */\n    doc) {\n        this.doc = doc;\n        /**\n        The steps in this transform.\n        */\n        this.steps = [];\n        /**\n        The documents before each of the steps.\n        */\n        this.docs = [];\n        /**\n        A mapping with the maps for each of the steps in this transform.\n        */\n        this.mapping = new Mapping;\n    }\n    /**\n    The starting document.\n    */\n    get before() { return this.docs.length ? this.docs[0] : this.doc; }\n    /**\n    Apply a new step in this transform, saving the result. Throws an\n    error when the step fails.\n    */\n    step(step) {\n        let result = this.maybeStep(step);\n        if (result.failed)\n            throw new TransformError(result.failed);\n        return this;\n    }\n    /**\n    Try to apply a step in this transformation, ignoring it if it\n    fails. Returns the step result.\n    */\n    maybeStep(step) {\n        let result = step.apply(this.doc);\n        if (!result.failed)\n            this.addStep(step, result.doc);\n        return result;\n    }\n    /**\n    True when the document has been changed (when there are any\n    steps).\n    */\n    get docChanged() {\n        return this.steps.length > 0;\n    }\n    /**\n    @internal\n    */\n    addStep(step, doc) {\n        this.docs.push(this.doc);\n        this.steps.push(step);\n        this.mapping.appendMap(step.getMap());\n        this.doc = doc;\n    }\n    /**\n    Replace the part of the document between `from` and `to` with the\n    given `slice`.\n    */\n    replace(from, to = from, slice = Slice.empty) {\n        let step = replaceStep(this.doc, from, to, slice);\n        if (step)\n            this.step(step);\n        return this;\n    }\n    /**\n    Replace the given range with the given content, which may be a\n    fragment, node, or array of nodes.\n    */\n    replaceWith(from, to, content) {\n        return this.replace(from, to, new Slice(Fragment.from(content), 0, 0));\n    }\n    /**\n    Delete the content between the given positions.\n    */\n    delete(from, to) {\n        return this.replace(from, to, Slice.empty);\n    }\n    /**\n    Insert the given content at the given position.\n    */\n    insert(pos, content) {\n        return this.replaceWith(pos, pos, content);\n    }\n    /**\n    Replace a range of the document with a given slice, using\n    `from`, `to`, and the slice's\n    [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather\n    than fixed start and end points. This method may grow the\n    replaced area or close open nodes in the slice in order to get a\n    fit that is more in line with WYSIWYG expectations, by dropping\n    fully covered parent nodes of the replaced region when they are\n    marked [non-defining as\n    context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an\n    open parent node from the slice that _is_ marked as [defining\n    its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).\n    \n    This is the method, for example, to handle paste. The similar\n    [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more\n    primitive tool which will _not_ move the start and end of its given\n    range, and is useful in situations where you need more precise\n    control over what happens.\n    */\n    replaceRange(from, to, slice) {\n        replaceRange(this, from, to, slice);\n        return this;\n    }\n    /**\n    Replace the given range with a node, but use `from` and `to` as\n    hints, rather than precise positions. When from and to are the same\n    and are at the start or end of a parent node in which the given\n    node doesn't fit, this method may _move_ them out towards a parent\n    that does allow the given node to be placed. When the given range\n    completely covers a parent node, this method may completely replace\n    that parent node.\n    */\n    replaceRangeWith(from, to, node) {\n        replaceRangeWith(this, from, to, node);\n        return this;\n    }\n    /**\n    Delete the given range, expanding it to cover fully covered\n    parent nodes until a valid replace is found.\n    */\n    deleteRange(from, to) {\n        deleteRange(this, from, to);\n        return this;\n    }\n    /**\n    Split the content in the given range off from its parent, if there\n    is sibling content before or after it, and move it up the tree to\n    the depth specified by `target`. You'll probably want to use\n    [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make\n    sure the lift is valid.\n    */\n    lift(range, target) {\n        lift(this, range, target);\n        return this;\n    }\n    /**\n    Join the blocks around the given position. If depth is 2, their\n    last and first siblings are also joined, and so on.\n    */\n    join(pos, depth = 1) {\n        join(this, pos, depth);\n        return this;\n    }\n    /**\n    Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.\n    The wrappers are assumed to be valid in this position, and should\n    probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).\n    */\n    wrap(range, wrappers) {\n        wrap(this, range, wrappers);\n        return this;\n    }\n    /**\n    Set the type of all textblocks (partly) between `from` and `to` to\n    the given node type with the given attributes.\n    */\n    setBlockType(from, to = from, type, attrs = null) {\n        setBlockType(this, from, to, type, attrs);\n        return this;\n    }\n    /**\n    Change the type, attributes, and/or marks of the node at `pos`.\n    When `type` isn't given, the existing node type is preserved,\n    */\n    setNodeMarkup(pos, type, attrs = null, marks) {\n        setNodeMarkup(this, pos, type, attrs, marks);\n        return this;\n    }\n    /**\n    Set a single attribute on a given node to a new value.\n    The `pos` addresses the document content. Use `setDocAttribute`\n    to set attributes on the document itself.\n    */\n    setNodeAttribute(pos, attr, value) {\n        this.step(new AttrStep(pos, attr, value));\n        return this;\n    }\n    /**\n    Set a single attribute on the document to a new value.\n    */\n    setDocAttribute(attr, value) {\n        this.step(new DocAttrStep(attr, value));\n        return this;\n    }\n    /**\n    Add a mark to the node at position `pos`.\n    */\n    addNodeMark(pos, mark) {\n        this.step(new AddNodeMarkStep(pos, mark));\n        return this;\n    }\n    /**\n    Remove a mark (or a mark of the given type) from the node at\n    position `pos`.\n    */\n    removeNodeMark(pos, mark) {\n        if (!(mark instanceof Mark)) {\n            let node = this.doc.nodeAt(pos);\n            if (!node)\n                throw new RangeError(\"No node at position \" + pos);\n            mark = mark.isInSet(node.marks);\n            if (!mark)\n                return this;\n        }\n        this.step(new RemoveNodeMarkStep(pos, mark));\n        return this;\n    }\n    /**\n    Split the node at the given position, and optionally, if `depth` is\n    greater than one, any number of nodes above that. By default, the\n    parts split off will inherit the node type of the original node.\n    This can be changed by passing an array of types and attributes to\n    use after the split.\n    */\n    split(pos, depth = 1, typesAfter) {\n        split(this, pos, depth, typesAfter);\n        return this;\n    }\n    /**\n    Add the given mark to the inline content between `from` and `to`.\n    */\n    addMark(from, to, mark) {\n        addMark(this, from, to, mark);\n        return this;\n    }\n    /**\n    Remove marks from inline nodes between `from` and `to`. When\n    `mark` is a single mark, remove precisely that mark. When it is\n    a mark type, remove all marks of that type. When it is null,\n    remove all marks of any type.\n    */\n    removeMark(from, to, mark) {\n        removeMark(this, from, to, mark);\n        return this;\n    }\n    /**\n    Removes all marks and nodes from the content of the node at\n    `pos` that don't match the given new parent node type. Accepts\n    an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as\n    third argument.\n    */\n    clearIncompatible(pos, parentType, match) {\n        clearIncompatible(this, pos, parentType, match);\n        return this;\n    }\n}\n\nexport { AddMarkStep, AddNodeMarkStep, AttrStep, DocAttrStep, MapResult, Mapping, RemoveMarkStep, RemoveNodeMarkStep, ReplaceAroundStep, ReplaceStep, Step, StepMap, StepResult, Transform, TransformError, canJoin, canSplit, dropPoint, findWrapping, insertPoint, joinPoint, liftTarget, replaceStep };\n","import { rehydrateRendererCache, createDOMRenderer } from '@griffel/core';\nimport * as React from 'react';\nimport { canUseDOM } from './utils/canUseDOM.esm.js';\n\n/**\n * @private\n */\nconst RendererContext = /*#__PURE__*/React.createContext( /*#__PURE__*/createDOMRenderer());\n/**\n * @public\n */\nconst RendererProvider = ({\n  children,\n  renderer,\n  targetDocument\n}) => {\n  React.useMemo(() => {\n    if (canUseDOM()) {\n      // \"rehydrateCache()\" can't be called in effects as it needs to be called before any component will be rendered to\n      // avoid double insertion of classes\n      rehydrateRendererCache(renderer, targetDocument);\n    }\n  }, [renderer, targetDocument]);\n  return /*#__PURE__*/React.createElement(RendererContext.Provider, {\n    value: renderer\n  }, children);\n};\n/**\n * Returns an instance of current makeStyles() renderer.\n *\n * @private Exported as \"useRenderer_unstable\" use it on own risk. Can be changed or removed without a notice.\n */\nfunction useRenderer() {\n  return React.useContext(RendererContext);\n}\n\nexport { RendererProvider, useRenderer };\n//# sourceMappingURL=RendererContext.esm.js.map\n","import { __rest } from \"tslib\";\nimport { isRestrictedDate } from './isRestrictedDate';\nimport { isAfterMaxDate } from './isAfterMaxDate';\nimport { isBeforeMinDate } from './isBeforeMinDate';\nimport { compareDatePart, addDays } from '../dateMath/dateMath';\n/**\n * Returns closest available date given the restriction `options`, or undefined otherwise\n * @param options - list of search options\n */\nexport var findAvailableDate = function (options) {\n    var targetDate = options.targetDate, initialDate = options.initialDate, direction = options.direction, restrictedDateOptions = __rest(options, [\"targetDate\", \"initialDate\", \"direction\"]);\n    var availableDate = targetDate;\n    // if the target date is available, return it immediately\n    if (!isRestrictedDate(targetDate, restrictedDateOptions)) {\n        return targetDate;\n    }\n    while (compareDatePart(initialDate, availableDate) !== 0 &&\n        isRestrictedDate(availableDate, restrictedDateOptions) &&\n        !isAfterMaxDate(availableDate, restrictedDateOptions) &&\n        !isBeforeMinDate(availableDate, restrictedDateOptions)) {\n        availableDate = addDays(availableDate, direction);\n    }\n    if (compareDatePart(initialDate, availableDate) !== 0 && !isRestrictedDate(availableDate, restrictedDateOptions)) {\n        return availableDate;\n    }\n    return undefined;\n};\n//# sourceMappingURL=findAvailableDate.js.map","import setPrototypeOf from \"./setPrototypeOf.js\";\nexport default function _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  Object.defineProperty(subClass, \"prototype\", {\n    writable: false\n  });\n  if (superClass) setPrototypeOf(subClass, superClass);\n}","function mergeRefs(refs) {\n  return function (value) {\n    refs.forEach(function (ref) {\n      if (typeof ref === \"function\") {\n        ref(value);\n      } else if (ref != null) {\n        ref.current = value;\n      }\n    });\n  };\n}\n\nexport default mergeRefs;\n//# sourceMappingURL=react-merge-refs.esm.js.map\n","import { canUseDOM } from './utils/canUseDOM.esm.js';\nimport { useInsertionEffect } from './useInsertionEffect.esm.js';\n\nconst insertionFactory = () => {\n  const insertionCache = {};\n  return function insert(renderer, cssRules) {\n    // Even if `useInsertionEffect` is available, we can use it on a client only as it will not be executed in SSR\n    if (useInsertionEffect && canUseDOM()) {\n      // eslint-disable-next-line react-hooks/rules-of-hooks\n      useInsertionEffect(() => {\n        renderer.insertCSSRules(cssRules);\n      }, [renderer, cssRules]);\n      return;\n    }\n    if (insertionCache[renderer.id] === undefined) {\n      renderer.insertCSSRules(cssRules);\n      insertionCache[renderer.id] = true;\n    }\n  };\n};\n\nexport { insertionFactory };\n//# sourceMappingURL=insertionFactory.esm.js.map\n","import { alpha } from '../numbers/index.js';\nimport { percent } from '../numbers/units.js';\nimport { sanitize } from '../utils.js';\nimport { isColorString, splitColor } from './utils.js';\n\nvar hsla = {\n    test: isColorString('hsl', 'hue'),\n    parse: splitColor('hue', 'saturation', 'lightness'),\n    transform: function (_a) {\n        var hue = _a.hue, saturation = _a.saturation, lightness = _a.lightness, _b = _a.alpha, alpha$1 = _b === void 0 ? 1 : _b;\n        return ('hsla(' +\n            Math.round(hue) +\n            ', ' +\n            percent.transform(sanitize(saturation)) +\n            ', ' +\n            percent.transform(sanitize(lightness)) +\n            ', ' +\n            sanitize(alpha.transform(alpha$1)) +\n            ')');\n    },\n};\n\nexport { hsla };\n","import $k7QOs$react, {useState as $k7QOs$useState, useCallback as $k7QOs$useCallback, useRef as $k7QOs$useRef, useEffect as $k7QOs$useEffect, useContext as $k7QOs$useContext, useMemo as $k7QOs$useMemo} from \"react\";\nimport {useLayoutEffect as $k7QOs$useLayoutEffect, useId as $k7QOs$useId, isIOS as $k7QOs$isIOS, chain as $k7QOs$chain, getScrollParent as $k7QOs$getScrollParent, useLabels as $k7QOs$useLabels, mergeProps as $k7QOs$mergeProps} from \"@react-aria/utils\";\nimport {useLocale as $k7QOs$useLocale, useLocalizedStringFormatter as $k7QOs$useLocalizedStringFormatter} from \"@react-aria/i18n\";\nimport {useInteractOutside as $k7QOs$useInteractOutside, useFocusWithin as $k7QOs$useFocusWithin} from \"@react-aria/interactions\";\nimport $k7QOs$reactdom from \"react-dom\";\nimport {useIsSSR as $k7QOs$useIsSSR} from \"@react-aria/ssr\";\nimport {VisuallyHidden as $k7QOs$VisuallyHidden} from \"@react-aria/visually-hidden\";\nimport {FocusScope as $k7QOs$FocusScope} from \"@react-aria/focus\";\n\nfunction $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\nconst $edcf132a9284368a$var$AXIS = {\n    top: 'top',\n    bottom: 'top',\n    left: 'left',\n    right: 'left'\n};\nconst $edcf132a9284368a$var$FLIPPED_DIRECTION = {\n    top: 'bottom',\n    bottom: 'top',\n    left: 'right',\n    right: 'left'\n};\nconst $edcf132a9284368a$var$CROSS_AXIS = {\n    top: 'left',\n    left: 'top'\n};\nconst $edcf132a9284368a$var$AXIS_SIZE = {\n    top: 'height',\n    left: 'width'\n};\nconst $edcf132a9284368a$var$PARSED_PLACEMENT_CACHE = {\n};\n// @ts-ignore\nlet $edcf132a9284368a$var$visualViewport = typeof window !== 'undefined' && window.visualViewport;\nfunction $edcf132a9284368a$var$getContainerDimensions(containerNode) {\n    let width = 0, height = 0, top = 0, left = 0;\n    let scroll = {\n    };\n    if (containerNode.tagName === 'BODY') {\n        let documentElement = document.documentElement;\n        var ref;\n        width = (ref = $edcf132a9284368a$var$visualViewport === null || $edcf132a9284368a$var$visualViewport === void 0 ? void 0 : $edcf132a9284368a$var$visualViewport.width) !== null && ref !== void 0 ? ref : documentElement.clientWidth;\n        var ref1;\n        height = (ref1 = $edcf132a9284368a$var$visualViewport === null || $edcf132a9284368a$var$visualViewport === void 0 ? void 0 : $edcf132a9284368a$var$visualViewport.height) !== null && ref1 !== void 0 ? ref1 : documentElement.clientHeight;\n        scroll.top = documentElement.scrollTop || containerNode.scrollTop;\n        scroll.left = documentElement.scrollLeft || containerNode.scrollLeft;\n    } else {\n        ({ width: width , height: height , top: top , left: left  } = $edcf132a9284368a$var$getOffset(containerNode));\n        scroll.top = containerNode.scrollTop;\n        scroll.left = containerNode.scrollLeft;\n    }\n    return {\n        width: width,\n        height: height,\n        scroll: scroll,\n        top: top,\n        left: left\n    };\n}\nfunction $edcf132a9284368a$var$getScroll(node) {\n    return {\n        top: node.scrollTop,\n        left: node.scrollLeft,\n        width: node.scrollWidth,\n        height: node.scrollHeight\n    };\n}\nfunction $edcf132a9284368a$var$getDelta(axis, offset, size, containerDimensions, padding) {\n    let containerScroll = containerDimensions.scroll[axis];\n    let containerHeight = containerDimensions[$edcf132a9284368a$var$AXIS_SIZE[axis]];\n    let startEdgeOffset = offset - padding - containerScroll;\n    let endEdgeOffset = offset + padding - containerScroll + size;\n    if (startEdgeOffset < 0) return -startEdgeOffset;\n    else if (endEdgeOffset > containerHeight) return Math.max(containerHeight - endEdgeOffset, -startEdgeOffset);\n    else return 0;\n}\nfunction $edcf132a9284368a$var$getMargins(node) {\n    let style = window.getComputedStyle(node);\n    return {\n        top: parseInt(style.marginTop, 10) || 0,\n        bottom: parseInt(style.marginBottom, 10) || 0,\n        left: parseInt(style.marginLeft, 10) || 0,\n        right: parseInt(style.marginRight, 10) || 0\n    };\n}\nfunction $edcf132a9284368a$var$parsePlacement(input) {\n    if ($edcf132a9284368a$var$PARSED_PLACEMENT_CACHE[input]) return $edcf132a9284368a$var$PARSED_PLACEMENT_CACHE[input];\n    let [placement, crossPlacement] = input.split(' ');\n    let axis = $edcf132a9284368a$var$AXIS[placement] || 'right';\n    let crossAxis = $edcf132a9284368a$var$CROSS_AXIS[axis];\n    if (!$edcf132a9284368a$var$AXIS[crossPlacement]) crossPlacement = 'center';\n    let size = $edcf132a9284368a$var$AXIS_SIZE[axis];\n    let crossSize = $edcf132a9284368a$var$AXIS_SIZE[crossAxis];\n    $edcf132a9284368a$var$PARSED_PLACEMENT_CACHE[input] = {\n        placement: placement,\n        crossPlacement: crossPlacement,\n        axis: axis,\n        crossAxis: crossAxis,\n        size: size,\n        crossSize: crossSize\n    };\n    return $edcf132a9284368a$var$PARSED_PLACEMENT_CACHE[input];\n}\nfunction $edcf132a9284368a$var$computePosition(childOffset, boundaryDimensions, overlaySize, placementInfo, offset, crossOffset, containerOffsetWithBoundary, isContainerPositioned) {\n    let { placement: placement , crossPlacement: crossPlacement , axis: axis , crossAxis: crossAxis , size: size , crossSize: crossSize  } = placementInfo;\n    let position = {\n    };\n    // button position\n    position[crossAxis] = childOffset[crossAxis];\n    if (crossPlacement === 'center') //  + (button size / 2) - (overlay size / 2)\n    // at this point the overlay center should match the button center\n    position[crossAxis] += (childOffset[crossSize] - overlaySize[crossSize]) / 2;\n    else if (crossPlacement !== crossAxis) //  + (button size) - (overlay size)\n    // at this point the overlay bottom should match the button bottom\n    position[crossAxis] += childOffset[crossSize] - overlaySize[crossSize];\n     /* else {\n    the overlay top should match the button top\n  } */ \n    // add the crossOffset from props\n    position[crossAxis] += crossOffset;\n    // this is button center position - the overlay size + half of the button to align bottom of overlay with button center\n    let minViablePosition = childOffset[crossAxis] + childOffset[crossSize] / 2 - overlaySize[crossSize];\n    // this is button position of center, aligns top of overlay with button center\n    let maxViablePosition = childOffset[crossAxis] + childOffset[crossSize] / 2;\n    // clamp it into the range of the min/max positions\n    position[crossAxis] = Math.min(Math.max(minViablePosition, position[crossAxis]), maxViablePosition);\n    // Floor these so the position isn't placed on a partial pixel, only whole pixels. Shouldn't matter if it was floored or ceiled, so chose one.\n    if (placement === axis) {\n        // If the container is positioned (non-static), then we use the container's actual\n        // height, as `bottom` will be relative to this height.  But if the container is static,\n        // then it can only be the `document.body`, and `bottom` will be relative to _its_\n        // container, which should be as large as boundaryDimensions.\n        const containerHeight = isContainerPositioned ? containerOffsetWithBoundary[size] : boundaryDimensions[size];\n        position[$edcf132a9284368a$var$FLIPPED_DIRECTION[axis]] = Math.floor(containerHeight - childOffset[axis] + offset);\n    } else position[axis] = Math.floor(childOffset[axis] + childOffset[size] + offset);\n    return position;\n}\nfunction $edcf132a9284368a$var$getMaxHeight(position, boundaryDimensions, containerOffsetWithBoundary, childOffset, margins, padding) {\n    return position.top != null ? Math.max(0, boundaryDimensions.height + boundaryDimensions.top + boundaryDimensions.scroll.top - (containerOffsetWithBoundary.top + position.top) - (margins.top + margins.bottom + padding) // save additional space for margin and padding\n    ) : Math.max(0, childOffset.top + containerOffsetWithBoundary.top - (boundaryDimensions.top + boundaryDimensions.scroll.top) - (margins.top + margins.bottom + padding) // save additional space for margin and padding\n    );\n}\nfunction $edcf132a9284368a$var$getAvailableSpace(boundaryDimensions, containerOffsetWithBoundary, childOffset, margins, padding, placementInfo) {\n    let { placement: placement , axis: axis , size: size  } = placementInfo;\n    if (placement === axis) return Math.max(0, childOffset[axis] - boundaryDimensions[axis] - boundaryDimensions.scroll[axis] + containerOffsetWithBoundary[axis] - margins[axis] - margins[$edcf132a9284368a$var$FLIPPED_DIRECTION[axis]] - padding);\n    return Math.max(0, boundaryDimensions[size] + boundaryDimensions[axis] + boundaryDimensions.scroll[axis] - containerOffsetWithBoundary[axis] - childOffset[axis] - childOffset[size] - margins[axis] - margins[$edcf132a9284368a$var$FLIPPED_DIRECTION[axis]] - padding);\n}\nfunction $edcf132a9284368a$export$6839422d1f33cee9(placementInput, childOffset, overlaySize, scrollSize, margins, padding, flip, boundaryDimensions, containerOffsetWithBoundary, offset, crossOffset, isContainerPositioned, userSetMaxHeight) {\n    let placementInfo = $edcf132a9284368a$var$parsePlacement(placementInput);\n    let { size: size , crossAxis: crossAxis , crossSize: crossSize , placement: placement , crossPlacement: crossPlacement  } = placementInfo;\n    let position = $edcf132a9284368a$var$computePosition(childOffset, boundaryDimensions, overlaySize, placementInfo, offset, crossOffset, containerOffsetWithBoundary, isContainerPositioned);\n    let normalizedOffset = offset;\n    let space = $edcf132a9284368a$var$getAvailableSpace(boundaryDimensions, containerOffsetWithBoundary, childOffset, margins, padding + offset, placementInfo);\n    // Check if the scroll size of the overlay is greater than the available space to determine if we need to flip\n    if (flip && scrollSize[size] > space) {\n        let flippedPlacementInfo = $edcf132a9284368a$var$parsePlacement(`${$edcf132a9284368a$var$FLIPPED_DIRECTION[placement]} ${crossPlacement}`);\n        let flippedPosition = $edcf132a9284368a$var$computePosition(childOffset, boundaryDimensions, overlaySize, flippedPlacementInfo, offset, crossOffset, containerOffsetWithBoundary, isContainerPositioned);\n        let flippedSpace = $edcf132a9284368a$var$getAvailableSpace(boundaryDimensions, containerOffsetWithBoundary, childOffset, margins, padding + offset, flippedPlacementInfo);\n        // If the available space for the flipped position is greater than the original available space, flip.\n        if (flippedSpace > space) {\n            placementInfo = flippedPlacementInfo;\n            position = flippedPosition;\n            normalizedOffset = offset;\n        }\n    }\n    let delta = $edcf132a9284368a$var$getDelta(crossAxis, position[crossAxis], overlaySize[crossSize], boundaryDimensions, padding);\n    position[crossAxis] += delta;\n    let maxHeight = $edcf132a9284368a$var$getMaxHeight(position, boundaryDimensions, containerOffsetWithBoundary, childOffset, margins, padding);\n    if (userSetMaxHeight && userSetMaxHeight < maxHeight) maxHeight = userSetMaxHeight;\n    overlaySize.height = Math.min(overlaySize.height, maxHeight);\n    position = $edcf132a9284368a$var$computePosition(childOffset, boundaryDimensions, overlaySize, placementInfo, normalizedOffset, crossOffset, containerOffsetWithBoundary, isContainerPositioned);\n    delta = $edcf132a9284368a$var$getDelta(crossAxis, position[crossAxis], overlaySize[crossSize], boundaryDimensions, padding);\n    position[crossAxis] += delta;\n    let arrowPosition = {\n    };\n    arrowPosition[crossAxis] = childOffset[crossAxis] - position[crossAxis] + childOffset[crossSize] / 2;\n    return {\n        position: position,\n        maxHeight: maxHeight,\n        arrowOffsetLeft: arrowPosition.left,\n        arrowOffsetTop: arrowPosition.top,\n        placement: placementInfo.placement\n    };\n}\nfunction $edcf132a9284368a$export$b3ceb0cbf1056d98(opts) {\n    let { placement: placement , targetNode: targetNode , overlayNode: overlayNode , scrollNode: scrollNode , padding: padding , shouldFlip: shouldFlip , boundaryElement: boundaryElement , offset: offset , crossOffset: crossOffset , maxHeight: maxHeight  } = opts;\n    let container = overlayNode instanceof HTMLElement && overlayNode.offsetParent || document.body;\n    let isBodyContainer = container.tagName === 'BODY';\n    const containerPositionStyle = window.getComputedStyle(container).position;\n    let isContainerPositioned = !!containerPositionStyle && containerPositionStyle !== 'static';\n    let childOffset = isBodyContainer ? $edcf132a9284368a$var$getOffset(targetNode) : $edcf132a9284368a$var$getPosition(targetNode, container);\n    if (!isBodyContainer) {\n        let { marginTop: marginTop , marginLeft: marginLeft  } = window.getComputedStyle(targetNode);\n        childOffset.top += parseInt(marginTop, 10) || 0;\n        childOffset.left += parseInt(marginLeft, 10) || 0;\n    }\n    let overlaySize = $edcf132a9284368a$var$getOffset(overlayNode);\n    let margins = $edcf132a9284368a$var$getMargins(overlayNode);\n    overlaySize.width += margins.left + margins.right;\n    overlaySize.height += margins.top + margins.bottom;\n    let scrollSize = $edcf132a9284368a$var$getScroll(scrollNode);\n    let boundaryDimensions = $edcf132a9284368a$var$getContainerDimensions(boundaryElement);\n    let containerOffsetWithBoundary = boundaryElement.tagName === 'BODY' ? $edcf132a9284368a$var$getOffset(container) : $edcf132a9284368a$var$getPosition(container, boundaryElement);\n    return $edcf132a9284368a$export$6839422d1f33cee9(placement, childOffset, overlaySize, scrollSize, margins, padding, shouldFlip, boundaryDimensions, containerOffsetWithBoundary, offset, crossOffset, isContainerPositioned, maxHeight);\n}\nfunction $edcf132a9284368a$var$getOffset(node) {\n    let { top: top , left: left , width: width , height: height  } = node.getBoundingClientRect();\n    let { scrollTop: scrollTop , scrollLeft: scrollLeft , clientTop: clientTop , clientLeft: clientLeft  } = document.documentElement;\n    return {\n        top: top + scrollTop - clientTop,\n        left: left + scrollLeft - clientLeft,\n        width: width,\n        height: height\n    };\n}\nfunction $edcf132a9284368a$var$getPosition(node, parent) {\n    let style = window.getComputedStyle(node);\n    let offset;\n    if (style.position === 'fixed') {\n        let { top: top , left: left , width: width , height: height  } = node.getBoundingClientRect();\n        offset = {\n            top: top,\n            left: left,\n            width: width,\n            height: height\n        };\n    } else {\n        offset = $edcf132a9284368a$var$getOffset(node);\n        let parentOffset = $edcf132a9284368a$var$getOffset(parent);\n        let parentStyle = window.getComputedStyle(parent);\n        parentOffset.top += (parseInt(parentStyle.borderTopWidth, 10) || 0) - parent.scrollTop;\n        parentOffset.left += (parseInt(parentStyle.borderLeftWidth, 10) || 0) - parent.scrollLeft;\n        offset.top -= parentOffset.top;\n        offset.left -= parentOffset.left;\n    }\n    offset.top -= parseInt(style.marginTop, 10) || 0;\n    offset.left -= parseInt(style.marginLeft, 10) || 0;\n    return offset;\n}\n\n\n\n\nconst $dd149f63282afbbf$export$f6211563215e3b37 = new WeakMap();\nfunction $dd149f63282afbbf$export$18fc8428861184da(opts) {\n    let { triggerRef: triggerRef , isOpen: isOpen , onClose: onClose  } = opts;\n    $k7QOs$useEffect(()=>{\n        if (!isOpen) return;\n        let onScroll = (e)=>{\n            // Ignore if scrolling an scrollable region outside the trigger's tree.\n            let target = e.target;\n            // window is not a Node and doesn't have contain, but window contains everything\n            if (!triggerRef.current || target instanceof Node && !target.contains(triggerRef.current)) return;\n            let onCloseHandler = onClose || $dd149f63282afbbf$export$f6211563215e3b37.get(triggerRef.current);\n            if (onCloseHandler) onCloseHandler();\n        };\n        window.addEventListener('scroll', onScroll, true);\n        return ()=>{\n            window.removeEventListener('scroll', onScroll, true);\n        };\n    }, [\n        isOpen,\n        onClose,\n        triggerRef\n    ]);\n}\n\n\n\n\n// @ts-ignore\nlet $2a41e45df1593e64$var$visualViewport = typeof window !== 'undefined' && window.visualViewport;\nfunction $2a41e45df1593e64$export$d39e1813b3bdd0e1(props) {\n    let { direction: direction  } = $k7QOs$useLocale();\n    let { targetRef: targetRef , overlayRef: overlayRef , scrollRef: scrollRef = overlayRef , placement: placement = 'bottom' , containerPadding: containerPadding = 12 , shouldFlip: shouldFlip = true , boundaryElement: boundaryElement = typeof document !== 'undefined' ? document.body : null , offset: offset = 0 , crossOffset: crossOffset = 0 , shouldUpdatePosition: shouldUpdatePosition = true , isOpen: isOpen = true , onClose: onClose , maxHeight: maxHeight  } = props;\n    let [position, setPosition] = $k7QOs$useState({\n        position: {\n        },\n        arrowOffsetLeft: undefined,\n        arrowOffsetTop: undefined,\n        maxHeight: undefined,\n        placement: undefined\n    });\n    let deps = [\n        shouldUpdatePosition,\n        placement,\n        overlayRef.current,\n        targetRef.current,\n        scrollRef.current,\n        containerPadding,\n        shouldFlip,\n        boundaryElement,\n        offset,\n        crossOffset,\n        isOpen,\n        direction,\n        maxHeight\n    ];\n    let updatePosition = $k7QOs$useCallback(()=>{\n        if (shouldUpdatePosition === false || !isOpen || !overlayRef.current || !targetRef.current || !scrollRef.current || !boundaryElement) return;\n        setPosition($edcf132a9284368a$export$b3ceb0cbf1056d98({\n            placement: $2a41e45df1593e64$var$translateRTL(placement, direction),\n            overlayNode: overlayRef.current,\n            targetNode: targetRef.current,\n            scrollNode: scrollRef.current,\n            padding: containerPadding,\n            shouldFlip: shouldFlip,\n            boundaryElement: boundaryElement,\n            offset: offset,\n            crossOffset: crossOffset,\n            maxHeight: maxHeight\n        }));\n    }, deps);\n    // Update position when anything changes\n    $k7QOs$useLayoutEffect(updatePosition, deps);\n    // Update position on window resize\n    $2a41e45df1593e64$var$useResize(updatePosition);\n    // Reposition the overlay and do not close on scroll while the visual viewport is resizing.\n    // This will ensure that overlays adjust their positioning when the iOS virtual keyboard appears.\n    let isResizing = $k7QOs$useRef(false);\n    $k7QOs$useLayoutEffect(()=>{\n        let timeout;\n        let onResize = ()=>{\n            isResizing.current = true;\n            clearTimeout(timeout);\n            timeout = setTimeout(()=>{\n                isResizing.current = false;\n            }, 500);\n            updatePosition();\n        };\n        $2a41e45df1593e64$var$visualViewport === null || $2a41e45df1593e64$var$visualViewport === void 0 ? void 0 : $2a41e45df1593e64$var$visualViewport.addEventListener('resize', onResize);\n        return ()=>{\n            $2a41e45df1593e64$var$visualViewport === null || $2a41e45df1593e64$var$visualViewport === void 0 ? void 0 : $2a41e45df1593e64$var$visualViewport.removeEventListener('resize', onResize);\n        };\n    }, [\n        updatePosition\n    ]);\n    let close = $k7QOs$useCallback(()=>{\n        if (!isResizing.current) onClose();\n    }, [\n        onClose,\n        isResizing\n    ]);\n    // When scrolling a parent scrollable region of the trigger (other than the body),\n    // we hide the popover. Otherwise, its position would be incorrect.\n    $dd149f63282afbbf$export$18fc8428861184da({\n        triggerRef: targetRef,\n        isOpen: isOpen,\n        onClose: onClose ? close : undefined\n    });\n    return {\n        overlayProps: {\n            style: {\n                position: 'absolute',\n                zIndex: 100000,\n                ...position.position,\n                maxHeight: position.maxHeight\n            }\n        },\n        placement: position.placement,\n        arrowProps: {\n            style: {\n                left: position.arrowOffsetLeft,\n                top: position.arrowOffsetTop\n            }\n        },\n        updatePosition: updatePosition\n    };\n}\nfunction $2a41e45df1593e64$var$useResize(onResize) {\n    $k7QOs$useLayoutEffect(()=>{\n        window.addEventListener('resize', onResize, false);\n        return ()=>{\n            window.removeEventListener('resize', onResize, false);\n        };\n    }, [\n        onResize\n    ]);\n}\nfunction $2a41e45df1593e64$var$translateRTL(position, direction) {\n    if (direction === 'rtl') return position.replace('start', 'right').replace('end', 'left');\n    return position.replace('start', 'left').replace('end', 'right');\n}\n\n\n\n\nconst $a11501f3d1d39e6c$var$visibleOverlays = [];\nfunction $a11501f3d1d39e6c$export$ea8f71083e90600f(props, ref) {\n    let { onClose: onClose , shouldCloseOnBlur: shouldCloseOnBlur , isOpen: isOpen , isDismissable: isDismissable = false , isKeyboardDismissDisabled: isKeyboardDismissDisabled = false , shouldCloseOnInteractOutside: shouldCloseOnInteractOutside  } = props;\n    // Add the overlay ref to the stack of visible overlays on mount, and remove on unmount.\n    $k7QOs$useEffect(()=>{\n        if (isOpen) $a11501f3d1d39e6c$var$visibleOverlays.push(ref);\n        return ()=>{\n            let index = $a11501f3d1d39e6c$var$visibleOverlays.indexOf(ref);\n            if (index >= 0) $a11501f3d1d39e6c$var$visibleOverlays.splice(index, 1);\n        };\n    }, [\n        isOpen,\n        ref\n    ]);\n    // Only hide the overlay when it is the topmost visible overlay in the stack.\n    let onHide = ()=>{\n        if ($a11501f3d1d39e6c$var$visibleOverlays[$a11501f3d1d39e6c$var$visibleOverlays.length - 1] === ref && onClose) onClose();\n    };\n    let onInteractOutsideStart = (e)=>{\n        if (!shouldCloseOnInteractOutside || shouldCloseOnInteractOutside(e.target)) {\n            if ($a11501f3d1d39e6c$var$visibleOverlays[$a11501f3d1d39e6c$var$visibleOverlays.length - 1] === ref) {\n                e.stopPropagation();\n                e.preventDefault();\n            }\n        }\n    };\n    let onInteractOutside = (e)=>{\n        if (!shouldCloseOnInteractOutside || shouldCloseOnInteractOutside(e.target)) {\n            if ($a11501f3d1d39e6c$var$visibleOverlays[$a11501f3d1d39e6c$var$visibleOverlays.length - 1] === ref) {\n                e.stopPropagation();\n                e.preventDefault();\n            }\n            onHide();\n        }\n    };\n    // Handle the escape key\n    let onKeyDown = (e)=>{\n        if (e.key === 'Escape' && !isKeyboardDismissDisabled) {\n            e.stopPropagation();\n            e.preventDefault();\n            onHide();\n        }\n    };\n    // Handle clicking outside the overlay to close it\n    $k7QOs$useInteractOutside({\n        ref: ref,\n        onInteractOutside: isDismissable ? onInteractOutside : null,\n        onInteractOutsideStart: onInteractOutsideStart\n    });\n    let { focusWithinProps: focusWithinProps  } = $k7QOs$useFocusWithin({\n        isDisabled: !shouldCloseOnBlur,\n        onBlurWithin: (e)=>{\n            if (!shouldCloseOnInteractOutside || shouldCloseOnInteractOutside(e.relatedTarget)) onClose();\n        }\n    });\n    let onPointerDownUnderlay = (e)=>{\n        // fixes a firefox issue that starts text selection https://bugzilla.mozilla.org/show_bug.cgi?id=1675846\n        if (e.target === e.currentTarget) e.preventDefault();\n    };\n    return {\n        overlayProps: {\n            onKeyDown: onKeyDown,\n            ...focusWithinProps\n        },\n        underlayProps: {\n            onPointerDown: onPointerDownUnderlay\n        }\n    };\n}\n\n\n\n\n\nfunction $628037886ba31236$export$f9d5c8beee7d008d(props, state, ref) {\n    let { type: type  } = props;\n    let { isOpen: isOpen  } = state;\n    // Backward compatibility. Share state close function with useOverlayPosition so it can close on scroll\n    // without forcing users to pass onClose.\n    $k7QOs$useEffect(()=>{\n        if (ref && ref.current) $dd149f63282afbbf$export$f6211563215e3b37.set(ref.current, state.close);\n    });\n    // Aria 1.1 supports multiple values for aria-haspopup other than just menus.\n    // https://www.w3.org/TR/wai-aria-1.1/#aria-haspopup\n    // However, we only add it for menus for now because screen readers often\n    // announce it as a menu even for other values.\n    let ariaHasPopup = undefined;\n    if (type === 'menu') ariaHasPopup = true;\n    else if (type === 'listbox') ariaHasPopup = 'listbox';\n    let overlayId = $k7QOs$useId();\n    return {\n        triggerProps: {\n            'aria-haspopup': ariaHasPopup,\n            'aria-expanded': isOpen,\n            'aria-controls': isOpen ? overlayId : null,\n            onPress: state.toggle\n        },\n        overlayProps: {\n            id: overlayId\n        }\n    };\n}\n\n\n\n// @ts-ignore\nconst $49c51c25361d4cd2$var$visualViewport = typeof window !== 'undefined' && window.visualViewport;\n// HTML input types that do not cause the software keyboard to appear.\nconst $49c51c25361d4cd2$var$nonTextInputTypes = new Set([\n    'checkbox',\n    'radio',\n    'range',\n    'color',\n    'file',\n    'image',\n    'button',\n    'submit',\n    'reset'\n]);\nfunction $49c51c25361d4cd2$export$ee0f7cc6afcd1c18(options = {\n}) {\n    let { isDisabled: isDisabled  } = options;\n    $k7QOs$useLayoutEffect(()=>{\n        if (isDisabled) return;\n        if ($k7QOs$isIOS()) return $49c51c25361d4cd2$var$preventScrollMobileSafari();\n        else return $49c51c25361d4cd2$var$preventScrollStandard();\n    }, [\n        isDisabled\n    ]);\n}\n// For most browsers, all we need to do is set `overflow: hidden` on the root element, and\n// add some padding to prevent the page from shifting when the scrollbar is hidden.\nfunction $49c51c25361d4cd2$var$preventScrollStandard() {\n    return $k7QOs$chain($49c51c25361d4cd2$var$setStyle(document.documentElement, 'paddingRight', `${window.innerWidth - document.documentElement.clientWidth}px`), $49c51c25361d4cd2$var$setStyle(document.documentElement, 'overflow', 'hidden'));\n}\n// Mobile Safari is a whole different beast. Even with overflow: hidden,\n// it still scrolls the page in many situations:\n//\n// 1. When the bottom toolbar and address bar are collapsed, page scrolling is always allowed.\n// 2. When the keyboard is visible, the viewport does not resize. Instead, the keyboard covers part of\n//    it, so it becomes scrollable.\n// 3. When tapping on an input, the page always scrolls so that the input is centered in the visual viewport.\n//    This may cause even fixed position elements to scroll off the screen.\n// 4. When using the next/previous buttons in the keyboard to navigate between inputs, the whole page always\n//    scrolls, even if the input is inside a nested scrollable element that could be scrolled instead.\n//\n// In order to work around these cases, and prevent scrolling without jankiness, we do a few things:\n//\n// 1. Prevent default on `touchmove` events that are not in a scrollable element. This prevents touch scrolling\n//    on the window.\n// 2. Prevent default on `touchmove` events inside a scrollable element when the scroll position is at the\n//    top or bottom. This avoids the whole page scrolling instead, but does prevent overscrolling.\n// 3. Prevent default on `touchend` events on input elements and handle focusing the element ourselves.\n// 4. When focusing an input, apply a transform to trick Safari into thinking the input is at the top\n//    of the page, which prevents it from scrolling the page. After the input is focused, scroll the element\n//    into view ourselves, without scrolling the whole page.\n// 5. Offset the body by the scroll position using a negative margin and scroll to the top. This should appear the\n//    same visually, but makes the actual scroll position always zero. This is required to make all of the\n//    above work or Safari will still try to scroll the page when focusing an input.\n// 6. As a last resort, handle window scroll events, and scroll back to the top. This can happen when attempting\n//    to navigate to an input with the next/previous buttons that's outside a modal.\nfunction $49c51c25361d4cd2$var$preventScrollMobileSafari() {\n    let scrollable;\n    let lastY = 0;\n    let onTouchStart = (e)=>{\n        // Store the nearest scrollable parent element from the element that the user touched.\n        scrollable = $k7QOs$getScrollParent(e.target);\n        if (scrollable === document.documentElement && scrollable === document.body) return;\n        lastY = e.changedTouches[0].pageY;\n    };\n    let onTouchMove = (e)=>{\n        // Prevent scrolling the window.\n        if (scrollable === document.documentElement || scrollable === document.body) {\n            e.preventDefault();\n            return;\n        }\n        // Prevent scrolling up when at the top and scrolling down when at the bottom\n        // of a nested scrollable area, otherwise mobile Safari will start scrolling\n        // the window instead. Unfortunately, this disables bounce scrolling when at\n        // the top but it's the best we can do.\n        let y = e.changedTouches[0].pageY;\n        let scrollTop = scrollable.scrollTop;\n        let bottom = scrollable.scrollHeight - scrollable.clientHeight;\n        if (scrollTop <= 0 && y > lastY || scrollTop >= bottom && y < lastY) e.preventDefault();\n        lastY = y;\n    };\n    let onTouchEnd = (e)=>{\n        let target = e.target;\n        // Apply this change if we're not already focused on the target element\n        if ($49c51c25361d4cd2$var$willOpenKeyboard(target) && target !== document.activeElement) {\n            e.preventDefault();\n            // Apply a transform to trick Safari into thinking the input is at the top of the page\n            // so it doesn't try to scroll it into view. When tapping on an input, this needs to\n            // be done before the \"focus\" event, so we have to focus the element ourselves.\n            target.style.transform = 'translateY(-2000px)';\n            target.focus();\n            requestAnimationFrame(()=>{\n                target.style.transform = '';\n            });\n        }\n    };\n    let onFocus = (e)=>{\n        let target = e.target;\n        if ($49c51c25361d4cd2$var$willOpenKeyboard(target)) {\n            // Transform also needs to be applied in the focus event in cases where focus moves\n            // other than tapping on an input directly, e.g. the next/previous buttons in the\n            // software keyboard. In these cases, it seems applying the transform in the focus event\n            // is good enough, whereas when tapping an input, it must be done before the focus event. \n            target.style.transform = 'translateY(-2000px)';\n            requestAnimationFrame(()=>{\n                target.style.transform = '';\n                // This will have prevented the browser from scrolling the focused element into view,\n                // so we need to do this ourselves in a way that doesn't cause the whole page to scroll.\n                if ($49c51c25361d4cd2$var$visualViewport) {\n                    if ($49c51c25361d4cd2$var$visualViewport.height < window.innerHeight) // If the keyboard is already visible, do this after one additional frame\n                    // to wait for the transform to be removed.\n                    requestAnimationFrame(()=>{\n                        $49c51c25361d4cd2$var$scrollIntoView(target);\n                    });\n                    else // Otherwise, wait for the visual viewport to resize before scrolling so we can\n                    // measure the correct position to scroll to.\n                    $49c51c25361d4cd2$var$visualViewport.addEventListener('resize', ()=>$49c51c25361d4cd2$var$scrollIntoView(target)\n                    , {\n                        once: true\n                    });\n                }\n            });\n        }\n    };\n    let onWindowScroll = ()=>{\n        // Last resort. If the window scrolled, scroll it back to the top.\n        // It should always be at the top because the body will have a negative margin (see below).\n        window.scrollTo(0, 0);\n    };\n    // Record the original scroll position so we can restore it.\n    // Then apply a negative margin to the body to offset it by the scroll position. This will\n    // enable us to scroll the window to the top, which is required for the rest of this to work.\n    let scrollX = window.pageXOffset;\n    let scrollY = window.pageYOffset;\n    let restoreStyles = $k7QOs$chain($49c51c25361d4cd2$var$setStyle(document.documentElement, 'paddingRight', `${window.innerWidth - document.documentElement.clientWidth}px`), $49c51c25361d4cd2$var$setStyle(document.documentElement, 'overflow', 'hidden'), $49c51c25361d4cd2$var$setStyle(document.body, 'marginTop', `-${scrollY}px`));\n    // Scroll to the top. The negative margin on the body will make this appear the same.\n    window.scrollTo(0, 0);\n    let removeEvents = $k7QOs$chain($49c51c25361d4cd2$var$addEvent(document, 'touchstart', onTouchStart, {\n        passive: false,\n        capture: true\n    }), $49c51c25361d4cd2$var$addEvent(document, 'touchmove', onTouchMove, {\n        passive: false,\n        capture: true\n    }), $49c51c25361d4cd2$var$addEvent(document, 'touchend', onTouchEnd, {\n        passive: false,\n        capture: true\n    }), $49c51c25361d4cd2$var$addEvent(document, 'focus', onFocus, true), $49c51c25361d4cd2$var$addEvent(window, 'scroll', onWindowScroll));\n    return ()=>{\n        // Restore styles and scroll the page back to where it was.\n        restoreStyles();\n        removeEvents();\n        window.scrollTo(scrollX, scrollY);\n    };\n}\n// Sets a CSS property on an element, and returns a function to revert it to the previous value.\nfunction $49c51c25361d4cd2$var$setStyle(element, style, value) {\n    let cur = element.style[style];\n    element.style[style] = value;\n    return ()=>{\n        element.style[style] = cur;\n    };\n}\n// Adds an event listener to an element, and returns a function to remove it.\nfunction $49c51c25361d4cd2$var$addEvent(target, event, handler, options) {\n    target.addEventListener(event, handler, options);\n    return ()=>{\n        target.removeEventListener(event, handler, options);\n    };\n}\nfunction $49c51c25361d4cd2$var$scrollIntoView(target) {\n    let root = document.scrollingElement || document.documentElement;\n    while(target && target !== root){\n        // Find the parent scrollable element and adjust the scroll position if the target is not already in view.\n        let scrollable = $k7QOs$getScrollParent(target);\n        if (scrollable !== document.documentElement && scrollable !== document.body && scrollable !== target) {\n            let scrollableTop = scrollable.getBoundingClientRect().top;\n            let targetTop = target.getBoundingClientRect().top;\n            if (targetTop > scrollableTop + target.clientHeight) scrollable.scrollTop += targetTop - scrollableTop;\n        }\n        target = scrollable.parentElement;\n    }\n}\nfunction $49c51c25361d4cd2$var$willOpenKeyboard(target) {\n    return target instanceof HTMLInputElement && !$49c51c25361d4cd2$var$nonTextInputTypes.has(target.type) || target instanceof HTMLTextAreaElement || target instanceof HTMLElement && target.isContentEditable;\n}\n\n\n\n\n\nconst $f57aed4a881a3485$var$Context = /*#__PURE__*/ $k7QOs$react.createContext(null);\nfunction $f57aed4a881a3485$export$178405afcd8c5eb(props) {\n    let { children: children  } = props;\n    let parent = $k7QOs$useContext($f57aed4a881a3485$var$Context);\n    let [modalCount, setModalCount] = $k7QOs$useState(0);\n    let context = $k7QOs$useMemo(()=>({\n            parent: parent,\n            modalCount: modalCount,\n            addModal () {\n                setModalCount((count)=>count + 1\n                );\n                if (parent) parent.addModal();\n            },\n            removeModal () {\n                setModalCount((count)=>count - 1\n                );\n                if (parent) parent.removeModal();\n            }\n        })\n    , [\n        parent,\n        modalCount\n    ]);\n    return(/*#__PURE__*/ $k7QOs$react.createElement($f57aed4a881a3485$var$Context.Provider, {\n        value: context\n    }, children));\n}\nfunction $f57aed4a881a3485$export$d9aaed4c3ece1bc0() {\n    let context = $k7QOs$useContext($f57aed4a881a3485$var$Context);\n    return {\n        modalProviderProps: {\n            'aria-hidden': context && context.modalCount > 0 ? true : null\n        }\n    };\n}\n/**\n * Creates a root node that will be aria-hidden if there are other modals open.\n */ function $f57aed4a881a3485$var$OverlayContainerDOM(props) {\n    let { modalProviderProps: modalProviderProps  } = $f57aed4a881a3485$export$d9aaed4c3ece1bc0();\n    return(/*#__PURE__*/ $k7QOs$react.createElement(\"div\", {\n        \"data-overlay-container\": true,\n        ...props,\n        ...modalProviderProps\n    }));\n}\nfunction $f57aed4a881a3485$export$bf688221f59024e5(props) {\n    return(/*#__PURE__*/ $k7QOs$react.createElement($f57aed4a881a3485$export$178405afcd8c5eb, null, /*#__PURE__*/ $k7QOs$react.createElement($f57aed4a881a3485$var$OverlayContainerDOM, props)));\n}\nfunction $f57aed4a881a3485$export$b47c3594eab58386(props) {\n    let isSSR = $k7QOs$useIsSSR();\n    let { portalContainer: portalContainer = isSSR ? null : document.body , ...rest } = props;\n    $k7QOs$react.useEffect(()=>{\n        if (portalContainer === null || portalContainer === void 0 ? void 0 : portalContainer.closest('[data-overlay-container]')) throw new Error('An OverlayContainer must not be inside another container. Please change the portalContainer prop.');\n    }, [\n        portalContainer\n    ]);\n    if (!portalContainer) return null;\n    let contents = /*#__PURE__*/ $k7QOs$react.createElement($f57aed4a881a3485$export$bf688221f59024e5, rest);\n    return(/*#__PURE__*/ $k7QOs$reactdom.createPortal(contents, portalContainer));\n}\nfunction $f57aed4a881a3485$export$33ffd74ebf07f060(options) {\n    // Add aria-hidden to all parent providers on mount, and restore on unmount.\n    let context = $k7QOs$useContext($f57aed4a881a3485$var$Context);\n    if (!context) throw new Error('Modal is not contained within a provider');\n    $k7QOs$useEffect(()=>{\n        if ((options === null || options === void 0 ? void 0 : options.isDisabled) || !context || !context.parent) return;\n        // The immediate context is from the provider containing this modal, so we only\n        // want to trigger aria-hidden on its parents not on the modal provider itself.\n        context.parent.addModal();\n        return ()=>{\n            if (context && context.parent) context.parent.removeModal();\n        };\n    }, [\n        context,\n        context.parent,\n        options === null || options === void 0 ? void 0 : options.isDisabled\n    ]);\n    return {\n        modalProps: {\n            'data-ismodal': !(options === null || options === void 0 ? void 0 : options.isDisabled)\n        }\n    };\n}\n\n\nvar $61fe14465afefc5e$exports = {};\nvar $773d5888b972f1cf$exports = {};\n$773d5888b972f1cf$exports = {\n    \"dismiss\": ``\n};\n\n\nvar $d11f19852b941573$exports = {};\n$d11f19852b941573$exports = {\n    \"dismiss\": ``\n};\n\n\nvar $b983974c2ee1efb3$exports = {};\n$b983974c2ee1efb3$exports = {\n    \"dismiss\": `Odstranit`\n};\n\n\nvar $5809cc9d4e92de73$exports = {};\n$5809cc9d4e92de73$exports = {\n    \"dismiss\": `Luk`\n};\n\n\nvar $c68c2e4fc74398d1$exports = {};\n$c68c2e4fc74398d1$exports = {\n    \"dismiss\": `Schlieen`\n};\n\n\nvar $0898b4c153db2b77$exports = {};\n$0898b4c153db2b77$exports = {\n    \"dismiss\": ``\n};\n\n\nvar $6d74810286a15183$exports = {};\n$6d74810286a15183$exports = {\n    \"dismiss\": `Dismiss`\n};\n\n\nvar $309d73dc65f78055$exports = {};\n$309d73dc65f78055$exports = {\n    \"dismiss\": `Descartar`\n};\n\n\nvar $44ad94f7205cf593$exports = {};\n$44ad94f7205cf593$exports = {\n    \"dismiss\": `Lpeta`\n};\n\n\nvar $7c28f5687f0779a9$exports = {};\n$7c28f5687f0779a9$exports = {\n    \"dismiss\": `Hylk`\n};\n\n\nvar $e6d75df4b68bd73a$exports = {};\n$e6d75df4b68bd73a$exports = {\n    \"dismiss\": `Rejeter`\n};\n\n\nvar $87505c9dab186d0f$exports = {};\n$87505c9dab186d0f$exports = {\n    \"dismiss\": ``\n};\n\n\nvar $553439c3ffb3e492$exports = {};\n$553439c3ffb3e492$exports = {\n    \"dismiss\": `Odbaci`\n};\n\n\nvar $74cf411061b983a2$exports = {};\n$74cf411061b983a2$exports = {\n    \"dismiss\": `Elutasts`\n};\n\n\nvar $e933f298574dc435$exports = {};\n$e933f298574dc435$exports = {\n    \"dismiss\": `Ignora`\n};\n\n\nvar $ac91fc9fe02f71f6$exports = {};\n$ac91fc9fe02f71f6$exports = {\n    \"dismiss\": ``\n};\n\n\nvar $52b96f86422025af$exports = {};\n$52b96f86422025af$exports = {\n    \"dismiss\": ``\n};\n\n\nvar $c0d724c3e51dafa6$exports = {};\n$c0d724c3e51dafa6$exports = {\n    \"dismiss\": `Atmesti`\n};\n\n\nvar $c92899672a3fe72e$exports = {};\n$c92899672a3fe72e$exports = {\n    \"dismiss\": `Nerdt`\n};\n\n\nvar $9f576b39d8e7a9d6$exports = {};\n$9f576b39d8e7a9d6$exports = {\n    \"dismiss\": `Lukk`\n};\n\n\nvar $9d025808aeec81a7$exports = {};\n$9d025808aeec81a7$exports = {\n    \"dismiss\": `Negeren`\n};\n\n\nvar $fce709921e2c0fa6$exports = {};\n$fce709921e2c0fa6$exports = {\n    \"dismiss\": `Zignoruj`\n};\n\n\nvar $2599cf0c4ab37f59$exports = {};\n$2599cf0c4ab37f59$exports = {\n    \"dismiss\": `Descartar`\n};\n\n\nvar $3c220ae7ef8a35fd$exports = {};\n$3c220ae7ef8a35fd$exports = {\n    \"dismiss\": `Dispensar`\n};\n\n\nvar $93562b5094072f54$exports = {};\n$93562b5094072f54$exports = {\n    \"dismiss\": `Revocare`\n};\n\n\nvar $cd9e2abd0d06c7b4$exports = {};\n$cd9e2abd0d06c7b4$exports = {\n    \"dismiss\": ``\n};\n\n\nvar $45375701f409adf1$exports = {};\n$45375701f409adf1$exports = {\n    \"dismiss\": `Zrui`\n};\n\n\nvar $27fab53a576de9dd$exports = {};\n$27fab53a576de9dd$exports = {\n    \"dismiss\": `Opusti`\n};\n\n\nvar $4438748d9952e7c7$exports = {};\n$4438748d9952e7c7$exports = {\n    \"dismiss\": `Odbaci`\n};\n\n\nvar $0936d7347ef4da4c$exports = {};\n$0936d7347ef4da4c$exports = {\n    \"dismiss\": `Avvisa`\n};\n\n\nvar $29700c92185d38f8$exports = {};\n$29700c92185d38f8$exports = {\n    \"dismiss\": `Kapat`\n};\n\n\nvar $662ccaf2be4c25b3$exports = {};\n$662ccaf2be4c25b3$exports = {\n    \"dismiss\": ``\n};\n\n\nvar $d80a27deda7cdb3c$exports = {};\n$d80a27deda7cdb3c$exports = {\n    \"dismiss\": ``\n};\n\n\nvar $2b2734393847c884$exports = {};\n$2b2734393847c884$exports = {\n    \"dismiss\": ``\n};\n\n\n$61fe14465afefc5e$exports = {\n    \"ar-AE\": $773d5888b972f1cf$exports,\n    \"bg-BG\": $d11f19852b941573$exports,\n    \"cs-CZ\": $b983974c2ee1efb3$exports,\n    \"da-DK\": $5809cc9d4e92de73$exports,\n    \"de-DE\": $c68c2e4fc74398d1$exports,\n    \"el-GR\": $0898b4c153db2b77$exports,\n    \"en-US\": $6d74810286a15183$exports,\n    \"es-ES\": $309d73dc65f78055$exports,\n    \"et-EE\": $44ad94f7205cf593$exports,\n    \"fi-FI\": $7c28f5687f0779a9$exports,\n    \"fr-FR\": $e6d75df4b68bd73a$exports,\n    \"he-IL\": $87505c9dab186d0f$exports,\n    \"hr-HR\": $553439c3ffb3e492$exports,\n    \"hu-HU\": $74cf411061b983a2$exports,\n    \"it-IT\": $e933f298574dc435$exports,\n    \"ja-JP\": $ac91fc9fe02f71f6$exports,\n    \"ko-KR\": $52b96f86422025af$exports,\n    \"lt-LT\": $c0d724c3e51dafa6$exports,\n    \"lv-LV\": $c92899672a3fe72e$exports,\n    \"nb-NO\": $9f576b39d8e7a9d6$exports,\n    \"nl-NL\": $9d025808aeec81a7$exports,\n    \"pl-PL\": $fce709921e2c0fa6$exports,\n    \"pt-BR\": $2599cf0c4ab37f59$exports,\n    \"pt-PT\": $3c220ae7ef8a35fd$exports,\n    \"ro-RO\": $93562b5094072f54$exports,\n    \"ru-RU\": $cd9e2abd0d06c7b4$exports,\n    \"sk-SK\": $45375701f409adf1$exports,\n    \"sl-SI\": $27fab53a576de9dd$exports,\n    \"sr-SP\": $4438748d9952e7c7$exports,\n    \"sv-SE\": $0936d7347ef4da4c$exports,\n    \"tr-TR\": $29700c92185d38f8$exports,\n    \"uk-UA\": $662ccaf2be4c25b3$exports,\n    \"zh-CN\": $d80a27deda7cdb3c$exports,\n    \"zh-TW\": $2b2734393847c884$exports\n};\n\n\n\n\n\n\nfunction $86ea4cb521eb2e37$export$2317d149ed6f78c4(props) {\n    let { onDismiss: onDismiss , ...otherProps } = props;\n    let stringFormatter = $k7QOs$useLocalizedStringFormatter((/*@__PURE__*/$parcel$interopDefault($61fe14465afefc5e$exports)));\n    let labels = $k7QOs$useLabels(otherProps, stringFormatter.format('dismiss'));\n    let onClick = ()=>{\n        if (onDismiss) onDismiss();\n    };\n    return(/*#__PURE__*/ $k7QOs$react.createElement($k7QOs$VisuallyHidden, null, /*#__PURE__*/ $k7QOs$react.createElement(\"button\", {\n        ...labels,\n        tabIndex: -1,\n        onClick: onClick\n    })));\n}\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ // Keeps a ref count of all hidden elements. Added to when hiding an element, and\n// subtracted from when showing it again. When it reaches zero, aria-hidden is removed.\nlet $5e3802645cc19319$var$refCountMap = new WeakMap();\nfunction $5e3802645cc19319$export$1c3ebcada18427bf(targets, root = document.body) {\n    let visibleNodes = new Set(targets);\n    let hiddenNodes = new Set();\n    let walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, {\n        acceptNode (node) {\n            // If this node is a live announcer, add it to the set of nodes to keep visible.\n            if ((node instanceof HTMLElement || node instanceof SVGElement) && node.dataset.liveAnnouncer === 'true') visibleNodes.add(node);\n            // Skip this node and its children if it is one of the target nodes, or a live announcer.\n            // Also skip children of already hidden nodes, as aria-hidden is recursive. An exception is\n            // made for elements with role=\"row\" since VoiceOver on iOS has issues hiding elements with role=\"row\".\n            // For that case we want to hide the cells inside as well (https://bugs.webkit.org/show_bug.cgi?id=222623).\n            if (visibleNodes.has(node) || hiddenNodes.has(node.parentElement) && node.parentElement.getAttribute('role') !== 'row') return NodeFilter.FILTER_REJECT;\n            // Skip this node but continue to children if one of the targets is inside the node.\n            if (targets.some((target)=>node.contains(target)\n            )) return NodeFilter.FILTER_SKIP;\n            return NodeFilter.FILTER_ACCEPT;\n        }\n    });\n    let hide = (node)=>{\n        var ref;\n        let refCount = (ref = $5e3802645cc19319$var$refCountMap.get(node)) !== null && ref !== void 0 ? ref : 0;\n        // If already aria-hidden, and the ref count is zero, then this element\n        // was already hidden and there's nothing for us to do.\n        if (node.getAttribute('aria-hidden') === 'true' && refCount === 0) return;\n        if (refCount === 0) node.setAttribute('aria-hidden', 'true');\n        hiddenNodes.add(node);\n        $5e3802645cc19319$var$refCountMap.set(node, refCount + 1);\n    };\n    let node1 = walker.nextNode();\n    while(node1 != null){\n        hide(node1);\n        node1 = walker.nextNode();\n    }\n    let observer = new MutationObserver((changes)=>{\n        for (let change of changes){\n            if (change.type !== 'childList' || change.addedNodes.length === 0) continue;\n            // If the parent element of the added nodes is not within one of the targets,\n            // and not already inside a hidden node, hide all of the new children.\n            if (![\n                ...visibleNodes,\n                ...hiddenNodes\n            ].some((node)=>node.contains(change.target)\n            )) for (let node2 of change.addedNodes){\n                if ((node2 instanceof HTMLElement || node2 instanceof SVGElement) && node2.dataset.liveAnnouncer === 'true') visibleNodes.add(node2);\n                else if (node2 instanceof Element) hide(node2);\n            }\n        }\n    });\n    observer.observe(root, {\n        childList: true,\n        subtree: true\n    });\n    return ()=>{\n        observer.disconnect();\n        for (let node of hiddenNodes){\n            let count = $5e3802645cc19319$var$refCountMap.get(node);\n            if (count === 1) {\n                node.removeAttribute('aria-hidden');\n                $5e3802645cc19319$var$refCountMap.delete(node);\n            } else $5e3802645cc19319$var$refCountMap.set(node, count - 1);\n        }\n    };\n}\n\n\n\n\n\n\n\nfunction $f2f8a6077418541e$export$542a6fd13ac93354(props, state) {\n    let { triggerRef: triggerRef , popoverRef: popoverRef , isNonModal: isNonModal , ...otherProps } = props;\n    let { overlayProps: overlayProps  } = $a11501f3d1d39e6c$export$ea8f71083e90600f({\n        isOpen: state.isOpen,\n        onClose: state.close,\n        shouldCloseOnBlur: true,\n        isDismissable: true\n    }, popoverRef);\n    let { overlayProps: positionProps , arrowProps: arrowProps  } = $2a41e45df1593e64$export$d39e1813b3bdd0e1({\n        ...otherProps,\n        targetRef: triggerRef,\n        overlayRef: popoverRef,\n        isOpen: state.isOpen\n    });\n    $k7QOs$useEffect(()=>{\n        if (state.isOpen && !isNonModal) return $5e3802645cc19319$export$1c3ebcada18427bf([\n            popoverRef.current\n        ]);\n    }, [\n        isNonModal,\n        state.isOpen,\n        popoverRef\n    ]);\n    return {\n        popoverProps: $k7QOs$mergeProps(overlayProps, positionProps),\n        arrowProps: arrowProps\n    };\n}\n\n\n\n\n\n\n\n\n\n\n\nconst $337b884510726a0d$var$OverlayContext = /*#__PURE__*/ $k7QOs$react.createContext(null);\nfunction $337b884510726a0d$export$c6fdb837b070b4ff(props) {\n    let isSSR = $k7QOs$useIsSSR();\n    let { portalContainer: portalContainer = isSSR ? null : document.body  } = props;\n    let [contain, setContain] = $k7QOs$useState(false);\n    if (!portalContainer) return null;\n    let contents = /*#__PURE__*/ $k7QOs$react.createElement($337b884510726a0d$var$OverlayContext.Provider, {\n        value: setContain\n    }, /*#__PURE__*/ $k7QOs$react.createElement($k7QOs$FocusScope, {\n        restoreFocus: true,\n        contain: contain\n    }, props.children));\n    return(/*#__PURE__*/ $k7QOs$reactdom.createPortal(contents, portalContainer));\n}\nfunction $337b884510726a0d$export$14c98a7594375490() {\n    let setContain = $k7QOs$useContext($337b884510726a0d$var$OverlayContext);\n    $k7QOs$useLayoutEffect(()=>{\n        setContain === null || setContain === void 0 ? void 0 : setContain(true);\n    }, [\n        setContain\n    ]);\n}\n\n\n\nfunction $8ac8429251c45e4b$export$dbc0f175b25fb0fb(props, state, ref) {\n    let { overlayProps: overlayProps , underlayProps: underlayProps  } = $a11501f3d1d39e6c$export$ea8f71083e90600f({\n        ...props,\n        isOpen: state.isOpen,\n        onClose: state.close\n    }, ref);\n    $49c51c25361d4cd2$export$ee0f7cc6afcd1c18({\n        isDisabled: !state.isOpen\n    });\n    $337b884510726a0d$export$14c98a7594375490();\n    $k7QOs$useEffect(()=>{\n        if (state.isOpen) return $5e3802645cc19319$export$1c3ebcada18427bf([\n            ref.current\n        ]);\n    }, [\n        state.isOpen,\n        ref\n    ]);\n    return {\n        modalProps: $k7QOs$mergeProps(overlayProps),\n        underlayProps: underlayProps\n    };\n}\n\n\n\n\n\nexport {$2a41e45df1593e64$export$d39e1813b3bdd0e1 as useOverlayPosition, $a11501f3d1d39e6c$export$ea8f71083e90600f as useOverlay, $628037886ba31236$export$f9d5c8beee7d008d as useOverlayTrigger, $49c51c25361d4cd2$export$ee0f7cc6afcd1c18 as usePreventScroll, $f57aed4a881a3485$export$178405afcd8c5eb as ModalProvider, $f57aed4a881a3485$export$d9aaed4c3ece1bc0 as useModalProvider, $f57aed4a881a3485$export$bf688221f59024e5 as OverlayProvider, $f57aed4a881a3485$export$b47c3594eab58386 as OverlayContainer, $f57aed4a881a3485$export$33ffd74ebf07f060 as useModal, $86ea4cb521eb2e37$export$2317d149ed6f78c4 as DismissButton, $5e3802645cc19319$export$1c3ebcada18427bf as ariaHideOutside, $f2f8a6077418541e$export$542a6fd13ac93354 as usePopover, $8ac8429251c45e4b$export$dbc0f175b25fb0fb as useModalOverlay, $337b884510726a0d$export$c6fdb837b070b4ff as Overlay, $337b884510726a0d$export$14c98a7594375490 as useOverlayFocusContain};\n//# sourceMappingURL=module.js.map\n","import { getStyleOptions } from './StyleOptionsState';\nimport { Stylesheet } from './Stylesheet';\nimport { serializeRuleEntries } from './styleToClassName';\n/**\n * Registers a font face.\n * @public\n */\nexport function fontFace(font) {\n    var stylesheet = Stylesheet.getInstance();\n    var rule = serializeRuleEntries(getStyleOptions(), font);\n    var className = stylesheet.classNameFromKey(rule);\n    if (className) {\n        return;\n    }\n    var name = stylesheet.getClassName();\n    stylesheet.insertRule(\"@font-face{\".concat(rule, \"}\"), true);\n    stylesheet.cacheClassName(name, rule, [], ['font-face', rule]);\n}\n//# sourceMappingURL=fontFace.js.map","export default function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}","/**\n * {@docCategory FocusZone}\n */\nexport var FocusZoneTabbableElements = {\n    /** Tabbing is not allowed */\n    none: 0,\n    /** All tabbing action is allowed */\n    all: 1,\n    /** Tabbing is allowed only on input elements */\n    inputOnly: 2,\n};\n/**\n * {@docCategory FocusZone}\n */\nexport var FocusZoneDirection;\n(function (FocusZoneDirection) {\n    /** Only react to up/down arrows. */\n    FocusZoneDirection[FocusZoneDirection[\"vertical\"] = 0] = \"vertical\";\n    /** Only react to left/right arrows. */\n    FocusZoneDirection[FocusZoneDirection[\"horizontal\"] = 1] = \"horizontal\";\n    /** React to all arrows. */\n    FocusZoneDirection[FocusZoneDirection[\"bidirectional\"] = 2] = \"bidirectional\";\n    /**\n     * React to all arrows. Navigate next item in DOM on right/down arrow keys and previous - left/up arrow keys.\n     * Right and Left arrow keys are swapped in RTL mode.\n     */\n    FocusZoneDirection[FocusZoneDirection[\"domOrder\"] = 3] = \"domOrder\";\n})(FocusZoneDirection || (FocusZoneDirection = {}));\n//# sourceMappingURL=FocusZone.types.js.map","import { HighContrastSelector } from './CommonStyles';\nimport { IsFocusVisibleClassName } from '@fluentui/utilities';\nimport { ZIndexes } from './zIndexes';\nexport function getFocusStyle(theme, insetOrOptions, position, highContrastStyle, borderColor, outlineColor, isFocusedOnly, borderRadius) {\n    if (typeof insetOrOptions === 'number' || !insetOrOptions) {\n        return _getFocusStyleInternal(theme, {\n            inset: insetOrOptions,\n            position: position,\n            highContrastStyle: highContrastStyle,\n            borderColor: borderColor,\n            outlineColor: outlineColor,\n            isFocusedOnly: isFocusedOnly,\n            borderRadius: borderRadius,\n        });\n    }\n    else {\n        return _getFocusStyleInternal(theme, insetOrOptions);\n    }\n}\nfunction _getFocusStyleInternal(theme, options) {\n    var _a, _b;\n    if (options === void 0) { options = {}; }\n    var borderRadius = options.borderRadius, _c = options.inset, inset = _c === void 0 ? 0 : _c, _d = options.width, width = _d === void 0 ? 1 : _d, _e = options.position, position = _e === void 0 ? 'relative' : _e, highContrastStyle = options.highContrastStyle, _f = options.borderColor, borderColor = _f === void 0 ? theme.palette.white : _f, _g = options.outlineColor, outlineColor = _g === void 0 ? theme.palette.neutralSecondary : _g, _h = options.isFocusedOnly, isFocusedOnly = _h === void 0 ? true : _h, pointerEvents = options.pointerEvents;\n    return {\n        // Clear browser-specific focus styles and use 'transparent' as placeholder for focus style.\n        outline: 'transparent',\n        // Requirement because pseudo-element is absolutely positioned.\n        position: position,\n        selectors: (_a = {\n                // Clear the focus border in Firefox.\n                // Reference: http://stackoverflow.com/a/199319/1436671\n                '::-moz-focus-inner': {\n                    border: '0',\n                }\n            },\n            // When the element that uses this mixin is in a :focus state, add a pseudo-element to\n            // create a border.\n            _a[\".\".concat(IsFocusVisibleClassName, \" &\").concat(isFocusedOnly ? ':focus' : '', \":after, :host(.\").concat(IsFocusVisibleClassName, \") &\").concat(isFocusedOnly ? ':focus' : '', \":after\")] = {\n                content: '\"\"',\n                position: 'absolute',\n                pointerEvents: pointerEvents,\n                left: inset + 1,\n                top: inset + 1,\n                bottom: inset + 1,\n                right: inset + 1,\n                border: \"\".concat(width, \"px solid \").concat(borderColor),\n                outline: \"\".concat(width, \"px solid \").concat(outlineColor),\n                zIndex: ZIndexes.FocusStyle,\n                borderRadius: borderRadius,\n                selectors: (_b = {},\n                    _b[HighContrastSelector] = highContrastStyle,\n                    _b),\n            },\n            _a),\n    };\n}\n/**\n * Generates style to clear browser specific focus styles.\n */\nexport function focusClear() {\n    return {\n        selectors: {\n            '&::-moz-focus-inner': {\n                // Clear the focus border in Firefox. Reference: http://stackoverflow.com/a/199319/1436671\n                border: 0,\n            },\n            '&': {\n                // Clear browser specific focus styles and use transparent as placeholder for focus style\n                outline: 'transparent',\n            },\n        },\n    };\n}\n/**\n * Generates a style which can be used to set a border on focus.\n *\n * @param theme - The theme object to use.\n * @param inset - The number of pixels to inset the border (default 0)\n * @param width - The border width in pixels (default 1)\n * @param color - Color of the outline (default `theme.palette.neutralSecondary`)\n * @returns The style object.\n */\nexport function getFocusOutlineStyle(theme, inset, width, color) {\n    var _a;\n    if (inset === void 0) { inset = 0; }\n    if (width === void 0) { width = 1; }\n    return {\n        selectors: (_a = {},\n            _a[\":global(\".concat(IsFocusVisibleClassName, \") &:focus\")] = {\n                outline: \"\".concat(width, \" solid \").concat(color || theme.palette.neutralSecondary),\n                outlineOffset: \"\".concat(-inset, \"px\"),\n            },\n            _a),\n    };\n}\n/**\n * Generates text input border styles on focus.\n *\n * @param borderColor - Color of the border.\n * @param borderRadius - Radius of the border.\n * @param borderType - Type of the border.\n * @param borderPosition - Position of the border relative to the input element (default to -1\n * as it's the most common border width of the input element)\n * @returns The style object.\n */\nexport var getInputFocusStyle = function (borderColor, borderRadius, borderType, borderPosition) {\n    var _a, _b, _c;\n    if (borderType === void 0) { borderType = 'border'; }\n    if (borderPosition === void 0) { borderPosition = -1; }\n    var isBorderBottom = borderType === 'borderBottom';\n    return {\n        borderColor: borderColor,\n        selectors: {\n            ':after': (_a = {\n                    pointerEvents: 'none',\n                    content: \"''\",\n                    position: 'absolute',\n                    left: isBorderBottom ? 0 : borderPosition,\n                    top: borderPosition,\n                    bottom: borderPosition,\n                    right: isBorderBottom ? 0 : borderPosition\n                },\n                _a[borderType] = \"2px solid \".concat(borderColor),\n                _a.borderRadius = borderRadius,\n                _a.width = borderType === 'borderBottom' ? '100%' : undefined,\n                _a.selectors = (_b = {},\n                    _b[HighContrastSelector] = (_c = {},\n                        _c[borderType === 'border' ? 'borderColor' : 'borderBottomColor'] = 'Highlight',\n                        _c),\n                    _b),\n                _a),\n        },\n    };\n};\n//# sourceMappingURL=getFocusStyle.js.map","import { merge } from '@fluentui/utilities';\nimport { getSemanticColors } from './utilities/makeSemanticColors';\n/**\n * Merge a partial/full theme into a full theme and returns a merged full theme.\n */\nexport function mergeThemes(theme, partialTheme) {\n    var _a, _b, _c;\n    if (partialTheme === void 0) { partialTheme = {}; }\n    var mergedTheme = merge({}, theme, partialTheme, {\n        semanticColors: getSemanticColors(partialTheme.palette, partialTheme.effects, partialTheme.semanticColors, partialTheme.isInverted === undefined ? theme.isInverted : partialTheme.isInverted),\n    });\n    if (((_a = partialTheme.palette) === null || _a === void 0 ? void 0 : _a.themePrimary) && !((_b = partialTheme.palette) === null || _b === void 0 ? void 0 : _b.accent)) {\n        mergedTheme.palette.accent = partialTheme.palette.themePrimary;\n    }\n    if (partialTheme.defaultFontStyle) {\n        for (var _i = 0, _d = Object.keys(mergedTheme.fonts); _i < _d.length; _i++) {\n            var fontStyle = _d[_i];\n            mergedTheme.fonts[fontStyle] = merge(mergedTheme.fonts[fontStyle], partialTheme.defaultFontStyle, (_c = partialTheme === null || partialTheme === void 0 ? void 0 : partialTheme.fonts) === null || _c === void 0 ? void 0 : _c[fontStyle]);\n        }\n    }\n    return mergedTheme;\n}\n//# sourceMappingURL=mergeThemes.js.map","import { spring } from '../generators/spring.js';\nimport { keyframes } from '../generators/keyframes.js';\nimport { decay } from '../generators/decay.js';\n\nvar types = { keyframes: keyframes, spring: spring, decay: decay };\nfunction detectAnimationFromOptions(config) {\n    if (Array.isArray(config.to)) {\n        return keyframes;\n    }\n    else if (types[config.type]) {\n        return types[config.type];\n    }\n    var keys = new Set(Object.keys(config));\n    if (keys.has(\"ease\") ||\n        (keys.has(\"duration\") && !keys.has(\"dampingRatio\"))) {\n        return keyframes;\n    }\n    else if (keys.has(\"dampingRatio\") ||\n        keys.has(\"stiffness\") ||\n        keys.has(\"mass\") ||\n        keys.has(\"damping\") ||\n        keys.has(\"restSpeed\") ||\n        keys.has(\"restDelta\")) {\n        return spring;\n    }\n    return keyframes;\n}\n\nexport { detectAnimationFromOptions };\n","export function warn() {\n  if (console && console.warn) {\n    var _console;\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    if (typeof args[0] === 'string') args[0] = \"react-i18next:: \".concat(args[0]);\n\n    (_console = console).warn.apply(_console, args);\n  }\n}\nvar alreadyWarned = {};\nexport function warnOnce() {\n  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    args[_key2] = arguments[_key2];\n  }\n\n  if (typeof args[0] === 'string' && alreadyWarned[args[0]]) return;\n  if (typeof args[0] === 'string') alreadyWarned[args[0]] = new Date();\n  warn.apply(void 0, args);\n}\nexport function loadNamespaces(i18n, ns, cb) {\n  i18n.loadNamespaces(ns, function () {\n    if (i18n.isInitialized) {\n      cb();\n    } else {\n      var initialized = function initialized() {\n        setTimeout(function () {\n          i18n.off('initialized', initialized);\n        }, 0);\n        cb();\n      };\n\n      i18n.on('initialized', initialized);\n    }\n  });\n}\n\nfunction oldI18nextHasLoadedNamespace(ns, i18n) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var lng = i18n.languages[0];\n  var fallbackLng = i18n.options ? i18n.options.fallbackLng : false;\n  var lastLng = i18n.languages[i18n.languages.length - 1];\n  if (lng.toLowerCase() === 'cimode') return true;\n\n  var loadNotPending = function loadNotPending(l, n) {\n    var loadState = i18n.services.backendConnector.state[\"\".concat(l, \"|\").concat(n)];\n    return loadState === -1 || loadState === 2;\n  };\n\n  if (options.bindI18n && options.bindI18n.indexOf('languageChanging') > -1 && i18n.services.backendConnector.backend && i18n.isLanguageChangingTo && !loadNotPending(i18n.isLanguageChangingTo, ns)) return false;\n  if (i18n.hasResourceBundle(lng, ns)) return true;\n  if (!i18n.services.backendConnector.backend || i18n.options.resources && !i18n.options.partialBundledLanguages) return true;\n  if (loadNotPending(lng, ns) && (!fallbackLng || loadNotPending(lastLng, ns))) return true;\n  return false;\n}\n\nexport function hasLoadedNamespace(ns, i18n) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  if (!i18n.languages || !i18n.languages.length) {\n    warnOnce('i18n.languages were undefined or empty', i18n.languages);\n    return true;\n  }\n\n  var isNewerI18next = i18n.options.ignoreJSONStructure !== undefined;\n\n  if (!isNewerI18next) {\n    return oldI18nextHasLoadedNamespace(ns, i18n, options);\n  }\n\n  return i18n.hasLoadedNamespace(ns, {\n    precheck: function precheck(i18nInstance, loadNotPending) {\n      if (options.bindI18n && options.bindI18n.indexOf('languageChanging') > -1 && i18nInstance.services.backendConnector.backend && i18nInstance.isLanguageChangingTo && !loadNotPending(i18nInstance.isLanguageChangingTo, ns)) return false;\n    }\n  });\n}\nexport function getDisplayName(Component) {\n  return Component.displayName || Component.name || (typeof Component === 'string' && Component.length > 0 ? Component : 'Unknown');\n}","import { SEQUENCE_PREFIX, RESET_HASH_PREFIX, DEBUG_RESET_CLASSES, SEQUENCE_SIZE, DEFINITION_LOOKUP_TABLE, LOOKUP_DEFINITIONS_INDEX, LOOKUP_DIR_INDEX } from './constants.esm.js';\nimport { hashSequence } from './runtime/utils/hashSequence.esm.js';\nimport { reduceToClassName } from './runtime/reduceToClassNameForSlots.esm.js';\n\n// Contains a mapping of previously resolved sequences of atomic classnames\nconst mergeClassesCachedResults = {};\nfunction mergeClasses() {\n  // arguments are parsed manually to avoid double loops as TS & Babel transforms rest via an additional loop\n  // @see https://babeljs.io/docs/en/babel-plugin-transform-parameters\n  /* eslint-disable prefer-rest-params */\n  let dir = null;\n  let resultClassName = '';\n  // Is used as a cache key to avoid object merging\n  let sequenceMatch = '';\n  const sequencesIds = new Array(arguments.length);\n  let containsResetClassName = '';\n  for (let i = 0; i < arguments.length; i++) {\n    const className = arguments[i];\n    if (typeof className === 'string' && className !== '') {\n      // All classes generated by `makeStyles()` are prefixed by a sequence hash, this allows to identify class sets\n      // without parsing each className in a string\n      const sequenceIndex = className.indexOf(SEQUENCE_PREFIX);\n      if (sequenceIndex === -1) {\n        if (process.env.NODE_ENV !== 'production') {\n          className.split(' ').forEach(entry => {\n            if (entry.startsWith(RESET_HASH_PREFIX) && DEBUG_RESET_CLASSES[entry]) {\n              if (containsResetClassName) {\n                // eslint-disable-next-line no-console\n                console.error('mergeClasses(): a passed string contains multiple classes produced by makeResetStyles (' + `${className} & ${resultClassName}, this will lead to non-deterministic behavior. Learn more:` + 'https://griffel.js.org/react/api/make-reset-styles#limitations' + '\\n' + `Source string: ${className}`);\n              } else {\n                containsResetClassName = entry;\n              }\n            }\n          });\n        }\n        resultClassName += className + ' ';\n      } else {\n        const sequenceId = className.substr(sequenceIndex, SEQUENCE_SIZE);\n        // Handles a case with mixed classnames, i.e. \"ui-button ATOMIC_CLASSES\"\n        if (sequenceIndex > 0) {\n          resultClassName += className.slice(0, sequenceIndex);\n        }\n        sequenceMatch += sequenceId;\n        sequencesIds[i] = sequenceId;\n      }\n      if (process.env.NODE_ENV !== 'production') {\n        if (className.indexOf(SEQUENCE_PREFIX, sequenceIndex + 1) !== -1) {\n          // eslint-disable-next-line no-console\n          console.error('mergeClasses(): a passed string contains multiple identifiers of atomic classes (classes that start ' + `with \"${SEQUENCE_PREFIX}\"), it's possible that passed classes were concatenated in a wrong way. ` + `Source string: ${className}`);\n        }\n      }\n    }\n  }\n  // .slice() there allows to avoid trailing space for non-atomic classes\n  // \"ui-button ui-flex \" => \"ui-button ui-flex\"\n  if (sequenceMatch === '') {\n    return resultClassName.slice(0, -1);\n  }\n  // It's safe to reuse results to avoid continuous merging as results are stable\n  // \"__seq1 ... __seq2 ...\" => \"__seq12 ...\"\n  const mergeClassesResult = mergeClassesCachedResults[sequenceMatch];\n  if (mergeClassesResult !== undefined) {\n    return resultClassName + mergeClassesResult;\n  }\n  const sequenceMappings = [];\n  for (let i = 0; i < arguments.length; i++) {\n    const sequenceId = sequencesIds[i];\n    if (sequenceId) {\n      const sequenceMapping = DEFINITION_LOOKUP_TABLE[sequenceId];\n      if (sequenceMapping) {\n        sequenceMappings.push(sequenceMapping[LOOKUP_DEFINITIONS_INDEX]);\n        if (process.env.NODE_ENV !== 'production') {\n          if (dir !== null && dir !== sequenceMapping[LOOKUP_DIR_INDEX]) {\n            // eslint-disable-next-line no-console\n            console.error(`mergeClasses(): a passed string contains an identifier (${sequenceId}) that has different direction ` + `(dir=\"${sequenceMapping[1] ? 'rtl' : 'ltr'}\") setting than other classes. This is not supported. ` + `Source string: ${arguments[i]}`);\n          }\n        }\n        dir = sequenceMapping[LOOKUP_DIR_INDEX];\n      } else {\n        if (process.env.NODE_ENV !== 'production') {\n          // eslint-disable-next-line no-console\n          console.error(`mergeClasses(): a passed string contains an identifier (${sequenceId}) that does not match any entry ` + `in cache. Source string: ${arguments[i]}`);\n        }\n      }\n    }\n  }\n  // eslint-disable-next-line prefer-spread\n  const resultClassesMap = Object.assign.apply(Object,\n  // .assign() mutates the first object, we can't mutate mappings as it will produce invalid results later\n  [{}].concat(sequenceMappings));\n  const [atomicClasses, classesMapHash] = reduceToClassName(resultClassesMap, dir);\n  // Each merge of classes generates a new sequence of atomic classes that needs to be registered\n  const newSequenceHash = hashSequence(classesMapHash, dir, sequencesIds);\n  const newClassName = newSequenceHash + ' ' + atomicClasses;\n  mergeClassesCachedResults[sequenceMatch] = newClassName;\n  DEFINITION_LOOKUP_TABLE[newSequenceHash] = [resultClassesMap, dir];\n  return resultClassName + newClassName;\n}\n\nexport { mergeClasses, mergeClassesCachedResults };\n//# sourceMappingURL=mergeClasses.esm.js.map\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ let $488c6ddbf4ef74c2$var$formatterCache = new Map();\nlet $488c6ddbf4ef74c2$var$supportsSignDisplay = false;\ntry {\n    // @ts-ignore\n    $488c6ddbf4ef74c2$var$supportsSignDisplay = new Intl.NumberFormat('de-DE', {\n        signDisplay: 'exceptZero'\n    }).resolvedOptions().signDisplay === 'exceptZero';\n// eslint-disable-next-line no-empty\n} catch (e) {\n}\nlet $488c6ddbf4ef74c2$var$supportsUnit = false;\ntry {\n    // @ts-ignore\n    $488c6ddbf4ef74c2$var$supportsUnit = new Intl.NumberFormat('de-DE', {\n        style: 'unit',\n        unit: 'degree'\n    }).resolvedOptions().style === 'unit';\n// eslint-disable-next-line no-empty\n} catch (e1) {\n}\n// Polyfill for units since Safari doesn't support them yet. See https://bugs.webkit.org/show_bug.cgi?id=215438.\n// Currently only polyfilling the unit degree in narrow format for ColorSlider in our supported locales.\n// Values were determined by switching to each locale manually in Chrome.\nconst $488c6ddbf4ef74c2$var$UNITS = {\n    degree: {\n        narrow: {\n            default: '',\n            'ja-JP': ' ',\n            'zh-TW': '',\n            'sl-SI': ' '\n        }\n    }\n};\nclass $488c6ddbf4ef74c2$export$cc77c4ff7e8673c5 {\n    /** Formats a number value as a string, according to the locale and options provided to the constructor. */ format(value) {\n        let res = '';\n        if (!$488c6ddbf4ef74c2$var$supportsSignDisplay && this.options.signDisplay != null) res = $488c6ddbf4ef74c2$export$711b50b3c525e0f2(this.numberFormatter, this.options.signDisplay, value);\n        else res = this.numberFormatter.format(value);\n        if (this.options.style === 'unit' && !$488c6ddbf4ef74c2$var$supportsUnit) {\n            var ref;\n            let { unit: unit , unitDisplay: unitDisplay = 'short' , locale: locale  } = this.resolvedOptions();\n            let values = (ref = $488c6ddbf4ef74c2$var$UNITS[unit]) === null || ref === void 0 ? void 0 : ref[unitDisplay];\n            res += values[locale] || values.default;\n        }\n        return res;\n    }\n    /** Formats a number to an array of parts such as separators, digits, punctuation, and more. */ formatToParts(value) {\n        // TODO: implement signDisplay for formatToParts\n        // @ts-ignore\n        return this.numberFormatter.formatToParts(value);\n    }\n    /** Formats a number range as a string. */ formatRange(start, end) {\n        // @ts-ignore\n        if (typeof this.numberFormatter.formatRange === 'function') // @ts-ignore\n        return this.numberFormatter.formatRange(start, end);\n        if (end < start) throw new RangeError('End date must be >= start date');\n        // Very basic fallback for old browsers.\n        return `${this.format(start)}  ${this.format(end)}`;\n    }\n    /** Formats a number range as an array of parts. */ formatRangeToParts(start, end) {\n        // @ts-ignore\n        if (typeof this.numberFormatter.formatRangeToParts === 'function') // @ts-ignore\n        return this.numberFormatter.formatRangeToParts(start, end);\n        if (end < start) throw new RangeError('End date must be >= start date');\n        let startParts = this.numberFormatter.formatToParts(start);\n        let endParts = this.numberFormatter.formatToParts(end);\n        return [\n            ...startParts.map((p)=>({\n                    ...p,\n                    source: 'startRange'\n                })\n            ),\n            {\n                type: 'literal',\n                value: '  ',\n                source: 'shared'\n            },\n            ...endParts.map((p)=>({\n                    ...p,\n                    source: 'endRange'\n                })\n            )\n        ];\n    }\n    /** Returns the resolved formatting options based on the values passed to the constructor. */ resolvedOptions() {\n        let options = this.numberFormatter.resolvedOptions();\n        if (!$488c6ddbf4ef74c2$var$supportsSignDisplay && this.options.signDisplay != null) options = {\n            ...options,\n            signDisplay: this.options.signDisplay\n        };\n        if (!$488c6ddbf4ef74c2$var$supportsUnit && this.options.style === 'unit') options = {\n            ...options,\n            style: 'unit',\n            unit: this.options.unit,\n            unitDisplay: this.options.unitDisplay\n        };\n        return options;\n    }\n    constructor(locale, options = {\n    }){\n        this.numberFormatter = $488c6ddbf4ef74c2$var$getCachedNumberFormatter(locale, options);\n        this.options = options;\n    }\n}\nfunction $488c6ddbf4ef74c2$var$getCachedNumberFormatter(locale, options = {\n}) {\n    let { numberingSystem: numberingSystem  } = options;\n    if (numberingSystem && locale.indexOf('-u-nu-') === -1) locale = `${locale}-u-nu-${numberingSystem}`;\n    if (options.style === 'unit' && !$488c6ddbf4ef74c2$var$supportsUnit) {\n        var ref;\n        let { unit: unit , unitDisplay: unitDisplay = 'short'  } = options;\n        if (!unit) throw new Error('unit option must be provided with style: \"unit\"');\n        if (!((ref = $488c6ddbf4ef74c2$var$UNITS[unit]) === null || ref === void 0 ? void 0 : ref[unitDisplay])) throw new Error(`Unsupported unit ${unit} with unitDisplay = ${unitDisplay}`);\n        options = {\n            ...options,\n            style: 'decimal'\n        };\n    }\n    let cacheKey = locale + (options ? Object.entries(options).sort((a, b)=>a[0] < b[0] ? -1 : 1\n    ).join() : '');\n    if ($488c6ddbf4ef74c2$var$formatterCache.has(cacheKey)) return $488c6ddbf4ef74c2$var$formatterCache.get(cacheKey);\n    let numberFormatter = new Intl.NumberFormat(locale, options);\n    $488c6ddbf4ef74c2$var$formatterCache.set(cacheKey, numberFormatter);\n    return numberFormatter;\n}\nfunction $488c6ddbf4ef74c2$export$711b50b3c525e0f2(numberFormat, signDisplay, num) {\n    if (signDisplay === 'auto') return numberFormat.format(num);\n    else if (signDisplay === 'never') return numberFormat.format(Math.abs(num));\n    else {\n        let needsPositiveSign = false;\n        if (signDisplay === 'always') needsPositiveSign = num > 0 || Object.is(num, 0);\n        else if (signDisplay === 'exceptZero') {\n            if (Object.is(num, -0) || Object.is(num, 0)) num = Math.abs(num);\n            else needsPositiveSign = num > 0;\n        }\n        if (needsPositiveSign) {\n            let negative = numberFormat.format(-num);\n            let noSign = numberFormat.format(num);\n            // ignore RTL/LTR marker character\n            let minus = negative.replace(noSign, '').replace(/\\u200e|\\u061C/, '');\n            if ([\n                ...minus\n            ].length !== 1) console.warn('@react-aria/i18n polyfill for NumberFormat signDisplay: Unsupported case');\n            let positive = negative.replace(noSign, '!!!').replace(minus, '+').replace('!!!', noSign);\n            return positive;\n        } else return numberFormat.format(num);\n    }\n}\n\n\nconst $6c7bd7858deea686$var$CURRENCY_SIGN_REGEX = new RegExp('^.*\\\\(.*\\\\).*$');\nconst $6c7bd7858deea686$var$NUMBERING_SYSTEMS = [\n    'latn',\n    'arab',\n    'hanidec'\n];\nclass $6c7bd7858deea686$export$cd11ab140839f11d {\n    /**\n   * Parses the given string to a number. Returns NaN if a valid number could not be parsed.\n   */ parse(value) {\n        return $6c7bd7858deea686$var$getNumberParserImpl(this.locale, this.options, value).parse(value);\n    }\n    /**\n   * Returns whether the given string could potentially be a valid number. This should be used to\n   * validate user input as the user types. If a `minValue` or `maxValue` is provided, the validity\n   * of the minus/plus sign characters can be checked.\n   */ isValidPartialNumber(value, minValue, maxValue) {\n        return $6c7bd7858deea686$var$getNumberParserImpl(this.locale, this.options, value).isValidPartialNumber(value, minValue, maxValue);\n    }\n    /**\n   * Returns a numbering system for which the given string is valid in the current locale.\n   * If no numbering system could be detected, the default numbering system for the current\n   * locale is returned.\n   */ getNumberingSystem(value) {\n        return $6c7bd7858deea686$var$getNumberParserImpl(this.locale, this.options, value).options.numberingSystem;\n    }\n    constructor(locale, options = {\n    }){\n        this.locale = locale;\n        this.options = options;\n    }\n}\nconst $6c7bd7858deea686$var$numberParserCache = new Map();\nfunction $6c7bd7858deea686$var$getNumberParserImpl(locale, options, value) {\n    // First try the default numbering system for the provided locale\n    let defaultParser = $6c7bd7858deea686$var$getCachedNumberParser(locale, options);\n    // If that doesn't match, and the locale doesn't include a hard coded numbering system,\n    // try each of the other supported numbering systems until we find one that matches.\n    if (!locale.includes('-nu-') && !defaultParser.isValidPartialNumber(value)) {\n        for (let numberingSystem of $6c7bd7858deea686$var$NUMBERING_SYSTEMS)if (numberingSystem !== defaultParser.options.numberingSystem) {\n            let parser = $6c7bd7858deea686$var$getCachedNumberParser(locale + (locale.includes('-u-') ? '-nu-' : '-u-nu-') + numberingSystem, options);\n            if (parser.isValidPartialNumber(value)) return parser;\n        }\n    }\n    return defaultParser;\n}\nfunction $6c7bd7858deea686$var$getCachedNumberParser(locale, options) {\n    let cacheKey = locale + (options ? Object.entries(options).sort((a, b)=>a[0] < b[0] ? -1 : 1\n    ).join() : '');\n    let parser = $6c7bd7858deea686$var$numberParserCache.get(cacheKey);\n    if (!parser) {\n        parser = new $6c7bd7858deea686$var$NumberParserImpl(locale, options);\n        $6c7bd7858deea686$var$numberParserCache.set(cacheKey, parser);\n    }\n    return parser;\n}\n// The actual number parser implementation. Instances of this class are cached\n// based on the locale, options, and detected numbering system.\nclass $6c7bd7858deea686$var$NumberParserImpl {\n    parse(value) {\n        // to parse the number, we need to remove anything that isn't actually part of the number, for example we want '-10.40' not '-10.40 USD'\n        let fullySanitizedValue = this.sanitize(value);\n        // Remove group characters, and replace decimal points and numerals with ASCII values.\n        fullySanitizedValue = $6c7bd7858deea686$var$replaceAll(fullySanitizedValue, this.symbols.group, '').replace(this.symbols.decimal, '.').replace(this.symbols.minusSign, '-').replace(this.symbols.numeral, this.symbols.index);\n        let newValue = fullySanitizedValue ? +fullySanitizedValue : NaN;\n        if (isNaN(newValue)) return NaN;\n        // accounting will always be stripped to a positive number, so if it's accounting and has a () around everything, then we need to make it negative again\n        if (this.options.currencySign === 'accounting' && $6c7bd7858deea686$var$CURRENCY_SIGN_REGEX.test(value)) newValue = -1 * newValue;\n        // when reading the number, if it's a percent, then it should be interpreted as being divided by 100\n        if (this.options.style === 'percent') {\n            newValue /= 100;\n            var _maximumFractionDigits;\n            // after dividing to get the percent value, javascript may get .0210999999 instead of .0211, so fix the number of fraction digits\n            newValue = +newValue.toFixed(((_maximumFractionDigits = this.options.maximumFractionDigits) !== null && _maximumFractionDigits !== void 0 ? _maximumFractionDigits : 0) + 2);\n        }\n        return newValue;\n    }\n    sanitize(value) {\n        // Remove literals and whitespace, which are allowed anywhere in the string\n        value = value.replace(this.symbols.literals, '');\n        // Replace the ASCII minus sign with the minus sign used in the current locale\n        // so that both are allowed in case the user's keyboard doesn't have the locale's minus sign.\n        value = value.replace('-', this.symbols.minusSign);\n        // In arab numeral system, their decimal character is 1643, but most keyboards don't type that\n        // instead they use the , (44) character or apparently the (1548) character.\n        if (this.options.numberingSystem === 'arab') {\n            value = value.replace(',', this.symbols.decimal);\n            value = value.replace(String.fromCharCode(1548), this.symbols.decimal);\n            value = $6c7bd7858deea686$var$replaceAll(value, '.', this.symbols.group);\n        }\n        // fr-FR group character is char code 8239, but that's not a key on the french keyboard,\n        // so allow 'period' as a group char and replace it with a space\n        if (this.options.locale === 'fr-FR') value = $6c7bd7858deea686$var$replaceAll(value, '.', String.fromCharCode(8239));\n        return value;\n    }\n    isValidPartialNumber(value, minValue = -Infinity, maxValue = Infinity) {\n        value = this.sanitize(value);\n        // Remove minus or plus sign, which must be at the start of the string.\n        if (value.startsWith(this.symbols.minusSign) && minValue < 0) value = value.slice(this.symbols.minusSign.length);\n        else if (this.symbols.plusSign && value.startsWith(this.symbols.plusSign) && maxValue > 0) value = value.slice(this.symbols.plusSign.length);\n        // Numbers cannot start with a group separator\n        if (value.startsWith(this.symbols.group)) return false;\n        // Remove numerals, groups, and decimals\n        value = $6c7bd7858deea686$var$replaceAll(value, this.symbols.group, '').replace(this.symbols.numeral, '').replace(this.symbols.decimal, '');\n        // The number is valid if there are no remaining characters\n        return value.length === 0;\n    }\n    constructor(locale, options = {\n    }){\n        this.formatter = new Intl.NumberFormat(locale, options);\n        this.options = this.formatter.resolvedOptions();\n        this.symbols = $6c7bd7858deea686$var$getSymbols(this.formatter, this.options, options);\n    }\n}\nconst $6c7bd7858deea686$var$nonLiteralParts = new Set([\n    'decimal',\n    'fraction',\n    'integer',\n    'minusSign',\n    'plusSign',\n    'group'\n]);\nfunction $6c7bd7858deea686$var$getSymbols(formatter, intlOptions, originalOptions) {\n    var ref, ref1, ref2, ref3;\n    // Note: some locale's don't add a group symbol until there is a ten thousands place\n    let allParts = formatter.formatToParts(-10000.111);\n    let posAllParts = formatter.formatToParts(10000.111);\n    let singularParts = formatter.formatToParts(1);\n    var ref4;\n    let minusSign = (ref4 = (ref = allParts.find((p)=>p.type === 'minusSign'\n    )) === null || ref === void 0 ? void 0 : ref.value) !== null && ref4 !== void 0 ? ref4 : '-';\n    let plusSign = (ref1 = posAllParts.find((p)=>p.type === 'plusSign'\n    )) === null || ref1 === void 0 ? void 0 : ref1.value;\n    // Safari does not support the signDisplay option, but our number parser polyfills it.\n    // If no plus sign was returned, but the original options contained signDisplay, default to the '+' character.\n    // @ts-ignore\n    if (!plusSign && ((originalOptions === null || originalOptions === void 0 ? void 0 : originalOptions.signDisplay) === 'exceptZero' || (originalOptions === null || originalOptions === void 0 ? void 0 : originalOptions.signDisplay) === 'always')) plusSign = '+';\n    let decimal = (ref2 = allParts.find((p)=>p.type === 'decimal'\n    )) === null || ref2 === void 0 ? void 0 : ref2.value;\n    let group = (ref3 = allParts.find((p)=>p.type === 'group'\n    )) === null || ref3 === void 0 ? void 0 : ref3.value;\n    // this set is also for a regex, it's all literals that might be in the string we want to eventually parse that\n    // don't contribute to the numerical value\n    let pluralLiterals = allParts.filter((p)=>!$6c7bd7858deea686$var$nonLiteralParts.has(p.type)\n    ).map((p)=>$6c7bd7858deea686$var$escapeRegex(p.value)\n    );\n    let singularLiterals = singularParts.filter((p)=>!$6c7bd7858deea686$var$nonLiteralParts.has(p.type)\n    ).map((p)=>$6c7bd7858deea686$var$escapeRegex(p.value)\n    );\n    let sortedLiterals = [\n        ...new Set([\n            ...singularLiterals,\n            ...pluralLiterals\n        ])\n    ].sort((a, b)=>b.length - a.length\n    );\n    let literals = sortedLiterals.length === 0 ? new RegExp('[\\\\p{White_Space}]', 'gu') : new RegExp(`${sortedLiterals.join('|')}|[\\\\p{White_Space}]`, 'gu');\n    // These are for replacing non-latn characters with the latn equivalent\n    let numerals = [\n        ...new Intl.NumberFormat(intlOptions.locale, {\n            useGrouping: false\n        }).format(9876543210)\n    ].reverse();\n    let indexes = new Map(numerals.map((d, i)=>[\n            d,\n            i\n        ]\n    ));\n    let numeral = new RegExp(`[${numerals.join('')}]`, 'g');\n    let index = (d)=>String(indexes.get(d))\n    ;\n    return {\n        minusSign: minusSign,\n        plusSign: plusSign,\n        decimal: decimal,\n        group: group,\n        literals: literals,\n        numeral: numeral,\n        index: index\n    };\n}\nfunction $6c7bd7858deea686$var$replaceAll(str, find, replace) {\n    // @ts-ignore\n    if (str.replaceAll) // @ts-ignore\n    return str.replaceAll(find, replace);\n    return str.split(find).join(replace);\n}\nfunction $6c7bd7858deea686$var$escapeRegex(string) {\n    return string.replace(/[-/\\\\^$*+?.()|[\\]{}]/g, '\\\\$&');\n}\n\n\n\n\nexport {$488c6ddbf4ef74c2$export$cc77c4ff7e8673c5 as NumberFormatter, $6c7bd7858deea686$export$cd11ab140839f11d as NumberParser};\n//# sourceMappingURL=module.js.map\n","!function(e,t){\"object\"==typeof exports&&\"object\"==typeof module?module.exports=t():\"function\"==typeof define&&define.amd?define([],t):\"object\"==typeof exports?exports.bowser=t():e.bowser=t()}(this,(function(){return function(e){var t={};function r(n){if(t[n])return t[n].exports;var i=t[n]={i:n,l:!1,exports:{}};return e[n].call(i.exports,i,i.exports,r),i.l=!0,i.exports}return r.m=e,r.c=t,r.d=function(e,t,n){r.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:n})},r.r=function(e){\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(e,\"__esModule\",{value:!0})},r.t=function(e,t){if(1&t&&(e=r(e)),8&t)return e;if(4&t&&\"object\"==typeof e&&e&&e.__esModule)return e;var n=Object.create(null);if(r.r(n),Object.defineProperty(n,\"default\",{enumerable:!0,value:e}),2&t&&\"string\"!=typeof e)for(var i in e)r.d(n,i,function(t){return e[t]}.bind(null,i));return n},r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,\"a\",t),t},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r.p=\"\",r(r.s=90)}({17:function(e,t,r){\"use strict\";t.__esModule=!0,t.default=void 0;var n=r(18),i=function(){function e(){}return e.getFirstMatch=function(e,t){var r=t.match(e);return r&&r.length>0&&r[1]||\"\"},e.getSecondMatch=function(e,t){var r=t.match(e);return r&&r.length>1&&r[2]||\"\"},e.matchAndReturnConst=function(e,t,r){if(e.test(t))return r},e.getWindowsVersionName=function(e){switch(e){case\"NT\":return\"NT\";case\"XP\":return\"XP\";case\"NT 5.0\":return\"2000\";case\"NT 5.1\":return\"XP\";case\"NT 5.2\":return\"2003\";case\"NT 6.0\":return\"Vista\";case\"NT 6.1\":return\"7\";case\"NT 6.2\":return\"8\";case\"NT 6.3\":return\"8.1\";case\"NT 10.0\":return\"10\";default:return}},e.getMacOSVersionName=function(e){var t=e.split(\".\").splice(0,2).map((function(e){return parseInt(e,10)||0}));if(t.push(0),10===t[0])switch(t[1]){case 5:return\"Leopard\";case 6:return\"Snow Leopard\";case 7:return\"Lion\";case 8:return\"Mountain Lion\";case 9:return\"Mavericks\";case 10:return\"Yosemite\";case 11:return\"El Capitan\";case 12:return\"Sierra\";case 13:return\"High Sierra\";case 14:return\"Mojave\";case 15:return\"Catalina\";default:return}},e.getAndroidVersionName=function(e){var t=e.split(\".\").splice(0,2).map((function(e){return parseInt(e,10)||0}));if(t.push(0),!(1===t[0]&&t[1]<5))return 1===t[0]&&t[1]<6?\"Cupcake\":1===t[0]&&t[1]>=6?\"Donut\":2===t[0]&&t[1]<2?\"Eclair\":2===t[0]&&2===t[1]?\"Froyo\":2===t[0]&&t[1]>2?\"Gingerbread\":3===t[0]?\"Honeycomb\":4===t[0]&&t[1]<1?\"Ice Cream Sandwich\":4===t[0]&&t[1]<4?\"Jelly Bean\":4===t[0]&&t[1]>=4?\"KitKat\":5===t[0]?\"Lollipop\":6===t[0]?\"Marshmallow\":7===t[0]?\"Nougat\":8===t[0]?\"Oreo\":9===t[0]?\"Pie\":void 0},e.getVersionPrecision=function(e){return e.split(\".\").length},e.compareVersions=function(t,r,n){void 0===n&&(n=!1);var i=e.getVersionPrecision(t),s=e.getVersionPrecision(r),a=Math.max(i,s),o=0,u=e.map([t,r],(function(t){var r=a-e.getVersionPrecision(t),n=t+new Array(r+1).join(\".0\");return e.map(n.split(\".\"),(function(e){return new Array(20-e.length).join(\"0\")+e})).reverse()}));for(n&&(o=a-Math.min(i,s)),a-=1;a>=o;){if(u[0][a]>u[1][a])return 1;if(u[0][a]===u[1][a]){if(a===o)return 0;a-=1}else if(u[0][a]<u[1][a])return-1}},e.map=function(e,t){var r,n=[];if(Array.prototype.map)return Array.prototype.map.call(e,t);for(r=0;r<e.length;r+=1)n.push(t(e[r]));return n},e.find=function(e,t){var r,n;if(Array.prototype.find)return Array.prototype.find.call(e,t);for(r=0,n=e.length;r<n;r+=1){var i=e[r];if(t(i,r))return i}},e.assign=function(e){for(var t,r,n=e,i=arguments.length,s=new Array(i>1?i-1:0),a=1;a<i;a++)s[a-1]=arguments[a];if(Object.assign)return Object.assign.apply(Object,[e].concat(s));var o=function(){var e=s[t];\"object\"==typeof e&&null!==e&&Object.keys(e).forEach((function(t){n[t]=e[t]}))};for(t=0,r=s.length;t<r;t+=1)o();return e},e.getBrowserAlias=function(e){return n.BROWSER_ALIASES_MAP[e]},e.getBrowserTypeByAlias=function(e){return n.BROWSER_MAP[e]||\"\"},e}();t.default=i,e.exports=t.default},18:function(e,t,r){\"use strict\";t.__esModule=!0,t.ENGINE_MAP=t.OS_MAP=t.PLATFORMS_MAP=t.BROWSER_MAP=t.BROWSER_ALIASES_MAP=void 0;t.BROWSER_ALIASES_MAP={\"Amazon Silk\":\"amazon_silk\",\"Android Browser\":\"android\",Bada:\"bada\",BlackBerry:\"blackberry\",Chrome:\"chrome\",Chromium:\"chromium\",Electron:\"electron\",Epiphany:\"epiphany\",Firefox:\"firefox\",Focus:\"focus\",Generic:\"generic\",\"Google Search\":\"google_search\",Googlebot:\"googlebot\",\"Internet Explorer\":\"ie\",\"K-Meleon\":\"k_meleon\",Maxthon:\"maxthon\",\"Microsoft Edge\":\"edge\",\"MZ Browser\":\"mz\",\"NAVER Whale Browser\":\"naver\",Opera:\"opera\",\"Opera Coast\":\"opera_coast\",PhantomJS:\"phantomjs\",Puffin:\"puffin\",QupZilla:\"qupzilla\",QQ:\"qq\",QQLite:\"qqlite\",Safari:\"safari\",Sailfish:\"sailfish\",\"Samsung Internet for Android\":\"samsung_internet\",SeaMonkey:\"seamonkey\",Sleipnir:\"sleipnir\",Swing:\"swing\",Tizen:\"tizen\",\"UC Browser\":\"uc\",Vivaldi:\"vivaldi\",\"WebOS Browser\":\"webos\",WeChat:\"wechat\",\"Yandex Browser\":\"yandex\",Roku:\"roku\"};t.BROWSER_MAP={amazon_silk:\"Amazon Silk\",android:\"Android Browser\",bada:\"Bada\",blackberry:\"BlackBerry\",chrome:\"Chrome\",chromium:\"Chromium\",electron:\"Electron\",epiphany:\"Epiphany\",firefox:\"Firefox\",focus:\"Focus\",generic:\"Generic\",googlebot:\"Googlebot\",google_search:\"Google Search\",ie:\"Internet Explorer\",k_meleon:\"K-Meleon\",maxthon:\"Maxthon\",edge:\"Microsoft Edge\",mz:\"MZ Browser\",naver:\"NAVER Whale Browser\",opera:\"Opera\",opera_coast:\"Opera Coast\",phantomjs:\"PhantomJS\",puffin:\"Puffin\",qupzilla:\"QupZilla\",qq:\"QQ Browser\",qqlite:\"QQ Browser Lite\",safari:\"Safari\",sailfish:\"Sailfish\",samsung_internet:\"Samsung Internet for Android\",seamonkey:\"SeaMonkey\",sleipnir:\"Sleipnir\",swing:\"Swing\",tizen:\"Tizen\",uc:\"UC Browser\",vivaldi:\"Vivaldi\",webos:\"WebOS Browser\",wechat:\"WeChat\",yandex:\"Yandex Browser\"};t.PLATFORMS_MAP={tablet:\"tablet\",mobile:\"mobile\",desktop:\"desktop\",tv:\"tv\"};t.OS_MAP={WindowsPhone:\"Windows Phone\",Windows:\"Windows\",MacOS:\"macOS\",iOS:\"iOS\",Android:\"Android\",WebOS:\"WebOS\",BlackBerry:\"BlackBerry\",Bada:\"Bada\",Tizen:\"Tizen\",Linux:\"Linux\",ChromeOS:\"Chrome OS\",PlayStation4:\"PlayStation 4\",Roku:\"Roku\"};t.ENGINE_MAP={EdgeHTML:\"EdgeHTML\",Blink:\"Blink\",Trident:\"Trident\",Presto:\"Presto\",Gecko:\"Gecko\",WebKit:\"WebKit\"}},90:function(e,t,r){\"use strict\";t.__esModule=!0,t.default=void 0;var n,i=(n=r(91))&&n.__esModule?n:{default:n},s=r(18);function a(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}var o=function(){function e(){}var t,r,n;return e.getParser=function(e,t){if(void 0===t&&(t=!1),\"string\"!=typeof e)throw new Error(\"UserAgent should be a string\");return new i.default(e,t)},e.parse=function(e){return new i.default(e).getResult()},t=e,n=[{key:\"BROWSER_MAP\",get:function(){return s.BROWSER_MAP}},{key:\"ENGINE_MAP\",get:function(){return s.ENGINE_MAP}},{key:\"OS_MAP\",get:function(){return s.OS_MAP}},{key:\"PLATFORMS_MAP\",get:function(){return s.PLATFORMS_MAP}}],(r=null)&&a(t.prototype,r),n&&a(t,n),e}();t.default=o,e.exports=t.default},91:function(e,t,r){\"use strict\";t.__esModule=!0,t.default=void 0;var n=u(r(92)),i=u(r(93)),s=u(r(94)),a=u(r(95)),o=u(r(17));function u(e){return e&&e.__esModule?e:{default:e}}var d=function(){function e(e,t){if(void 0===t&&(t=!1),null==e||\"\"===e)throw new Error(\"UserAgent parameter can't be empty\");this._ua=e,this.parsedResult={},!0!==t&&this.parse()}var t=e.prototype;return t.getUA=function(){return this._ua},t.test=function(e){return e.test(this._ua)},t.parseBrowser=function(){var e=this;this.parsedResult.browser={};var t=o.default.find(n.default,(function(t){if(\"function\"==typeof t.test)return t.test(e);if(t.test instanceof Array)return t.test.some((function(t){return e.test(t)}));throw new Error(\"Browser's test function is not valid\")}));return t&&(this.parsedResult.browser=t.describe(this.getUA())),this.parsedResult.browser},t.getBrowser=function(){return this.parsedResult.browser?this.parsedResult.browser:this.parseBrowser()},t.getBrowserName=function(e){return e?String(this.getBrowser().name).toLowerCase()||\"\":this.getBrowser().name||\"\"},t.getBrowserVersion=function(){return this.getBrowser().version},t.getOS=function(){return this.parsedResult.os?this.parsedResult.os:this.parseOS()},t.parseOS=function(){var e=this;this.parsedResult.os={};var t=o.default.find(i.default,(function(t){if(\"function\"==typeof t.test)return t.test(e);if(t.test instanceof Array)return t.test.some((function(t){return e.test(t)}));throw new Error(\"Browser's test function is not valid\")}));return t&&(this.parsedResult.os=t.describe(this.getUA())),this.parsedResult.os},t.getOSName=function(e){var t=this.getOS().name;return e?String(t).toLowerCase()||\"\":t||\"\"},t.getOSVersion=function(){return this.getOS().version},t.getPlatform=function(){return this.parsedResult.platform?this.parsedResult.platform:this.parsePlatform()},t.getPlatformType=function(e){void 0===e&&(e=!1);var t=this.getPlatform().type;return e?String(t).toLowerCase()||\"\":t||\"\"},t.parsePlatform=function(){var e=this;this.parsedResult.platform={};var t=o.default.find(s.default,(function(t){if(\"function\"==typeof t.test)return t.test(e);if(t.test instanceof Array)return t.test.some((function(t){return e.test(t)}));throw new Error(\"Browser's test function is not valid\")}));return t&&(this.parsedResult.platform=t.describe(this.getUA())),this.parsedResult.platform},t.getEngine=function(){return this.parsedResult.engine?this.parsedResult.engine:this.parseEngine()},t.getEngineName=function(e){return e?String(this.getEngine().name).toLowerCase()||\"\":this.getEngine().name||\"\"},t.parseEngine=function(){var e=this;this.parsedResult.engine={};var t=o.default.find(a.default,(function(t){if(\"function\"==typeof t.test)return t.test(e);if(t.test instanceof Array)return t.test.some((function(t){return e.test(t)}));throw new Error(\"Browser's test function is not valid\")}));return t&&(this.parsedResult.engine=t.describe(this.getUA())),this.parsedResult.engine},t.parse=function(){return this.parseBrowser(),this.parseOS(),this.parsePlatform(),this.parseEngine(),this},t.getResult=function(){return o.default.assign({},this.parsedResult)},t.satisfies=function(e){var t=this,r={},n=0,i={},s=0;if(Object.keys(e).forEach((function(t){var a=e[t];\"string\"==typeof a?(i[t]=a,s+=1):\"object\"==typeof a&&(r[t]=a,n+=1)})),n>0){var a=Object.keys(r),u=o.default.find(a,(function(e){return t.isOS(e)}));if(u){var d=this.satisfies(r[u]);if(void 0!==d)return d}var c=o.default.find(a,(function(e){return t.isPlatform(e)}));if(c){var f=this.satisfies(r[c]);if(void 0!==f)return f}}if(s>0){var l=Object.keys(i),h=o.default.find(l,(function(e){return t.isBrowser(e,!0)}));if(void 0!==h)return this.compareVersion(i[h])}},t.isBrowser=function(e,t){void 0===t&&(t=!1);var r=this.getBrowserName().toLowerCase(),n=e.toLowerCase(),i=o.default.getBrowserTypeByAlias(n);return t&&i&&(n=i.toLowerCase()),n===r},t.compareVersion=function(e){var t=[0],r=e,n=!1,i=this.getBrowserVersion();if(\"string\"==typeof i)return\">\"===e[0]||\"<\"===e[0]?(r=e.substr(1),\"=\"===e[1]?(n=!0,r=e.substr(2)):t=[],\">\"===e[0]?t.push(1):t.push(-1)):\"=\"===e[0]?r=e.substr(1):\"~\"===e[0]&&(n=!0,r=e.substr(1)),t.indexOf(o.default.compareVersions(i,r,n))>-1},t.isOS=function(e){return this.getOSName(!0)===String(e).toLowerCase()},t.isPlatform=function(e){return this.getPlatformType(!0)===String(e).toLowerCase()},t.isEngine=function(e){return this.getEngineName(!0)===String(e).toLowerCase()},t.is=function(e,t){return void 0===t&&(t=!1),this.isBrowser(e,t)||this.isOS(e)||this.isPlatform(e)},t.some=function(e){var t=this;return void 0===e&&(e=[]),e.some((function(e){return t.is(e)}))},e}();t.default=d,e.exports=t.default},92:function(e,t,r){\"use strict\";t.__esModule=!0,t.default=void 0;var n,i=(n=r(17))&&n.__esModule?n:{default:n};var s=/version\\/(\\d+(\\.?_?\\d+)+)/i,a=[{test:[/googlebot/i],describe:function(e){var t={name:\"Googlebot\"},r=i.default.getFirstMatch(/googlebot\\/(\\d+(\\.\\d+))/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/opera/i],describe:function(e){var t={name:\"Opera\"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:opera)[\\s/](\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/opr\\/|opios/i],describe:function(e){var t={name:\"Opera\"},r=i.default.getFirstMatch(/(?:opr|opios)[\\s/](\\S+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/SamsungBrowser/i],describe:function(e){var t={name:\"Samsung Internet for Android\"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:SamsungBrowser)[\\s/](\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/Whale/i],describe:function(e){var t={name:\"NAVER Whale Browser\"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:whale)[\\s/](\\d+(?:\\.\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/MZBrowser/i],describe:function(e){var t={name:\"MZ Browser\"},r=i.default.getFirstMatch(/(?:MZBrowser)[\\s/](\\d+(?:\\.\\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/focus/i],describe:function(e){var t={name:\"Focus\"},r=i.default.getFirstMatch(/(?:focus)[\\s/](\\d+(?:\\.\\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/swing/i],describe:function(e){var t={name:\"Swing\"},r=i.default.getFirstMatch(/(?:swing)[\\s/](\\d+(?:\\.\\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/coast/i],describe:function(e){var t={name:\"Opera Coast\"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:coast)[\\s/](\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/opt\\/\\d+(?:.?_?\\d+)+/i],describe:function(e){var t={name:\"Opera Touch\"},r=i.default.getFirstMatch(/(?:opt)[\\s/](\\d+(\\.?_?\\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/yabrowser/i],describe:function(e){var t={name:\"Yandex Browser\"},r=i.default.getFirstMatch(/(?:yabrowser)[\\s/](\\d+(\\.?_?\\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/ucbrowser/i],describe:function(e){var t={name:\"UC Browser\"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:ucbrowser)[\\s/](\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/Maxthon|mxios/i],describe:function(e){var t={name:\"Maxthon\"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:Maxthon|mxios)[\\s/](\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/epiphany/i],describe:function(e){var t={name:\"Epiphany\"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:epiphany)[\\s/](\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/puffin/i],describe:function(e){var t={name:\"Puffin\"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:puffin)[\\s/](\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/sleipnir/i],describe:function(e){var t={name:\"Sleipnir\"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:sleipnir)[\\s/](\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/k-meleon/i],describe:function(e){var t={name:\"K-Meleon\"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:k-meleon)[\\s/](\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/micromessenger/i],describe:function(e){var t={name:\"WeChat\"},r=i.default.getFirstMatch(/(?:micromessenger)[\\s/](\\d+(\\.?_?\\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/qqbrowser/i],describe:function(e){var t={name:/qqbrowserlite/i.test(e)?\"QQ Browser Lite\":\"QQ Browser\"},r=i.default.getFirstMatch(/(?:qqbrowserlite|qqbrowser)[/](\\d+(\\.?_?\\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/msie|trident/i],describe:function(e){var t={name:\"Internet Explorer\"},r=i.default.getFirstMatch(/(?:msie |rv:)(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/\\sedg\\//i],describe:function(e){var t={name:\"Microsoft Edge\"},r=i.default.getFirstMatch(/\\sedg\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/edg([ea]|ios)/i],describe:function(e){var t={name:\"Microsoft Edge\"},r=i.default.getSecondMatch(/edg([ea]|ios)\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/vivaldi/i],describe:function(e){var t={name:\"Vivaldi\"},r=i.default.getFirstMatch(/vivaldi\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/seamonkey/i],describe:function(e){var t={name:\"SeaMonkey\"},r=i.default.getFirstMatch(/seamonkey\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/sailfish/i],describe:function(e){var t={name:\"Sailfish\"},r=i.default.getFirstMatch(/sailfish\\s?browser\\/(\\d+(\\.\\d+)?)/i,e);return r&&(t.version=r),t}},{test:[/silk/i],describe:function(e){var t={name:\"Amazon Silk\"},r=i.default.getFirstMatch(/silk\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/phantom/i],describe:function(e){var t={name:\"PhantomJS\"},r=i.default.getFirstMatch(/phantomjs\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/slimerjs/i],describe:function(e){var t={name:\"SlimerJS\"},r=i.default.getFirstMatch(/slimerjs\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/blackberry|\\bbb\\d+/i,/rim\\stablet/i],describe:function(e){var t={name:\"BlackBerry\"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/blackberry[\\d]+\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/(web|hpw)[o0]s/i],describe:function(e){var t={name:\"WebOS Browser\"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/w(?:eb)?[o0]sbrowser\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/bada/i],describe:function(e){var t={name:\"Bada\"},r=i.default.getFirstMatch(/dolfin\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/tizen/i],describe:function(e){var t={name:\"Tizen\"},r=i.default.getFirstMatch(/(?:tizen\\s?)?browser\\/(\\d+(\\.?_?\\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/qupzilla/i],describe:function(e){var t={name:\"QupZilla\"},r=i.default.getFirstMatch(/(?:qupzilla)[\\s/](\\d+(\\.?_?\\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/firefox|iceweasel|fxios/i],describe:function(e){var t={name:\"Firefox\"},r=i.default.getFirstMatch(/(?:firefox|iceweasel|fxios)[\\s/](\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/electron/i],describe:function(e){var t={name:\"Electron\"},r=i.default.getFirstMatch(/(?:electron)\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/MiuiBrowser/i],describe:function(e){var t={name:\"Miui\"},r=i.default.getFirstMatch(/(?:MiuiBrowser)[\\s/](\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/chromium/i],describe:function(e){var t={name:\"Chromium\"},r=i.default.getFirstMatch(/(?:chromium)[\\s/](\\d+(\\.?_?\\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/chrome|crios|crmo/i],describe:function(e){var t={name:\"Chrome\"},r=i.default.getFirstMatch(/(?:chrome|crios|crmo)\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/GSA/i],describe:function(e){var t={name:\"Google Search\"},r=i.default.getFirstMatch(/(?:GSA)\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:function(e){var t=!e.test(/like android/i),r=e.test(/android/i);return t&&r},describe:function(e){var t={name:\"Android Browser\"},r=i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/playstation 4/i],describe:function(e){var t={name:\"PlayStation 4\"},r=i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/safari|applewebkit/i],describe:function(e){var t={name:\"Safari\"},r=i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/.*/i],describe:function(e){var t=-1!==e.search(\"\\\\(\")?/^(.*)\\/(.*)[ \\t]\\((.*)/:/^(.*)\\/(.*) /;return{name:i.default.getFirstMatch(t,e),version:i.default.getSecondMatch(t,e)}}}];t.default=a,e.exports=t.default},93:function(e,t,r){\"use strict\";t.__esModule=!0,t.default=void 0;var n,i=(n=r(17))&&n.__esModule?n:{default:n},s=r(18);var a=[{test:[/Roku\\/DVP/],describe:function(e){var t=i.default.getFirstMatch(/Roku\\/DVP-(\\d+\\.\\d+)/i,e);return{name:s.OS_MAP.Roku,version:t}}},{test:[/windows phone/i],describe:function(e){var t=i.default.getFirstMatch(/windows phone (?:os)?\\s?(\\d+(\\.\\d+)*)/i,e);return{name:s.OS_MAP.WindowsPhone,version:t}}},{test:[/windows /i],describe:function(e){var t=i.default.getFirstMatch(/Windows ((NT|XP)( \\d\\d?.\\d)?)/i,e),r=i.default.getWindowsVersionName(t);return{name:s.OS_MAP.Windows,version:t,versionName:r}}},{test:[/Macintosh(.*?) FxiOS(.*?)\\//],describe:function(e){var t={name:s.OS_MAP.iOS},r=i.default.getSecondMatch(/(Version\\/)(\\d[\\d.]+)/,e);return r&&(t.version=r),t}},{test:[/macintosh/i],describe:function(e){var t=i.default.getFirstMatch(/mac os x (\\d+(\\.?_?\\d+)+)/i,e).replace(/[_\\s]/g,\".\"),r=i.default.getMacOSVersionName(t),n={name:s.OS_MAP.MacOS,version:t};return r&&(n.versionName=r),n}},{test:[/(ipod|iphone|ipad)/i],describe:function(e){var t=i.default.getFirstMatch(/os (\\d+([_\\s]\\d+)*) like mac os x/i,e).replace(/[_\\s]/g,\".\");return{name:s.OS_MAP.iOS,version:t}}},{test:function(e){var t=!e.test(/like android/i),r=e.test(/android/i);return t&&r},describe:function(e){var t=i.default.getFirstMatch(/android[\\s/-](\\d+(\\.\\d+)*)/i,e),r=i.default.getAndroidVersionName(t),n={name:s.OS_MAP.Android,version:t};return r&&(n.versionName=r),n}},{test:[/(web|hpw)[o0]s/i],describe:function(e){var t=i.default.getFirstMatch(/(?:web|hpw)[o0]s\\/(\\d+(\\.\\d+)*)/i,e),r={name:s.OS_MAP.WebOS};return t&&t.length&&(r.version=t),r}},{test:[/blackberry|\\bbb\\d+/i,/rim\\stablet/i],describe:function(e){var t=i.default.getFirstMatch(/rim\\stablet\\sos\\s(\\d+(\\.\\d+)*)/i,e)||i.default.getFirstMatch(/blackberry\\d+\\/(\\d+([_\\s]\\d+)*)/i,e)||i.default.getFirstMatch(/\\bbb(\\d+)/i,e);return{name:s.OS_MAP.BlackBerry,version:t}}},{test:[/bada/i],describe:function(e){var t=i.default.getFirstMatch(/bada\\/(\\d+(\\.\\d+)*)/i,e);return{name:s.OS_MAP.Bada,version:t}}},{test:[/tizen/i],describe:function(e){var t=i.default.getFirstMatch(/tizen[/\\s](\\d+(\\.\\d+)*)/i,e);return{name:s.OS_MAP.Tizen,version:t}}},{test:[/linux/i],describe:function(){return{name:s.OS_MAP.Linux}}},{test:[/CrOS/],describe:function(){return{name:s.OS_MAP.ChromeOS}}},{test:[/PlayStation 4/],describe:function(e){var t=i.default.getFirstMatch(/PlayStation 4[/\\s](\\d+(\\.\\d+)*)/i,e);return{name:s.OS_MAP.PlayStation4,version:t}}}];t.default=a,e.exports=t.default},94:function(e,t,r){\"use strict\";t.__esModule=!0,t.default=void 0;var n,i=(n=r(17))&&n.__esModule?n:{default:n},s=r(18);var a=[{test:[/googlebot/i],describe:function(){return{type:\"bot\",vendor:\"Google\"}}},{test:[/huawei/i],describe:function(e){var t=i.default.getFirstMatch(/(can-l01)/i,e)&&\"Nova\",r={type:s.PLATFORMS_MAP.mobile,vendor:\"Huawei\"};return t&&(r.model=t),r}},{test:[/nexus\\s*(?:7|8|9|10).*/i],describe:function(){return{type:s.PLATFORMS_MAP.tablet,vendor:\"Nexus\"}}},{test:[/ipad/i],describe:function(){return{type:s.PLATFORMS_MAP.tablet,vendor:\"Apple\",model:\"iPad\"}}},{test:[/Macintosh(.*?) FxiOS(.*?)\\//],describe:function(){return{type:s.PLATFORMS_MAP.tablet,vendor:\"Apple\",model:\"iPad\"}}},{test:[/kftt build/i],describe:function(){return{type:s.PLATFORMS_MAP.tablet,vendor:\"Amazon\",model:\"Kindle Fire HD 7\"}}},{test:[/silk/i],describe:function(){return{type:s.PLATFORMS_MAP.tablet,vendor:\"Amazon\"}}},{test:[/tablet(?! pc)/i],describe:function(){return{type:s.PLATFORMS_MAP.tablet}}},{test:function(e){var t=e.test(/ipod|iphone/i),r=e.test(/like (ipod|iphone)/i);return t&&!r},describe:function(e){var t=i.default.getFirstMatch(/(ipod|iphone)/i,e);return{type:s.PLATFORMS_MAP.mobile,vendor:\"Apple\",model:t}}},{test:[/nexus\\s*[0-6].*/i,/galaxy nexus/i],describe:function(){return{type:s.PLATFORMS_MAP.mobile,vendor:\"Nexus\"}}},{test:[/[^-]mobi/i],describe:function(){return{type:s.PLATFORMS_MAP.mobile}}},{test:function(e){return\"blackberry\"===e.getBrowserName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.mobile,vendor:\"BlackBerry\"}}},{test:function(e){return\"bada\"===e.getBrowserName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.mobile}}},{test:function(e){return\"windows phone\"===e.getBrowserName()},describe:function(){return{type:s.PLATFORMS_MAP.mobile,vendor:\"Microsoft\"}}},{test:function(e){var t=Number(String(e.getOSVersion()).split(\".\")[0]);return\"android\"===e.getOSName(!0)&&t>=3},describe:function(){return{type:s.PLATFORMS_MAP.tablet}}},{test:function(e){return\"android\"===e.getOSName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.mobile}}},{test:function(e){return\"macos\"===e.getOSName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.desktop,vendor:\"Apple\"}}},{test:function(e){return\"windows\"===e.getOSName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.desktop}}},{test:function(e){return\"linux\"===e.getOSName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.desktop}}},{test:function(e){return\"playstation 4\"===e.getOSName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.tv}}},{test:function(e){return\"roku\"===e.getOSName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.tv}}}];t.default=a,e.exports=t.default},95:function(e,t,r){\"use strict\";t.__esModule=!0,t.default=void 0;var n,i=(n=r(17))&&n.__esModule?n:{default:n},s=r(18);var a=[{test:function(e){return\"microsoft edge\"===e.getBrowserName(!0)},describe:function(e){if(/\\sedg\\//i.test(e))return{name:s.ENGINE_MAP.Blink};var t=i.default.getFirstMatch(/edge\\/(\\d+(\\.?_?\\d+)+)/i,e);return{name:s.ENGINE_MAP.EdgeHTML,version:t}}},{test:[/trident/i],describe:function(e){var t={name:s.ENGINE_MAP.Trident},r=i.default.getFirstMatch(/trident\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:function(e){return e.test(/presto/i)},describe:function(e){var t={name:s.ENGINE_MAP.Presto},r=i.default.getFirstMatch(/presto\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:function(e){var t=e.test(/gecko/i),r=e.test(/like gecko/i);return t&&!r},describe:function(e){var t={name:s.ENGINE_MAP.Gecko},r=i.default.getFirstMatch(/gecko\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/(apple)?webkit\\/537\\.36/i],describe:function(){return{name:s.ENGINE_MAP.Blink}}},{test:[/(apple)?webkit/i],describe:function(e){var t={name:s.ENGINE_MAP.WebKit},r=i.default.getFirstMatch(/webkit\\/(\\d+(\\.?_?\\d+)+)/i,e);return r&&(t.version=r),t}}];t.default=a,e.exports=t.default}})}));","import '@tiptap/extension-text-style';\nimport { Extension } from '@tiptap/core';\n\n/**\n * This extension allows you to color your text.\n * @see https://tiptap.dev/api/extensions/color\n */\nconst Color = Extension.create({\n    name: 'color',\n    addOptions() {\n        return {\n            types: ['textStyle'],\n        };\n    },\n    addGlobalAttributes() {\n        return [\n            {\n                types: this.options.types,\n                attributes: {\n                    color: {\n                        default: null,\n                        parseHTML: element => { var _a; return (_a = element.style.color) === null || _a === void 0 ? void 0 : _a.replace(/['\"]+/g, ''); },\n                        renderHTML: attributes => {\n                            if (!attributes.color) {\n                                return {};\n                            }\n                            return {\n                                style: `color: ${attributes.color}`,\n                            };\n                        },\n                    },\n                },\n            },\n        ];\n    },\n    addCommands() {\n        return {\n            setColor: color => ({ chain }) => {\n                return chain()\n                    .setMark('textStyle', { color })\n                    .run();\n            },\n            unsetColor: () => ({ chain }) => {\n                return chain()\n                    .setMark('textStyle', { color: null })\n                    .removeEmptyTextStyle()\n                    .run();\n            },\n        };\n    },\n});\n\nexport { Color, Color as default };\n//# sourceMappingURL=index.js.map\n","/**\n * @internal\n *\n * @param entry - CSS bucket entry that can be either a string or an array\n * @returns An array where the first element is the CSS rule\n */\nfunction normalizeCSSBucketEntry(entry) {\n  if (!Array.isArray(entry)) {\n    return [entry];\n  }\n  if (process.env.NODE_ENV !== 'production' && entry.length > 2) {\n    throw new Error('CSS Bucket contains an entry with greater than 2 items, please report this to https://github.com/microsoft/griffel/issues');\n  }\n  return entry;\n}\n\nexport { normalizeCSSBucketEntry };\n//# sourceMappingURL=normalizeCSSBucketEntry.esm.js.map\n","import setPrototypeOf from \"./setPrototypeOf.js\";\nexport default function _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  setPrototypeOf(subClass, superClass);\n}","import { Mark, mergeAttributes, markInputRule, markPasteRule } from '@tiptap/core';\n\n/**\n * Matches bold text via `**` as input.\n */\nconst starInputRegex = /(?:^|\\s)(\\*\\*(?!\\s+\\*\\*)((?:[^*]+))\\*\\*(?!\\s+\\*\\*))$/;\n/**\n * Matches bold text via `**` while pasting.\n */\nconst starPasteRegex = /(?:^|\\s)(\\*\\*(?!\\s+\\*\\*)((?:[^*]+))\\*\\*(?!\\s+\\*\\*))/g;\n/**\n * Matches bold text via `__` as input.\n */\nconst underscoreInputRegex = /(?:^|\\s)(__(?!\\s+__)((?:[^_]+))__(?!\\s+__))$/;\n/**\n * Matches bold text via `__` while pasting.\n */\nconst underscorePasteRegex = /(?:^|\\s)(__(?!\\s+__)((?:[^_]+))__(?!\\s+__))/g;\n/**\n * This extension allows you to mark text as bold.\n * @see https://tiptap.dev/api/marks/bold\n */\nconst Bold = Mark.create({\n    name: 'bold',\n    addOptions() {\n        return {\n            HTMLAttributes: {},\n        };\n    },\n    parseHTML() {\n        return [\n            {\n                tag: 'strong',\n            },\n            {\n                tag: 'b',\n                getAttrs: node => node.style.fontWeight !== 'normal' && null,\n            },\n            {\n                style: 'font-weight',\n                getAttrs: value => /^(bold(er)?|[5-9]\\d{2,})$/.test(value) && null,\n            },\n        ];\n    },\n    renderHTML({ HTMLAttributes }) {\n        return ['strong', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];\n    },\n    addCommands() {\n        return {\n            setBold: () => ({ commands }) => {\n                return commands.setMark(this.name);\n            },\n            toggleBold: () => ({ commands }) => {\n                return commands.toggleMark(this.name);\n            },\n            unsetBold: () => ({ commands }) => {\n                return commands.unsetMark(this.name);\n            },\n        };\n    },\n    addKeyboardShortcuts() {\n        return {\n            'Mod-b': () => this.editor.commands.toggleBold(),\n            'Mod-B': () => this.editor.commands.toggleBold(),\n        };\n    },\n    addInputRules() {\n        return [\n            markInputRule({\n                find: starInputRegex,\n                type: this.type,\n            }),\n            markInputRule({\n                find: underscoreInputRegex,\n                type: this.type,\n            }),\n        ];\n    },\n    addPasteRules() {\n        return [\n            markPasteRule({\n                find: starPasteRegex,\n                type: this.type,\n            }),\n            markPasteRule({\n                find: underscorePasteRegex,\n                type: this.type,\n            }),\n        ];\n    },\n});\n\nexport { Bold, Bold as default, starInputRegex, starPasteRegex, underscoreInputRegex, underscorePasteRegex };\n//# sourceMappingURL=index.js.map\n","import * as React from 'react';\nvar PortalCompatContext = React.createContext(undefined);\nvar portalCompatContextDefaultValue = function() {\n    return function() {\n        return undefined;\n    };\n};\nexport var PortalCompatContextProvider = PortalCompatContext.Provider;\nexport function usePortalCompat() {\n    var _React_useContext;\n    return (_React_useContext = React.useContext(PortalCompatContext)) !== null && _React_useContext !== void 0 ? _React_useContext : portalCompatContextDefaultValue;\n}\n","import { __rest, __assign } from 'tslib';\nimport { detectAnimationFromOptions } from './utils/detect-animation-from-options.js';\nimport sync, { cancelSync } from 'framesync';\nimport { interpolate } from '../utils/interpolate.js';\nimport { hasRepeatDelayElapsed, reverseElapsed, loopElapsed } from './utils/elapsed.js';\n\nvar framesync = function (update) {\n    var passTimestamp = function (_a) {\n        var delta = _a.delta;\n        return update(delta);\n    };\n    return {\n        start: function () { return sync.update(passTimestamp, true); },\n        stop: function () { return cancelSync.update(passTimestamp); },\n    };\n};\nfunction animate(_a) {\n    var _b, _c;\n    var from = _a.from, _d = _a.autoplay, autoplay = _d === void 0 ? true : _d, _e = _a.driver, driver = _e === void 0 ? framesync : _e, _f = _a.elapsed, elapsed = _f === void 0 ? 0 : _f, _g = _a.repeat, repeatMax = _g === void 0 ? 0 : _g, _h = _a.repeatType, repeatType = _h === void 0 ? \"loop\" : _h, _j = _a.repeatDelay, repeatDelay = _j === void 0 ? 0 : _j, onPlay = _a.onPlay, onStop = _a.onStop, onComplete = _a.onComplete, onRepeat = _a.onRepeat, onUpdate = _a.onUpdate, options = __rest(_a, [\"from\", \"autoplay\", \"driver\", \"elapsed\", \"repeat\", \"repeatType\", \"repeatDelay\", \"onPlay\", \"onStop\", \"onComplete\", \"onRepeat\", \"onUpdate\"]);\n    var to = options.to;\n    var driverControls;\n    var repeatCount = 0;\n    var computedDuration = options.duration;\n    var latest;\n    var isComplete = false;\n    var isForwardPlayback = true;\n    var interpolateFromNumber;\n    var animator = detectAnimationFromOptions(options);\n    if ((_c = (_b = animator).needsInterpolation) === null || _c === void 0 ? void 0 : _c.call(_b, from, to)) {\n        interpolateFromNumber = interpolate([0, 100], [from, to], {\n            clamp: false,\n        });\n        from = 0;\n        to = 100;\n    }\n    var animation = animator(__assign(__assign({}, options), { from: from, to: to }));\n    function repeat() {\n        repeatCount++;\n        if (repeatType === \"reverse\") {\n            isForwardPlayback = repeatCount % 2 === 0;\n            elapsed = reverseElapsed(elapsed, computedDuration, repeatDelay, isForwardPlayback);\n        }\n        else {\n            elapsed = loopElapsed(elapsed, computedDuration, repeatDelay);\n            if (repeatType === \"mirror\")\n                animation.flipTarget();\n        }\n        isComplete = false;\n        onRepeat && onRepeat();\n    }\n    function complete() {\n        driverControls.stop();\n        onComplete && onComplete();\n    }\n    function update(delta) {\n        if (!isForwardPlayback)\n            delta = -delta;\n        elapsed += delta;\n        if (!isComplete) {\n            var state = animation.next(Math.max(0, elapsed));\n            latest = state.value;\n            if (interpolateFromNumber)\n                latest = interpolateFromNumber(latest);\n            isComplete = isForwardPlayback ? state.done : elapsed <= 0;\n        }\n        onUpdate === null || onUpdate === void 0 ? void 0 : onUpdate(latest);\n        if (isComplete) {\n            if (repeatCount === 0)\n                computedDuration !== null && computedDuration !== void 0 ? computedDuration : (computedDuration = elapsed);\n            if (repeatCount < repeatMax) {\n                hasRepeatDelayElapsed(elapsed, computedDuration, repeatDelay, isForwardPlayback) && repeat();\n            }\n            else {\n                complete();\n            }\n        }\n    }\n    function play() {\n        onPlay === null || onPlay === void 0 ? void 0 : onPlay();\n        driverControls = driver(update);\n        driverControls.start();\n    }\n    autoplay && play();\n    return {\n        stop: function () {\n            onStop === null || onStop === void 0 ? void 0 : onStop();\n            driverControls.stop();\n        },\n    };\n}\n\nexport { animate };\n","// TODO: duplicated from https://github.com/lahmatiy/react-render-tracker/blob/main/src/publisher/react-integration/utils/stackTrace.ts\n// once it is published as a standalone npm package, remove this file\n// Adopted version of StackTrace-Parser\n// https://github.com/errwischt/stacktrace-parser/blob/master/src/stack-trace-parser.js\nconst UNKNOWN_FUNCTION = '<unknown>';\nfunction parseStackTraceLine(line) {\n  return parseChrome(line) || parseGecko(line) || parseJSC(line);\n}\nconst chromeRe = /^\\s*at (.*?) ?\\(((?:file|https?|blob|chrome-extension|native|eval|webpack|<anonymous>|\\/|[a-z]:\\\\|\\\\\\\\).*?)?\\)?\\s*$/i;\nconst chromeRe2 = /^\\s*at ()((?:file|https?|blob|chrome-extension|native|eval|webpack|<anonymous>|\\/|[a-z]:\\\\|\\\\\\\\).*?)\\s*$/i;\nconst chromeEvalRe = /\\((\\S*)\\)/;\nfunction parseChrome(line) {\n  const parts = chromeRe.exec(line) || chromeRe2.exec(line);\n  if (!parts) {\n    return null;\n  }\n  let loc = parts[2];\n  const isNative = loc && loc.indexOf('native') === 0; // start of line\n  const isEval = loc && loc.indexOf('eval') === 0; // start of line\n  const submatch = chromeEvalRe.exec(loc);\n  if (isEval && submatch != null) {\n    // throw out eval line/column and use top-most line/column number\n    loc = submatch[1]; // url\n  }\n  return {\n    loc: !isNative ? parts[2] : null,\n    name: parts[1] || UNKNOWN_FUNCTION\n  };\n}\nconst geckoRe = /^\\s*(.*?)(?:\\((.*?)\\))?(?:^|@)((?:file|https?|blob|chrome|webpack|resource|\\[native).*?|[^@]*bundle)\\s*$/i;\nconst geckoEvalRe = /(\\S+) line (\\d+)(?: > eval line \\d+)* > eval/i;\nfunction parseGecko(line) {\n  const parts = geckoRe.exec(line);\n  if (!parts) {\n    return null;\n  }\n  let loc = parts[3];\n  const isEval = loc && loc.indexOf(' > eval') > -1;\n  const submatch = geckoEvalRe.exec(loc);\n  if (isEval && submatch != null) {\n    // throw out eval line/column and use top-most line number\n    loc = submatch[1];\n  }\n  return {\n    loc: parts[3],\n    name: parts[1] || UNKNOWN_FUNCTION\n  };\n}\nconst javaScriptCoreRe = /^\\s*(?:([^@]*)(?:\\((.*?)\\))?@)?(\\S.*?)\\s*$/i;\nfunction parseJSC(line) {\n  const parts = javaScriptCoreRe.exec(line);\n  if (!parts) {\n    return null;\n  }\n  return {\n    loc: parts[3],\n    name: parts[1] || UNKNOWN_FUNCTION\n  };\n}\n\nexport { parseStackTraceLine };\n//# sourceMappingURL=stackTrace.esm.js.map\n","// commands/index.ts\nexport * from \"prosemirror-commands\";\n","import { getParent } from './getParent';\n/**\n * Finds the first parent element where the matchFunction returns true\n * @param element - element to start searching at\n * @param matchFunction - the function that determines if the element is a match\n * @returns the matched element or null no match was found\n */\nexport function findElementRecursive(element, matchFunction, doc) {\n    // eslint-disable-next-line no-restricted-globals\n    doc !== null && doc !== void 0 ? doc : (doc = document);\n    if (!element || element === doc.body) {\n        return null;\n    }\n    return matchFunction(element) ? element : findElementRecursive(getParent(element), matchFunction);\n}\n//# sourceMappingURL=findElementRecursive.js.map","export var HighContrastSelector = '@media screen and (-ms-high-contrast: active), screen and (forced-colors: active)';\nexport var HighContrastSelectorWhite = \n// eslint-disable-next-line @fluentui/max-len\n'@media screen and (-ms-high-contrast: black-on-white), screen and (forced-colors: active) and (prefers-color-scheme: light)';\nexport var HighContrastSelectorBlack = \n// eslint-disable-next-line @fluentui/max-len\n'@media screen and (-ms-high-contrast: white-on-black), screen and (forced-colors: active) and (prefers-color-scheme: dark)';\n/**\n * @deprecated Use `HighContrastSelector`\n */\nexport var EdgeChromiumHighContrastSelector = '@media screen and (-ms-high-contrast: active), screen and (forced-colors: active)';\nexport var ScreenWidthMinSmall = 320;\nexport var ScreenWidthMinMedium = 480;\nexport var ScreenWidthMinLarge = 640;\nexport var ScreenWidthMinXLarge = 1024;\nexport var ScreenWidthMinXXLarge = 1366;\nexport var ScreenWidthMinXXXLarge = 1920;\nexport var ScreenWidthMaxSmall = ScreenWidthMinMedium - 1;\nexport var ScreenWidthMaxMedium = ScreenWidthMinLarge - 1;\nexport var ScreenWidthMaxLarge = ScreenWidthMinXLarge - 1;\nexport var ScreenWidthMaxXLarge = ScreenWidthMinXXLarge - 1;\nexport var ScreenWidthMaxXXLarge = ScreenWidthMinXXXLarge - 1;\nexport var ScreenWidthMinUhfMobile = 768;\nexport function getScreenSelector(min, max) {\n    var minSelector = typeof min === 'number' ? \" and (min-width: \".concat(min, \"px)\") : '';\n    var maxSelector = typeof max === 'number' ? \" and (max-width: \".concat(max, \"px)\") : '';\n    return \"@media only screen\".concat(minSelector).concat(maxSelector);\n}\n/**\n * The style which turns off high contrast adjustment in browsers.\n */\nexport function getHighContrastNoAdjustStyle() {\n    return {\n        forcedColorAdjust: 'none',\n        MsHighContrastAdjust: 'none',\n    };\n}\n/**\n * The style which turns off high contrast adjustment in (only) Edge Chromium browser.\n *  @deprecated Use `getHighContrastNoAdjustStyle`\n */\n// eslint-disable-next-line deprecation/deprecation\nexport function getEdgeChromiumNoHighContrastAdjustSelector() {\n    var _a;\n    return _a = {},\n        // eslint-disable-next-line deprecation/deprecation\n        _a[EdgeChromiumHighContrastSelector] = {\n            forcedColorAdjust: 'none',\n            MsHighContrastAdjust: 'none',\n        },\n        _a;\n}\n//# sourceMappingURL=CommonStyles.js.map","/** PURE_IMPORTS_START _Subscriber,_symbol_rxSubscriber,_Observer PURE_IMPORTS_END */\nimport { Subscriber } from '../Subscriber';\nimport { rxSubscriber as rxSubscriberSymbol } from '../symbol/rxSubscriber';\nimport { empty as emptyObserver } from '../Observer';\nexport function toSubscriber(nextOrObserver, error, complete) {\n    if (nextOrObserver) {\n        if (nextOrObserver instanceof Subscriber) {\n            return nextOrObserver;\n        }\n        if (nextOrObserver[rxSubscriberSymbol]) {\n            return nextOrObserver[rxSubscriberSymbol]();\n        }\n    }\n    if (!nextOrObserver && !error && !complete) {\n        return new Subscriber(emptyObserver);\n    }\n    return new Subscriber(nextOrObserver, error, complete);\n}\n//# sourceMappingURL=toSubscriber.js.map\n","import getWindow from \"./getWindow.js\";\nexport default function getComputedStyle(element) {\n  return getWindow(element).getComputedStyle(element);\n}","/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise, SuppressedError, Symbol */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\r\n    function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\r\n    var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\r\n    var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\r\n    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\r\n    var _, done = false;\r\n    for (var i = decorators.length - 1; i >= 0; i--) {\r\n        var context = {};\r\n        for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\r\n        for (var p in contextIn.access) context.access[p] = contextIn.access[p];\r\n        context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\r\n        var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\r\n        if (kind === \"accessor\") {\r\n            if (result === void 0) continue;\r\n            if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\r\n            if (_ = accept(result.get)) descriptor.get = _;\r\n            if (_ = accept(result.set)) descriptor.set = _;\r\n            if (_ = accept(result.init)) initializers.unshift(_);\r\n        }\r\n        else if (_ = accept(result)) {\r\n            if (kind === \"field\") initializers.unshift(_);\r\n            else descriptor[key] = _;\r\n        }\r\n    }\r\n    if (target) Object.defineProperty(target, contextIn.name, descriptor);\r\n    done = true;\r\n};\r\n\r\nexport function __runInitializers(thisArg, initializers, value) {\r\n    var useValue = arguments.length > 2;\r\n    for (var i = 0; i < initializers.length; i++) {\r\n        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\r\n    }\r\n    return useValue ? value : void 0;\r\n};\r\n\r\nexport function __propKey(x) {\r\n    return typeof x === \"symbol\" ? x : \"\".concat(x);\r\n};\r\n\r\nexport function __setFunctionName(f, name, prefix) {\r\n    if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\r\n    return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\r\n};\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n        desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n\r\nexport function __classPrivateFieldIn(state, receiver) {\r\n    if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\r\n    return typeof state === \"function\" ? receiver === state : state.has(receiver);\r\n}\r\n\r\nexport function __addDisposableResource(env, value, async) {\r\n    if (value !== null && value !== void 0) {\r\n        if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\r\n        var dispose;\r\n        if (async) {\r\n            if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\r\n            dispose = value[Symbol.asyncDispose];\r\n        }\r\n        if (dispose === void 0) {\r\n            if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\r\n            dispose = value[Symbol.dispose];\r\n        }\r\n        if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\r\n        env.stack.push({ value: value, dispose: dispose, async: async });\r\n    }\r\n    else if (async) {\r\n        env.stack.push({ async: true });\r\n    }\r\n    return value;\r\n}\r\n\r\nvar _SuppressedError = typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n    var e = new Error(message);\r\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n};\r\n\r\nexport function __disposeResources(env) {\r\n    function fail(e) {\r\n        env.error = env.hasError ? new _SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\r\n        env.hasError = true;\r\n    }\r\n    function next() {\r\n        while (env.stack.length) {\r\n            var rec = env.stack.pop();\r\n            try {\r\n                var result = rec.dispose && rec.dispose.call(rec.value);\r\n                if (rec.async) return Promise.resolve(result).then(next, function(e) { fail(e); return next(); });\r\n            }\r\n            catch (e) {\r\n                fail(e);\r\n            }\r\n        }\r\n        if (env.hasError) throw env.error;\r\n    }\r\n    return next();\r\n}\r\n\r\nexport default {\r\n    __extends: __extends,\r\n    __assign: __assign,\r\n    __rest: __rest,\r\n    __decorate: __decorate,\r\n    __param: __param,\r\n    __metadata: __metadata,\r\n    __awaiter: __awaiter,\r\n    __generator: __generator,\r\n    __createBinding: __createBinding,\r\n    __exportStar: __exportStar,\r\n    __values: __values,\r\n    __read: __read,\r\n    __spread: __spread,\r\n    __spreadArrays: __spreadArrays,\r\n    __spreadArray: __spreadArray,\r\n    __await: __await,\r\n    __asyncGenerator: __asyncGenerator,\r\n    __asyncDelegator: __asyncDelegator,\r\n    __asyncValues: __asyncValues,\r\n    __makeTemplateObject: __makeTemplateObject,\r\n    __importStar: __importStar,\r\n    __importDefault: __importDefault,\r\n    __classPrivateFieldGet: __classPrivateFieldGet,\r\n    __classPrivateFieldSet: __classPrivateFieldSet,\r\n    __classPrivateFieldIn: __classPrivateFieldIn,\r\n    __addDisposableResource: __addDisposableResource,\r\n    __disposeResources: __disposeResources,\r\n};\r\n","var mix = function (from, to, progress) {\n    return -progress * from + progress * to + from;\n};\n\nexport { mix };\n","import _typeof from \"./typeof.js\";\nimport toPrimitive from \"./toPrimitive.js\";\nexport default function _toPropertyKey(arg) {\n  var key = toPrimitive(arg, \"string\");\n  return _typeof(key) === \"symbol\" ? key : String(key);\n}","import { isPoint } from './is-point.js';\n\nvar isPoint3D = function (point) {\n    return isPoint(point) && point.hasOwnProperty('z');\n};\n\nexport { isPoint3D };\n","import { Slice, Fragment, Mark, Node } from 'prosemirror-model';\nimport { ReplaceStep, ReplaceAroundStep, Transform } from 'prosemirror-transform';\n\nconst classesById = Object.create(null);\n/**\nSuperclass for editor selections. Every selection type should\nextend this. Should not be instantiated directly.\n*/\nclass Selection {\n    /**\n    Initialize a selection with the head and anchor and ranges. If no\n    ranges are given, constructs a single range across `$anchor` and\n    `$head`.\n    */\n    constructor(\n    /**\n    The resolved anchor of the selection (the side that stays in\n    place when the selection is modified).\n    */\n    $anchor, \n    /**\n    The resolved head of the selection (the side that moves when\n    the selection is modified).\n    */\n    $head, ranges) {\n        this.$anchor = $anchor;\n        this.$head = $head;\n        this.ranges = ranges || [new SelectionRange($anchor.min($head), $anchor.max($head))];\n    }\n    /**\n    The selection's anchor, as an unresolved position.\n    */\n    get anchor() { return this.$anchor.pos; }\n    /**\n    The selection's head.\n    */\n    get head() { return this.$head.pos; }\n    /**\n    The lower bound of the selection's main range.\n    */\n    get from() { return this.$from.pos; }\n    /**\n    The upper bound of the selection's main range.\n    */\n    get to() { return this.$to.pos; }\n    /**\n    The resolved lower  bound of the selection's main range.\n    */\n    get $from() {\n        return this.ranges[0].$from;\n    }\n    /**\n    The resolved upper bound of the selection's main range.\n    */\n    get $to() {\n        return this.ranges[0].$to;\n    }\n    /**\n    Indicates whether the selection contains any content.\n    */\n    get empty() {\n        let ranges = this.ranges;\n        for (let i = 0; i < ranges.length; i++)\n            if (ranges[i].$from.pos != ranges[i].$to.pos)\n                return false;\n        return true;\n    }\n    /**\n    Get the content of this selection as a slice.\n    */\n    content() {\n        return this.$from.doc.slice(this.from, this.to, true);\n    }\n    /**\n    Replace the selection with a slice or, if no slice is given,\n    delete the selection. Will append to the given transaction.\n    */\n    replace(tr, content = Slice.empty) {\n        // Put the new selection at the position after the inserted\n        // content. When that ended in an inline node, search backwards,\n        // to get the position after that node. If not, search forward.\n        let lastNode = content.content.lastChild, lastParent = null;\n        for (let i = 0; i < content.openEnd; i++) {\n            lastParent = lastNode;\n            lastNode = lastNode.lastChild;\n        }\n        let mapFrom = tr.steps.length, ranges = this.ranges;\n        for (let i = 0; i < ranges.length; i++) {\n            let { $from, $to } = ranges[i], mapping = tr.mapping.slice(mapFrom);\n            tr.replaceRange(mapping.map($from.pos), mapping.map($to.pos), i ? Slice.empty : content);\n            if (i == 0)\n                selectionToInsertionEnd(tr, mapFrom, (lastNode ? lastNode.isInline : lastParent && lastParent.isTextblock) ? -1 : 1);\n        }\n    }\n    /**\n    Replace the selection with the given node, appending the changes\n    to the given transaction.\n    */\n    replaceWith(tr, node) {\n        let mapFrom = tr.steps.length, ranges = this.ranges;\n        for (let i = 0; i < ranges.length; i++) {\n            let { $from, $to } = ranges[i], mapping = tr.mapping.slice(mapFrom);\n            let from = mapping.map($from.pos), to = mapping.map($to.pos);\n            if (i) {\n                tr.deleteRange(from, to);\n            }\n            else {\n                tr.replaceRangeWith(from, to, node);\n                selectionToInsertionEnd(tr, mapFrom, node.isInline ? -1 : 1);\n            }\n        }\n    }\n    /**\n    Find a valid cursor or leaf node selection starting at the given\n    position and searching back if `dir` is negative, and forward if\n    positive. When `textOnly` is true, only consider cursor\n    selections. Will return null when no valid selection position is\n    found.\n    */\n    static findFrom($pos, dir, textOnly = false) {\n        let inner = $pos.parent.inlineContent ? new TextSelection($pos)\n            : findSelectionIn($pos.node(0), $pos.parent, $pos.pos, $pos.index(), dir, textOnly);\n        if (inner)\n            return inner;\n        for (let depth = $pos.depth - 1; depth >= 0; depth--) {\n            let found = dir < 0\n                ? findSelectionIn($pos.node(0), $pos.node(depth), $pos.before(depth + 1), $pos.index(depth), dir, textOnly)\n                : findSelectionIn($pos.node(0), $pos.node(depth), $pos.after(depth + 1), $pos.index(depth) + 1, dir, textOnly);\n            if (found)\n                return found;\n        }\n        return null;\n    }\n    /**\n    Find a valid cursor or leaf node selection near the given\n    position. Searches forward first by default, but if `bias` is\n    negative, it will search backwards first.\n    */\n    static near($pos, bias = 1) {\n        return this.findFrom($pos, bias) || this.findFrom($pos, -bias) || new AllSelection($pos.node(0));\n    }\n    /**\n    Find the cursor or leaf node selection closest to the start of\n    the given document. Will return an\n    [`AllSelection`](https://prosemirror.net/docs/ref/#state.AllSelection) if no valid position\n    exists.\n    */\n    static atStart(doc) {\n        return findSelectionIn(doc, doc, 0, 0, 1) || new AllSelection(doc);\n    }\n    /**\n    Find the cursor or leaf node selection closest to the end of the\n    given document.\n    */\n    static atEnd(doc) {\n        return findSelectionIn(doc, doc, doc.content.size, doc.childCount, -1) || new AllSelection(doc);\n    }\n    /**\n    Deserialize the JSON representation of a selection. Must be\n    implemented for custom classes (as a static class method).\n    */\n    static fromJSON(doc, json) {\n        if (!json || !json.type)\n            throw new RangeError(\"Invalid input for Selection.fromJSON\");\n        let cls = classesById[json.type];\n        if (!cls)\n            throw new RangeError(`No selection type ${json.type} defined`);\n        return cls.fromJSON(doc, json);\n    }\n    /**\n    To be able to deserialize selections from JSON, custom selection\n    classes must register themselves with an ID string, so that they\n    can be disambiguated. Try to pick something that's unlikely to\n    clash with classes from other modules.\n    */\n    static jsonID(id, selectionClass) {\n        if (id in classesById)\n            throw new RangeError(\"Duplicate use of selection JSON ID \" + id);\n        classesById[id] = selectionClass;\n        selectionClass.prototype.jsonID = id;\n        return selectionClass;\n    }\n    /**\n    Get a [bookmark](https://prosemirror.net/docs/ref/#state.SelectionBookmark) for this selection,\n    which is a value that can be mapped without having access to a\n    current document, and later resolved to a real selection for a\n    given document again. (This is used mostly by the history to\n    track and restore old selections.) The default implementation of\n    this method just converts the selection to a text selection and\n    returns the bookmark for that.\n    */\n    getBookmark() {\n        return TextSelection.between(this.$anchor, this.$head).getBookmark();\n    }\n}\nSelection.prototype.visible = true;\n/**\nRepresents a selected range in a document.\n*/\nclass SelectionRange {\n    /**\n    Create a range.\n    */\n    constructor(\n    /**\n    The lower bound of the range.\n    */\n    $from, \n    /**\n    The upper bound of the range.\n    */\n    $to) {\n        this.$from = $from;\n        this.$to = $to;\n    }\n}\nlet warnedAboutTextSelection = false;\nfunction checkTextSelection($pos) {\n    if (!warnedAboutTextSelection && !$pos.parent.inlineContent) {\n        warnedAboutTextSelection = true;\n        console[\"warn\"](\"TextSelection endpoint not pointing into a node with inline content (\" + $pos.parent.type.name + \")\");\n    }\n}\n/**\nA text selection represents a classical editor selection, with a\nhead (the moving side) and anchor (immobile side), both of which\npoint into textblock nodes. It can be empty (a regular cursor\nposition).\n*/\nclass TextSelection extends Selection {\n    /**\n    Construct a text selection between the given points.\n    */\n    constructor($anchor, $head = $anchor) {\n        checkTextSelection($anchor);\n        checkTextSelection($head);\n        super($anchor, $head);\n    }\n    /**\n    Returns a resolved position if this is a cursor selection (an\n    empty text selection), and null otherwise.\n    */\n    get $cursor() { return this.$anchor.pos == this.$head.pos ? this.$head : null; }\n    map(doc, mapping) {\n        let $head = doc.resolve(mapping.map(this.head));\n        if (!$head.parent.inlineContent)\n            return Selection.near($head);\n        let $anchor = doc.resolve(mapping.map(this.anchor));\n        return new TextSelection($anchor.parent.inlineContent ? $anchor : $head, $head);\n    }\n    replace(tr, content = Slice.empty) {\n        super.replace(tr, content);\n        if (content == Slice.empty) {\n            let marks = this.$from.marksAcross(this.$to);\n            if (marks)\n                tr.ensureMarks(marks);\n        }\n    }\n    eq(other) {\n        return other instanceof TextSelection && other.anchor == this.anchor && other.head == this.head;\n    }\n    getBookmark() {\n        return new TextBookmark(this.anchor, this.head);\n    }\n    toJSON() {\n        return { type: \"text\", anchor: this.anchor, head: this.head };\n    }\n    /**\n    @internal\n    */\n    static fromJSON(doc, json) {\n        if (typeof json.anchor != \"number\" || typeof json.head != \"number\")\n            throw new RangeError(\"Invalid input for TextSelection.fromJSON\");\n        return new TextSelection(doc.resolve(json.anchor), doc.resolve(json.head));\n    }\n    /**\n    Create a text selection from non-resolved positions.\n    */\n    static create(doc, anchor, head = anchor) {\n        let $anchor = doc.resolve(anchor);\n        return new this($anchor, head == anchor ? $anchor : doc.resolve(head));\n    }\n    /**\n    Return a text selection that spans the given positions or, if\n    they aren't text positions, find a text selection near them.\n    `bias` determines whether the method searches forward (default)\n    or backwards (negative number) first. Will fall back to calling\n    [`Selection.near`](https://prosemirror.net/docs/ref/#state.Selection^near) when the document\n    doesn't contain a valid text position.\n    */\n    static between($anchor, $head, bias) {\n        let dPos = $anchor.pos - $head.pos;\n        if (!bias || dPos)\n            bias = dPos >= 0 ? 1 : -1;\n        if (!$head.parent.inlineContent) {\n            let found = Selection.findFrom($head, bias, true) || Selection.findFrom($head, -bias, true);\n            if (found)\n                $head = found.$head;\n            else\n                return Selection.near($head, bias);\n        }\n        if (!$anchor.parent.inlineContent) {\n            if (dPos == 0) {\n                $anchor = $head;\n            }\n            else {\n                $anchor = (Selection.findFrom($anchor, -bias, true) || Selection.findFrom($anchor, bias, true)).$anchor;\n                if (($anchor.pos < $head.pos) != (dPos < 0))\n                    $anchor = $head;\n            }\n        }\n        return new TextSelection($anchor, $head);\n    }\n}\nSelection.jsonID(\"text\", TextSelection);\nclass TextBookmark {\n    constructor(anchor, head) {\n        this.anchor = anchor;\n        this.head = head;\n    }\n    map(mapping) {\n        return new TextBookmark(mapping.map(this.anchor), mapping.map(this.head));\n    }\n    resolve(doc) {\n        return TextSelection.between(doc.resolve(this.anchor), doc.resolve(this.head));\n    }\n}\n/**\nA node selection is a selection that points at a single node. All\nnodes marked [selectable](https://prosemirror.net/docs/ref/#model.NodeSpec.selectable) can be the\ntarget of a node selection. In such a selection, `from` and `to`\npoint directly before and after the selected node, `anchor` equals\n`from`, and `head` equals `to`..\n*/\nclass NodeSelection extends Selection {\n    /**\n    Create a node selection. Does not verify the validity of its\n    argument.\n    */\n    constructor($pos) {\n        let node = $pos.nodeAfter;\n        let $end = $pos.node(0).resolve($pos.pos + node.nodeSize);\n        super($pos, $end);\n        this.node = node;\n    }\n    map(doc, mapping) {\n        let { deleted, pos } = mapping.mapResult(this.anchor);\n        let $pos = doc.resolve(pos);\n        if (deleted)\n            return Selection.near($pos);\n        return new NodeSelection($pos);\n    }\n    content() {\n        return new Slice(Fragment.from(this.node), 0, 0);\n    }\n    eq(other) {\n        return other instanceof NodeSelection && other.anchor == this.anchor;\n    }\n    toJSON() {\n        return { type: \"node\", anchor: this.anchor };\n    }\n    getBookmark() { return new NodeBookmark(this.anchor); }\n    /**\n    @internal\n    */\n    static fromJSON(doc, json) {\n        if (typeof json.anchor != \"number\")\n            throw new RangeError(\"Invalid input for NodeSelection.fromJSON\");\n        return new NodeSelection(doc.resolve(json.anchor));\n    }\n    /**\n    Create a node selection from non-resolved positions.\n    */\n    static create(doc, from) {\n        return new NodeSelection(doc.resolve(from));\n    }\n    /**\n    Determines whether the given node may be selected as a node\n    selection.\n    */\n    static isSelectable(node) {\n        return !node.isText && node.type.spec.selectable !== false;\n    }\n}\nNodeSelection.prototype.visible = false;\nSelection.jsonID(\"node\", NodeSelection);\nclass NodeBookmark {\n    constructor(anchor) {\n        this.anchor = anchor;\n    }\n    map(mapping) {\n        let { deleted, pos } = mapping.mapResult(this.anchor);\n        return deleted ? new TextBookmark(pos, pos) : new NodeBookmark(pos);\n    }\n    resolve(doc) {\n        let $pos = doc.resolve(this.anchor), node = $pos.nodeAfter;\n        if (node && NodeSelection.isSelectable(node))\n            return new NodeSelection($pos);\n        return Selection.near($pos);\n    }\n}\n/**\nA selection type that represents selecting the whole document\n(which can not necessarily be expressed with a text selection, when\nthere are for example leaf block nodes at the start or end of the\ndocument).\n*/\nclass AllSelection extends Selection {\n    /**\n    Create an all-selection over the given document.\n    */\n    constructor(doc) {\n        super(doc.resolve(0), doc.resolve(doc.content.size));\n    }\n    replace(tr, content = Slice.empty) {\n        if (content == Slice.empty) {\n            tr.delete(0, tr.doc.content.size);\n            let sel = Selection.atStart(tr.doc);\n            if (!sel.eq(tr.selection))\n                tr.setSelection(sel);\n        }\n        else {\n            super.replace(tr, content);\n        }\n    }\n    toJSON() { return { type: \"all\" }; }\n    /**\n    @internal\n    */\n    static fromJSON(doc) { return new AllSelection(doc); }\n    map(doc) { return new AllSelection(doc); }\n    eq(other) { return other instanceof AllSelection; }\n    getBookmark() { return AllBookmark; }\n}\nSelection.jsonID(\"all\", AllSelection);\nconst AllBookmark = {\n    map() { return this; },\n    resolve(doc) { return new AllSelection(doc); }\n};\n// FIXME we'll need some awareness of text direction when scanning for selections\n// Try to find a selection inside the given node. `pos` points at the\n// position where the search starts. When `text` is true, only return\n// text selections.\nfunction findSelectionIn(doc, node, pos, index, dir, text = false) {\n    if (node.inlineContent)\n        return TextSelection.create(doc, pos);\n    for (let i = index - (dir > 0 ? 0 : 1); dir > 0 ? i < node.childCount : i >= 0; i += dir) {\n        let child = node.child(i);\n        if (!child.isAtom) {\n            let inner = findSelectionIn(doc, child, pos + dir, dir < 0 ? child.childCount : 0, dir, text);\n            if (inner)\n                return inner;\n        }\n        else if (!text && NodeSelection.isSelectable(child)) {\n            return NodeSelection.create(doc, pos - (dir < 0 ? child.nodeSize : 0));\n        }\n        pos += child.nodeSize * dir;\n    }\n    return null;\n}\nfunction selectionToInsertionEnd(tr, startLen, bias) {\n    let last = tr.steps.length - 1;\n    if (last < startLen)\n        return;\n    let step = tr.steps[last];\n    if (!(step instanceof ReplaceStep || step instanceof ReplaceAroundStep))\n        return;\n    let map = tr.mapping.maps[last], end;\n    map.forEach((_from, _to, _newFrom, newTo) => { if (end == null)\n        end = newTo; });\n    tr.setSelection(Selection.near(tr.doc.resolve(end), bias));\n}\n\nconst UPDATED_SEL = 1, UPDATED_MARKS = 2, UPDATED_SCROLL = 4;\n/**\nAn editor state transaction, which can be applied to a state to\ncreate an updated state. Use\n[`EditorState.tr`](https://prosemirror.net/docs/ref/#state.EditorState.tr) to create an instance.\n\nTransactions track changes to the document (they are a subclass of\n[`Transform`](https://prosemirror.net/docs/ref/#transform.Transform)), but also other state changes,\nlike selection updates and adjustments of the set of [stored\nmarks](https://prosemirror.net/docs/ref/#state.EditorState.storedMarks). In addition, you can store\nmetadata properties in a transaction, which are extra pieces of\ninformation that client code or plugins can use to describe what a\ntransaction represents, so that they can update their [own\nstate](https://prosemirror.net/docs/ref/#state.StateField) accordingly.\n\nThe [editor view](https://prosemirror.net/docs/ref/#view.EditorView) uses a few metadata\nproperties: it will attach a property `\"pointer\"` with the value\n`true` to selection transactions directly caused by mouse or touch\ninput, a `\"composition\"` property holding an ID identifying the\ncomposition that caused it to transactions caused by composed DOM\ninput, and a `\"uiEvent\"` property of that may be `\"paste\"`,\n`\"cut\"`, or `\"drop\"`.\n*/\nclass Transaction extends Transform {\n    /**\n    @internal\n    */\n    constructor(state) {\n        super(state.doc);\n        // The step count for which the current selection is valid.\n        this.curSelectionFor = 0;\n        // Bitfield to track which aspects of the state were updated by\n        // this transaction.\n        this.updated = 0;\n        // Object used to store metadata properties for the transaction.\n        this.meta = Object.create(null);\n        this.time = Date.now();\n        this.curSelection = state.selection;\n        this.storedMarks = state.storedMarks;\n    }\n    /**\n    The transaction's current selection. This defaults to the editor\n    selection [mapped](https://prosemirror.net/docs/ref/#state.Selection.map) through the steps in the\n    transaction, but can be overwritten with\n    [`setSelection`](https://prosemirror.net/docs/ref/#state.Transaction.setSelection).\n    */\n    get selection() {\n        if (this.curSelectionFor < this.steps.length) {\n            this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor));\n            this.curSelectionFor = this.steps.length;\n        }\n        return this.curSelection;\n    }\n    /**\n    Update the transaction's current selection. Will determine the\n    selection that the editor gets when the transaction is applied.\n    */\n    setSelection(selection) {\n        if (selection.$from.doc != this.doc)\n            throw new RangeError(\"Selection passed to setSelection must point at the current document\");\n        this.curSelection = selection;\n        this.curSelectionFor = this.steps.length;\n        this.updated = (this.updated | UPDATED_SEL) & ~UPDATED_MARKS;\n        this.storedMarks = null;\n        return this;\n    }\n    /**\n    Whether the selection was explicitly updated by this transaction.\n    */\n    get selectionSet() {\n        return (this.updated & UPDATED_SEL) > 0;\n    }\n    /**\n    Set the current stored marks.\n    */\n    setStoredMarks(marks) {\n        this.storedMarks = marks;\n        this.updated |= UPDATED_MARKS;\n        return this;\n    }\n    /**\n    Make sure the current stored marks or, if that is null, the marks\n    at the selection, match the given set of marks. Does nothing if\n    this is already the case.\n    */\n    ensureMarks(marks) {\n        if (!Mark.sameSet(this.storedMarks || this.selection.$from.marks(), marks))\n            this.setStoredMarks(marks);\n        return this;\n    }\n    /**\n    Add a mark to the set of stored marks.\n    */\n    addStoredMark(mark) {\n        return this.ensureMarks(mark.addToSet(this.storedMarks || this.selection.$head.marks()));\n    }\n    /**\n    Remove a mark or mark type from the set of stored marks.\n    */\n    removeStoredMark(mark) {\n        return this.ensureMarks(mark.removeFromSet(this.storedMarks || this.selection.$head.marks()));\n    }\n    /**\n    Whether the stored marks were explicitly set for this transaction.\n    */\n    get storedMarksSet() {\n        return (this.updated & UPDATED_MARKS) > 0;\n    }\n    /**\n    @internal\n    */\n    addStep(step, doc) {\n        super.addStep(step, doc);\n        this.updated = this.updated & ~UPDATED_MARKS;\n        this.storedMarks = null;\n    }\n    /**\n    Update the timestamp for the transaction.\n    */\n    setTime(time) {\n        this.time = time;\n        return this;\n    }\n    /**\n    Replace the current selection with the given slice.\n    */\n    replaceSelection(slice) {\n        this.selection.replace(this, slice);\n        return this;\n    }\n    /**\n    Replace the selection with the given node. When `inheritMarks` is\n    true and the content is inline, it inherits the marks from the\n    place where it is inserted.\n    */\n    replaceSelectionWith(node, inheritMarks = true) {\n        let selection = this.selection;\n        if (inheritMarks)\n            node = node.mark(this.storedMarks || (selection.empty ? selection.$from.marks() : (selection.$from.marksAcross(selection.$to) || Mark.none)));\n        selection.replaceWith(this, node);\n        return this;\n    }\n    /**\n    Delete the selection.\n    */\n    deleteSelection() {\n        this.selection.replace(this);\n        return this;\n    }\n    /**\n    Replace the given range, or the selection if no range is given,\n    with a text node containing the given string.\n    */\n    insertText(text, from, to) {\n        let schema = this.doc.type.schema;\n        if (from == null) {\n            if (!text)\n                return this.deleteSelection();\n            return this.replaceSelectionWith(schema.text(text), true);\n        }\n        else {\n            if (to == null)\n                to = from;\n            to = to == null ? from : to;\n            if (!text)\n                return this.deleteRange(from, to);\n            let marks = this.storedMarks;\n            if (!marks) {\n                let $from = this.doc.resolve(from);\n                marks = to == from ? $from.marks() : $from.marksAcross(this.doc.resolve(to));\n            }\n            this.replaceRangeWith(from, to, schema.text(text, marks));\n            if (!this.selection.empty)\n                this.setSelection(Selection.near(this.selection.$to));\n            return this;\n        }\n    }\n    /**\n    Store a metadata property in this transaction, keyed either by\n    name or by plugin.\n    */\n    setMeta(key, value) {\n        this.meta[typeof key == \"string\" ? key : key.key] = value;\n        return this;\n    }\n    /**\n    Retrieve a metadata property for a given name or plugin.\n    */\n    getMeta(key) {\n        return this.meta[typeof key == \"string\" ? key : key.key];\n    }\n    /**\n    Returns true if this transaction doesn't contain any metadata,\n    and can thus safely be extended.\n    */\n    get isGeneric() {\n        for (let _ in this.meta)\n            return false;\n        return true;\n    }\n    /**\n    Indicate that the editor should scroll the selection into view\n    when updated to the state produced by this transaction.\n    */\n    scrollIntoView() {\n        this.updated |= UPDATED_SCROLL;\n        return this;\n    }\n    /**\n    True when this transaction has had `scrollIntoView` called on it.\n    */\n    get scrolledIntoView() {\n        return (this.updated & UPDATED_SCROLL) > 0;\n    }\n}\n\nfunction bind(f, self) {\n    return !self || !f ? f : f.bind(self);\n}\nclass FieldDesc {\n    constructor(name, desc, self) {\n        this.name = name;\n        this.init = bind(desc.init, self);\n        this.apply = bind(desc.apply, self);\n    }\n}\nconst baseFields = [\n    new FieldDesc(\"doc\", {\n        init(config) { return config.doc || config.schema.topNodeType.createAndFill(); },\n        apply(tr) { return tr.doc; }\n    }),\n    new FieldDesc(\"selection\", {\n        init(config, instance) { return config.selection || Selection.atStart(instance.doc); },\n        apply(tr) { return tr.selection; }\n    }),\n    new FieldDesc(\"storedMarks\", {\n        init(config) { return config.storedMarks || null; },\n        apply(tr, _marks, _old, state) { return state.selection.$cursor ? tr.storedMarks : null; }\n    }),\n    new FieldDesc(\"scrollToSelection\", {\n        init() { return 0; },\n        apply(tr, prev) { return tr.scrolledIntoView ? prev + 1 : prev; }\n    })\n];\n// Object wrapping the part of a state object that stays the same\n// across transactions. Stored in the state's `config` property.\nclass Configuration {\n    constructor(schema, plugins) {\n        this.schema = schema;\n        this.plugins = [];\n        this.pluginsByKey = Object.create(null);\n        this.fields = baseFields.slice();\n        if (plugins)\n            plugins.forEach(plugin => {\n                if (this.pluginsByKey[plugin.key])\n                    throw new RangeError(\"Adding different instances of a keyed plugin (\" + plugin.key + \")\");\n                this.plugins.push(plugin);\n                this.pluginsByKey[plugin.key] = plugin;\n                if (plugin.spec.state)\n                    this.fields.push(new FieldDesc(plugin.key, plugin.spec.state, plugin));\n            });\n    }\n}\n/**\nThe state of a ProseMirror editor is represented by an object of\nthis type. A state is a persistent data structureit isn't\nupdated, but rather a new state value is computed from an old one\nusing the [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) method.\n\nA state holds a number of built-in fields, and plugins can\n[define](https://prosemirror.net/docs/ref/#state.PluginSpec.state) additional fields.\n*/\nclass EditorState {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    @internal\n    */\n    config) {\n        this.config = config;\n    }\n    /**\n    The schema of the state's document.\n    */\n    get schema() {\n        return this.config.schema;\n    }\n    /**\n    The plugins that are active in this state.\n    */\n    get plugins() {\n        return this.config.plugins;\n    }\n    /**\n    Apply the given transaction to produce a new state.\n    */\n    apply(tr) {\n        return this.applyTransaction(tr).state;\n    }\n    /**\n    @internal\n    */\n    filterTransaction(tr, ignore = -1) {\n        for (let i = 0; i < this.config.plugins.length; i++)\n            if (i != ignore) {\n                let plugin = this.config.plugins[i];\n                if (plugin.spec.filterTransaction && !plugin.spec.filterTransaction.call(plugin, tr, this))\n                    return false;\n            }\n        return true;\n    }\n    /**\n    Verbose variant of [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) that\n    returns the precise transactions that were applied (which might\n    be influenced by the [transaction\n    hooks](https://prosemirror.net/docs/ref/#state.PluginSpec.filterTransaction) of\n    plugins) along with the new state.\n    */\n    applyTransaction(rootTr) {\n        if (!this.filterTransaction(rootTr))\n            return { state: this, transactions: [] };\n        let trs = [rootTr], newState = this.applyInner(rootTr), seen = null;\n        // This loop repeatedly gives plugins a chance to respond to\n        // transactions as new transactions are added, making sure to only\n        // pass the transactions the plugin did not see before.\n        for (;;) {\n            let haveNew = false;\n            for (let i = 0; i < this.config.plugins.length; i++) {\n                let plugin = this.config.plugins[i];\n                if (plugin.spec.appendTransaction) {\n                    let n = seen ? seen[i].n : 0, oldState = seen ? seen[i].state : this;\n                    let tr = n < trs.length &&\n                        plugin.spec.appendTransaction.call(plugin, n ? trs.slice(n) : trs, oldState, newState);\n                    if (tr && newState.filterTransaction(tr, i)) {\n                        tr.setMeta(\"appendedTransaction\", rootTr);\n                        if (!seen) {\n                            seen = [];\n                            for (let j = 0; j < this.config.plugins.length; j++)\n                                seen.push(j < i ? { state: newState, n: trs.length } : { state: this, n: 0 });\n                        }\n                        trs.push(tr);\n                        newState = newState.applyInner(tr);\n                        haveNew = true;\n                    }\n                    if (seen)\n                        seen[i] = { state: newState, n: trs.length };\n                }\n            }\n            if (!haveNew)\n                return { state: newState, transactions: trs };\n        }\n    }\n    /**\n    @internal\n    */\n    applyInner(tr) {\n        if (!tr.before.eq(this.doc))\n            throw new RangeError(\"Applying a mismatched transaction\");\n        let newInstance = new EditorState(this.config), fields = this.config.fields;\n        for (let i = 0; i < fields.length; i++) {\n            let field = fields[i];\n            newInstance[field.name] = field.apply(tr, this[field.name], this, newInstance);\n        }\n        return newInstance;\n    }\n    /**\n    Start a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) from this state.\n    */\n    get tr() { return new Transaction(this); }\n    /**\n    Create a new state.\n    */\n    static create(config) {\n        let $config = new Configuration(config.doc ? config.doc.type.schema : config.schema, config.plugins);\n        let instance = new EditorState($config);\n        for (let i = 0; i < $config.fields.length; i++)\n            instance[$config.fields[i].name] = $config.fields[i].init(config, instance);\n        return instance;\n    }\n    /**\n    Create a new state based on this one, but with an adjusted set\n    of active plugins. State fields that exist in both sets of\n    plugins are kept unchanged. Those that no longer exist are\n    dropped, and those that are new are initialized using their\n    [`init`](https://prosemirror.net/docs/ref/#state.StateField.init) method, passing in the new\n    configuration object..\n    */\n    reconfigure(config) {\n        let $config = new Configuration(this.schema, config.plugins);\n        let fields = $config.fields, instance = new EditorState($config);\n        for (let i = 0; i < fields.length; i++) {\n            let name = fields[i].name;\n            instance[name] = this.hasOwnProperty(name) ? this[name] : fields[i].init(config, instance);\n        }\n        return instance;\n    }\n    /**\n    Serialize this state to JSON. If you want to serialize the state\n    of plugins, pass an object mapping property names to use in the\n    resulting JSON object to plugin objects. The argument may also be\n    a string or number, in which case it is ignored, to support the\n    way `JSON.stringify` calls `toString` methods.\n    */\n    toJSON(pluginFields) {\n        let result = { doc: this.doc.toJSON(), selection: this.selection.toJSON() };\n        if (this.storedMarks)\n            result.storedMarks = this.storedMarks.map(m => m.toJSON());\n        if (pluginFields && typeof pluginFields == 'object')\n            for (let prop in pluginFields) {\n                if (prop == \"doc\" || prop == \"selection\")\n                    throw new RangeError(\"The JSON fields `doc` and `selection` are reserved\");\n                let plugin = pluginFields[prop], state = plugin.spec.state;\n                if (state && state.toJSON)\n                    result[prop] = state.toJSON.call(plugin, this[plugin.key]);\n            }\n        return result;\n    }\n    /**\n    Deserialize a JSON representation of a state. `config` should\n    have at least a `schema` field, and should contain array of\n    plugins to initialize the state with. `pluginFields` can be used\n    to deserialize the state of plugins, by associating plugin\n    instances with the property names they use in the JSON object.\n    */\n    static fromJSON(config, json, pluginFields) {\n        if (!json)\n            throw new RangeError(\"Invalid input for EditorState.fromJSON\");\n        if (!config.schema)\n            throw new RangeError(\"Required config field 'schema' missing\");\n        let $config = new Configuration(config.schema, config.plugins);\n        let instance = new EditorState($config);\n        $config.fields.forEach(field => {\n            if (field.name == \"doc\") {\n                instance.doc = Node.fromJSON(config.schema, json.doc);\n            }\n            else if (field.name == \"selection\") {\n                instance.selection = Selection.fromJSON(instance.doc, json.selection);\n            }\n            else if (field.name == \"storedMarks\") {\n                if (json.storedMarks)\n                    instance.storedMarks = json.storedMarks.map(config.schema.markFromJSON);\n            }\n            else {\n                if (pluginFields)\n                    for (let prop in pluginFields) {\n                        let plugin = pluginFields[prop], state = plugin.spec.state;\n                        if (plugin.key == field.name && state && state.fromJSON &&\n                            Object.prototype.hasOwnProperty.call(json, prop)) {\n                            instance[field.name] = state.fromJSON.call(plugin, config, json[prop], instance);\n                            return;\n                        }\n                    }\n                instance[field.name] = field.init(config, instance);\n            }\n        });\n        return instance;\n    }\n}\n\nfunction bindProps(obj, self, target) {\n    for (let prop in obj) {\n        let val = obj[prop];\n        if (val instanceof Function)\n            val = val.bind(self);\n        else if (prop == \"handleDOMEvents\")\n            val = bindProps(val, self, {});\n        target[prop] = val;\n    }\n    return target;\n}\n/**\nPlugins bundle functionality that can be added to an editor.\nThey are part of the [editor state](https://prosemirror.net/docs/ref/#state.EditorState) and\nmay influence that state and the view that contains it.\n*/\nclass Plugin {\n    /**\n    Create a plugin.\n    */\n    constructor(\n    /**\n    The plugin's [spec object](https://prosemirror.net/docs/ref/#state.PluginSpec).\n    */\n    spec) {\n        this.spec = spec;\n        /**\n        The [props](https://prosemirror.net/docs/ref/#view.EditorProps) exported by this plugin.\n        */\n        this.props = {};\n        if (spec.props)\n            bindProps(spec.props, this, this.props);\n        this.key = spec.key ? spec.key.key : createKey(\"plugin\");\n    }\n    /**\n    Extract the plugin's state field from an editor state.\n    */\n    getState(state) { return state[this.key]; }\n}\nconst keys = Object.create(null);\nfunction createKey(name) {\n    if (name in keys)\n        return name + \"$\" + ++keys[name];\n    keys[name] = 0;\n    return name + \"$\";\n}\n/**\nA key is used to [tag](https://prosemirror.net/docs/ref/#state.PluginSpec.key) plugins in a way\nthat makes it possible to find them, given an editor state.\nAssigning a key does mean only one plugin of that type can be\nactive in a state.\n*/\nclass PluginKey {\n    /**\n    Create a plugin key.\n    */\n    constructor(name = \"key\") { this.key = createKey(name); }\n    /**\n    Get the active plugin with this key, if any, from an editor\n    state.\n    */\n    get(state) { return state.config.pluginsByKey[this.key]; }\n    /**\n    Get the plugin's state from an editor state.\n    */\n    getState(state) { return state[this.key]; }\n}\n\nexport { AllSelection, EditorState, NodeSelection, Plugin, PluginKey, Selection, SelectionRange, TextSelection, Transaction };\n","/** PURE_IMPORTS_START tslib,_util_isFunction,_Observer,_Subscription,_internal_symbol_rxSubscriber,_config,_util_hostReportError PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { isFunction } from './util/isFunction';\nimport { empty as emptyObserver } from './Observer';\nimport { Subscription } from './Subscription';\nimport { rxSubscriber as rxSubscriberSymbol } from '../internal/symbol/rxSubscriber';\nimport { config } from './config';\nimport { hostReportError } from './util/hostReportError';\nvar Subscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(Subscriber, _super);\n    function Subscriber(destinationOrNext, error, complete) {\n        var _this = _super.call(this) || this;\n        _this.syncErrorValue = null;\n        _this.syncErrorThrown = false;\n        _this.syncErrorThrowable = false;\n        _this.isStopped = false;\n        switch (arguments.length) {\n            case 0:\n                _this.destination = emptyObserver;\n                break;\n            case 1:\n                if (!destinationOrNext) {\n                    _this.destination = emptyObserver;\n                    break;\n                }\n                if (typeof destinationOrNext === 'object') {\n                    if (destinationOrNext instanceof Subscriber) {\n                        _this.syncErrorThrowable = destinationOrNext.syncErrorThrowable;\n                        _this.destination = destinationOrNext;\n                        destinationOrNext.add(_this);\n                    }\n                    else {\n                        _this.syncErrorThrowable = true;\n                        _this.destination = new SafeSubscriber(_this, destinationOrNext);\n                    }\n                    break;\n                }\n            default:\n                _this.syncErrorThrowable = true;\n                _this.destination = new SafeSubscriber(_this, destinationOrNext, error, complete);\n                break;\n        }\n        return _this;\n    }\n    Subscriber.prototype[rxSubscriberSymbol] = function () { return this; };\n    Subscriber.create = function (next, error, complete) {\n        var subscriber = new Subscriber(next, error, complete);\n        subscriber.syncErrorThrowable = false;\n        return subscriber;\n    };\n    Subscriber.prototype.next = function (value) {\n        if (!this.isStopped) {\n            this._next(value);\n        }\n    };\n    Subscriber.prototype.error = function (err) {\n        if (!this.isStopped) {\n            this.isStopped = true;\n            this._error(err);\n        }\n    };\n    Subscriber.prototype.complete = function () {\n        if (!this.isStopped) {\n            this.isStopped = true;\n            this._complete();\n        }\n    };\n    Subscriber.prototype.unsubscribe = function () {\n        if (this.closed) {\n            return;\n        }\n        this.isStopped = true;\n        _super.prototype.unsubscribe.call(this);\n    };\n    Subscriber.prototype._next = function (value) {\n        this.destination.next(value);\n    };\n    Subscriber.prototype._error = function (err) {\n        this.destination.error(err);\n        this.unsubscribe();\n    };\n    Subscriber.prototype._complete = function () {\n        this.destination.complete();\n        this.unsubscribe();\n    };\n    Subscriber.prototype._unsubscribeAndRecycle = function () {\n        var _parentOrParents = this._parentOrParents;\n        this._parentOrParents = null;\n        this.unsubscribe();\n        this.closed = false;\n        this.isStopped = false;\n        this._parentOrParents = _parentOrParents;\n        return this;\n    };\n    return Subscriber;\n}(Subscription));\nexport { Subscriber };\nvar SafeSubscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(SafeSubscriber, _super);\n    function SafeSubscriber(_parentSubscriber, observerOrNext, error, complete) {\n        var _this = _super.call(this) || this;\n        _this._parentSubscriber = _parentSubscriber;\n        var next;\n        var context = _this;\n        if (isFunction(observerOrNext)) {\n            next = observerOrNext;\n        }\n        else if (observerOrNext) {\n            next = observerOrNext.next;\n            error = observerOrNext.error;\n            complete = observerOrNext.complete;\n            if (observerOrNext !== emptyObserver) {\n                context = Object.create(observerOrNext);\n                if (isFunction(context.unsubscribe)) {\n                    _this.add(context.unsubscribe.bind(context));\n                }\n                context.unsubscribe = _this.unsubscribe.bind(_this);\n            }\n        }\n        _this._context = context;\n        _this._next = next;\n        _this._error = error;\n        _this._complete = complete;\n        return _this;\n    }\n    SafeSubscriber.prototype.next = function (value) {\n        if (!this.isStopped && this._next) {\n            var _parentSubscriber = this._parentSubscriber;\n            if (!config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {\n                this.__tryOrUnsub(this._next, value);\n            }\n            else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {\n                this.unsubscribe();\n            }\n        }\n    };\n    SafeSubscriber.prototype.error = function (err) {\n        if (!this.isStopped) {\n            var _parentSubscriber = this._parentSubscriber;\n            var useDeprecatedSynchronousErrorHandling = config.useDeprecatedSynchronousErrorHandling;\n            if (this._error) {\n                if (!useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {\n                    this.__tryOrUnsub(this._error, err);\n                    this.unsubscribe();\n                }\n                else {\n                    this.__tryOrSetError(_parentSubscriber, this._error, err);\n                    this.unsubscribe();\n                }\n            }\n            else if (!_parentSubscriber.syncErrorThrowable) {\n                this.unsubscribe();\n                if (useDeprecatedSynchronousErrorHandling) {\n                    throw err;\n                }\n                hostReportError(err);\n            }\n            else {\n                if (useDeprecatedSynchronousErrorHandling) {\n                    _parentSubscriber.syncErrorValue = err;\n                    _parentSubscriber.syncErrorThrown = true;\n                }\n                else {\n                    hostReportError(err);\n                }\n                this.unsubscribe();\n            }\n        }\n    };\n    SafeSubscriber.prototype.complete = function () {\n        var _this = this;\n        if (!this.isStopped) {\n            var _parentSubscriber = this._parentSubscriber;\n            if (this._complete) {\n                var wrappedComplete = function () { return _this._complete.call(_this._context); };\n                if (!config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {\n                    this.__tryOrUnsub(wrappedComplete);\n                    this.unsubscribe();\n                }\n                else {\n                    this.__tryOrSetError(_parentSubscriber, wrappedComplete);\n                    this.unsubscribe();\n                }\n            }\n            else {\n                this.unsubscribe();\n            }\n        }\n    };\n    SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {\n        try {\n            fn.call(this._context, value);\n        }\n        catch (err) {\n            this.unsubscribe();\n            if (config.useDeprecatedSynchronousErrorHandling) {\n                throw err;\n            }\n            else {\n                hostReportError(err);\n            }\n        }\n    };\n    SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {\n        if (!config.useDeprecatedSynchronousErrorHandling) {\n            throw new Error('bad call');\n        }\n        try {\n            fn.call(this._context, value);\n        }\n        catch (err) {\n            if (config.useDeprecatedSynchronousErrorHandling) {\n                parent.syncErrorValue = err;\n                parent.syncErrorThrown = true;\n                return true;\n            }\n            else {\n                hostReportError(err);\n                return true;\n            }\n        }\n        return false;\n    };\n    SafeSubscriber.prototype._unsubscribe = function () {\n        var _parentSubscriber = this._parentSubscriber;\n        this._context = null;\n        this._parentSubscriber = null;\n        _parentSubscriber.unsubscribe();\n    };\n    return SafeSubscriber;\n}(Subscriber));\nexport { SafeSubscriber };\n//# sourceMappingURL=Subscriber.js.map\n","import { __spreadArray } from \"tslib\";\nimport { isShadowConfig } from './shadowConfig';\n/**\n * Combine a set of styles together (but does not register css classes).\n * @param styleSets - One or more stylesets to be merged (each param can also be falsy).\n */\nexport function concatStyleSets() {\n    var styleSets = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        styleSets[_i] = arguments[_i];\n    }\n    if (styleSets &&\n        styleSets.length === 1 &&\n        styleSets[0] &&\n        !styleSets[0].subComponentStyles &&\n        !isShadowConfig(styleSets[0])) {\n        return styleSets[0];\n    }\n    var mergedSet = {};\n    // We process sub component styles in two phases. First we collect them, then we combine them into 1 style function.\n    var workingSubcomponentStyles = {};\n    for (var _a = 0, styleSets_1 = styleSets; _a < styleSets_1.length; _a++) {\n        var currentSet = styleSets_1[_a];\n        if (currentSet && !isShadowConfig(currentSet)) {\n            for (var prop in currentSet) {\n                if (currentSet.hasOwnProperty(prop)) {\n                    if (prop === 'subComponentStyles' && currentSet.subComponentStyles !== undefined) {\n                        // subcomponent styles - style functions or objects\n                        var currentComponentStyles = currentSet.subComponentStyles;\n                        for (var subCompProp in currentComponentStyles) {\n                            if (currentComponentStyles.hasOwnProperty(subCompProp)) {\n                                if (workingSubcomponentStyles.hasOwnProperty(subCompProp)) {\n                                    workingSubcomponentStyles[subCompProp].push(currentComponentStyles[subCompProp]);\n                                }\n                                else {\n                                    workingSubcomponentStyles[subCompProp] = [currentComponentStyles[subCompProp]];\n                                }\n                            }\n                        }\n                        continue;\n                    }\n                    // the as any casts below is a workaround for ts 2.8.\n                    // todo: remove cast to any in ts 2.9.\n                    var mergedValue = mergedSet[prop];\n                    var currentValue = currentSet[prop];\n                    if (mergedValue === undefined) {\n                        mergedSet[prop] = currentValue;\n                    }\n                    else {\n                        mergedSet[prop] = __spreadArray(__spreadArray([], (Array.isArray(mergedValue) ? mergedValue : [mergedValue]), true), (Array.isArray(currentValue) ? currentValue : [currentValue]), true);\n                    }\n                }\n            }\n        }\n    }\n    if (Object.keys(workingSubcomponentStyles).length > 0) {\n        mergedSet.subComponentStyles = {};\n        var mergedSubStyles = mergedSet.subComponentStyles;\n        var _loop_1 = function (subCompProp) {\n            if (workingSubcomponentStyles.hasOwnProperty(subCompProp)) {\n                var workingSet_1 = workingSubcomponentStyles[subCompProp];\n                mergedSubStyles[subCompProp] = function (styleProps) {\n                    return concatStyleSets.apply(void 0, workingSet_1.map(function (styleFunctionOrObject) {\n                        return typeof styleFunctionOrObject === 'function' ? styleFunctionOrObject(styleProps) : styleFunctionOrObject;\n                    }));\n                };\n            }\n        };\n        // now we process the subcomponent styles if there are any\n        for (var subCompProp in workingSubcomponentStyles) {\n            _loop_1(subCompProp);\n        }\n    }\n    return mergedSet;\n}\n//# sourceMappingURL=concatStyleSets.js.map","import * as React from 'react';\nimport { getId } from '@fluentui/utilities';\n/**\n * Hook to generate a unique ID in the global scope (spanning across duplicate copies of the same library).\n *\n * @param prefix - Optional prefix for the ID\n * @param providedId - Optional id provided by a parent component. Defaults to the provided value if present,\n *  without conditioning the hook call\n * @returns The ID\n */\nexport function useId(prefix, providedId) {\n    // getId should only be called once since it updates the global constant for the next ID value.\n    // (While an extra update isn't likely to cause problems in practice, it's better to avoid it.)\n    var ref = React.useRef(providedId);\n    if (!ref.current) {\n        ref.current = getId(prefix);\n    }\n    return ref.current;\n}\n//# sourceMappingURL=useId.js.map","'use strict';\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('./cjs/react.production.min.js');\n} else {\n  module.exports = require('./cjs/react.development.js');\n}\n","import $89yE2$react, {useContext as $89yE2$useContext, useMemo as $89yE2$useMemo, useState as $89yE2$useState, useLayoutEffect as $89yE2$useLayoutEffect} from \"react\";\n\n\n// Default context value to use in case there is no SSRProvider. This is fine for\n// client-only apps. In order to support multiple copies of React Aria potentially\n// being on the page at once, the prefix is set to a random number. SSRProvider\n// will reset this to zero for consistency between server and client, so in the\n// SSR case multiple copies of React Aria is not supported.\nconst $704cf1d3b684cc5c$var$defaultContext = {\n    prefix: String(Math.round(Math.random() * 10000000000)),\n    current: 0\n};\nconst $704cf1d3b684cc5c$var$SSRContext = /*#__PURE__*/ $89yE2$react.createContext($704cf1d3b684cc5c$var$defaultContext);\nfunction $704cf1d3b684cc5c$export$9f8ac96af4b1b2ae(props) {\n    let cur = $89yE2$useContext($704cf1d3b684cc5c$var$SSRContext);\n    let value = $89yE2$useMemo(()=>({\n            // If this is the first SSRProvider, start with an empty string prefix, otherwise\n            // append and increment the counter.\n            prefix: cur === $704cf1d3b684cc5c$var$defaultContext ? '' : `${cur.prefix}-${++cur.current}`,\n            current: 0\n        })\n    , [\n        cur\n    ]);\n    return(/*#__PURE__*/ $89yE2$react.createElement($704cf1d3b684cc5c$var$SSRContext.Provider, {\n        value: value\n    }, props.children));\n}\nlet $704cf1d3b684cc5c$var$canUseDOM = Boolean(typeof window !== 'undefined' && window.document && window.document.createElement);\nfunction $704cf1d3b684cc5c$export$619500959fc48b26(defaultId) {\n    let ctx = $89yE2$useContext($704cf1d3b684cc5c$var$SSRContext);\n    // If we are rendering in a non-DOM environment, and there's no SSRProvider,\n    // provide a warning to hint to the developer to add one.\n    if (ctx === $704cf1d3b684cc5c$var$defaultContext && !$704cf1d3b684cc5c$var$canUseDOM) console.warn('When server rendering, you must wrap your application in an <SSRProvider> to ensure consistent ids are generated between the client and server.');\n    return $89yE2$useMemo(()=>defaultId || `react-aria${ctx.prefix}-${++ctx.current}`\n    , [\n        defaultId\n    ]);\n}\nfunction $704cf1d3b684cc5c$export$535bd6ca7f90a273() {\n    let cur = $89yE2$useContext($704cf1d3b684cc5c$var$SSRContext);\n    let isInSSRContext = cur !== $704cf1d3b684cc5c$var$defaultContext;\n    let [isSSR, setIsSSR] = $89yE2$useState(isInSSRContext);\n    // If on the client, and the component was initially server rendered,\n    // then schedule a layout effect to update the component after hydration.\n    if (typeof window !== 'undefined' && isInSSRContext) // This if statement technically breaks the rules of hooks, but is safe\n    // because the condition never changes after mounting.\n    // eslint-disable-next-line react-hooks/rules-of-hooks\n    $89yE2$useLayoutEffect(()=>{\n        setIsSSR(false);\n    }, []);\n    return isSSR;\n}\n\n\n\n\nexport {$704cf1d3b684cc5c$export$9f8ac96af4b1b2ae as SSRProvider, $704cf1d3b684cc5c$export$619500959fc48b26 as useSSRSafeId, $704cf1d3b684cc5c$export$535bd6ca7f90a273 as useIsSSR};\n//# sourceMappingURL=module.js.map\n","import { Async } from '@fluentui/utilities';\nimport * as React from 'react';\n/**\n * Hook to provide an Async instance that is automatically cleaned up on dismount.\n */\nexport function useAsync() {\n    var asyncRef = React.useRef();\n    if (!asyncRef.current) {\n        asyncRef.current = new Async();\n    }\n    React.useEffect(function () {\n        return function () {\n            var _a;\n            (_a = asyncRef.current) === null || _a === void 0 ? void 0 : _a.dispose();\n            asyncRef.current = undefined;\n        };\n    }, []);\n    return asyncRef.current;\n}\n//# sourceMappingURL=useAsync.js.map","/** PURE_IMPORTS_START  PURE_IMPORTS_END */\nvar UnsubscriptionErrorImpl = /*@__PURE__*/ (function () {\n    function UnsubscriptionErrorImpl(errors) {\n        Error.call(this);\n        this.message = errors ?\n            errors.length + \" errors occurred during unsubscription:\\n\" + errors.map(function (err, i) { return i + 1 + \") \" + err.toString(); }).join('\\n  ') : '';\n        this.name = 'UnsubscriptionError';\n        this.errors = errors;\n        return this;\n    }\n    UnsubscriptionErrorImpl.prototype = /*@__PURE__*/ Object.create(Error.prototype);\n    return UnsubscriptionErrorImpl;\n})();\nexport var UnsubscriptionError = UnsubscriptionErrorImpl;\n//# sourceMappingURL=UnsubscriptionError.js.map\n","import getNodeName from \"../dom-utils/getNodeName.js\";\nimport { isHTMLElement } from \"../dom-utils/instanceOf.js\"; // This modifier takes the styles prepared by the `computeStyles` modifier\n// and applies them to the HTMLElements such as popper and arrow\n\nfunction applyStyles(_ref) {\n  var state = _ref.state;\n  Object.keys(state.elements).forEach(function (name) {\n    var style = state.styles[name] || {};\n    var attributes = state.attributes[name] || {};\n    var element = state.elements[name]; // arrow is optional + virtual elements\n\n    if (!isHTMLElement(element) || !getNodeName(element)) {\n      return;\n    } // Flow doesn't support to extend this property, but it's the most\n    // effective way to apply styles to an HTMLElement\n    // $FlowFixMe[cannot-write]\n\n\n    Object.assign(element.style, style);\n    Object.keys(attributes).forEach(function (name) {\n      var value = attributes[name];\n\n      if (value === false) {\n        element.removeAttribute(name);\n      } else {\n        element.setAttribute(name, value === true ? '' : value);\n      }\n    });\n  });\n}\n\nfunction effect(_ref2) {\n  var state = _ref2.state;\n  var initialStyles = {\n    popper: {\n      position: state.options.strategy,\n      left: '0',\n      top: '0',\n      margin: '0'\n    },\n    arrow: {\n      position: 'absolute'\n    },\n    reference: {}\n  };\n  Object.assign(state.elements.popper.style, initialStyles.popper);\n  state.styles = initialStyles;\n\n  if (state.elements.arrow) {\n    Object.assign(state.elements.arrow.style, initialStyles.arrow);\n  }\n\n  return function () {\n    Object.keys(state.elements).forEach(function (name) {\n      var element = state.elements[name];\n      var attributes = state.attributes[name] || {};\n      var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them\n\n      var style = styleProperties.reduce(function (style, property) {\n        style[property] = '';\n        return style;\n      }, {}); // arrow is optional + virtual elements\n\n      if (!isHTMLElement(element) || !getNodeName(element)) {\n        return;\n      }\n\n      Object.assign(element.style, style);\n      Object.keys(attributes).forEach(function (attribute) {\n        element.removeAttribute(attribute);\n      });\n    });\n  };\n} // eslint-disable-next-line import/no-unused-modules\n\n\nexport default {\n  name: 'applyStyles',\n  enabled: true,\n  phase: 'write',\n  fn: applyStyles,\n  effect: effect,\n  requires: ['computeStyles']\n};","/** PURE_IMPORTS_START  PURE_IMPORTS_END */\nexport function isObject(x) {\n    return x !== null && typeof x === 'object';\n}\n//# sourceMappingURL=isObject.js.map\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","import { Node, mergeAttributes } from '@tiptap/core';\n\n/**\n * This extension allows you to create list items.\n * @see https://www.tiptap.dev/api/nodes/list-item\n */\nconst ListItem = Node.create({\n    name: 'listItem',\n    addOptions() {\n        return {\n            HTMLAttributes: {},\n            bulletListTypeName: 'bulletList',\n            orderedListTypeName: 'orderedList',\n        };\n    },\n    content: 'paragraph block*',\n    defining: true,\n    parseHTML() {\n        return [\n            {\n                tag: 'li',\n            },\n        ];\n    },\n    renderHTML({ HTMLAttributes }) {\n        return ['li', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];\n    },\n    addKeyboardShortcuts() {\n        return {\n            Enter: () => this.editor.commands.splitListItem(this.name),\n            Tab: () => this.editor.commands.sinkListItem(this.name),\n            'Shift-Tab': () => this.editor.commands.liftListItem(this.name),\n        };\n    },\n});\n\nexport { ListItem, ListItem as default };\n//# sourceMappingURL=index.js.map\n","import { mergeStyles } from '../MergeStyles';\n/**\n * Builds a class names object from a given map.\n *\n * @param styles - Map of unprocessed styles.\n * @returns Map of property name to class name.\n */\nexport function buildClassMap(styles) {\n    var classes = {};\n    var _loop_1 = function (styleName) {\n        if (styles.hasOwnProperty(styleName)) {\n            var className_1;\n            Object.defineProperty(classes, styleName, {\n                get: function () {\n                    if (className_1 === undefined) {\n                        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                        className_1 = mergeStyles(styles[styleName]).toString();\n                    }\n                    return className_1;\n                },\n                enumerable: true,\n                configurable: true,\n            });\n        }\n    };\n    for (var styleName in styles) {\n        _loop_1(styleName);\n    }\n    return classes;\n}\n//# sourceMappingURL=buildClassMap.js.map","import { Extension, callOrReturn, getExtensionField } from '@tiptap/core';\nimport { gapCursor } from '@tiptap/pm/gapcursor';\n\n/**\n * This extension allows you to add a gap cursor to your editor.\n * A gap cursor is a cursor that appears when you click on a place\n * where no content is present, for example inbetween nodes.\n * @see https://tiptap.dev/api/extensions/gapcursor\n */\nconst Gapcursor = Extension.create({\n    name: 'gapCursor',\n    addProseMirrorPlugins() {\n        return [\n            gapCursor(),\n        ];\n    },\n    extendNodeSchema(extension) {\n        var _a;\n        const context = {\n            name: extension.name,\n            options: extension.options,\n            storage: extension.storage,\n        };\n        return {\n            allowGapCursor: (_a = callOrReturn(getExtensionField(extension, 'allowGapCursor', context))) !== null && _a !== void 0 ? _a : null,\n        };\n    },\n});\n\nexport { Gapcursor, Gapcursor as default };\n//# sourceMappingURL=index.js.map\n","import { auto } from \"../enums.js\";\nexport default function getBasePlacement(placement) {\n  return placement.split('-')[0];\n}","import { __assign } from \"tslib\";\nimport { GlobalSettings, warn } from '@fluentui/utilities';\nimport { fontFace, mergeStyles, Stylesheet } from '@fluentui/merge-styles';\nvar ICON_SETTING_NAME = 'icons';\nvar _iconSettings = GlobalSettings.getValue(ICON_SETTING_NAME, {\n    __options: {\n        disableWarnings: false,\n        warnOnMissingIcons: true,\n    },\n    __remapped: {},\n});\n// Reset icon registration on stylesheet resets.\nvar stylesheet = Stylesheet.getInstance();\nif (stylesheet && stylesheet.onReset) {\n    stylesheet.onReset(function () {\n        for (var name_1 in _iconSettings) {\n            if (_iconSettings.hasOwnProperty(name_1) && !!_iconSettings[name_1].subset) {\n                _iconSettings[name_1].subset.className = undefined;\n            }\n        }\n    });\n}\n/**\n * Normalizes an icon name for consistent mapping.\n * Current implementation is to convert the icon name to lower case.\n *\n * @param name - Icon name to normalize.\n * @returns {string} Normalized icon name to use for indexing and mapping.\n */\nvar normalizeIconName = function (name) { return name.toLowerCase(); };\n/**\n * Registers a given subset of icons.\n *\n * @param iconSubset - the icon subset definition.\n */\nexport function registerIcons(iconSubset, options) {\n    var subset = __assign(__assign({}, iconSubset), { isRegistered: false, className: undefined });\n    var icons = iconSubset.icons;\n    // Grab options, optionally mix user provided ones on top.\n    options = options ? __assign(__assign({}, _iconSettings.__options), options) : _iconSettings.__options;\n    for (var iconName in icons) {\n        if (icons.hasOwnProperty(iconName)) {\n            var code = icons[iconName];\n            var normalizedIconName = normalizeIconName(iconName);\n            if (_iconSettings[normalizedIconName]) {\n                _warnDuplicateIcon(iconName);\n            }\n            else {\n                _iconSettings[normalizedIconName] = {\n                    code: code,\n                    subset: subset,\n                };\n            }\n        }\n    }\n}\n/**\n * Unregisters icons by name.\n *\n * @param iconNames - List of icons to unregister.\n */\nexport function unregisterIcons(iconNames) {\n    var options = _iconSettings.__options;\n    var _loop_1 = function (iconName) {\n        var normalizedIconName = normalizeIconName(iconName);\n        if (_iconSettings[normalizedIconName]) {\n            delete _iconSettings[normalizedIconName];\n        }\n        else {\n            // Warn that we are trying to delete an icon that doesn't exist\n            if (!options.disableWarnings) {\n                warn(\"The icon \\\"\".concat(iconName, \"\\\" tried to unregister but was not registered.\"));\n            }\n        }\n        // Delete any aliases for this iconName\n        if (_iconSettings.__remapped[normalizedIconName]) {\n            delete _iconSettings.__remapped[normalizedIconName];\n        }\n        // Delete any items that were an alias for this iconName\n        Object.keys(_iconSettings.__remapped).forEach(function (key) {\n            if (_iconSettings.__remapped[key] === normalizedIconName) {\n                delete _iconSettings.__remapped[key];\n            }\n        });\n    };\n    for (var _i = 0, iconNames_1 = iconNames; _i < iconNames_1.length; _i++) {\n        var iconName = iconNames_1[_i];\n        _loop_1(iconName);\n    }\n}\n/**\n * Remaps one icon name to another.\n */\nexport function registerIconAlias(iconName, mappedToName) {\n    _iconSettings.__remapped[normalizeIconName(iconName)] = normalizeIconName(mappedToName);\n}\n/**\n * Gets an icon definition. If an icon is requested but the subset has yet to be registered,\n * it will get registered immediately.\n *\n * @public\n * @param name - Name of icon.\n */\nexport function getIcon(name) {\n    var icon = undefined;\n    var options = _iconSettings.__options;\n    name = name ? normalizeIconName(name) : '';\n    name = _iconSettings.__remapped[name] || name;\n    if (name) {\n        icon = _iconSettings[name];\n        if (icon) {\n            var subset = icon.subset;\n            if (subset && subset.fontFace) {\n                if (!subset.isRegistered) {\n                    fontFace(subset.fontFace);\n                    subset.isRegistered = true;\n                }\n                if (!subset.className) {\n                    subset.className = mergeStyles(subset.style, {\n                        fontFamily: subset.fontFace.fontFamily,\n                        fontWeight: subset.fontFace.fontWeight || 'normal',\n                        fontStyle: subset.fontFace.fontStyle || 'normal',\n                    });\n                }\n            }\n        }\n        else {\n            // eslint-disable-next-line deprecation/deprecation\n            if (!options.disableWarnings && options.warnOnMissingIcons) {\n                warn(\"The icon \\\"\".concat(name, \"\\\" was used but not registered. See https://github.com/microsoft/fluentui/wiki/Using-icons for more information.\"));\n            }\n        }\n    }\n    return icon;\n}\n/**\n * Sets the icon options.\n *\n * @public\n */\nexport function setIconOptions(options) {\n    _iconSettings.__options = __assign(__assign({}, _iconSettings.__options), options);\n}\nvar _missingIcons = [];\nvar _missingIconsTimer = undefined;\nfunction _warnDuplicateIcon(iconName) {\n    var options = _iconSettings.__options;\n    var warningDelay = 2000;\n    var maxIconsInMessage = 10;\n    if (!options.disableWarnings) {\n        _missingIcons.push(iconName);\n        if (_missingIconsTimer === undefined) {\n            _missingIconsTimer = setTimeout(function () {\n                warn(\"Some icons were re-registered. Applications should only call registerIcons for any given \" +\n                    \"icon once. Redefining what an icon is may have unintended consequences. Duplicates \" +\n                    \"include: \\n\" +\n                    _missingIcons.slice(0, maxIconsInMessage).join(', ') +\n                    (_missingIcons.length > maxIconsInMessage ? \" (+ \".concat(_missingIcons.length - maxIconsInMessage, \" more)\") : ''));\n                _missingIconsTimer = undefined;\n                _missingIcons = [];\n            }, warningDelay);\n        }\n    }\n}\n//# sourceMappingURL=icons.js.map","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\nvar isArray = require('isarray')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n","(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.i18nextResourcesToBackend = factory());\n}(this, (function () { 'use strict';\n\n  var resourcesToBackend = function resourcesToBackend(res) {\n    return {\n      type: 'backend',\n      init: function init(services, backendOptions, i18nextOptions) {},\n      read: function read(language, namespace, callback) {\n        if (typeof res === 'function') {\n          res(language, namespace, callback);\n          return;\n        }\n\n        callback(null, res && res[language] && res[language][namespace]);\n      }\n    };\n  };\n\n  return resourcesToBackend;\n\n})));\n","/**\n * Enumeration of icon file names, and what extensions they map to.\n * Please keep items alphabetical. Items without extensions may require specific logic in the code to map.\n * Always use getFileTypeIconProps to get the most up-to-date icon at the right pixel density.\n */\nexport var FileTypeIconMap = {\n    accdb: {\n        extensions: ['accdb', 'mdb'],\n    },\n    archive: {\n        extensions: ['7z', 'ace', 'arc', 'arj', 'dmg', 'gz', 'iso', 'lzh', 'pkg', 'rar', 'sit', 'tgz', 'tar', 'z'],\n    },\n    audio: {\n        extensions: [\n            'aif',\n            'aiff',\n            'aac',\n            'alac',\n            'amr',\n            'ape',\n            'au',\n            'awb',\n            'dct',\n            'dss',\n            'dvf',\n            'flac',\n            'gsm',\n            'm4a',\n            'm4p',\n            'mid',\n            'mmf',\n            'mp3',\n            'oga',\n            'ra',\n            'rm',\n            'wav',\n            'wma',\n            'wv',\n        ],\n    },\n    calendar: {\n        extensions: ['ical', 'icalendar', 'ics', 'ifb', 'vcs'],\n    },\n    classifier: {\n        extensions: ['classifier'],\n    },\n    clipchamp: {\n        extensions: ['clipchamp'],\n    },\n    code: {\n        extensions: [\n            'abap',\n            'ada',\n            'adp',\n            'ahk',\n            'as',\n            'as3',\n            'asc',\n            'ascx',\n            'asm',\n            'asp',\n            'awk',\n            'bash',\n            'bash_login',\n            'bash_logout',\n            'bash_profile',\n            'bashrc',\n            'bat',\n            'bib',\n            'bsh',\n            'build',\n            'builder',\n            'c',\n            'cbl',\n            'c++',\n            'capfile',\n            'cc',\n            'cfc',\n            'cfm',\n            'cfml',\n            'cl',\n            'clj',\n            'cls',\n            'cmake',\n            'cmd',\n            'coffee',\n            'config',\n            'cpp',\n            'cpt',\n            'cpy',\n            'cs',\n            'cshtml',\n            'cson',\n            'csproj',\n            'css',\n            'ctp',\n            'cxx',\n            'd',\n            'ddl',\n            'di',\n            'disco',\n            'dml',\n            'dtd',\n            'dtml',\n            'el',\n            'emakefile',\n            'erb',\n            'erl',\n            'f',\n            'f90',\n            'f95',\n            'fs',\n            'fsi',\n            'fsscript',\n            'fsx',\n            'gemfile',\n            'gemspec',\n            'gitconfig',\n            'go',\n            'groovy',\n            'gvy',\n            'h',\n            'h++',\n            'haml',\n            'handlebars',\n            'hbs',\n            'hcp',\n            'hh',\n            'hpp',\n            'hrl',\n            'hs',\n            'htc',\n            'hxx',\n            'idl',\n            'iim',\n            'inc',\n            'inf',\n            'ini',\n            'inl',\n            'ipp',\n            'irbrc',\n            'jade',\n            'jav',\n            'java',\n            'js',\n            'json',\n            'jsp',\n            'jsproj',\n            'jsx',\n            'l',\n            'less',\n            'lhs',\n            'lisp',\n            'log',\n            'lst',\n            'ltx',\n            'lua',\n            'm',\n            'mak',\n            'make',\n            'manifest',\n            'master',\n            'md',\n            'markdn',\n            'markdown',\n            'mdown',\n            'mkdn',\n            'ml',\n            'mli',\n            'mll',\n            'mly',\n            'mm',\n            'mud',\n            'nfo',\n            'opml',\n            'osascript',\n            'p',\n            'pas',\n            'patch',\n            'php',\n            'php2',\n            'php3',\n            'php4',\n            'php5',\n            'phtml',\n            'pl',\n            'pm',\n            'pod',\n            'pp',\n            'profile',\n            'ps1',\n            'ps1xml',\n            'psd1',\n            'psm1',\n            'pss',\n            'pt',\n            'py',\n            'pyw',\n            'r',\n            'rake',\n            'rb',\n            'rbx',\n            'rc',\n            'rdf',\n            're',\n            'reg',\n            'rest',\n            'resw',\n            'resx',\n            'rhtml',\n            'rjs',\n            'rprofile',\n            'rpy',\n            'rss',\n            'rst',\n            'ruby',\n            'rxml',\n            's',\n            'sass',\n            'scala',\n            'scm',\n            'sconscript',\n            'sconstruct',\n            'script',\n            'scss',\n            'sgml',\n            'sh',\n            'shtml',\n            'sml',\n            'svn-base',\n            'swift',\n            'sql',\n            'sty',\n            'tcl',\n            'tex',\n            'textile',\n            'tld',\n            'tli',\n            'tmpl',\n            'tpl',\n            'vb',\n            'vi',\n            'vim',\n            'vmg',\n            'webpart',\n            'wsp',\n            'wsdl',\n            'xhtml',\n            'xoml',\n            'xsd',\n            'xslt',\n            'yaml',\n            'yaws',\n            'yml',\n            'zsh',\n        ],\n    },\n    contact: {\n        extensions: ['vcf'],\n    },\n    /*  css: {},  not broken out yet, snapping to 'code' for now */\n    csv: {\n        extensions: ['csv'],\n    },\n    designer: {\n        extensions: ['design'],\n    },\n    desktopfolder: {},\n    docset: {},\n    documentsfolder: {},\n    docx: {\n        extensions: ['doc', 'docm', 'docx', 'docb'],\n    },\n    dotx: {\n        extensions: ['dot', 'dotm', 'dotx'],\n    },\n    email: {\n        extensions: ['eml', 'msg', 'oft', 'ost', 'pst'],\n    },\n    exe: {\n        extensions: ['application', 'appref-ms', 'apk', 'app', 'appx', 'exe', 'ipa', 'msi', 'xap'],\n    },\n    favoritesfolder: {},\n    folder: {},\n    font: {\n        extensions: ['ttf', 'otf', 'woff'],\n    },\n    form: {},\n    genericfile: {},\n    html: {\n        extensions: ['htm', 'html', 'mht', 'mhtml'],\n    },\n    ipynb: {\n        extensions: ['nnb', 'ipynb'],\n    },\n    link: {\n        extensions: ['lnk', 'link', 'url', 'website', 'webloc'],\n    },\n    linkedfolder: {},\n    listitem: {},\n    loop: {\n        extensions: ['fluid', 'loop', 'note'],\n    },\n    loopworkspace: {},\n    officescript: {\n        extensions: ['osts'],\n    },\n    splist: {},\n    mcworld: {\n        extensions: ['mcworld'],\n    },\n    mctemplate: {\n        extensions: ['mctemplate'],\n    },\n    model: {\n        extensions: [\n            '3ds',\n            '3mf',\n            'blend',\n            'cool',\n            'dae',\n            'df',\n            'dwfx',\n            'dwg',\n            'dxf',\n            'fbx',\n            'glb',\n            'gltf',\n            'holo',\n            'layer',\n            'layout',\n            'max',\n            'mtl',\n            'obj',\n            'off',\n            'ply',\n            'skp',\n            'stp',\n            'stl',\n            't',\n            'thl',\n            'x',\n        ],\n    },\n    mpp: {\n        extensions: ['mpp'],\n    },\n    mpt: {\n        extensions: ['mpt'],\n    },\n    multiple: {},\n    one: {\n        // This is a partial OneNote page or section export. Not whole notebooks, see \"onetoc\"\n        extensions: ['one'],\n    },\n    onetoc: {\n        // This is an entire OneNote notebook.\n        extensions: ['ms-one-stub', 'onetoc', 'onetoc2', 'onepkg'], // This represents a complete, logical notebook.\n    },\n    pbiapp: {},\n    pdf: {\n        extensions: ['pdf'],\n    },\n    photo: {\n        extensions: [\n            'arw',\n            'bmp',\n            'cr2',\n            'crw',\n            'dic',\n            'dicm',\n            'dcm',\n            'dcm30',\n            'dcr',\n            'dds',\n            'dib',\n            'dng',\n            'erf',\n            'gif',\n            'heic',\n            'heif',\n            'ico',\n            'jfi',\n            'jfif',\n            'jif',\n            'jpe',\n            'jpeg',\n            'jpg',\n            'jxr',\n            'kdc',\n            'mrw',\n            'nef',\n            'orf',\n            'pct',\n            'pict',\n            'png',\n            'pns',\n            'psb',\n            'psd',\n            'raw',\n            'tga',\n            'tif',\n            'tiff',\n            'wdp',\n        ],\n    },\n    photo360: {},\n    picturesfolder: {},\n    planner: {},\n    potx: {\n        extensions: ['pot', 'potm', 'potx'],\n    },\n    powerbi: {\n        extensions: ['pbids', 'pbix'],\n    },\n    ppsx: {\n        extensions: ['pps', 'ppsm', 'ppsx'],\n    },\n    pptx: {\n        extensions: ['ppt', 'pptm', 'pptx', 'sldx', 'sldm'],\n    },\n    presentation: {\n        extensions: ['odp', 'gslides', 'key'],\n    },\n    pub: {\n        extensions: ['pub'],\n    },\n    spo: {\n        extensions: ['aspx'],\n    },\n    sponews: {},\n    spreadsheet: {\n        extensions: ['odc', 'ods', 'gsheet', 'numbers', 'tsv'],\n    },\n    rtf: {\n        extensions: ['epub', 'gdoc', 'odt', 'rtf', 'wri', 'pages'],\n    },\n    sharedfolder: {},\n    playlist: {},\n    sway: {},\n    sysfile: {\n        extensions: [\n            'bak',\n            'bin',\n            'cab',\n            'cache',\n            'cat',\n            'cer',\n            'class',\n            'dat',\n            'db',\n            'dbg',\n            'dl_',\n            'dll',\n            'ithmb',\n            'jar',\n            'kb',\n            'ldt',\n            'lrprev',\n            'pkpass',\n            'ppa',\n            'ppam',\n            'pdb',\n            'rom',\n            'thm',\n            'thmx',\n            'vsl',\n            'xla',\n            'xlam',\n            'xlb',\n            'xll',\n        ],\n    },\n    todoitem: {},\n    txt: {\n        extensions: ['dif', 'diff', 'readme', 'out', 'plist', 'properties', 'text', 'txt'],\n    },\n    vaultclosed: {},\n    vaultopen: {},\n    vector: {\n        extensions: [\n            'ai',\n            'ait',\n            'cvs',\n            'dgn',\n            'gdraw',\n            'pd',\n            'emf',\n            'eps',\n            'fig',\n            'ind',\n            'indd',\n            'indl',\n            'indt',\n            'indb',\n            'ps',\n            'svg',\n            'svgz',\n            'wmf',\n            'oxps',\n            'xps',\n            'xd',\n            'sketch',\n        ],\n    },\n    video: {\n        extensions: [\n            '3g2',\n            '3gp',\n            '3gp2',\n            '3gpp',\n            'asf',\n            'avi',\n            'dvr-ms',\n            'flv',\n            'm1v',\n            'm4v',\n            'mkv',\n            'mod',\n            'mov',\n            'mm4p',\n            'mp2',\n            'mp2v',\n            'mp4',\n            'mp4v',\n            'mpa',\n            'mpe',\n            'mpeg',\n            'mpg',\n            'mpv',\n            'mpv2',\n            'mts',\n            'ogg',\n            'qt',\n            'swf',\n            'ts',\n            'vob',\n            'webm',\n            'wlmp',\n            'wm',\n            'wmv',\n            'wmx',\n        ],\n    },\n    video360: {},\n    vsdx: {\n        extensions: ['vdx', 'vsd', 'vsdm', 'vsdx', 'vsw', 'vdw'],\n    },\n    vssx: {\n        extensions: ['vss', 'vssm', 'vssx'],\n    },\n    vstx: {\n        extensions: ['vst', 'vstm', 'vstx', 'vsx'],\n    },\n    whiteboard: {\n        extensions: ['whiteboard', 'wbtx'],\n    },\n    xlsx: {\n        extensions: ['xlc', 'xls', 'xlsb', 'xlsm', 'xlsx', 'xlw'],\n    },\n    xltx: {\n        extensions: ['xlt', 'xltm', 'xltx'],\n    },\n    xml: {\n        extensions: ['xaml', 'xml', 'xsl'],\n    },\n    xsn: {\n        extensions: ['xsn'],\n    },\n    zip: {\n        extensions: ['zip'],\n    },\n};\n//# sourceMappingURL=FileTypeIconMap.js.map","import { getParent } from './getParent';\n/**\n * Determines whether or not a parent element contains a given child element.\n * If `allowVirtualParents` is true, this method may return `true` if the child\n * has the parent in its virtual element hierarchy.\n *\n * @public\n */\nexport function elementContains(parent, child, allowVirtualParents) {\n    if (allowVirtualParents === void 0) { allowVirtualParents = true; }\n    var isContained = false;\n    if (parent && child) {\n        if (allowVirtualParents) {\n            if (parent === child) {\n                isContained = true;\n            }\n            else {\n                isContained = false;\n                while (child) {\n                    var nextParent = getParent(child);\n                    if (nextParent === parent) {\n                        isContained = true;\n                        break;\n                    }\n                    child = nextParent;\n                }\n            }\n        }\n        else if (parent.contains) {\n            isContained = parent.contains(child);\n        }\n    }\n    return isContained;\n}\n//# sourceMappingURL=elementContains.js.map","/**\n * React Router v6.3.0\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */\nimport { parsePath, createMemoryHistory, Action } from 'history';\nexport { Action as NavigationType, createPath, parsePath } from 'history';\nimport { createContext, useContext, useMemo, useRef, useEffect, useCallback, createElement, useState, useLayoutEffect, Children, isValidElement, Fragment } from 'react';\n\nconst NavigationContext = /*#__PURE__*/createContext(null);\n\nif (process.env.NODE_ENV !== \"production\") {\n  NavigationContext.displayName = \"Navigation\";\n}\n\nconst LocationContext = /*#__PURE__*/createContext(null);\n\nif (process.env.NODE_ENV !== \"production\") {\n  LocationContext.displayName = \"Location\";\n}\n\nconst RouteContext = /*#__PURE__*/createContext({\n  outlet: null,\n  matches: []\n});\n\nif (process.env.NODE_ENV !== \"production\") {\n  RouteContext.displayName = \"Route\";\n}\n\nfunction invariant(cond, message) {\n  if (!cond) throw new Error(message);\n}\nfunction warning(cond, message) {\n  if (!cond) {\n    // eslint-disable-next-line no-console\n    if (typeof console !== \"undefined\") console.warn(message);\n\n    try {\n      // Welcome to debugging React Router!\n      //\n      // This error is thrown as a convenience so you can more easily\n      // find the source for a warning that appears in the console by\n      // enabling \"pause on exceptions\" in your JavaScript debugger.\n      throw new Error(message); // eslint-disable-next-line no-empty\n    } catch (e) {}\n  }\n}\nconst alreadyWarned = {};\nfunction warningOnce(key, cond, message) {\n  if (!cond && !alreadyWarned[key]) {\n    alreadyWarned[key] = true;\n    process.env.NODE_ENV !== \"production\" ? warning(false, message) : void 0;\n  }\n}\n\n/**\n * Returns a path with params interpolated.\n *\n * @see https://reactrouter.com/docs/en/v6/api#generatepath\n */\nfunction generatePath(path, params) {\n  if (params === void 0) {\n    params = {};\n  }\n\n  return path.replace(/:(\\w+)/g, (_, key) => {\n    !(params[key] != null) ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"Missing \\\":\" + key + \"\\\" param\") : invariant(false) : void 0;\n    return params[key];\n  }).replace(/\\/*\\*$/, _ => params[\"*\"] == null ? \"\" : params[\"*\"].replace(/^\\/*/, \"/\"));\n}\n/**\n * A RouteMatch contains info about how a route matched a URL.\n */\n\n/**\n * Matches the given routes to a location and returns the match data.\n *\n * @see https://reactrouter.com/docs/en/v6/api#matchroutes\n */\nfunction matchRoutes(routes, locationArg, basename) {\n  if (basename === void 0) {\n    basename = \"/\";\n  }\n\n  let location = typeof locationArg === \"string\" ? parsePath(locationArg) : locationArg;\n  let pathname = stripBasename(location.pathname || \"/\", basename);\n\n  if (pathname == null) {\n    return null;\n  }\n\n  let branches = flattenRoutes(routes);\n  rankRouteBranches(branches);\n  let matches = null;\n\n  for (let i = 0; matches == null && i < branches.length; ++i) {\n    matches = matchRouteBranch(branches[i], pathname);\n  }\n\n  return matches;\n}\n\nfunction flattenRoutes(routes, branches, parentsMeta, parentPath) {\n  if (branches === void 0) {\n    branches = [];\n  }\n\n  if (parentsMeta === void 0) {\n    parentsMeta = [];\n  }\n\n  if (parentPath === void 0) {\n    parentPath = \"\";\n  }\n\n  routes.forEach((route, index) => {\n    let meta = {\n      relativePath: route.path || \"\",\n      caseSensitive: route.caseSensitive === true,\n      childrenIndex: index,\n      route\n    };\n\n    if (meta.relativePath.startsWith(\"/\")) {\n      !meta.relativePath.startsWith(parentPath) ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"Absolute route path \\\"\" + meta.relativePath + \"\\\" nested under path \" + (\"\\\"\" + parentPath + \"\\\" is not valid. An absolute child route path \") + \"must start with the combined path of all its parent routes.\") : invariant(false) : void 0;\n      meta.relativePath = meta.relativePath.slice(parentPath.length);\n    }\n\n    let path = joinPaths([parentPath, meta.relativePath]);\n    let routesMeta = parentsMeta.concat(meta); // Add the children before adding this route to the array so we traverse the\n    // route tree depth-first and child routes appear before their parents in\n    // the \"flattened\" version.\n\n    if (route.children && route.children.length > 0) {\n      !(route.index !== true) ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"Index routes must not have child routes. Please remove \" + (\"all child routes from route path \\\"\" + path + \"\\\".\")) : invariant(false) : void 0;\n      flattenRoutes(route.children, branches, routesMeta, path);\n    } // Routes without a path shouldn't ever match by themselves unless they are\n    // index routes, so don't add them to the list of possible branches.\n\n\n    if (route.path == null && !route.index) {\n      return;\n    }\n\n    branches.push({\n      path,\n      score: computeScore(path, route.index),\n      routesMeta\n    });\n  });\n  return branches;\n}\n\nfunction rankRouteBranches(branches) {\n  branches.sort((a, b) => a.score !== b.score ? b.score - a.score // Higher score first\n  : compareIndexes(a.routesMeta.map(meta => meta.childrenIndex), b.routesMeta.map(meta => meta.childrenIndex)));\n}\n\nconst paramRe = /^:\\w+$/;\nconst dynamicSegmentValue = 3;\nconst indexRouteValue = 2;\nconst emptySegmentValue = 1;\nconst staticSegmentValue = 10;\nconst splatPenalty = -2;\n\nconst isSplat = s => s === \"*\";\n\nfunction computeScore(path, index) {\n  let segments = path.split(\"/\");\n  let initialScore = segments.length;\n\n  if (segments.some(isSplat)) {\n    initialScore += splatPenalty;\n  }\n\n  if (index) {\n    initialScore += indexRouteValue;\n  }\n\n  return segments.filter(s => !isSplat(s)).reduce((score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === \"\" ? emptySegmentValue : staticSegmentValue), initialScore);\n}\n\nfunction compareIndexes(a, b) {\n  let siblings = a.length === b.length && a.slice(0, -1).every((n, i) => n === b[i]);\n  return siblings ? // If two routes are siblings, we should try to match the earlier sibling\n  // first. This allows people to have fine-grained control over the matching\n  // behavior by simply putting routes with identical paths in the order they\n  // want them tried.\n  a[a.length - 1] - b[b.length - 1] : // Otherwise, it doesn't really make sense to rank non-siblings by index,\n  // so they sort equally.\n  0;\n}\n\nfunction matchRouteBranch(branch, pathname) {\n  let {\n    routesMeta\n  } = branch;\n  let matchedParams = {};\n  let matchedPathname = \"/\";\n  let matches = [];\n\n  for (let i = 0; i < routesMeta.length; ++i) {\n    let meta = routesMeta[i];\n    let end = i === routesMeta.length - 1;\n    let remainingPathname = matchedPathname === \"/\" ? pathname : pathname.slice(matchedPathname.length) || \"/\";\n    let match = matchPath({\n      path: meta.relativePath,\n      caseSensitive: meta.caseSensitive,\n      end\n    }, remainingPathname);\n    if (!match) return null;\n    Object.assign(matchedParams, match.params);\n    let route = meta.route;\n    matches.push({\n      params: matchedParams,\n      pathname: joinPaths([matchedPathname, match.pathname]),\n      pathnameBase: normalizePathname(joinPaths([matchedPathname, match.pathnameBase])),\n      route\n    });\n\n    if (match.pathnameBase !== \"/\") {\n      matchedPathname = joinPaths([matchedPathname, match.pathnameBase]);\n    }\n  }\n\n  return matches;\n}\n/**\n * A PathPattern is used to match on some portion of a URL pathname.\n */\n\n\n/**\n * Performs pattern matching on a URL pathname and returns information about\n * the match.\n *\n * @see https://reactrouter.com/docs/en/v6/api#matchpath\n */\nfunction matchPath(pattern, pathname) {\n  if (typeof pattern === \"string\") {\n    pattern = {\n      path: pattern,\n      caseSensitive: false,\n      end: true\n    };\n  }\n\n  let [matcher, paramNames] = compilePath(pattern.path, pattern.caseSensitive, pattern.end);\n  let match = pathname.match(matcher);\n  if (!match) return null;\n  let matchedPathname = match[0];\n  let pathnameBase = matchedPathname.replace(/(.)\\/+$/, \"$1\");\n  let captureGroups = match.slice(1);\n  let params = paramNames.reduce((memo, paramName, index) => {\n    // We need to compute the pathnameBase here using the raw splat value\n    // instead of using params[\"*\"] later because it will be decoded then\n    if (paramName === \"*\") {\n      let splatValue = captureGroups[index] || \"\";\n      pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\\/+$/, \"$1\");\n    }\n\n    memo[paramName] = safelyDecodeURIComponent(captureGroups[index] || \"\", paramName);\n    return memo;\n  }, {});\n  return {\n    params,\n    pathname: matchedPathname,\n    pathnameBase,\n    pattern\n  };\n}\n\nfunction compilePath(path, caseSensitive, end) {\n  if (caseSensitive === void 0) {\n    caseSensitive = false;\n  }\n\n  if (end === void 0) {\n    end = true;\n  }\n\n  process.env.NODE_ENV !== \"production\" ? warning(path === \"*\" || !path.endsWith(\"*\") || path.endsWith(\"/*\"), \"Route path \\\"\" + path + \"\\\" will be treated as if it were \" + (\"\\\"\" + path.replace(/\\*$/, \"/*\") + \"\\\" because the `*` character must \") + \"always follow a `/` in the pattern. To get rid of this warning, \" + (\"please change the route path to \\\"\" + path.replace(/\\*$/, \"/*\") + \"\\\".\")) : void 0;\n  let paramNames = [];\n  let regexpSource = \"^\" + path.replace(/\\/*\\*?$/, \"\") // Ignore trailing / and /*, we'll handle it below\n  .replace(/^\\/*/, \"/\") // Make sure it has a leading /\n  .replace(/[\\\\.*+^$?{}|()[\\]]/g, \"\\\\$&\") // Escape special regex chars\n  .replace(/:(\\w+)/g, (_, paramName) => {\n    paramNames.push(paramName);\n    return \"([^\\\\/]+)\";\n  });\n\n  if (path.endsWith(\"*\")) {\n    paramNames.push(\"*\");\n    regexpSource += path === \"*\" || path === \"/*\" ? \"(.*)$\" // Already matched the initial /, just match the rest\n    : \"(?:\\\\/(.+)|\\\\/*)$\"; // Don't include the / in params[\"*\"]\n  } else {\n    regexpSource += end ? \"\\\\/*$\" // When matching to the end, ignore trailing slashes\n    : // Otherwise, match a word boundary or a proceeding /. The word boundary restricts\n    // parent routes to matching only their own words and nothing more, e.g. parent\n    // route \"/home\" should not match \"/home2\".\n    // Additionally, allow paths starting with `.`, `-`, `~`, and url-encoded entities,\n    // but do not consume the character in the matched path so they can match against\n    // nested paths.\n    \"(?:(?=[.~-]|%[0-9A-F]{2})|\\\\b|\\\\/|$)\";\n  }\n\n  let matcher = new RegExp(regexpSource, caseSensitive ? undefined : \"i\");\n  return [matcher, paramNames];\n}\n\nfunction safelyDecodeURIComponent(value, paramName) {\n  try {\n    return decodeURIComponent(value);\n  } catch (error) {\n    process.env.NODE_ENV !== \"production\" ? warning(false, \"The value for the URL param \\\"\" + paramName + \"\\\" will not be decoded because\" + (\" the string \\\"\" + value + \"\\\" is a malformed URL segment. This is probably\") + (\" due to a bad percent encoding (\" + error + \").\")) : void 0;\n    return value;\n  }\n}\n/**\n * Returns a resolved path object relative to the given pathname.\n *\n * @see https://reactrouter.com/docs/en/v6/api#resolvepath\n */\n\n\nfunction resolvePath(to, fromPathname) {\n  if (fromPathname === void 0) {\n    fromPathname = \"/\";\n  }\n\n  let {\n    pathname: toPathname,\n    search = \"\",\n    hash = \"\"\n  } = typeof to === \"string\" ? parsePath(to) : to;\n  let pathname = toPathname ? toPathname.startsWith(\"/\") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;\n  return {\n    pathname,\n    search: normalizeSearch(search),\n    hash: normalizeHash(hash)\n  };\n}\n\nfunction resolvePathname(relativePath, fromPathname) {\n  let segments = fromPathname.replace(/\\/+$/, \"\").split(\"/\");\n  let relativeSegments = relativePath.split(\"/\");\n  relativeSegments.forEach(segment => {\n    if (segment === \"..\") {\n      // Keep the root \"\" segment so the pathname starts at /\n      if (segments.length > 1) segments.pop();\n    } else if (segment !== \".\") {\n      segments.push(segment);\n    }\n  });\n  return segments.length > 1 ? segments.join(\"/\") : \"/\";\n}\n\nfunction resolveTo(toArg, routePathnames, locationPathname) {\n  let to = typeof toArg === \"string\" ? parsePath(toArg) : toArg;\n  let toPathname = toArg === \"\" || to.pathname === \"\" ? \"/\" : to.pathname; // If a pathname is explicitly provided in `to`, it should be relative to the\n  // route context. This is explained in `Note on `<Link to>` values` in our\n  // migration guide from v5 as a means of disambiguation between `to` values\n  // that begin with `/` and those that do not. However, this is problematic for\n  // `to` values that do not provide a pathname. `to` can simply be a search or\n  // hash string, in which case we should assume that the navigation is relative\n  // to the current location's pathname and *not* the route pathname.\n\n  let from;\n\n  if (toPathname == null) {\n    from = locationPathname;\n  } else {\n    let routePathnameIndex = routePathnames.length - 1;\n\n    if (toPathname.startsWith(\"..\")) {\n      let toSegments = toPathname.split(\"/\"); // Each leading .. segment means \"go up one route\" instead of \"go up one\n      // URL segment\".  This is a key difference from how <a href> works and a\n      // major reason we call this a \"to\" value instead of a \"href\".\n\n      while (toSegments[0] === \"..\") {\n        toSegments.shift();\n        routePathnameIndex -= 1;\n      }\n\n      to.pathname = toSegments.join(\"/\");\n    } // If there are more \"..\" segments than parent routes, resolve relative to\n    // the root / URL.\n\n\n    from = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : \"/\";\n  }\n\n  let path = resolvePath(to, from); // Ensure the pathname has a trailing slash if the original to value had one.\n\n  if (toPathname && toPathname !== \"/\" && toPathname.endsWith(\"/\") && !path.pathname.endsWith(\"/\")) {\n    path.pathname += \"/\";\n  }\n\n  return path;\n}\nfunction getToPathname(to) {\n  // Empty strings should be treated the same as / paths\n  return to === \"\" || to.pathname === \"\" ? \"/\" : typeof to === \"string\" ? parsePath(to).pathname : to.pathname;\n}\nfunction stripBasename(pathname, basename) {\n  if (basename === \"/\") return pathname;\n\n  if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {\n    return null;\n  }\n\n  let nextChar = pathname.charAt(basename.length);\n\n  if (nextChar && nextChar !== \"/\") {\n    // pathname does not start with basename/\n    return null;\n  }\n\n  return pathname.slice(basename.length) || \"/\";\n}\nconst joinPaths = paths => paths.join(\"/\").replace(/\\/\\/+/g, \"/\");\nconst normalizePathname = pathname => pathname.replace(/\\/+$/, \"\").replace(/^\\/*/, \"/\");\n\nconst normalizeSearch = search => !search || search === \"?\" ? \"\" : search.startsWith(\"?\") ? search : \"?\" + search;\n\nconst normalizeHash = hash => !hash || hash === \"#\" ? \"\" : hash.startsWith(\"#\") ? hash : \"#\" + hash;\n\n/**\n * Returns the full href for the given \"to\" value. This is useful for building\n * custom links that are also accessible and preserve right-click behavior.\n *\n * @see https://reactrouter.com/docs/en/v6/api#usehref\n */\n\nfunction useHref(to) {\n  !useInRouterContext() ? process.env.NODE_ENV !== \"production\" ? invariant(false, // TODO: This error is probably because they somehow have 2 versions of the\n  // router loaded. We can help them understand how to avoid that.\n  \"useHref() may be used only in the context of a <Router> component.\") : invariant(false) : void 0;\n  let {\n    basename,\n    navigator\n  } = useContext(NavigationContext);\n  let {\n    hash,\n    pathname,\n    search\n  } = useResolvedPath(to);\n  let joinedPathname = pathname;\n\n  if (basename !== \"/\") {\n    let toPathname = getToPathname(to);\n    let endsWithSlash = toPathname != null && toPathname.endsWith(\"/\");\n    joinedPathname = pathname === \"/\" ? basename + (endsWithSlash ? \"/\" : \"\") : joinPaths([basename, pathname]);\n  }\n\n  return navigator.createHref({\n    pathname: joinedPathname,\n    search,\n    hash\n  });\n}\n/**\n * Returns true if this component is a descendant of a <Router>.\n *\n * @see https://reactrouter.com/docs/en/v6/api#useinroutercontext\n */\n\nfunction useInRouterContext() {\n  return useContext(LocationContext) != null;\n}\n/**\n * Returns the current location object, which represents the current URL in web\n * browsers.\n *\n * Note: If you're using this it may mean you're doing some of your own\n * \"routing\" in your app, and we'd like to know what your use case is. We may\n * be able to provide something higher-level to better suit your needs.\n *\n * @see https://reactrouter.com/docs/en/v6/api#uselocation\n */\n\nfunction useLocation() {\n  !useInRouterContext() ? process.env.NODE_ENV !== \"production\" ? invariant(false, // TODO: This error is probably because they somehow have 2 versions of the\n  // router loaded. We can help them understand how to avoid that.\n  \"useLocation() may be used only in the context of a <Router> component.\") : invariant(false) : void 0;\n  return useContext(LocationContext).location;\n}\n/**\n * Returns the current navigation action which describes how the router came to\n * the current location, either by a pop, push, or replace on the history stack.\n *\n * @see https://reactrouter.com/docs/en/v6/api#usenavigationtype\n */\n\nfunction useNavigationType() {\n  return useContext(LocationContext).navigationType;\n}\n/**\n * Returns true if the URL for the given \"to\" value matches the current URL.\n * This is useful for components that need to know \"active\" state, e.g.\n * <NavLink>.\n *\n * @see https://reactrouter.com/docs/en/v6/api#usematch\n */\n\nfunction useMatch(pattern) {\n  !useInRouterContext() ? process.env.NODE_ENV !== \"production\" ? invariant(false, // TODO: This error is probably because they somehow have 2 versions of the\n  // router loaded. We can help them understand how to avoid that.\n  \"useMatch() may be used only in the context of a <Router> component.\") : invariant(false) : void 0;\n  let {\n    pathname\n  } = useLocation();\n  return useMemo(() => matchPath(pattern, pathname), [pathname, pattern]);\n}\n/**\n * The interface for the navigate() function returned from useNavigate().\n */\n\n/**\n * Returns an imperative method for changing the location. Used by <Link>s, but\n * may also be used by other elements to change the location.\n *\n * @see https://reactrouter.com/docs/en/v6/api#usenavigate\n */\nfunction useNavigate() {\n  !useInRouterContext() ? process.env.NODE_ENV !== \"production\" ? invariant(false, // TODO: This error is probably because they somehow have 2 versions of the\n  // router loaded. We can help them understand how to avoid that.\n  \"useNavigate() may be used only in the context of a <Router> component.\") : invariant(false) : void 0;\n  let {\n    basename,\n    navigator\n  } = useContext(NavigationContext);\n  let {\n    matches\n  } = useContext(RouteContext);\n  let {\n    pathname: locationPathname\n  } = useLocation();\n  let routePathnamesJson = JSON.stringify(matches.map(match => match.pathnameBase));\n  let activeRef = useRef(false);\n  useEffect(() => {\n    activeRef.current = true;\n  });\n  let navigate = useCallback(function (to, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    process.env.NODE_ENV !== \"production\" ? warning(activeRef.current, \"You should call navigate() in a React.useEffect(), not when \" + \"your component is first rendered.\") : void 0;\n    if (!activeRef.current) return;\n\n    if (typeof to === \"number\") {\n      navigator.go(to);\n      return;\n    }\n\n    let path = resolveTo(to, JSON.parse(routePathnamesJson), locationPathname);\n\n    if (basename !== \"/\") {\n      path.pathname = joinPaths([basename, path.pathname]);\n    }\n\n    (!!options.replace ? navigator.replace : navigator.push)(path, options.state);\n  }, [basename, navigator, routePathnamesJson, locationPathname]);\n  return navigate;\n}\nconst OutletContext = /*#__PURE__*/createContext(null);\n/**\n * Returns the context (if provided) for the child route at this level of the route\n * hierarchy.\n * @see https://reactrouter.com/docs/en/v6/api#useoutletcontext\n */\n\nfunction useOutletContext() {\n  return useContext(OutletContext);\n}\n/**\n * Returns the element for the child route at this level of the route\n * hierarchy. Used internally by <Outlet> to render child routes.\n *\n * @see https://reactrouter.com/docs/en/v6/api#useoutlet\n */\n\nfunction useOutlet(context) {\n  let outlet = useContext(RouteContext).outlet;\n\n  if (outlet) {\n    return /*#__PURE__*/createElement(OutletContext.Provider, {\n      value: context\n    }, outlet);\n  }\n\n  return outlet;\n}\n/**\n * Returns an object of key/value pairs of the dynamic params from the current\n * URL that were matched by the route path.\n *\n * @see https://reactrouter.com/docs/en/v6/api#useparams\n */\n\nfunction useParams() {\n  let {\n    matches\n  } = useContext(RouteContext);\n  let routeMatch = matches[matches.length - 1];\n  return routeMatch ? routeMatch.params : {};\n}\n/**\n * Resolves the pathname of the given `to` value against the current location.\n *\n * @see https://reactrouter.com/docs/en/v6/api#useresolvedpath\n */\n\nfunction useResolvedPath(to) {\n  let {\n    matches\n  } = useContext(RouteContext);\n  let {\n    pathname: locationPathname\n  } = useLocation();\n  let routePathnamesJson = JSON.stringify(matches.map(match => match.pathnameBase));\n  return useMemo(() => resolveTo(to, JSON.parse(routePathnamesJson), locationPathname), [to, routePathnamesJson, locationPathname]);\n}\n/**\n * Returns the element of the route that matched the current location, prepared\n * with the correct context to render the remainder of the route tree. Route\n * elements in the tree must render an <Outlet> to render their child route's\n * element.\n *\n * @see https://reactrouter.com/docs/en/v6/api#useroutes\n */\n\nfunction useRoutes(routes, locationArg) {\n  !useInRouterContext() ? process.env.NODE_ENV !== \"production\" ? invariant(false, // TODO: This error is probably because they somehow have 2 versions of the\n  // router loaded. We can help them understand how to avoid that.\n  \"useRoutes() may be used only in the context of a <Router> component.\") : invariant(false) : void 0;\n  let {\n    matches: parentMatches\n  } = useContext(RouteContext);\n  let routeMatch = parentMatches[parentMatches.length - 1];\n  let parentParams = routeMatch ? routeMatch.params : {};\n  let parentPathname = routeMatch ? routeMatch.pathname : \"/\";\n  let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : \"/\";\n  let parentRoute = routeMatch && routeMatch.route;\n\n  if (process.env.NODE_ENV !== \"production\") {\n    // You won't get a warning about 2 different <Routes> under a <Route>\n    // without a trailing *, but this is a best-effort warning anyway since we\n    // cannot even give the warning unless they land at the parent route.\n    //\n    // Example:\n    //\n    // <Routes>\n    //   {/* This route path MUST end with /* because otherwise\n    //       it will never match /blog/post/123 */}\n    //   <Route path=\"blog\" element={<Blog />} />\n    //   <Route path=\"blog/feed\" element={<BlogFeed />} />\n    // </Routes>\n    //\n    // function Blog() {\n    //   return (\n    //     <Routes>\n    //       <Route path=\"post/:id\" element={<Post />} />\n    //     </Routes>\n    //   );\n    // }\n    let parentPath = parentRoute && parentRoute.path || \"\";\n    warningOnce(parentPathname, !parentRoute || parentPath.endsWith(\"*\"), \"You rendered descendant <Routes> (or called `useRoutes()`) at \" + (\"\\\"\" + parentPathname + \"\\\" (under <Route path=\\\"\" + parentPath + \"\\\">) but the \") + \"parent route path has no trailing \\\"*\\\". This means if you navigate \" + \"deeper, the parent won't match anymore and therefore the child \" + \"routes will never render.\\n\\n\" + (\"Please change the parent <Route path=\\\"\" + parentPath + \"\\\"> to <Route \") + (\"path=\\\"\" + (parentPath === \"/\" ? \"*\" : parentPath + \"/*\") + \"\\\">.\"));\n  }\n\n  let locationFromContext = useLocation();\n  let location;\n\n  if (locationArg) {\n    var _parsedLocationArg$pa;\n\n    let parsedLocationArg = typeof locationArg === \"string\" ? parsePath(locationArg) : locationArg;\n    !(parentPathnameBase === \"/\" || ((_parsedLocationArg$pa = parsedLocationArg.pathname) == null ? void 0 : _parsedLocationArg$pa.startsWith(parentPathnameBase))) ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"When overriding the location using `<Routes location>` or `useRoutes(routes, location)`, \" + \"the location pathname must begin with the portion of the URL pathname that was \" + (\"matched by all parent routes. The current pathname base is \\\"\" + parentPathnameBase + \"\\\" \") + (\"but pathname \\\"\" + parsedLocationArg.pathname + \"\\\" was given in the `location` prop.\")) : invariant(false) : void 0;\n    location = parsedLocationArg;\n  } else {\n    location = locationFromContext;\n  }\n\n  let pathname = location.pathname || \"/\";\n  let remainingPathname = parentPathnameBase === \"/\" ? pathname : pathname.slice(parentPathnameBase.length) || \"/\";\n  let matches = matchRoutes(routes, {\n    pathname: remainingPathname\n  });\n\n  if (process.env.NODE_ENV !== \"production\") {\n    process.env.NODE_ENV !== \"production\" ? warning(parentRoute || matches != null, \"No routes matched location \\\"\" + location.pathname + location.search + location.hash + \"\\\" \") : void 0;\n    process.env.NODE_ENV !== \"production\" ? warning(matches == null || matches[matches.length - 1].route.element !== undefined, \"Matched leaf route at location \\\"\" + location.pathname + location.search + location.hash + \"\\\" does not have an element. \" + \"This means it will render an <Outlet /> with a null value by default resulting in an \\\"empty\\\" page.\") : void 0;\n  }\n\n  return _renderMatches(matches && matches.map(match => Object.assign({}, match, {\n    params: Object.assign({}, parentParams, match.params),\n    pathname: joinPaths([parentPathnameBase, match.pathname]),\n    pathnameBase: match.pathnameBase === \"/\" ? parentPathnameBase : joinPaths([parentPathnameBase, match.pathnameBase])\n  })), parentMatches);\n}\nfunction _renderMatches(matches, parentMatches) {\n  if (parentMatches === void 0) {\n    parentMatches = [];\n  }\n\n  if (matches == null) return null;\n  return matches.reduceRight((outlet, match, index) => {\n    return /*#__PURE__*/createElement(RouteContext.Provider, {\n      children: match.route.element !== undefined ? match.route.element : outlet,\n      value: {\n        outlet,\n        matches: parentMatches.concat(matches.slice(0, index + 1))\n      }\n    });\n  }, null);\n}\n\n/**\n * A <Router> that stores all entries in memory.\n *\n * @see https://reactrouter.com/docs/en/v6/api#memoryrouter\n */\nfunction MemoryRouter(_ref) {\n  let {\n    basename,\n    children,\n    initialEntries,\n    initialIndex\n  } = _ref;\n  let historyRef = useRef();\n\n  if (historyRef.current == null) {\n    historyRef.current = createMemoryHistory({\n      initialEntries,\n      initialIndex\n    });\n  }\n\n  let history = historyRef.current;\n  let [state, setState] = useState({\n    action: history.action,\n    location: history.location\n  });\n  useLayoutEffect(() => history.listen(setState), [history]);\n  return /*#__PURE__*/createElement(Router, {\n    basename: basename,\n    children: children,\n    location: state.location,\n    navigationType: state.action,\n    navigator: history\n  });\n}\n\n/**\n * Changes the current location.\n *\n * Note: This API is mostly useful in React.Component subclasses that are not\n * able to use hooks. In functional components, we recommend you use the\n * `useNavigate` hook instead.\n *\n * @see https://reactrouter.com/docs/en/v6/api#navigate\n */\nfunction Navigate(_ref2) {\n  let {\n    to,\n    replace,\n    state\n  } = _ref2;\n  !useInRouterContext() ? process.env.NODE_ENV !== \"production\" ? invariant(false, // TODO: This error is probably because they somehow have 2 versions of\n  // the router loaded. We can help them understand how to avoid that.\n  \"<Navigate> may be used only in the context of a <Router> component.\") : invariant(false) : void 0;\n  process.env.NODE_ENV !== \"production\" ? warning(!useContext(NavigationContext).static, \"<Navigate> must not be used on the initial render in a <StaticRouter>. \" + \"This is a no-op, but you should modify your code so the <Navigate> is \" + \"only ever rendered in response to some user interaction or state change.\") : void 0;\n  let navigate = useNavigate();\n  useEffect(() => {\n    navigate(to, {\n      replace,\n      state\n    });\n  });\n  return null;\n}\n\n/**\n * Renders the child route's element, if there is one.\n *\n * @see https://reactrouter.com/docs/en/v6/api#outlet\n */\nfunction Outlet(props) {\n  return useOutlet(props.context);\n}\n\n/**\n * Declares an element that should be rendered at a certain URL path.\n *\n * @see https://reactrouter.com/docs/en/v6/api#route\n */\nfunction Route(_props) {\n   process.env.NODE_ENV !== \"production\" ? invariant(false, \"A <Route> is only ever to be used as the child of <Routes> element, \" + \"never rendered directly. Please wrap your <Route> in a <Routes>.\") : invariant(false) ;\n}\n\n/**\n * Provides location context for the rest of the app.\n *\n * Note: You usually won't render a <Router> directly. Instead, you'll render a\n * router that is more specific to your environment such as a <BrowserRouter>\n * in web browsers or a <StaticRouter> for server rendering.\n *\n * @see https://reactrouter.com/docs/en/v6/api#router\n */\nfunction Router(_ref3) {\n  let {\n    basename: basenameProp = \"/\",\n    children = null,\n    location: locationProp,\n    navigationType = Action.Pop,\n    navigator,\n    static: staticProp = false\n  } = _ref3;\n  !!useInRouterContext() ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"You cannot render a <Router> inside another <Router>.\" + \" You should never have more than one in your app.\") : invariant(false) : void 0;\n  let basename = normalizePathname(basenameProp);\n  let navigationContext = useMemo(() => ({\n    basename,\n    navigator,\n    static: staticProp\n  }), [basename, navigator, staticProp]);\n\n  if (typeof locationProp === \"string\") {\n    locationProp = parsePath(locationProp);\n  }\n\n  let {\n    pathname = \"/\",\n    search = \"\",\n    hash = \"\",\n    state = null,\n    key = \"default\"\n  } = locationProp;\n  let location = useMemo(() => {\n    let trailingPathname = stripBasename(pathname, basename);\n\n    if (trailingPathname == null) {\n      return null;\n    }\n\n    return {\n      pathname: trailingPathname,\n      search,\n      hash,\n      state,\n      key\n    };\n  }, [basename, pathname, search, hash, state, key]);\n  process.env.NODE_ENV !== \"production\" ? warning(location != null, \"<Router basename=\\\"\" + basename + \"\\\"> is not able to match the URL \" + (\"\\\"\" + pathname + search + hash + \"\\\" because it does not start with the \") + \"basename, so the <Router> won't render anything.\") : void 0;\n\n  if (location == null) {\n    return null;\n  }\n\n  return /*#__PURE__*/createElement(NavigationContext.Provider, {\n    value: navigationContext\n  }, /*#__PURE__*/createElement(LocationContext.Provider, {\n    children: children,\n    value: {\n      location,\n      navigationType\n    }\n  }));\n}\n\n/**\n * A container for a nested tree of <Route> elements that renders the branch\n * that best matches the current location.\n *\n * @see https://reactrouter.com/docs/en/v6/api#routes\n */\nfunction Routes(_ref4) {\n  let {\n    children,\n    location\n  } = _ref4;\n  return useRoutes(createRoutesFromChildren(children), location);\n} ///////////////////////////////////////////////////////////////////////////////\n// UTILS\n///////////////////////////////////////////////////////////////////////////////\n\n/**\n * Creates a route config from a React \"children\" object, which is usually\n * either a `<Route>` element or an array of them. Used internally by\n * `<Routes>` to create a route config from its children.\n *\n * @see https://reactrouter.com/docs/en/v6/api#createroutesfromchildren\n */\n\nfunction createRoutesFromChildren(children) {\n  let routes = [];\n  Children.forEach(children, element => {\n    if (! /*#__PURE__*/isValidElement(element)) {\n      // Ignore non-elements. This allows people to more easily inline\n      // conditionals in their route config.\n      return;\n    }\n\n    if (element.type === Fragment) {\n      // Transparently support React.Fragment and its children.\n      routes.push.apply(routes, createRoutesFromChildren(element.props.children));\n      return;\n    }\n\n    !(element.type === Route) ? process.env.NODE_ENV !== \"production\" ? invariant(false, \"[\" + (typeof element.type === \"string\" ? element.type : element.type.name) + \"] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>\") : invariant(false) : void 0;\n    let route = {\n      caseSensitive: element.props.caseSensitive,\n      element: element.props.element,\n      index: element.props.index,\n      path: element.props.path\n    };\n\n    if (element.props.children) {\n      route.children = createRoutesFromChildren(element.props.children);\n    }\n\n    routes.push(route);\n  });\n  return routes;\n}\n/**\n * Renders the result of `matchRoutes()` into a React element.\n */\n\nfunction renderMatches(matches) {\n  return _renderMatches(matches);\n}\n\nexport { MemoryRouter, Navigate, Outlet, Route, Router, Routes, LocationContext as UNSAFE_LocationContext, NavigationContext as UNSAFE_NavigationContext, RouteContext as UNSAFE_RouteContext, createRoutesFromChildren, generatePath, matchPath, matchRoutes, renderMatches, resolvePath, useHref, useInRouterContext, useLocation, useMatch, useNavigate, useNavigationType, useOutlet, useOutletContext, useParams, useResolvedPath, useRoutes };\n//# sourceMappingURL=index.js.map\n","import arrayLikeToArray from \"./arrayLikeToArray.js\";\nexport default function _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}","export var GLOBAL_STYLESHEET_KEY = '__global__';\nexport var SHADOW_DOM_STYLESHEET_SETTING = '__shadow_dom_stylesheet__';\nexport var DEFAULT_SHADOW_CONFIG = {\n    stylesheetKey: GLOBAL_STYLESHEET_KEY,\n    inShadow: false,\n    window: undefined,\n    __isShadowConfig__: true,\n};\nexport var makeShadowConfig = function (stylesheetKey, inShadow, window) {\n    return {\n        stylesheetKey: stylesheetKey,\n        inShadow: inShadow,\n        window: window,\n        __isShadowConfig__: true,\n    };\n};\nexport var isShadowConfig = function (value) {\n    if (!(value && isRecord(value))) {\n        return false;\n    }\n    return value.__isShadowConfig__ === true;\n};\nfunction isRecord(value) {\n    return value !== null && typeof value === 'object' && !Array.isArray(value);\n}\n//# sourceMappingURL=shadowConfig.js.map","/** PURE_IMPORTS_START _util_canReportError,_util_toSubscriber,_symbol_observable,_util_pipe,_config PURE_IMPORTS_END */\nimport { canReportError } from './util/canReportError';\nimport { toSubscriber } from './util/toSubscriber';\nimport { observable as Symbol_observable } from './symbol/observable';\nimport { pipeFromArray } from './util/pipe';\nimport { config } from './config';\nvar Observable = /*@__PURE__*/ (function () {\n    function Observable(subscribe) {\n        this._isScalar = false;\n        if (subscribe) {\n            this._subscribe = subscribe;\n        }\n    }\n    Observable.prototype.lift = function (operator) {\n        var observable = new Observable();\n        observable.source = this;\n        observable.operator = operator;\n        return observable;\n    };\n    Observable.prototype.subscribe = function (observerOrNext, error, complete) {\n        var operator = this.operator;\n        var sink = toSubscriber(observerOrNext, error, complete);\n        if (operator) {\n            sink.add(operator.call(sink, this.source));\n        }\n        else {\n            sink.add(this.source || (config.useDeprecatedSynchronousErrorHandling && !sink.syncErrorThrowable) ?\n                this._subscribe(sink) :\n                this._trySubscribe(sink));\n        }\n        if (config.useDeprecatedSynchronousErrorHandling) {\n            if (sink.syncErrorThrowable) {\n                sink.syncErrorThrowable = false;\n                if (sink.syncErrorThrown) {\n                    throw sink.syncErrorValue;\n                }\n            }\n        }\n        return sink;\n    };\n    Observable.prototype._trySubscribe = function (sink) {\n        try {\n            return this._subscribe(sink);\n        }\n        catch (err) {\n            if (config.useDeprecatedSynchronousErrorHandling) {\n                sink.syncErrorThrown = true;\n                sink.syncErrorValue = err;\n            }\n            if (canReportError(sink)) {\n                sink.error(err);\n            }\n            else {\n                console.warn(err);\n            }\n        }\n    };\n    Observable.prototype.forEach = function (next, promiseCtor) {\n        var _this = this;\n        promiseCtor = getPromiseCtor(promiseCtor);\n        return new promiseCtor(function (resolve, reject) {\n            var subscription;\n            subscription = _this.subscribe(function (value) {\n                try {\n                    next(value);\n                }\n                catch (err) {\n                    reject(err);\n                    if (subscription) {\n                        subscription.unsubscribe();\n                    }\n                }\n            }, reject, resolve);\n        });\n    };\n    Observable.prototype._subscribe = function (subscriber) {\n        var source = this.source;\n        return source && source.subscribe(subscriber);\n    };\n    Observable.prototype[Symbol_observable] = function () {\n        return this;\n    };\n    Observable.prototype.pipe = function () {\n        var operations = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            operations[_i] = arguments[_i];\n        }\n        if (operations.length === 0) {\n            return this;\n        }\n        return pipeFromArray(operations)(this);\n    };\n    Observable.prototype.toPromise = function (promiseCtor) {\n        var _this = this;\n        promiseCtor = getPromiseCtor(promiseCtor);\n        return new promiseCtor(function (resolve, reject) {\n            var value;\n            _this.subscribe(function (x) { return value = x; }, function (err) { return reject(err); }, function () { return resolve(value); });\n        });\n    };\n    Observable.create = function (subscribe) {\n        return new Observable(subscribe);\n    };\n    return Observable;\n}());\nexport { Observable };\nfunction getPromiseCtor(promiseCtor) {\n    if (!promiseCtor) {\n        promiseCtor = config.Promise || Promise;\n    }\n    if (!promiseCtor) {\n        throw new Error('no Promise impl found');\n    }\n    return promiseCtor;\n}\n//# sourceMappingURL=Observable.js.map\n","import { __assign } from \"tslib\";\n/**\n * Format date to a day string representation\n * @param date - input date to format\n */\nexport var formatDay = function (date) { return date.getDate().toString(); };\n/**\n * Format date to a month-day-year string\n * @param date - input date to format\n * @param strings - localized strings\n */\nexport var formatMonthDayYear = function (date, strings) {\n    return strings.months[date.getMonth()] + ' ' + date.getDate() + ', ' + date.getFullYear();\n};\n/**\n * Format date to a month-year string\n * @param date - input date to format\n * @param strings - localized strings\n */\nexport var formatMonthYear = function (date, strings) {\n    return strings.months[date.getMonth()] + ' ' + date.getFullYear();\n};\n/**\n * Format date to a month string\n * @param date - input date to format\n * @param strings - localized strings\n */\nexport var formatMonth = function (date, strings) { return strings.months[date.getMonth()]; };\n/**\n * Format date to a year string representation\n * @param date - input date to format\n */\nexport var formatYear = function (date) { return date.getFullYear().toString(); };\nexport var DEFAULT_DATE_GRID_STRINGS = {\n    months: [\n        'January',\n        'February',\n        'March',\n        'April',\n        'May',\n        'June',\n        'July',\n        'August',\n        'September',\n        'October',\n        'November',\n        'December',\n    ],\n    shortMonths: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],\n    days: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],\n    shortDays: ['S', 'M', 'T', 'W', 'T', 'F', 'S'],\n};\nexport var DEFAULT_DATE_FORMATTING = {\n    formatDay: formatDay,\n    formatMonth: formatMonth,\n    formatYear: formatYear,\n    formatMonthDayYear: formatMonthDayYear,\n    formatMonthYear: formatMonthYear,\n};\nexport var DEFAULT_CALENDAR_STRINGS = __assign(__assign({}, DEFAULT_DATE_GRID_STRINGS), { goToToday: 'Go to today', weekNumberFormatString: 'Week number {0}', prevMonthAriaLabel: 'Previous month', nextMonthAriaLabel: 'Next month', prevYearAriaLabel: 'Previous year', nextYearAriaLabel: 'Next year', prevYearRangeAriaLabel: 'Previous year range', nextYearRangeAriaLabel: 'Next year range', closeButtonAriaLabel: 'Close', selectedDateFormatString: 'Selected date {0}', todayDateFormatString: \"Today's date {0}\", monthPickerHeaderAriaLabel: '{0}, change year', yearPickerHeaderAriaLabel: '{0}, change month', dayMarkedAriaLabel: 'marked' });\n//# sourceMappingURL=dateFormatting.defaults.js.map","import { Node } from '@tiptap/core';\n\n/**\n * The default document node which represents the top level node of the editor.\n * @see https://tiptap.dev/api/nodes/document\n */\nconst Document = Node.create({\n    name: 'doc',\n    topNode: true,\n    content: 'block+',\n});\n\nexport { Document, Document as default };\n//# sourceMappingURL=index.js.map\n","import { FontSizes, FontWeights, LocalizedFontFamilies, LocalizedFontNames } from './FluentFonts';\n// Fallback fonts, if specified system or web fonts are unavailable.\nvar FontFamilyFallbacks = \"'Segoe UI', -apple-system, BlinkMacSystemFont, 'Roboto', 'Helvetica Neue', sans-serif\";\n// By default, we favor system fonts for the default.\n// All localized fonts use a web font and never use the system font.\nvar defaultFontFamily = \"'Segoe UI', '\".concat(LocalizedFontNames.WestEuropean, \"'\");\n// Mapping of language prefix to to font family.\nvar LanguageToFontMap = {\n    ar: LocalizedFontFamilies.Arabic,\n    bg: LocalizedFontFamilies.Cyrillic,\n    cs: LocalizedFontFamilies.EastEuropean,\n    el: LocalizedFontFamilies.Greek,\n    et: LocalizedFontFamilies.EastEuropean,\n    he: LocalizedFontFamilies.Hebrew,\n    hi: LocalizedFontFamilies.Hindi,\n    hr: LocalizedFontFamilies.EastEuropean,\n    hu: LocalizedFontFamilies.EastEuropean,\n    ja: LocalizedFontFamilies.Japanese,\n    kk: LocalizedFontFamilies.EastEuropean,\n    ko: LocalizedFontFamilies.Korean,\n    lt: LocalizedFontFamilies.EastEuropean,\n    lv: LocalizedFontFamilies.EastEuropean,\n    pl: LocalizedFontFamilies.EastEuropean,\n    ru: LocalizedFontFamilies.Cyrillic,\n    sk: LocalizedFontFamilies.EastEuropean,\n    'sr-latn': LocalizedFontFamilies.EastEuropean,\n    th: LocalizedFontFamilies.Thai,\n    tr: LocalizedFontFamilies.EastEuropean,\n    uk: LocalizedFontFamilies.Cyrillic,\n    vi: LocalizedFontFamilies.Vietnamese,\n    'zh-hans': LocalizedFontFamilies.ChineseSimplified,\n    'zh-hant': LocalizedFontFamilies.ChineseTraditional,\n    hy: LocalizedFontFamilies.Armenian,\n    ka: LocalizedFontFamilies.Georgian,\n};\nfunction _fontFamilyWithFallbacks(fontFamily) {\n    return \"\".concat(fontFamily, \", \").concat(FontFamilyFallbacks);\n}\n/**\n * If there is a localized font for this language, return that.\n * Returns undefined if there is no localized font for that language.\n */\nfunction _getLocalizedFontFamily(language) {\n    for (var lang in LanguageToFontMap) {\n        if (LanguageToFontMap.hasOwnProperty(lang) && language && lang.indexOf(language) === 0) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            return LanguageToFontMap[lang];\n        }\n    }\n    return defaultFontFamily;\n}\nfunction _createFont(size, weight, fontFamily) {\n    return {\n        fontFamily: fontFamily,\n        MozOsxFontSmoothing: 'grayscale',\n        WebkitFontSmoothing: 'antialiased',\n        fontSize: size,\n        fontWeight: weight,\n    };\n}\nexport function createFontStyles(localeCode) {\n    var localizedFont = _getLocalizedFontFamily(localeCode);\n    var fontFamilyWithFallback = _fontFamilyWithFallbacks(localizedFont);\n    var fontStyles = {\n        tiny: _createFont(FontSizes.mini, FontWeights.regular, fontFamilyWithFallback),\n        xSmall: _createFont(FontSizes.xSmall, FontWeights.regular, fontFamilyWithFallback),\n        small: _createFont(FontSizes.small, FontWeights.regular, fontFamilyWithFallback),\n        smallPlus: _createFont(FontSizes.smallPlus, FontWeights.regular, fontFamilyWithFallback),\n        medium: _createFont(FontSizes.medium, FontWeights.regular, fontFamilyWithFallback),\n        mediumPlus: _createFont(FontSizes.mediumPlus, FontWeights.regular, fontFamilyWithFallback),\n        large: _createFont(FontSizes.large, FontWeights.regular, fontFamilyWithFallback),\n        xLarge: _createFont(FontSizes.xLarge, FontWeights.semibold, fontFamilyWithFallback),\n        xLargePlus: _createFont(FontSizes.xLargePlus, FontWeights.semibold, fontFamilyWithFallback),\n        xxLarge: _createFont(FontSizes.xxLarge, FontWeights.semibold, fontFamilyWithFallback),\n        xxLargePlus: _createFont(FontSizes.xxLargePlus, FontWeights.semibold, fontFamilyWithFallback),\n        superLarge: _createFont(FontSizes.superLarge, FontWeights.semibold, fontFamilyWithFallback),\n        mega: _createFont(FontSizes.mega, FontWeights.semibold, fontFamilyWithFallback),\n    };\n    return fontStyles;\n}\n//# sourceMappingURL=createFontStyles.js.map","import { __assign } from 'tslib';\nimport { isString } from '../utils.js';\n\nvar createUnitType = function (unit) { return ({\n    test: function (v) {\n        return isString(v) && v.endsWith(unit) && v.split(' ').length === 1;\n    },\n    parse: parseFloat,\n    transform: function (v) { return \"\" + v + unit; },\n}); };\nvar degrees = createUnitType('deg');\nvar percent = createUnitType('%');\nvar px = createUnitType('px');\nvar vh = createUnitType('vh');\nvar vw = createUnitType('vw');\nvar progressPercentage = __assign(__assign({}, percent), { parse: function (v) { return percent.parse(v) / 100; }, transform: function (v) { return percent.transform(v * 100); } });\n\nexport { degrees, percent, progressPercentage, px, vh, vw };\n","import native from './native.js';\nimport rng from './rng.js';\nimport { unsafeStringify } from './stringify.js';\n\nfunction v4(options, buf, offset) {\n  if (native.randomUUID && !buf && !options) {\n    return native.randomUUID();\n  }\n\n  options = options || {};\n  const rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (let i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return unsafeStringify(rnds);\n}\n\nexport default v4;","// keymap/index.ts\nexport * from \"prosemirror-keymap\";\n","import { Mark, mergeAttributes } from '@tiptap/core';\n\n/**\n * This extension allows you to create underline text.\n * @see https://www.tiptap.dev/api/marks/underline\n */\nconst Underline = Mark.create({\n    name: 'underline',\n    addOptions() {\n        return {\n            HTMLAttributes: {},\n        };\n    },\n    parseHTML() {\n        return [\n            {\n                tag: 'u',\n            },\n            {\n                style: 'text-decoration',\n                consuming: false,\n                getAttrs: style => (style.includes('underline') ? {} : false),\n            },\n        ];\n    },\n    renderHTML({ HTMLAttributes }) {\n        return ['u', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];\n    },\n    addCommands() {\n        return {\n            setUnderline: () => ({ commands }) => {\n                return commands.setMark(this.name);\n            },\n            toggleUnderline: () => ({ commands }) => {\n                return commands.toggleMark(this.name);\n            },\n            unsetUnderline: () => ({ commands }) => {\n                return commands.unsetMark(this.name);\n            },\n        };\n    },\n    addKeyboardShortcuts() {\n        return {\n            'Mod-u': () => this.editor.commands.toggleUnderline(),\n            'Mod-U': () => this.editor.commands.toggleUnderline(),\n        };\n    },\n});\n\nexport { Underline, Underline as default };\n//# sourceMappingURL=index.js.map\n","import { findParentNodeClosestToPos, Node, mergeAttributes, callOrReturn, getExtensionField } from '@tiptap/core';\nimport { TextSelection } from '@tiptap/pm/state';\nimport { CellSelection, addColumnBefore, addColumnAfter, deleteColumn, addRowBefore, addRowAfter, deleteRow, deleteTable, mergeCells, splitCell, toggleHeader, toggleHeaderCell, setCellAttr, goToNextCell, fixTables, columnResizing, tableEditing } from '@tiptap/pm/tables';\n\nfunction updateColumns(node, colgroup, table, cellMinWidth, overrideCol, overrideValue) {\n    let totalWidth = 0;\n    let fixedWidth = true;\n    let nextDOM = colgroup.firstChild;\n    const row = node.firstChild;\n    for (let i = 0, col = 0; i < row.childCount; i += 1) {\n        const { colspan, colwidth } = row.child(i).attrs;\n        for (let j = 0; j < colspan; j += 1, col += 1) {\n            const hasWidth = overrideCol === col ? overrideValue : colwidth && colwidth[j];\n            const cssWidth = hasWidth ? `${hasWidth}px` : '';\n            totalWidth += hasWidth || cellMinWidth;\n            if (!hasWidth) {\n                fixedWidth = false;\n            }\n            if (!nextDOM) {\n                colgroup.appendChild(document.createElement('col')).style.width = cssWidth;\n            }\n            else {\n                if (nextDOM.style.width !== cssWidth) {\n                    nextDOM.style.width = cssWidth;\n                }\n                nextDOM = nextDOM.nextSibling;\n            }\n        }\n    }\n    while (nextDOM) {\n        const after = nextDOM.nextSibling;\n        nextDOM.parentNode.removeChild(nextDOM);\n        nextDOM = after;\n    }\n    if (fixedWidth) {\n        table.style.width = `${totalWidth}px`;\n        table.style.minWidth = '';\n    }\n    else {\n        table.style.width = '';\n        table.style.minWidth = `${totalWidth}px`;\n    }\n}\nclass TableView {\n    constructor(node, cellMinWidth) {\n        this.node = node;\n        this.cellMinWidth = cellMinWidth;\n        this.dom = document.createElement('div');\n        this.dom.className = 'tableWrapper';\n        this.table = this.dom.appendChild(document.createElement('table'));\n        this.colgroup = this.table.appendChild(document.createElement('colgroup'));\n        updateColumns(node, this.colgroup, this.table, cellMinWidth);\n        this.contentDOM = this.table.appendChild(document.createElement('tbody'));\n    }\n    update(node) {\n        if (node.type !== this.node.type) {\n            return false;\n        }\n        this.node = node;\n        updateColumns(node, this.colgroup, this.table, this.cellMinWidth);\n        return true;\n    }\n    ignoreMutation(mutation) {\n        return (mutation.type === 'attributes'\n            && (mutation.target === this.table || this.colgroup.contains(mutation.target)));\n    }\n}\n\n/**\n * Creates a colgroup element for a table node in ProseMirror.\n *\n * @param node - The ProseMirror node representing the table.\n * @param cellMinWidth - The minimum width of a cell in the table.\n * @param overrideCol - (Optional) The index of the column to override the width of.\n * @param overrideValue - (Optional) The width value to use for the overridden column.\n * @returns An object containing the colgroup element, the total width of the table, and the minimum width of the table.\n */\nfunction createColGroup(node, cellMinWidth, overrideCol, overrideValue) {\n    let totalWidth = 0;\n    let fixedWidth = true;\n    const cols = [];\n    const row = node.firstChild;\n    if (!row) {\n        return {};\n    }\n    for (let i = 0, col = 0; i < row.childCount; i += 1) {\n        const { colspan, colwidth } = row.child(i).attrs;\n        for (let j = 0; j < colspan; j += 1, col += 1) {\n            const hasWidth = overrideCol === col ? overrideValue : colwidth && colwidth[j];\n            const cssWidth = hasWidth ? `${hasWidth}px` : '';\n            totalWidth += hasWidth || cellMinWidth;\n            if (!hasWidth) {\n                fixedWidth = false;\n            }\n            cols.push(['col', cssWidth ? { style: `width: ${cssWidth}` } : {}]);\n        }\n    }\n    const tableWidth = fixedWidth ? `${totalWidth}px` : '';\n    const tableMinWidth = fixedWidth ? '' : `${totalWidth}px`;\n    const colgroup = ['colgroup', {}, ...cols];\n    return { colgroup, tableWidth, tableMinWidth };\n}\n\nfunction createCell(cellType, cellContent) {\n    if (cellContent) {\n        return cellType.createChecked(null, cellContent);\n    }\n    return cellType.createAndFill();\n}\n\nfunction getTableNodeTypes(schema) {\n    if (schema.cached.tableNodeTypes) {\n        return schema.cached.tableNodeTypes;\n    }\n    const roles = {};\n    Object.keys(schema.nodes).forEach(type => {\n        const nodeType = schema.nodes[type];\n        if (nodeType.spec.tableRole) {\n            roles[nodeType.spec.tableRole] = nodeType;\n        }\n    });\n    schema.cached.tableNodeTypes = roles;\n    return roles;\n}\n\nfunction createTable(schema, rowsCount, colsCount, withHeaderRow, cellContent) {\n    const types = getTableNodeTypes(schema);\n    const headerCells = [];\n    const cells = [];\n    for (let index = 0; index < colsCount; index += 1) {\n        const cell = createCell(types.cell, cellContent);\n        if (cell) {\n            cells.push(cell);\n        }\n        if (withHeaderRow) {\n            const headerCell = createCell(types.header_cell, cellContent);\n            if (headerCell) {\n                headerCells.push(headerCell);\n            }\n        }\n    }\n    const rows = [];\n    for (let index = 0; index < rowsCount; index += 1) {\n        rows.push(types.row.createChecked(null, withHeaderRow && index === 0 ? headerCells : cells));\n    }\n    return types.table.createChecked(null, rows);\n}\n\nfunction isCellSelection(value) {\n    return value instanceof CellSelection;\n}\n\nconst deleteTableWhenAllCellsSelected = ({ editor }) => {\n    const { selection } = editor.state;\n    if (!isCellSelection(selection)) {\n        return false;\n    }\n    let cellCount = 0;\n    const table = findParentNodeClosestToPos(selection.ranges[0].$from, node => {\n        return node.type.name === 'table';\n    });\n    table === null || table === void 0 ? void 0 : table.node.descendants(node => {\n        if (node.type.name === 'table') {\n            return false;\n        }\n        if (['tableCell', 'tableHeader'].includes(node.type.name)) {\n            cellCount += 1;\n        }\n    });\n    const allCellsSelected = cellCount === selection.ranges.length;\n    if (!allCellsSelected) {\n        return false;\n    }\n    editor.commands.deleteTable();\n    return true;\n};\n\n/**\n * This extension allows you to create tables.\n * @see https://www.tiptap.dev/api/nodes/table\n */\nconst Table = Node.create({\n    name: 'table',\n    // @ts-ignore\n    addOptions() {\n        return {\n            HTMLAttributes: {},\n            resizable: false,\n            handleWidth: 5,\n            cellMinWidth: 25,\n            // TODO: fix\n            View: TableView,\n            lastColumnResizable: true,\n            allowTableNodeSelection: false,\n        };\n    },\n    content: 'tableRow+',\n    tableRole: 'table',\n    isolating: true,\n    group: 'block',\n    parseHTML() {\n        return [{ tag: 'table' }];\n    },\n    renderHTML({ node, HTMLAttributes }) {\n        const { colgroup, tableWidth, tableMinWidth } = createColGroup(node, this.options.cellMinWidth);\n        const table = [\n            'table',\n            mergeAttributes(this.options.HTMLAttributes, HTMLAttributes, {\n                style: tableWidth\n                    ? `width: ${tableWidth}`\n                    : `min-width: ${tableMinWidth}`,\n            }),\n            colgroup,\n            ['tbody', 0],\n        ];\n        return table;\n    },\n    addCommands() {\n        return {\n            insertTable: ({ rows = 3, cols = 3, withHeaderRow = true } = {}) => ({ tr, dispatch, editor }) => {\n                const node = createTable(editor.schema, rows, cols, withHeaderRow);\n                if (dispatch) {\n                    const offset = tr.selection.from + 1;\n                    tr.replaceSelectionWith(node)\n                        .scrollIntoView()\n                        .setSelection(TextSelection.near(tr.doc.resolve(offset)));\n                }\n                return true;\n            },\n            addColumnBefore: () => ({ state, dispatch }) => {\n                return addColumnBefore(state, dispatch);\n            },\n            addColumnAfter: () => ({ state, dispatch }) => {\n                return addColumnAfter(state, dispatch);\n            },\n            deleteColumn: () => ({ state, dispatch }) => {\n                return deleteColumn(state, dispatch);\n            },\n            addRowBefore: () => ({ state, dispatch }) => {\n                return addRowBefore(state, dispatch);\n            },\n            addRowAfter: () => ({ state, dispatch }) => {\n                return addRowAfter(state, dispatch);\n            },\n            deleteRow: () => ({ state, dispatch }) => {\n                return deleteRow(state, dispatch);\n            },\n            deleteTable: () => ({ state, dispatch }) => {\n                return deleteTable(state, dispatch);\n            },\n            mergeCells: () => ({ state, dispatch }) => {\n                return mergeCells(state, dispatch);\n            },\n            splitCell: () => ({ state, dispatch }) => {\n                return splitCell(state, dispatch);\n            },\n            toggleHeaderColumn: () => ({ state, dispatch }) => {\n                return toggleHeader('column')(state, dispatch);\n            },\n            toggleHeaderRow: () => ({ state, dispatch }) => {\n                return toggleHeader('row')(state, dispatch);\n            },\n            toggleHeaderCell: () => ({ state, dispatch }) => {\n                return toggleHeaderCell(state, dispatch);\n            },\n            mergeOrSplit: () => ({ state, dispatch }) => {\n                if (mergeCells(state, dispatch)) {\n                    return true;\n                }\n                return splitCell(state, dispatch);\n            },\n            setCellAttribute: (name, value) => ({ state, dispatch }) => {\n                return setCellAttr(name, value)(state, dispatch);\n            },\n            goToNextCell: () => ({ state, dispatch }) => {\n                return goToNextCell(1)(state, dispatch);\n            },\n            goToPreviousCell: () => ({ state, dispatch }) => {\n                return goToNextCell(-1)(state, dispatch);\n            },\n            fixTables: () => ({ state, dispatch }) => {\n                if (dispatch) {\n                    fixTables(state);\n                }\n                return true;\n            },\n            setCellSelection: position => ({ tr, dispatch }) => {\n                if (dispatch) {\n                    const selection = CellSelection.create(tr.doc, position.anchorCell, position.headCell);\n                    // @ts-ignore\n                    tr.setSelection(selection);\n                }\n                return true;\n            },\n        };\n    },\n    addKeyboardShortcuts() {\n        return {\n            Tab: () => {\n                if (this.editor.commands.goToNextCell()) {\n                    return true;\n                }\n                if (!this.editor.can().addRowAfter()) {\n                    return false;\n                }\n                return this.editor.chain().addRowAfter().goToNextCell().run();\n            },\n            'Shift-Tab': () => this.editor.commands.goToPreviousCell(),\n            Backspace: deleteTableWhenAllCellsSelected,\n            'Mod-Backspace': deleteTableWhenAllCellsSelected,\n            Delete: deleteTableWhenAllCellsSelected,\n            'Mod-Delete': deleteTableWhenAllCellsSelected,\n        };\n    },\n    addProseMirrorPlugins() {\n        const isResizable = this.options.resizable && this.editor.isEditable;\n        return [\n            ...(isResizable\n                ? [\n                    columnResizing({\n                        handleWidth: this.options.handleWidth,\n                        cellMinWidth: this.options.cellMinWidth,\n                        View: this.options.View,\n                        lastColumnResizable: this.options.lastColumnResizable,\n                    }),\n                ]\n                : []),\n            tableEditing({\n                allowTableNodeSelection: this.options.allowTableNodeSelection,\n            }),\n        ];\n    },\n    extendNodeSchema(extension) {\n        const context = {\n            name: extension.name,\n            options: extension.options,\n            storage: extension.storage,\n        };\n        return {\n            tableRole: callOrReturn(getExtensionField(extension, 'tableRole', context)),\n        };\n    },\n});\n\nexport { Table, createColGroup, createTable, Table as default };\n//# sourceMappingURL=index.js.map\n","var _typeof = require(\"./typeof.js\")[\"default\"];\nvar toPrimitive = require(\"./toPrimitive.js\");\nfunction _toPropertyKey(arg) {\n  var key = toPrimitive(arg, \"string\");\n  return _typeof(key) === \"symbol\" ? key : String(key);\n}\nmodule.exports = _toPropertyKey, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","export var getActiveElement = function (doc) {\n    var ae = doc.activeElement;\n    while (ae === null || ae === void 0 ? void 0 : ae.shadowRoot) {\n        ae = ae.shadowRoot.activeElement;\n    }\n    return ae;\n};\n//# sourceMappingURL=getActiveElement.js.map","/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Subscriber } from '../Subscriber';\nexport function map(project, thisArg) {\n    return function mapOperation(source) {\n        if (typeof project !== 'function') {\n            throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');\n        }\n        return source.lift(new MapOperator(project, thisArg));\n    };\n}\nvar MapOperator = /*@__PURE__*/ (function () {\n    function MapOperator(project, thisArg) {\n        this.project = project;\n        this.thisArg = thisArg;\n    }\n    MapOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));\n    };\n    return MapOperator;\n}());\nexport { MapOperator };\nvar MapSubscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(MapSubscriber, _super);\n    function MapSubscriber(destination, project, thisArg) {\n        var _this = _super.call(this, destination) || this;\n        _this.project = project;\n        _this.count = 0;\n        _this.thisArg = thisArg || _this;\n        return _this;\n    }\n    MapSubscriber.prototype._next = function (value) {\n        var result;\n        try {\n            result = this.project.call(this.thisArg, value, this.count++);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        this.destination.next(result);\n    };\n    return MapSubscriber;\n}(Subscriber));\n//# sourceMappingURL=map.js.map\n","export var cloneCSSStyleSheet = function (srcSheet, targetSheet) {\n    for (var i = 0; i < srcSheet.cssRules.length; i++) {\n        targetSheet.insertRule(srcSheet.cssRules[i].cssText, i);\n    }\n    return targetSheet;\n};\nexport var cloneExtendedCSSStyleSheet = function (srcSheet, targetSheet) {\n    var clone = cloneCSSStyleSheet(srcSheet, targetSheet);\n    clone.bucketName = srcSheet.bucketName;\n    for (var _i = 0, _a = Object.keys(srcSheet.metadata); _i < _a.length; _i++) {\n        var key = _a[_i];\n        clone.metadata[key] = srcSheet.metadata[key];\n    }\n    return clone;\n};\n//# sourceMappingURL=cloneCSSStyleSheet.js.map","import _typeof from \"./typeof.js\";\nimport assertThisInitialized from \"./assertThisInitialized.js\";\nexport default function _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  } else if (call !== void 0) {\n    throw new TypeError(\"Derived constructors may only return object or undefined\");\n  }\n  return assertThisInitialized(self);\n}","import {clamp as $4507461a1b870123$re_export$clamp, snapValueToStep as $4507461a1b870123$re_export$snapValueToStep} from \"@react-stately/utils\";\nimport $12uGp$react, {useState as $12uGp$useState, useRef as $12uGp$useRef, useCallback as $12uGp$useCallback, useEffect as $12uGp$useEffect} from \"react\";\nimport {useSSRSafeId as $12uGp$useSSRSafeId} from \"@react-aria/ssr\";\nimport $12uGp$clsx from \"clsx\";\n\n\n\nconst $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c = typeof window !== 'undefined' ? $12uGp$react.useLayoutEffect : ()=>{\n};\n\n\n\n\nlet $bdb11010cef70236$var$idsUpdaterMap = new Map();\nfunction $bdb11010cef70236$export$f680877a34711e37(defaultId) {\n    let [value, setValue] = $12uGp$useState(defaultId);\n    let nextId = $12uGp$useRef(null);\n    let res = $12uGp$useSSRSafeId(value);\n    let updateValue = $12uGp$useCallback((val)=>{\n        nextId.current = val;\n    }, []);\n    $bdb11010cef70236$var$idsUpdaterMap.set(res, updateValue);\n    $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c(()=>{\n        let r = res;\n        return ()=>{\n            $bdb11010cef70236$var$idsUpdaterMap.delete(r);\n        };\n    }, [\n        res\n    ]);\n    // This cannot cause an infinite loop because the ref is updated first.\n    // eslint-disable-next-line\n    $12uGp$useEffect(()=>{\n        let newId = nextId.current;\n        if (newId) {\n            nextId.current = null;\n            setValue(newId);\n        }\n    });\n    return res;\n}\nfunction $bdb11010cef70236$export$cd8c9cb68f842629(idA, idB) {\n    if (idA === idB) return idA;\n    let setIdA = $bdb11010cef70236$var$idsUpdaterMap.get(idA);\n    if (setIdA) {\n        setIdA(idB);\n        return idB;\n    }\n    let setIdB = $bdb11010cef70236$var$idsUpdaterMap.get(idB);\n    if (setIdB) {\n        setIdB(idA);\n        return idA;\n    }\n    return idB;\n}\nfunction $bdb11010cef70236$export$b4cc09c592e8fdb8(depArray = []) {\n    let id = $bdb11010cef70236$export$f680877a34711e37();\n    let [resolvedId, setResolvedId] = $1dbecbe27a04f9af$export$14d238f342723f25(id);\n    let updateId = $12uGp$useCallback(()=>{\n        setResolvedId(function*() {\n            yield id;\n            yield document.getElementById(id) ? id : undefined;\n        });\n    }, [\n        id,\n        setResolvedId\n    ]);\n    $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c(updateId, [\n        id,\n        updateId,\n        ...depArray\n    ]);\n    return resolvedId;\n}\n\n\nfunction $ff5963eb1fccf552$export$e08e3b67e392101e(...callbacks) {\n    return (...args)=>{\n        for (let callback of callbacks)if (typeof callback === 'function') callback(...args);\n    };\n}\n\n\n\n\n\nfunction $3ef42575df84b30b$export$9d1611c77c2fe928(...args) {\n    // Start with a base clone of the first argument. This is a lot faster than starting\n    // with an empty object and adding properties as we go.\n    let result = {\n        ...args[0]\n    };\n    for(let i = 1; i < args.length; i++){\n        let props = args[i];\n        for(let key in props){\n            let a = result[key];\n            let b = props[key];\n            // Chain events\n            if (typeof a === 'function' && typeof b === 'function' && // This is a lot faster than a regex.\n            key[0] === 'o' && key[1] === 'n' && key.charCodeAt(2) >= /* 'A' */ 65 && key.charCodeAt(2) <= /* 'Z' */ 90) result[key] = $ff5963eb1fccf552$export$e08e3b67e392101e(a, b);\n            else if ((key === 'className' || key === 'UNSAFE_className') && typeof a === 'string' && typeof b === 'string') result[key] = $12uGp$clsx(a, b);\n            else if (key === 'id' && a && b) result.id = $bdb11010cef70236$export$cd8c9cb68f842629(a, b);\n            else result[key] = b !== undefined ? b : a;\n        }\n    }\n    return result;\n}\n\n\nfunction $5dc95899b306f630$export$c9058316764c140e(...refs) {\n    return (value)=>{\n        for (let ref of refs){\n            if (typeof ref === 'function') ref(value);\n            else if (ref != null) ref.current = value;\n        }\n    };\n}\n\n\nconst $65484d02dcb7eb3e$var$DOMPropNames = new Set([\n    'id'\n]);\nconst $65484d02dcb7eb3e$var$labelablePropNames = new Set([\n    'aria-label',\n    'aria-labelledby',\n    'aria-describedby',\n    'aria-details'\n]);\nconst $65484d02dcb7eb3e$var$propRe = /^(data-.*)$/;\nfunction $65484d02dcb7eb3e$export$457c3d6518dd4c6f(props, opts = {\n}) {\n    let { labelable: labelable , propNames: propNames  } = opts;\n    let filteredProps = {\n    };\n    for(const prop in props)if (Object.prototype.hasOwnProperty.call(props, prop) && ($65484d02dcb7eb3e$var$DOMPropNames.has(prop) || labelable && $65484d02dcb7eb3e$var$labelablePropNames.has(prop) || (propNames === null || propNames === void 0 ? void 0 : propNames.has(prop)) || $65484d02dcb7eb3e$var$propRe.test(prop))) filteredProps[prop] = props[prop];\n    return filteredProps;\n}\n\n\nfunction $7215afc6de606d6b$export$de79e2c695e052f3(element) {\n    if ($7215afc6de606d6b$var$supportsPreventScroll()) element.focus({\n        preventScroll: true\n    });\n    else {\n        let scrollableElements = $7215afc6de606d6b$var$getScrollableElements(element);\n        element.focus();\n        $7215afc6de606d6b$var$restoreScrollPosition(scrollableElements);\n    }\n}\nlet $7215afc6de606d6b$var$supportsPreventScrollCached = null;\nfunction $7215afc6de606d6b$var$supportsPreventScroll() {\n    if ($7215afc6de606d6b$var$supportsPreventScrollCached == null) {\n        $7215afc6de606d6b$var$supportsPreventScrollCached = false;\n        try {\n            var focusElem = document.createElement('div');\n            focusElem.focus({\n                get preventScroll () {\n                    $7215afc6de606d6b$var$supportsPreventScrollCached = true;\n                    return true;\n                }\n            });\n        } catch (e) {\n        // Ignore\n        }\n    }\n    return $7215afc6de606d6b$var$supportsPreventScrollCached;\n}\nfunction $7215afc6de606d6b$var$getScrollableElements(element) {\n    var parent = element.parentNode;\n    var scrollableElements = [];\n    var rootScrollingElement = document.scrollingElement || document.documentElement;\n    while(parent instanceof HTMLElement && parent !== rootScrollingElement){\n        if (parent.offsetHeight < parent.scrollHeight || parent.offsetWidth < parent.scrollWidth) scrollableElements.push({\n            element: parent,\n            scrollTop: parent.scrollTop,\n            scrollLeft: parent.scrollLeft\n        });\n        parent = parent.parentNode;\n    }\n    if (rootScrollingElement instanceof HTMLElement) scrollableElements.push({\n        element: rootScrollingElement,\n        scrollTop: rootScrollingElement.scrollTop,\n        scrollLeft: rootScrollingElement.scrollLeft\n    });\n    return scrollableElements;\n}\nfunction $7215afc6de606d6b$var$restoreScrollPosition(scrollableElements) {\n    for (let { element: element , scrollTop: scrollTop , scrollLeft: scrollLeft  } of scrollableElements){\n        element.scrollTop = scrollTop;\n        element.scrollLeft = scrollLeft;\n    }\n}\n\n\nfunction $ab71dadb03a6fb2e$export$622cea445a1c5b7d(element, reverse, orientation = 'horizontal') {\n    let rect = element.getBoundingClientRect();\n    if (reverse) return orientation === 'horizontal' ? rect.right : rect.bottom;\n    return orientation === 'horizontal' ? rect.left : rect.top;\n}\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ // We store a global list of elements that are currently transitioning,\n// mapped to a set of CSS properties that are transitioning for that element.\n// This is necessary rather than a simple count of transitions because of browser\n// bugs, e.g. Chrome sometimes fires both transitionend and transitioncancel rather\n// than one or the other. So we need to track what's actually transitioning so that\n// we can ignore these duplicate events.\nlet $bbed8b41f857bcc0$var$transitionsByElement = new Map();\n// A list of callbacks to call once there are no transitioning elements.\nlet $bbed8b41f857bcc0$var$transitionCallbacks = new Set();\nfunction $bbed8b41f857bcc0$var$setupGlobalEvents() {\n    if (typeof window === 'undefined') return;\n    let onTransitionStart = (e)=>{\n        // Add the transitioning property to the list for this element.\n        let transitions = $bbed8b41f857bcc0$var$transitionsByElement.get(e.target);\n        if (!transitions) {\n            transitions = new Set();\n            $bbed8b41f857bcc0$var$transitionsByElement.set(e.target, transitions);\n            // The transitioncancel event must be registered on the element itself, rather than as a global\n            // event. This enables us to handle when the node is deleted from the document while it is transitioning.\n            // In that case, the cancel event would have nowhere to bubble to so we need to handle it directly.\n            e.target.addEventListener('transitioncancel', onTransitionEnd);\n        }\n        transitions.add(e.propertyName);\n    };\n    let onTransitionEnd = (e)=>{\n        // Remove property from list of transitioning properties.\n        let properties = $bbed8b41f857bcc0$var$transitionsByElement.get(e.target);\n        if (!properties) return;\n        properties.delete(e.propertyName);\n        // If empty, remove transitioncancel event, and remove the element from the list of transitioning elements.\n        if (properties.size === 0) {\n            e.target.removeEventListener('transitioncancel', onTransitionEnd);\n            $bbed8b41f857bcc0$var$transitionsByElement.delete(e.target);\n        }\n        // If no transitioning elements, call all of the queued callbacks.\n        if ($bbed8b41f857bcc0$var$transitionsByElement.size === 0) {\n            for (let cb of $bbed8b41f857bcc0$var$transitionCallbacks)cb();\n            $bbed8b41f857bcc0$var$transitionCallbacks.clear();\n        }\n    };\n    document.body.addEventListener('transitionrun', onTransitionStart);\n    document.body.addEventListener('transitionend', onTransitionEnd);\n}\nif (typeof document !== 'undefined') {\n    if (document.readyState !== 'loading') $bbed8b41f857bcc0$var$setupGlobalEvents();\n    else document.addEventListener('DOMContentLoaded', $bbed8b41f857bcc0$var$setupGlobalEvents);\n}\nfunction $bbed8b41f857bcc0$export$24490316f764c430(fn) {\n    // Wait one frame to see if an animation starts, e.g. a transition on mount.\n    requestAnimationFrame(()=>{\n        // If no transitions are running, call the function immediately.\n        // Otherwise, add it to a list of callbacks to run at the end of the animation.\n        if ($bbed8b41f857bcc0$var$transitionsByElement.size === 0) fn();\n        else $bbed8b41f857bcc0$var$transitionCallbacks.add(fn);\n    });\n}\n\n\n\n\n// Keep track of elements that we are currently handling dragging for via useDrag1D.\n// If there's an ancestor and a descendant both using useDrag1D(), and the user starts\n// dragging the descendant, we don't want useDrag1D events to fire for the ancestor.\nconst $9cc09df9fd7676be$var$draggingElements = [];\nfunction $9cc09df9fd7676be$export$7bbed75feba39706(props) {\n    console.warn('useDrag1D is deprecated, please use `useMove` instead https://react-spectrum.adobe.com/react-aria/useMove.html');\n    let { containerRef: containerRef , reverse: reverse , orientation: orientation , onHover: onHover , onDrag: onDrag , onPositionChange: onPositionChange , onIncrement: onIncrement , onDecrement: onDecrement , onIncrementToMax: onIncrementToMax , onDecrementToMin: onDecrementToMin , onCollapseToggle: onCollapseToggle  } = props;\n    let getPosition = (e)=>orientation === 'horizontal' ? e.clientX : e.clientY\n    ;\n    let getNextOffset = (e)=>{\n        let containerOffset = $ab71dadb03a6fb2e$export$622cea445a1c5b7d(containerRef.current, reverse, orientation);\n        let mouseOffset = getPosition(e);\n        let nextOffset = reverse ? containerOffset - mouseOffset : mouseOffset - containerOffset;\n        return nextOffset;\n    };\n    let dragging = $12uGp$useRef(false);\n    let prevPosition = $12uGp$useRef(0);\n    // Keep track of the current handlers in a ref so that the events can access them.\n    let handlers = $12uGp$useRef({\n        onPositionChange: onPositionChange,\n        onDrag: onDrag\n    });\n    handlers.current.onDrag = onDrag;\n    handlers.current.onPositionChange = onPositionChange;\n    let onMouseDragged = (e)=>{\n        e.preventDefault();\n        let nextOffset = getNextOffset(e);\n        if (!dragging.current) {\n            dragging.current = true;\n            if (handlers.current.onDrag) handlers.current.onDrag(true);\n            if (handlers.current.onPositionChange) handlers.current.onPositionChange(nextOffset);\n        }\n        if (prevPosition.current === nextOffset) return;\n        prevPosition.current = nextOffset;\n        if (onPositionChange) onPositionChange(nextOffset);\n    };\n    let onMouseUp = (e)=>{\n        const target = e.target;\n        dragging.current = false;\n        let nextOffset = getNextOffset(e);\n        if (handlers.current.onDrag) handlers.current.onDrag(false);\n        if (handlers.current.onPositionChange) handlers.current.onPositionChange(nextOffset);\n        $9cc09df9fd7676be$var$draggingElements.splice($9cc09df9fd7676be$var$draggingElements.indexOf(target), 1);\n        window.removeEventListener('mouseup', onMouseUp, false);\n        window.removeEventListener('mousemove', onMouseDragged, false);\n    };\n    let onMouseDown = (e)=>{\n        const target = e.currentTarget;\n        // If we're already handling dragging on a descendant with useDrag1D, then\n        // we don't want to handle the drag motion on this target as well.\n        if ($9cc09df9fd7676be$var$draggingElements.some((elt)=>target.contains(elt)\n        )) return;\n        $9cc09df9fd7676be$var$draggingElements.push(target);\n        window.addEventListener('mousemove', onMouseDragged, false);\n        window.addEventListener('mouseup', onMouseUp, false);\n    };\n    let onMouseEnter = ()=>{\n        if (onHover) onHover(true);\n    };\n    let onMouseOut = ()=>{\n        if (onHover) onHover(false);\n    };\n    let onKeyDown = (e)=>{\n        switch(e.key){\n            case 'Left':\n            case 'ArrowLeft':\n                if (orientation === 'horizontal') {\n                    e.preventDefault();\n                    if (onDecrement && !reverse) onDecrement();\n                    else if (onIncrement && reverse) onIncrement();\n                }\n                break;\n            case 'Up':\n            case 'ArrowUp':\n                if (orientation === 'vertical') {\n                    e.preventDefault();\n                    if (onDecrement && !reverse) onDecrement();\n                    else if (onIncrement && reverse) onIncrement();\n                }\n                break;\n            case 'Right':\n            case 'ArrowRight':\n                if (orientation === 'horizontal') {\n                    e.preventDefault();\n                    if (onIncrement && !reverse) onIncrement();\n                    else if (onDecrement && reverse) onDecrement();\n                }\n                break;\n            case 'Down':\n            case 'ArrowDown':\n                if (orientation === 'vertical') {\n                    e.preventDefault();\n                    if (onIncrement && !reverse) onIncrement();\n                    else if (onDecrement && reverse) onDecrement();\n                }\n                break;\n            case 'Home':\n                e.preventDefault();\n                if (onDecrementToMin) onDecrementToMin();\n                break;\n            case 'End':\n                e.preventDefault();\n                if (onIncrementToMax) onIncrementToMax();\n                break;\n            case 'Enter':\n                e.preventDefault();\n                if (onCollapseToggle) onCollapseToggle();\n                break;\n        }\n    };\n    return {\n        onMouseDown: onMouseDown,\n        onMouseEnter: onMouseEnter,\n        onMouseOut: onMouseOut,\n        onKeyDown: onKeyDown\n    };\n}\n\n\n\nfunction $03deb23ff14920c4$export$4eaf04e54aa8eed6() {\n    let globalListeners = $12uGp$useRef(new Map());\n    let addGlobalListener = $12uGp$useCallback((eventTarget, type, listener, options)=>{\n        // Make sure we remove the listener after it is called with the `once` option.\n        let fn = (options === null || options === void 0 ? void 0 : options.once) ? (...args)=>{\n            globalListeners.current.delete(listener);\n            listener(...args);\n        } : listener;\n        globalListeners.current.set(listener, {\n            type: type,\n            eventTarget: eventTarget,\n            fn: fn,\n            options: options\n        });\n        eventTarget.addEventListener(type, listener, options);\n    }, []);\n    let removeGlobalListener = $12uGp$useCallback((eventTarget, type, listener, options)=>{\n        var ref;\n        let fn = ((ref = globalListeners.current.get(listener)) === null || ref === void 0 ? void 0 : ref.fn) || listener;\n        eventTarget.removeEventListener(type, fn, options);\n        globalListeners.current.delete(listener);\n    }, []);\n    let removeAllGlobalListeners = $12uGp$useCallback(()=>{\n        globalListeners.current.forEach((value, key)=>{\n            removeGlobalListener(value.eventTarget, value.type, key, value.options);\n        });\n    }, [\n        removeGlobalListener\n    ]);\n    // eslint-disable-next-line arrow-body-style\n    $12uGp$useEffect(()=>{\n        return removeAllGlobalListeners;\n    }, [\n        removeAllGlobalListeners\n    ]);\n    return {\n        addGlobalListener: addGlobalListener,\n        removeGlobalListener: removeGlobalListener,\n        removeAllGlobalListeners: removeAllGlobalListeners\n    };\n}\n\n\n\nfunction $313b98861ee5dd6c$export$d6875122194c7b44(props, defaultLabel) {\n    let { id: id , 'aria-label': label , 'aria-labelledby': labelledBy  } = props;\n    // If there is both an aria-label and aria-labelledby,\n    // combine them by pointing to the element itself.\n    id = $bdb11010cef70236$export$f680877a34711e37(id);\n    if (labelledBy && label) {\n        let ids = new Set([\n            ...labelledBy.trim().split(/\\s+/),\n            id\n        ]);\n        labelledBy = [\n            ...ids\n        ].join(' ');\n    } else if (labelledBy) labelledBy = labelledBy.trim().split(/\\s+/).join(' ');\n    // If no labels are provided, use the default\n    if (!label && !labelledBy && defaultLabel) label = defaultLabel;\n    return {\n        id: id,\n        'aria-label': label,\n        'aria-labelledby': labelledBy\n    };\n}\n\n\n\n\nfunction $df56164dff5785e2$export$4338b53315abf666(forwardedRef) {\n    const objRef = $12uGp$useRef();\n    /**\n   * We're using `useLayoutEffect` here instead of `useEffect` because we want\n   * to make sure that the `ref` value is up to date before other places in the\n   * the execution cycle try to read it.\n   */ $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c(()=>{\n        if (!forwardedRef) return;\n        if (typeof forwardedRef === 'function') forwardedRef(objRef.current);\n        else forwardedRef.current = objRef.current;\n    }, [\n        forwardedRef\n    ]);\n    return objRef;\n}\n\n\n\nfunction $4f58c5f72bcf79f7$export$496315a1608d9602(effect, dependencies) {\n    const isInitialMount = $12uGp$useRef(true);\n    $12uGp$useEffect(()=>{\n        if (isInitialMount.current) isInitialMount.current = false;\n        else effect();\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, dependencies);\n}\n\n\n\n\nfunction $9daab02d461809db$var$hasResizeObserver() {\n    return typeof window.ResizeObserver !== 'undefined';\n}\nfunction $9daab02d461809db$export$683480f191c0e3ea(options) {\n    const { ref: ref , onResize: onResize  } = options;\n    $12uGp$useEffect(()=>{\n        let element = ref === null || ref === void 0 ? void 0 : ref.current;\n        if (!element) return;\n        if (!$9daab02d461809db$var$hasResizeObserver()) {\n            window.addEventListener('resize', onResize, false);\n            return ()=>{\n                window.removeEventListener('resize', onResize, false);\n            };\n        } else {\n            const resizeObserverInstance = new window.ResizeObserver((entries)=>{\n                if (!entries.length) return;\n                onResize();\n            });\n            resizeObserverInstance.observe(element);\n            return ()=>{\n                if (element) resizeObserverInstance.unobserve(element);\n            };\n        }\n    }, [\n        onResize,\n        ref\n    ]);\n}\n\n\n\nfunction $e7801be82b4b2a53$export$4debdb1a3f0fa79e(context, ref) {\n    $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c(()=>{\n        if (context && context.ref && ref) {\n            context.ref.current = ref.current;\n            return ()=>{\n                context.ref.current = null;\n            };\n        }\n    }, [\n        context,\n        ref\n    ]);\n}\n\n\nfunction $62d8ded9296f3872$export$cfa2225e87938781(node) {\n    while(node && !$62d8ded9296f3872$var$isScrollable(node))node = node.parentElement;\n    return node || document.scrollingElement || document.documentElement;\n}\nfunction $62d8ded9296f3872$var$isScrollable(node) {\n    let style = window.getComputedStyle(node);\n    return /(auto|scroll)/.test(style.overflow + style.overflowX + style.overflowY);\n}\n\n\n\n// @ts-ignore\nlet $5df64b3807dc15ee$var$visualViewport = typeof window !== 'undefined' && window.visualViewport;\nfunction $5df64b3807dc15ee$export$d699905dd57c73ca() {\n    let [size1, setSize] = $12uGp$useState(()=>$5df64b3807dc15ee$var$getViewportSize()\n    );\n    $12uGp$useEffect(()=>{\n        // Use visualViewport api to track available height even on iOS virtual keyboard opening\n        let onResize = ()=>{\n            setSize((size)=>{\n                let newSize = $5df64b3807dc15ee$var$getViewportSize();\n                if (newSize.width === size.width && newSize.height === size.height) return size;\n                return newSize;\n            });\n        };\n        if (!$5df64b3807dc15ee$var$visualViewport) window.addEventListener('resize', onResize);\n        else $5df64b3807dc15ee$var$visualViewport.addEventListener('resize', onResize);\n        return ()=>{\n            if (!$5df64b3807dc15ee$var$visualViewport) window.removeEventListener('resize', onResize);\n            else $5df64b3807dc15ee$var$visualViewport.removeEventListener('resize', onResize);\n        };\n    }, []);\n    return size1;\n}\nfunction $5df64b3807dc15ee$var$getViewportSize() {\n    return {\n        width: ($5df64b3807dc15ee$var$visualViewport === null || $5df64b3807dc15ee$var$visualViewport === void 0 ? void 0 : $5df64b3807dc15ee$var$visualViewport.width) || window.innerWidth,\n        height: ($5df64b3807dc15ee$var$visualViewport === null || $5df64b3807dc15ee$var$visualViewport === void 0 ? void 0 : $5df64b3807dc15ee$var$visualViewport.height) || window.innerHeight\n    };\n}\n\n\n\n\nlet $ef06256079686ba0$var$descriptionId = 0;\nconst $ef06256079686ba0$var$descriptionNodes = new Map();\nfunction $ef06256079686ba0$export$f8aeda7b10753fa1(description) {\n    let [id1, setId] = $12uGp$useState(undefined);\n    $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c(()=>{\n        if (!description) return;\n        let desc = $ef06256079686ba0$var$descriptionNodes.get(description);\n        if (!desc) {\n            let id = `react-aria-description-${$ef06256079686ba0$var$descriptionId++}`;\n            setId(id);\n            let node = document.createElement('div');\n            node.id = id;\n            node.style.display = 'none';\n            node.textContent = description;\n            document.body.appendChild(node);\n            desc = {\n                refCount: 0,\n                element: node\n            };\n            $ef06256079686ba0$var$descriptionNodes.set(description, desc);\n        } else setId(desc.element.id);\n        desc.refCount++;\n        return ()=>{\n            if (--desc.refCount === 0) {\n                desc.element.remove();\n                $ef06256079686ba0$var$descriptionNodes.delete(description);\n            }\n        };\n    }, [\n        description\n    ]);\n    return {\n        'aria-describedby': description ? id1 : undefined\n    };\n}\n\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $c87311424ea30a05$var$testUserAgent(re) {\n    var ref;\n    if (typeof window === 'undefined' || window.navigator == null) return false;\n    return ((ref = window.navigator['userAgentData']) === null || ref === void 0 ? void 0 : ref.brands.some((brand)=>re.test(brand.brand)\n    )) || re.test(window.navigator.userAgent);\n}\nfunction $c87311424ea30a05$var$testPlatform(re) {\n    var ref;\n    return typeof window !== 'undefined' && window.navigator != null ? re.test(((ref = window.navigator['userAgentData']) === null || ref === void 0 ? void 0 : ref.platform) || window.navigator.platform) : false;\n}\nfunction $c87311424ea30a05$export$9ac100e40613ea10() {\n    return $c87311424ea30a05$var$testPlatform(/^Mac/i);\n}\nfunction $c87311424ea30a05$export$186c6964ca17d99() {\n    return $c87311424ea30a05$var$testPlatform(/^iPhone/i);\n}\nfunction $c87311424ea30a05$export$7bef049ce92e4224() {\n    return $c87311424ea30a05$var$testPlatform(/^iPad/i) || $c87311424ea30a05$export$9ac100e40613ea10() && navigator.maxTouchPoints > 1;\n}\nfunction $c87311424ea30a05$export$fedb369cb70207f1() {\n    return $c87311424ea30a05$export$186c6964ca17d99() || $c87311424ea30a05$export$7bef049ce92e4224();\n}\nfunction $c87311424ea30a05$export$e1865c3bedcd822b() {\n    return $c87311424ea30a05$export$9ac100e40613ea10() || $c87311424ea30a05$export$fedb369cb70207f1();\n}\nfunction $c87311424ea30a05$export$78551043582a6a98() {\n    return $c87311424ea30a05$var$testUserAgent(/AppleWebKit/i) && !$c87311424ea30a05$export$6446a186d09e379e();\n}\nfunction $c87311424ea30a05$export$6446a186d09e379e() {\n    return $c87311424ea30a05$var$testUserAgent(/Chrome/i);\n}\nfunction $c87311424ea30a05$export$a11b0059900ceec8() {\n    return $c87311424ea30a05$var$testUserAgent(/Android/i);\n}\n\n\n\nfunction $e9faafb641e167db$export$90fc3a17d93f704c(ref, event, handler1, options) {\n    let handlerRef = $12uGp$useRef(handler1);\n    handlerRef.current = handler1;\n    let isDisabled = handler1 == null;\n    $12uGp$useEffect(()=>{\n        if (isDisabled) return;\n        let element = ref.current;\n        let handler = (e)=>handlerRef.current.call(this, e)\n        ;\n        element.addEventListener(event, handler, options);\n        return ()=>{\n            element.removeEventListener(event, handler, options);\n        };\n    }, [\n        ref,\n        event,\n        options,\n        isDisabled\n    ]);\n}\n\n\n\n\nfunction $1dbecbe27a04f9af$export$14d238f342723f25(defaultValue) {\n    let [value, setValue] = $12uGp$useState(defaultValue);\n    let valueRef = $12uGp$useRef(value);\n    let effect = $12uGp$useRef(null);\n    valueRef.current = value;\n    // Store the function in a ref so we can always access the current version\n    // which has the proper `value` in scope.\n    let nextRef = $12uGp$useRef(null);\n    nextRef.current = ()=>{\n        // Run the generator to the next yield.\n        let newValue = effect.current.next();\n        // If the generator is done, reset the effect.\n        if (newValue.done) {\n            effect.current = null;\n            return;\n        }\n        // If the value is the same as the current value,\n        // then continue to the next yield. Otherwise,\n        // set the value in state and wait for the next layout effect.\n        if (value === newValue.value) nextRef.current();\n        else setValue(newValue.value);\n    };\n    $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c(()=>{\n        // If there is an effect currently running, continue to the next yield.\n        if (effect.current) nextRef.current();\n    });\n    let queue = $12uGp$useCallback((fn)=>{\n        effect.current = fn(valueRef.current);\n        nextRef.current();\n    }, [\n        effect,\n        nextRef\n    ]);\n    return [\n        value,\n        queue\n    ];\n}\n\n\nfunction $2f04cbc44ee30ce0$export$53a0910f038337bd(scrollView, element) {\n    let offsetX = $2f04cbc44ee30ce0$var$relativeOffset(scrollView, element, 'left');\n    let offsetY = $2f04cbc44ee30ce0$var$relativeOffset(scrollView, element, 'top');\n    let width = element.offsetWidth;\n    let height = element.offsetHeight;\n    let x = scrollView.scrollLeft;\n    let y = scrollView.scrollTop;\n    let maxX = x + scrollView.offsetWidth;\n    let maxY = y + scrollView.offsetHeight;\n    if (offsetX <= x) x = offsetX;\n    else if (offsetX + width > maxX) x += offsetX + width - maxX;\n    if (offsetY <= y) y = offsetY;\n    else if (offsetY + height > maxY) y += offsetY + height - maxY;\n    scrollView.scrollLeft = x;\n    scrollView.scrollTop = y;\n}\n/**\n * Computes the offset left or top from child to ancestor by accumulating\n * offsetLeft or offsetTop through intervening offsetParents.\n */ function $2f04cbc44ee30ce0$var$relativeOffset(ancestor, child, axis) {\n    const prop = axis === 'left' ? 'offsetLeft' : 'offsetTop';\n    let sum = 0;\n    while(child.offsetParent){\n        sum += child[prop];\n        if (child.offsetParent === ancestor) break;\n        else if (child.offsetParent.contains(ancestor)) {\n            // If the ancestor is not `position:relative`, then we stop at\n            // _its_ offset parent, and we subtract off _its_ offset, so that\n            // we end up with the proper offset from child to ancestor.\n            sum -= ancestor[prop];\n            break;\n        }\n        child = child.offsetParent;\n    }\n    return sum;\n}\n\n\n\n\nfunction $6a7db85432448f7f$export$60278871457622de(event) {\n    // JAWS/NVDA with Firefox.\n    if (event.mozInputSource === 0 && event.isTrusted) return true;\n    // Android TalkBack's detail value varies depending on the event listener providing the event so we have specific logic here instead\n    // If pointerType is defined, event is from a click listener. For events from mousedown listener, detail === 0 is a sufficient check\n    // to detect TalkBack virtual clicks.\n    if ($c87311424ea30a05$export$a11b0059900ceec8() && event.pointerType) return event.type === 'click' && event.buttons === 1;\n    return event.detail === 0 && !event.pointerType;\n}\nfunction $6a7db85432448f7f$export$29bf1b5f2c56cf63(event) {\n    // If the pointer size is zero, then we assume it's from a screen reader.\n    // Android TalkBack double tap will sometimes return a event with width and height of 1\n    // and pointerType === 'mouse' so we need to check for a specific combination of event attributes.\n    // Cannot use \"event.pressure === 0\" as the sole check due to Safari pointer events always returning pressure === 0\n    // instead of .5, see https://bugs.webkit.org/show_bug.cgi?id=206216. event.pointerType === 'mouse' is to distingush\n    // Talkback double tap from Windows Firefox touch screen press\n    return event.width === 0 && event.height === 0 || event.width === 1 && event.height === 1 && event.pressure === 0 && event.detail === 0 && event.pointerType === 'mouse';\n}\n\n\n\n\nexport {$bdb11010cef70236$export$f680877a34711e37 as useId, $bdb11010cef70236$export$cd8c9cb68f842629 as mergeIds, $bdb11010cef70236$export$b4cc09c592e8fdb8 as useSlotId, $ff5963eb1fccf552$export$e08e3b67e392101e as chain, $3ef42575df84b30b$export$9d1611c77c2fe928 as mergeProps, $5dc95899b306f630$export$c9058316764c140e as mergeRefs, $65484d02dcb7eb3e$export$457c3d6518dd4c6f as filterDOMProps, $7215afc6de606d6b$export$de79e2c695e052f3 as focusWithoutScrolling, $ab71dadb03a6fb2e$export$622cea445a1c5b7d as getOffset, $bbed8b41f857bcc0$export$24490316f764c430 as runAfterTransition, $9cc09df9fd7676be$export$7bbed75feba39706 as useDrag1D, $03deb23ff14920c4$export$4eaf04e54aa8eed6 as useGlobalListeners, $313b98861ee5dd6c$export$d6875122194c7b44 as useLabels, $df56164dff5785e2$export$4338b53315abf666 as useObjectRef, $4f58c5f72bcf79f7$export$496315a1608d9602 as useUpdateEffect, $f0a04ccd8dbdd83b$export$e5c5a5f917a5871c as useLayoutEffect, $9daab02d461809db$export$683480f191c0e3ea as useResizeObserver, $e7801be82b4b2a53$export$4debdb1a3f0fa79e as useSyncRef, $62d8ded9296f3872$export$cfa2225e87938781 as getScrollParent, $5df64b3807dc15ee$export$d699905dd57c73ca as useViewportSize, $ef06256079686ba0$export$f8aeda7b10753fa1 as useDescription, $c87311424ea30a05$export$9ac100e40613ea10 as isMac, $c87311424ea30a05$export$186c6964ca17d99 as isIPhone, $c87311424ea30a05$export$7bef049ce92e4224 as isIPad, $c87311424ea30a05$export$fedb369cb70207f1 as isIOS, $c87311424ea30a05$export$e1865c3bedcd822b as isAppleDevice, $c87311424ea30a05$export$78551043582a6a98 as isWebKit, $c87311424ea30a05$export$6446a186d09e379e as isChrome, $c87311424ea30a05$export$a11b0059900ceec8 as isAndroid, $e9faafb641e167db$export$90fc3a17d93f704c as useEvent, $1dbecbe27a04f9af$export$14d238f342723f25 as useValueEffect, $2f04cbc44ee30ce0$export$53a0910f038337bd as scrollIntoView, $4507461a1b870123$re_export$clamp as clamp, $4507461a1b870123$re_export$snapValueToStep as snapValueToStep, $6a7db85432448f7f$export$60278871457622de as isVirtualClick, $6a7db85432448f7f$export$29bf1b5f2c56cf63 as isVirtualPointerEvent};\n//# sourceMappingURL=module.js.map\n","import { SEQUENCE_PREFIX, SEQUENCE_SIZE } from '../constants.esm.js';\nimport { mergeClassesCachedResults } from '../mergeClasses.esm.js';\n\nconst sequenceDetails = {};\nconst cssRules = /*#__PURE__*/new Set();\nconst debugData = {\n  getChildrenSequences: debugSequenceHash => {\n    const key = Object.keys(mergeClassesCachedResults).find(key => mergeClassesCachedResults[key].startsWith(debugSequenceHash));\n    if (key) {\n      // key of the mergeClasses cache contains merge order\n      return key.split(SEQUENCE_PREFIX).filter(sequence => sequence.length).map(sequence => SEQUENCE_PREFIX + sequence);\n    }\n    return [];\n  },\n  addCSSRule: rule => {\n    cssRules.add(rule);\n  },\n  addSequenceDetails: (classNamesForSlots, sourceURL) => {\n    Object.entries(classNamesForSlots).forEach(([slotName, sequenceHash]) => {\n      sequenceDetails[sequenceHash.substring(0, SEQUENCE_SIZE)] = {\n        slotName,\n        sourceURL\n      };\n    });\n  },\n  getCSSRules: () => {\n    return Array.from(cssRules);\n  },\n  getSequenceDetails: sequenceHash => {\n    return sequenceDetails[sequenceHash];\n  }\n};\n\nexport { debugData };\n//# sourceMappingURL=store.esm.js.map\n","var toPropertyKey = require(\"./toPropertyKey.js\");\nfunction _defineProperty(obj, key, value) {\n  key = toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nmodule.exports = _defineProperty, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","import { interpolate } from '../../utils/interpolate.js';\nimport { easeInOut } from '../../easing/index.js';\n\nfunction defaultEasing(values, easing) {\n    return values.map(function () { return easing || easeInOut; }).splice(0, values.length - 1);\n}\nfunction defaultOffset(values) {\n    var numValues = values.length;\n    return values.map(function (_value, i) {\n        return i !== 0 ? i / (numValues - 1) : 0;\n    });\n}\nfunction convertOffsetToTimes(offset, duration) {\n    return offset.map(function (o) { return o * duration; });\n}\nfunction keyframes(_a) {\n    var _b = _a.from, from = _b === void 0 ? 0 : _b, _c = _a.to, to = _c === void 0 ? 1 : _c, ease = _a.ease, offset = _a.offset, _d = _a.duration, duration = _d === void 0 ? 300 : _d;\n    var state = { done: false, value: from };\n    var values = Array.isArray(to) ? to : [from, to];\n    var times = convertOffsetToTimes(offset && offset.length === values.length\n        ? offset\n        : defaultOffset(values), duration);\n    function createInterpolator() {\n        return interpolate(times, values, {\n            ease: Array.isArray(ease) ? ease : defaultEasing(values, ease),\n        });\n    }\n    var interpolator = createInterpolator();\n    return {\n        next: function (t) {\n            state.value = interpolator(t);\n            state.done = t >= duration;\n            return state;\n        },\n        flipTarget: function () {\n            values.reverse();\n            interpolator = createInterpolator();\n        },\n    };\n}\n\nexport { convertOffsetToTimes, defaultEasing, defaultOffset, keyframes };\n","var combineFunctions = function (a, b) { return function (v) { return b(a(v)); }; };\nvar pipe = function () {\n    var transformers = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        transformers[_i] = arguments[_i];\n    }\n    return transformers.reduce(combineFunctions);\n};\n\nexport { pipe };\n","import { __styles as __styles$1 } from '@griffel/core';\nimport { insertionFactory } from './insertionFactory.esm.js';\nimport { useRenderer } from './RendererContext.esm.js';\nimport { useTextDirection } from './TextDirectionContext.esm.js';\n\n/**\n * A version of makeStyles() that accepts build output as an input and skips all runtime transforms.\n *\n * @internal\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nfunction __styles(classesMapBySlot, cssRules) {\n  const getStyles = __styles$1(classesMapBySlot, cssRules, insertionFactory);\n  return function useClasses() {\n    const dir = useTextDirection();\n    const renderer = useRenderer();\n    return getStyles({\n      dir,\n      renderer\n    });\n  };\n}\n\nexport { __styles };\n//# sourceMappingURL=__styles.esm.js.map\n","import { isString } from '../utils.js';\nimport { hex } from './hex.js';\nimport { hsla } from './hsla.js';\nimport { rgba } from './rgba.js';\n\nvar color = {\n    test: function (v) { return rgba.test(v) || hex.test(v) || hsla.test(v); },\n    parse: function (v) {\n        if (rgba.test(v)) {\n            return rgba.parse(v);\n        }\n        else if (hsla.test(v)) {\n            return hsla.parse(v);\n        }\n        else {\n            return hex.parse(v);\n        }\n    },\n    transform: function (v) {\n        return isString(v)\n            ? v\n            : v.hasOwnProperty('red')\n                ? rgba.transform(v)\n                : hsla.transform(v);\n    },\n};\n\nexport { color };\n","import { Extension, isNodeEmpty } from '@tiptap/core';\nimport { Plugin, PluginKey } from '@tiptap/pm/state';\nimport { Decoration, DecorationSet } from '@tiptap/pm/view';\n\n/**\n * This extension allows you to add a placeholder to your editor.\n * A placeholder is a text that appears when the editor or a node is empty.\n * @see https://www.tiptap.dev/api/extensions/placeholder\n */\nconst Placeholder = Extension.create({\n    name: 'placeholder',\n    addOptions() {\n        return {\n            emptyEditorClass: 'is-editor-empty',\n            emptyNodeClass: 'is-empty',\n            placeholder: 'Write something ',\n            showOnlyWhenEditable: true,\n            showOnlyCurrent: true,\n            includeChildren: false,\n        };\n    },\n    addProseMirrorPlugins() {\n        return [\n            new Plugin({\n                key: new PluginKey('placeholder'),\n                props: {\n                    decorations: ({ doc, selection }) => {\n                        const active = this.editor.isEditable || !this.options.showOnlyWhenEditable;\n                        const { anchor } = selection;\n                        const decorations = [];\n                        if (!active) {\n                            return null;\n                        }\n                        const isEmptyDoc = this.editor.isEmpty;\n                        doc.descendants((node, pos) => {\n                            const hasAnchor = anchor >= pos && anchor <= pos + node.nodeSize;\n                            const isEmpty = !node.isLeaf && isNodeEmpty(node);\n                            if ((hasAnchor || !this.options.showOnlyCurrent) && isEmpty) {\n                                const classes = [this.options.emptyNodeClass];\n                                if (isEmptyDoc) {\n                                    classes.push(this.options.emptyEditorClass);\n                                }\n                                const decoration = Decoration.node(pos, pos + node.nodeSize, {\n                                    class: classes.join(' '),\n                                    'data-placeholder': typeof this.options.placeholder === 'function'\n                                        ? this.options.placeholder({\n                                            editor: this.editor,\n                                            node,\n                                            pos,\n                                            hasAnchor,\n                                        })\n                                        : this.options.placeholder,\n                                });\n                                decorations.push(decoration);\n                            }\n                            return this.options.includeChildren;\n                        });\n                        return DecorationSet.create(doc, decorations);\n                    },\n                },\n            }),\n        ];\n    },\n});\n\nexport { Placeholder, Placeholder as default };\n//# sourceMappingURL=index.js.map\n","/** PURE_IMPORTS_START _util_isArray,_util_isObject,_util_isFunction,_util_UnsubscriptionError PURE_IMPORTS_END */\nimport { isArray } from './util/isArray';\nimport { isObject } from './util/isObject';\nimport { isFunction } from './util/isFunction';\nimport { UnsubscriptionError } from './util/UnsubscriptionError';\nvar Subscription = /*@__PURE__*/ (function () {\n    function Subscription(unsubscribe) {\n        this.closed = false;\n        this._parentOrParents = null;\n        this._subscriptions = null;\n        if (unsubscribe) {\n            this._ctorUnsubscribe = true;\n            this._unsubscribe = unsubscribe;\n        }\n    }\n    Subscription.prototype.unsubscribe = function () {\n        var errors;\n        if (this.closed) {\n            return;\n        }\n        var _a = this, _parentOrParents = _a._parentOrParents, _ctorUnsubscribe = _a._ctorUnsubscribe, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;\n        this.closed = true;\n        this._parentOrParents = null;\n        this._subscriptions = null;\n        if (_parentOrParents instanceof Subscription) {\n            _parentOrParents.remove(this);\n        }\n        else if (_parentOrParents !== null) {\n            for (var index = 0; index < _parentOrParents.length; ++index) {\n                var parent_1 = _parentOrParents[index];\n                parent_1.remove(this);\n            }\n        }\n        if (isFunction(_unsubscribe)) {\n            if (_ctorUnsubscribe) {\n                this._unsubscribe = undefined;\n            }\n            try {\n                _unsubscribe.call(this);\n            }\n            catch (e) {\n                errors = e instanceof UnsubscriptionError ? flattenUnsubscriptionErrors(e.errors) : [e];\n            }\n        }\n        if (isArray(_subscriptions)) {\n            var index = -1;\n            var len = _subscriptions.length;\n            while (++index < len) {\n                var sub = _subscriptions[index];\n                if (isObject(sub)) {\n                    try {\n                        sub.unsubscribe();\n                    }\n                    catch (e) {\n                        errors = errors || [];\n                        if (e instanceof UnsubscriptionError) {\n                            errors = errors.concat(flattenUnsubscriptionErrors(e.errors));\n                        }\n                        else {\n                            errors.push(e);\n                        }\n                    }\n                }\n            }\n        }\n        if (errors) {\n            throw new UnsubscriptionError(errors);\n        }\n    };\n    Subscription.prototype.add = function (teardown) {\n        var subscription = teardown;\n        if (!teardown) {\n            return Subscription.EMPTY;\n        }\n        switch (typeof teardown) {\n            case 'function':\n                subscription = new Subscription(teardown);\n            case 'object':\n                if (subscription === this || subscription.closed || typeof subscription.unsubscribe !== 'function') {\n                    return subscription;\n                }\n                else if (this.closed) {\n                    subscription.unsubscribe();\n                    return subscription;\n                }\n                else if (!(subscription instanceof Subscription)) {\n                    var tmp = subscription;\n                    subscription = new Subscription();\n                    subscription._subscriptions = [tmp];\n                }\n                break;\n            default: {\n                throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');\n            }\n        }\n        var _parentOrParents = subscription._parentOrParents;\n        if (_parentOrParents === null) {\n            subscription._parentOrParents = this;\n        }\n        else if (_parentOrParents instanceof Subscription) {\n            if (_parentOrParents === this) {\n                return subscription;\n            }\n            subscription._parentOrParents = [_parentOrParents, this];\n        }\n        else if (_parentOrParents.indexOf(this) === -1) {\n            _parentOrParents.push(this);\n        }\n        else {\n            return subscription;\n        }\n        var subscriptions = this._subscriptions;\n        if (subscriptions === null) {\n            this._subscriptions = [subscription];\n        }\n        else {\n            subscriptions.push(subscription);\n        }\n        return subscription;\n    };\n    Subscription.prototype.remove = function (subscription) {\n        var subscriptions = this._subscriptions;\n        if (subscriptions) {\n            var subscriptionIndex = subscriptions.indexOf(subscription);\n            if (subscriptionIndex !== -1) {\n                subscriptions.splice(subscriptionIndex, 1);\n            }\n        }\n    };\n    Subscription.EMPTY = (function (empty) {\n        empty.closed = true;\n        return empty;\n    }(new Subscription()));\n    return Subscription;\n}());\nexport { Subscription };\nfunction flattenUnsubscriptionErrors(errors) {\n    return errors.reduce(function (errs, err) { return errs.concat((err instanceof UnsubscriptionError) ? err.errors : err); }, []);\n}\n//# sourceMappingURL=Subscription.js.map\n","/** PURE_IMPORTS_START tslib,_Subject,_util_ObjectUnsubscribedError PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Subject } from './Subject';\nimport { ObjectUnsubscribedError } from './util/ObjectUnsubscribedError';\nvar BehaviorSubject = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(BehaviorSubject, _super);\n    function BehaviorSubject(_value) {\n        var _this = _super.call(this) || this;\n        _this._value = _value;\n        return _this;\n    }\n    Object.defineProperty(BehaviorSubject.prototype, \"value\", {\n        get: function () {\n            return this.getValue();\n        },\n        enumerable: true,\n        configurable: true\n    });\n    BehaviorSubject.prototype._subscribe = function (subscriber) {\n        var subscription = _super.prototype._subscribe.call(this, subscriber);\n        if (subscription && !subscription.closed) {\n            subscriber.next(this._value);\n        }\n        return subscription;\n    };\n    BehaviorSubject.prototype.getValue = function () {\n        if (this.hasError) {\n            throw this.thrownError;\n        }\n        else if (this.closed) {\n            throw new ObjectUnsubscribedError();\n        }\n        else {\n            return this._value;\n        }\n    };\n    BehaviorSubject.prototype.next = function (value) {\n        _super.prototype.next.call(this, this._value = value);\n    };\n    return BehaviorSubject;\n}(Subject));\nexport { BehaviorSubject };\n//# sourceMappingURL=BehaviorSubject.js.map\n","import getVariation from \"./getVariation.js\";\nimport { variationPlacements, basePlacements, placements as allPlacements } from \"../enums.js\";\nimport detectOverflow from \"./detectOverflow.js\";\nimport getBasePlacement from \"./getBasePlacement.js\";\nexport default function computeAutoPlacement(state, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _options = options,\n      placement = _options.placement,\n      boundary = _options.boundary,\n      rootBoundary = _options.rootBoundary,\n      padding = _options.padding,\n      flipVariations = _options.flipVariations,\n      _options$allowedAutoP = _options.allowedAutoPlacements,\n      allowedAutoPlacements = _options$allowedAutoP === void 0 ? allPlacements : _options$allowedAutoP;\n  var variation = getVariation(placement);\n  var placements = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function (placement) {\n    return getVariation(placement) === variation;\n  }) : basePlacements;\n  var allowedPlacements = placements.filter(function (placement) {\n    return allowedAutoPlacements.indexOf(placement) >= 0;\n  });\n\n  if (allowedPlacements.length === 0) {\n    allowedPlacements = placements;\n  } // $FlowFixMe[incompatible-type]: Flow seems to have problems with two array unions...\n\n\n  var overflows = allowedPlacements.reduce(function (acc, placement) {\n    acc[placement] = detectOverflow(state, {\n      placement: placement,\n      boundary: boundary,\n      rootBoundary: rootBoundary,\n      padding: padding\n    })[getBasePlacement(placement)];\n    return acc;\n  }, {});\n  return Object.keys(overflows).sort(function (a, b) {\n    return overflows[a] - overflows[b];\n  });\n}","import { __assign } from \"tslib\";\nimport { concatStyleSets } from './concatStyleSets';\nimport { extractStyleParts } from './extractStyleParts';\nimport { getStyleOptions } from './StyleOptionsState';\nimport { applyRegistration, styleToRegistration } from './styleToClassName';\nimport { isShadowConfig } from './shadowConfig';\nimport { Stylesheet } from './Stylesheet';\n/**\n * Takes in one or more style set objects, each consisting of a set of areas,\n * each which will produce a class name. Using this is analogous to calling\n * `mergeStyles` for each property in the object, but ensures we maintain the\n * set ordering when multiple style sets are merged.\n *\n * @param styleSets - One or more style sets to be merged.\n */\nexport function mergeStyleSets() {\n    var styleSets = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        styleSets[_i] = arguments[_i];\n    }\n    return mergeCssSets(styleSets, getStyleOptions());\n}\n/**\n * Takes in one or more style set objects, each1consisting of a set of areas,\n * each which will produce a class name. Using this is analogous to calling\n * `mergeCss` for each property in the object, but ensures the\n * set ordering when multiple style sets are merged.\n *\n * @param styleSets - One or more style sets to be merged.\n * @param options - (optional) Options to use when creating rules.\n */\nexport function mergeCssSets(styleSets, options) {\n    var classNameSet = { subComponentStyles: {} };\n    var shadowConfig = undefined;\n    var styleSet;\n    if (isShadowConfig(styleSets[0])) {\n        shadowConfig = styleSets[0];\n        styleSet = styleSets[1];\n    }\n    else {\n        styleSet = styleSets[0];\n    }\n    shadowConfig !== null && shadowConfig !== void 0 ? shadowConfig : (shadowConfig = options === null || options === void 0 ? void 0 : options.shadowConfig);\n    var opts = __assign(__assign({}, options), { shadowConfig: shadowConfig });\n    if (!styleSet && styleSets.length <= 1) {\n        return { subComponentStyles: {} };\n    }\n    var sheet = Stylesheet.getInstance(shadowConfig);\n    opts.stylesheet = sheet;\n    var concatenatedStyleSet = concatStyleSets.apply(void 0, styleSets);\n    var registrations = [];\n    for (var styleSetArea in concatenatedStyleSet) {\n        if (concatenatedStyleSet.hasOwnProperty(styleSetArea)) {\n            if (styleSetArea === 'subComponentStyles') {\n                classNameSet.subComponentStyles = concatenatedStyleSet.subComponentStyles || {};\n                continue;\n            }\n            else if (styleSetArea === '__shadowConfig__') {\n                continue;\n            }\n            var styles = concatenatedStyleSet[styleSetArea];\n            var _a = extractStyleParts(sheet, styles), classes = _a.classes, objects = _a.objects;\n            if (objects === null || objects === void 0 ? void 0 : objects.length) {\n                var registration = styleToRegistration(opts || {}, { displayName: styleSetArea }, objects);\n                if (registration) {\n                    registrations.push(registration);\n                    classNameSet[styleSetArea] = classes.concat([registration.className]).join(' ');\n                }\n            }\n            else {\n                classNameSet[styleSetArea] = classes.join(' ');\n            }\n        }\n    }\n    for (var _i = 0, registrations_1 = registrations; _i < registrations_1.length; _i++) {\n        var registration = registrations_1[_i];\n        if (registration) {\n            applyRegistration(registration, options === null || options === void 0 ? void 0 : options.specificityMultiplier, shadowConfig);\n        }\n    }\n    return classNameSet;\n}\n//# sourceMappingURL=mergeStyleSets.js.map","const isDevToolsEnabled = /*#__PURE__*/(() => {\n  var _a;\n  // Accessing \"window.sessionStorage\" causes an exception when third party cookies are blocked\n  // https://stackoverflow.com/questions/30481516/iframe-in-chrome-error-failed-to-read-localstorage-from-window-access-deni\n  try {\n    return Boolean(typeof window !== 'undefined' && ((_a = window.sessionStorage) === null || _a === void 0 ? void 0 : _a.getItem('__GRIFFEL_DEVTOOLS__')));\n  } catch (e) {\n    return false;\n  }\n})();\n\nexport { isDevToolsEnabled };\n//# sourceMappingURL=isDevToolsEnabled.esm.js.map\n","import { getDocument } from '@fluentui/utilities';\nimport * as React from 'react';\nimport { useWindow } from '@fluentui/react-window-provider';\n/**\n * Hook to calculate and cache the target element specified by the given target attribute,\n * as well as the target element's (or host element's) parent window\n * @param target- Target selector passed to the component as a property, describing the element that\n * the callout should target\n * @param hostElement- The callout's host element, used for determining the parent window.\n */\nexport function useTarget(target, hostElement) {\n    var _a, _b, _c;\n    var previousTargetProp = React.useRef();\n    var targetRef = React.useRef(null);\n    /**\n     * Stores an instance of Window, used to check\n     * for server side rendering and if focus was lost.\n     */\n    var targetWindow = useWindow();\n    // If the target element changed, find the new one. If we are tracking\n    // target with class name, always find element because we do not know if\n    // fabric has rendered a new element and disposed the old element.\n    if (!target || target !== previousTargetProp.current || typeof target === 'string') {\n        var currentElement = hostElement === null || hostElement === void 0 ? void 0 : hostElement.current;\n        if (target) {\n            if (typeof target === 'string') {\n                // If element is part of shadow dom, then querySelector on shadow root, else query on document\n                if ((_a = currentElement === null || currentElement === void 0 ? void 0 : currentElement.getRootNode()) === null || _a === void 0 ? void 0 : _a.host) {\n                    targetRef.current = (_c = (_b = currentElement === null || currentElement === void 0 ? void 0 : currentElement.getRootNode()) === null || _b === void 0 ? void 0 : _b.querySelector(target)) !== null && _c !== void 0 ? _c : null;\n                }\n                else {\n                    var currentDoc = getDocument(currentElement);\n                    targetRef.current = currentDoc ? currentDoc.querySelector(target) : null;\n                }\n            }\n            else if ('stopPropagation' in target) {\n                targetRef.current = target;\n            }\n            else if ('getBoundingClientRect' in target) {\n                targetRef.current = target;\n            }\n            else if ('current' in target) {\n                targetRef.current = target.current;\n            }\n            else {\n                targetRef.current = target;\n            }\n        }\n        previousTargetProp.current = target;\n    }\n    return [targetRef, targetWindow];\n}\n//# sourceMappingURL=useTarget.js.map","import toPropertyKey from \"./toPropertyKey.js\";\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, toPropertyKey(descriptor.key), descriptor);\n  }\n}\nexport default function _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}","import { DayOfWeek, MonthOfYear, FirstWeekOfYear, DateRangeType } from '../dateValues/dateValues';\nimport { TimeConstants } from '../dateValues/timeConstants';\n/**\n * Returns a date offset from the given date by the specified number of days.\n * @param date - The origin date\n * @param days - The number of days to offset. 'days' can be negative.\n * @returns A new Date object offset from the origin date by the given number of days\n */\nexport function addDays(date, days) {\n    var result = new Date(date.getTime());\n    result.setDate(result.getDate() + days);\n    return result;\n}\n/**\n * Returns a date offset from the given date by the specified number of weeks.\n * @param date - The origin date\n * @param weeks - The number of weeks to offset. 'weeks' can be negative.\n * @returns A new Date object offset from the origin date by the given number of weeks\n */\nexport function addWeeks(date, weeks) {\n    return addDays(date, weeks * TimeConstants.DaysInOneWeek);\n}\n/**\n * Returns a date offset from the given date by the specified number of months.\n * The method tries to preserve the day-of-month; however, if the new month does not have enough days\n * to contain the original day-of-month, we'll use the last day of the new month.\n * @param date - The origin date\n * @param months - The number of months to offset. 'months' can be negative.\n * @returns A new Date object offset from the origin date by the given number of months\n */\nexport function addMonths(date, months) {\n    var result = new Date(date.getTime());\n    var newMonth = result.getMonth() + months;\n    result.setMonth(newMonth);\n    // We want to maintain the same day-of-month, but that may not be possible if the new month doesn't have enough days.\n    // Loop until we back up to a day the new month has.\n    // (Weird modulo math is due to Javascript's treatment of negative numbers in modulo)\n    if (result.getMonth() !==\n        ((newMonth % TimeConstants.MonthInOneYear) + TimeConstants.MonthInOneYear) % TimeConstants.MonthInOneYear) {\n        result = addDays(result, -result.getDate());\n    }\n    return result;\n}\n/**\n * Returns a date offset from the given date by the specified number of years.\n * The method tries to preserve the day-of-month; however, if the new month does not have enough days\n * to contain the original day-of-month, we'll use the last day of the new month.\n * @param date - The origin date\n * @param years - The number of years to offset. 'years' can be negative.\n * @returns A new Date object offset from the origin date by the given number of years\n */\nexport function addYears(date, years) {\n    var result = new Date(date.getTime());\n    result.setFullYear(date.getFullYear() + years);\n    // We want to maintain the same day-of-month, but that may not be possible if the new month doesn't have enough days.\n    // Loop until we back up to a day the new month has.\n    // (Weird modulo math is due to Javascript's treatment of negative numbers in modulo)\n    if (result.getMonth() !==\n        ((date.getMonth() % TimeConstants.MonthInOneYear) + TimeConstants.MonthInOneYear) % TimeConstants.MonthInOneYear) {\n        result = addDays(result, -result.getDate());\n    }\n    return result;\n}\n/**\n * Returns a date that is the first day of the month of the provided date.\n * @param date - The origin date\n * @returns A new Date object with the day set to the first day of the month.\n */\nexport function getMonthStart(date) {\n    return new Date(date.getFullYear(), date.getMonth(), 1, 0, 0, 0, 0);\n}\n/**\n * Returns a date that is the last day of the month of the provided date.\n * @param date - The origin date\n * @returns A new Date object with the day set to the last day of the month.\n */\nexport function getMonthEnd(date) {\n    return new Date(date.getFullYear(), date.getMonth() + 1, 0, 0, 0, 0, 0);\n}\n/**\n * Returns a date that is the first day of the year of the provided date.\n * @param date - The origin date\n * @returns A new Date object with the day set to the first day of the year.\n */\nexport function getYearStart(date) {\n    return new Date(date.getFullYear(), 0, 1, 0, 0, 0, 0);\n}\n/**\n * Returns a date that is the last day of the year of the provided date.\n * @param date - The origin date\n * @returns A new Date object with the day set to the last day of the year.\n */\nexport function getYearEnd(date) {\n    return new Date(date.getFullYear() + 1, 0, 0, 0, 0, 0, 0);\n}\n/**\n * Returns a date that is a copy of the given date, aside from the month changing to the given month.\n *  The method tries to preserve the day-of-month; however, if the new month does not have enough days\n * to contain the original day-of-month, we'll use the last day of the new month.\n * @param date - The origin date\n * @param month - The 0-based index of the month to set on the date.\n * @returns A new Date object with the given month set.\n */\nexport function setMonth(date, month) {\n    return addMonths(date, month - date.getMonth());\n}\n/**\n * Compares two dates, and returns true if the two dates (not accounting for time-of-day) are equal.\n * @returns True if the two dates represent the same date (regardless of time-of-day), false otherwise.\n */\nexport function compareDates(date1, date2) {\n    if (!date1 && !date2) {\n        return true;\n    }\n    else if (!date1 || !date2) {\n        return false;\n    }\n    else {\n        return (date1.getFullYear() === date2.getFullYear() &&\n            date1.getMonth() === date2.getMonth() &&\n            date1.getDate() === date2.getDate());\n    }\n}\n/**\n * Compare the date parts of two dates\n * @param date1 - The first date to compare\n * @param date2 - The second date to compare\n * @returns A negative value if date1 is earlier than date2, 0 if the dates are equal, or a positive value\n * if date1 is later than date2.\n */\nexport function compareDatePart(date1, date2) {\n    return getDatePartHashValue(date1) - getDatePartHashValue(date2);\n}\n/**\n * Gets the date range array including the specified date. The date range array is calculated as the list\n * of dates accounting for the specified first day of the week and date range type.\n * @param date - The input date\n * @param dateRangeType - The desired date range type, i.e., day, week, month, etc.\n * @param firstDayOfWeek - The first day of the week.\n * @param workWeekDays - The allowed days in work week. If not provided, assumes all days are allowed.\n * @param daysToSelectInDayView - The number of days to include when using dateRangeType === DateRangeType.Day\n * for multiday view. Defaults to 1\n * @returns An array of dates representing the date range containing the specified date.\n */\nexport function getDateRangeArray(date, dateRangeType, firstDayOfWeek, workWeekDays, daysToSelectInDayView) {\n    if (daysToSelectInDayView === void 0) { daysToSelectInDayView = 1; }\n    var datesArray = [];\n    var startDate;\n    var endDate = null;\n    if (!workWeekDays) {\n        workWeekDays = [DayOfWeek.Monday, DayOfWeek.Tuesday, DayOfWeek.Wednesday, DayOfWeek.Thursday, DayOfWeek.Friday];\n    }\n    daysToSelectInDayView = Math.max(daysToSelectInDayView, 1);\n    switch (dateRangeType) {\n        case DateRangeType.Day:\n            startDate = getDatePart(date);\n            endDate = addDays(startDate, daysToSelectInDayView);\n            break;\n        case DateRangeType.Week:\n        case DateRangeType.WorkWeek:\n            startDate = getStartDateOfWeek(getDatePart(date), firstDayOfWeek);\n            endDate = addDays(startDate, TimeConstants.DaysInOneWeek);\n            break;\n        case DateRangeType.Month:\n            startDate = new Date(date.getFullYear(), date.getMonth(), 1);\n            endDate = addMonths(startDate, 1);\n            break;\n        default:\n            throw new Error('Unexpected object: ' + dateRangeType);\n    }\n    // Populate the dates array with the dates in range\n    var nextDate = startDate;\n    do {\n        if (dateRangeType !== DateRangeType.WorkWeek) {\n            // push all days not in work week view\n            datesArray.push(nextDate);\n        }\n        else if (workWeekDays.indexOf(nextDate.getDay()) !== -1) {\n            datesArray.push(nextDate);\n        }\n        nextDate = addDays(nextDate, 1);\n    } while (!compareDates(nextDate, endDate));\n    return datesArray;\n}\n/**\n * Checks whether the specified date is in the given date range.\n * @param date - The origin date\n * @param dateRange - An array of dates to do the lookup on\n * @returns True if the date matches one of the dates in the specified array, false otherwise.\n */\nexport function isInDateRangeArray(date, dateRange) {\n    for (var _i = 0, dateRange_1 = dateRange; _i < dateRange_1.length; _i++) {\n        var dateInRange = dateRange_1[_i];\n        if (compareDates(date, dateInRange)) {\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * Returns the week number for a date.\n * Week numbers are 1 - 52 (53) in a year\n * @param navigatedDate - A date to find the week number for.\n * @param firstDayOfWeek - The first day of the week (0-6, Sunday = 0)\n * @param firstWeekOfYear - The first week of the year (1-2)\n * @returns The weeks number array for the current month.\n */\nexport function getWeekNumbersInMonth(weeksInMonth, firstDayOfWeek, firstWeekOfYear, navigatedDate) {\n    var selectedYear = navigatedDate.getFullYear();\n    var selectedMonth = navigatedDate.getMonth();\n    var dayOfMonth = 1;\n    var fistDayOfMonth = new Date(selectedYear, selectedMonth, dayOfMonth);\n    var endOfFirstWeek = dayOfMonth +\n        (firstDayOfWeek + TimeConstants.DaysInOneWeek - 1) -\n        adjustWeekDay(firstDayOfWeek, fistDayOfMonth.getDay());\n    var endOfWeekRange = new Date(selectedYear, selectedMonth, endOfFirstWeek);\n    dayOfMonth = endOfWeekRange.getDate();\n    var weeksArray = [];\n    for (var i = 0; i < weeksInMonth; i++) {\n        // Get week number for end of week\n        weeksArray.push(getWeekNumber(endOfWeekRange, firstDayOfWeek, firstWeekOfYear));\n        dayOfMonth += TimeConstants.DaysInOneWeek;\n        endOfWeekRange = new Date(selectedYear, selectedMonth, dayOfMonth);\n    }\n    return weeksArray;\n}\n/**\n * Returns the week number for a date.\n * Week numbers are 1 - 52 (53) in a year\n * @param date - A date to find the week number for.\n * @param firstDayOfWeek - The first day of the week (0-6, Sunday = 0)\n * @param firstWeekOfYear - The first week of the year (1-2)\n * @returns The week's number in the year.\n */\nexport function getWeekNumber(date, firstDayOfWeek, firstWeekOfYear) {\n    // First four-day week of the year - minumum days count\n    var fourDayWeek = 4;\n    switch (firstWeekOfYear) {\n        case FirstWeekOfYear.FirstFullWeek:\n            return getWeekOfYearFullDays(date, firstDayOfWeek, TimeConstants.DaysInOneWeek);\n        case FirstWeekOfYear.FirstFourDayWeek:\n            return getWeekOfYearFullDays(date, firstDayOfWeek, fourDayWeek);\n        default:\n            return getFirstDayWeekOfYear(date, firstDayOfWeek);\n    }\n}\n/**\n * Gets the date for the first day of the week based on the given date assuming\n * the specified first day of the week.\n * @param date - The date to find the beginning of the week date for.\n * @returns A new date object representing the first day of the week containing the input date.\n */\nexport function getStartDateOfWeek(date, firstDayOfWeek) {\n    var daysOffset = firstDayOfWeek - date.getDay();\n    if (daysOffset > 0) {\n        // If first day of week is > date, go 1 week back, to ensure resulting date is in the past.\n        daysOffset -= TimeConstants.DaysInOneWeek;\n    }\n    return addDays(date, daysOffset);\n}\n/**\n * Gets the date for the last day of the week based on the given date assuming\n * the specified first day of the week.\n * @param date - The date to find the beginning of the week date for.\n * @returns A new date object representing the first day of the week containing the input date.\n */\nexport function getEndDateOfWeek(date, firstDayOfWeek) {\n    var lastDayOfWeek = firstDayOfWeek - 1 >= 0 ? firstDayOfWeek - 1 : TimeConstants.DaysInOneWeek - 1;\n    var daysOffset = lastDayOfWeek - date.getDay();\n    if (daysOffset < 0) {\n        // If last day of week is < date, go 1 week forward, to ensure resulting date is in the future.\n        daysOffset += TimeConstants.DaysInOneWeek;\n    }\n    return addDays(date, daysOffset);\n}\n/**\n * Gets a new date with the time portion zeroed out, i.e., set to midnight\n * @param date - The origin date\n * @returns A new date with the time set to midnight\n */\nfunction getDatePart(date) {\n    return new Date(date.getFullYear(), date.getMonth(), date.getDate());\n}\n/**\n * Helper function to assist in date comparisons\n */\nexport function getDatePartHashValue(date) {\n    // Generate date hash value created as sum of Date (up to 31 = 5 bits), Month (up to 11 = 4 bits) and Year.\n    // eslint-disable-next-line no-bitwise\n    return date.getDate() + (date.getMonth() << 5) + (date.getFullYear() << 9);\n}\n/**\n * Helper function for `getWeekNumber`.\n * Returns week number for a date.\n * @param date - current selected date.\n * @param firstDayOfWeek - The first day of week (0-6, Sunday = 0)\n * @param numberOfFullDays - week settings.\n * @returns The week's number in the year.\n */\nfunction getWeekOfYearFullDays(date, firstDayOfWeek, numberOfFullDays) {\n    var dayOfYear = getDayOfYear(date) - 1;\n    var num = date.getDay() - (dayOfYear % TimeConstants.DaysInOneWeek);\n    var lastDayOfPrevYear = new Date(date.getFullYear() - 1, MonthOfYear.December, 31);\n    var daysInYear = getDayOfYear(lastDayOfPrevYear) - 1;\n    var num2 = (firstDayOfWeek - num + 2 * TimeConstants.DaysInOneWeek) % TimeConstants.DaysInOneWeek;\n    if (num2 !== 0 && num2 >= numberOfFullDays) {\n        num2 -= TimeConstants.DaysInOneWeek;\n    }\n    var num3 = dayOfYear - num2;\n    if (num3 < 0) {\n        num -= daysInYear % TimeConstants.DaysInOneWeek;\n        num2 = (firstDayOfWeek - num + 2 * TimeConstants.DaysInOneWeek) % TimeConstants.DaysInOneWeek;\n        if (num2 !== 0 && num2 + 1 >= numberOfFullDays) {\n            num2 -= TimeConstants.DaysInOneWeek;\n        }\n        num3 = daysInYear - num2;\n    }\n    return Math.floor(num3 / TimeConstants.DaysInOneWeek + 1);\n}\n/**\n * Helper function for `getWeekNumber`.\n * Returns week number for a date.\n * @param date - current selected date.\n * @param firstDayOfWeek - The first day of week (0-6, Sunday = 0)\n * @returns The week's number in the year.\n */\nfunction getFirstDayWeekOfYear(date, firstDayOfWeek) {\n    var num = getDayOfYear(date) - 1;\n    var num2 = date.getDay() - (num % TimeConstants.DaysInOneWeek);\n    var num3 = (num2 - firstDayOfWeek + 2 * TimeConstants.DaysInOneWeek) % TimeConstants.DaysInOneWeek;\n    return Math.floor((num + num3) / TimeConstants.DaysInOneWeek + 1);\n}\n/**\n * Helper function for `getWeekNumber`.\n * Returns adjusted week day number when `firstDayOfWeek` is other than Sunday.\n * For Week Day Number comparison checks\n * @param firstDayOfWeek - The first day of week (0-6, Sunday = 0)\n * @param dateWeekDay - shifts number forward to 1 week in case passed as true\n * @returns The day of week adjusted to `firstDayOfWeek`; e.g. when `firstDayOfWeek` is Monday (1),\n * Sunday becomes 7.\n */\nfunction adjustWeekDay(firstDayOfWeek, dateWeekDay) {\n    return firstDayOfWeek !== DayOfWeek.Sunday && dateWeekDay < firstDayOfWeek\n        ? dateWeekDay + TimeConstants.DaysInOneWeek\n        : dateWeekDay;\n}\n/**\n * Returns the day number for a date in a year:\n * the number of days since January 1st in the particular year.\n * @param date - A date to find the day number for.\n * @returns The day's number in the year.\n */\nfunction getDayOfYear(date) {\n    var month = date.getMonth();\n    var year = date.getFullYear();\n    var daysUntilDate = 0;\n    for (var i = 0; i < month; i++) {\n        daysUntilDate += daysInMonth(i + 1, year);\n    }\n    daysUntilDate += date.getDate();\n    return daysUntilDate;\n}\n/**\n * Returns the number of days in the month\n * @param month - The month number to target (months 1-12).\n * @param year - The year to target.\n * @returns The number of days in the month.\n */\nfunction daysInMonth(month, year) {\n    return new Date(year, month, 0).getDate();\n}\n//# sourceMappingURL=dateMath.js.map","import { Node, mergeAttributes } from '@tiptap/core';\nimport { PluginKey } from '@tiptap/pm/state';\nimport Suggestion from '@tiptap/suggestion';\n\n/**\n * The plugin key for the mention plugin.\n * @default 'mention'\n */\nconst MentionPluginKey = new PluginKey('mention');\n/**\n * This extension allows you to insert mentions into the editor.\n * @see https://www.tiptap.dev/api/extensions/mention\n */\nconst Mention = Node.create({\n    name: 'mention',\n    addOptions() {\n        return {\n            HTMLAttributes: {},\n            renderText({ options, node }) {\n                var _a;\n                return `${options.suggestion.char}${(_a = node.attrs.label) !== null && _a !== void 0 ? _a : node.attrs.id}`;\n            },\n            deleteTriggerWithBackspace: false,\n            renderHTML({ options, node }) {\n                var _a;\n                return [\n                    'span',\n                    mergeAttributes(this.HTMLAttributes, options.HTMLAttributes),\n                    `${options.suggestion.char}${(_a = node.attrs.label) !== null && _a !== void 0 ? _a : node.attrs.id}`,\n                ];\n            },\n            suggestion: {\n                char: '@',\n                pluginKey: MentionPluginKey,\n                command: ({ editor, range, props }) => {\n                    var _a, _b;\n                    // increase range.to by one when the next node is of type \"text\"\n                    // and starts with a space character\n                    const nodeAfter = editor.view.state.selection.$to.nodeAfter;\n                    const overrideSpace = (_a = nodeAfter === null || nodeAfter === void 0 ? void 0 : nodeAfter.text) === null || _a === void 0 ? void 0 : _a.startsWith(' ');\n                    if (overrideSpace) {\n                        range.to += 1;\n                    }\n                    editor\n                        .chain()\n                        .focus()\n                        .insertContentAt(range, [\n                        {\n                            type: this.name,\n                            attrs: props,\n                        },\n                        {\n                            type: 'text',\n                            text: ' ',\n                        },\n                    ])\n                        .run();\n                    (_b = window.getSelection()) === null || _b === void 0 ? void 0 : _b.collapseToEnd();\n                },\n                allow: ({ state, range }) => {\n                    const $from = state.doc.resolve(range.from);\n                    const type = state.schema.nodes[this.name];\n                    const allow = !!$from.parent.type.contentMatch.matchType(type);\n                    return allow;\n                },\n            },\n        };\n    },\n    group: 'inline',\n    inline: true,\n    selectable: false,\n    atom: true,\n    addAttributes() {\n        return {\n            id: {\n                default: null,\n                parseHTML: element => element.getAttribute('data-id'),\n                renderHTML: attributes => {\n                    if (!attributes.id) {\n                        return {};\n                    }\n                    return {\n                        'data-id': attributes.id,\n                    };\n                },\n            },\n            label: {\n                default: null,\n                parseHTML: element => element.getAttribute('data-label'),\n                renderHTML: attributes => {\n                    if (!attributes.label) {\n                        return {};\n                    }\n                    return {\n                        'data-label': attributes.label,\n                    };\n                },\n            },\n        };\n    },\n    parseHTML() {\n        return [\n            {\n                tag: `span[data-type=\"${this.name}\"]`,\n            },\n        ];\n    },\n    renderHTML({ node, HTMLAttributes }) {\n        if (this.options.renderLabel !== undefined) {\n            console.warn('renderLabel is deprecated use renderText and renderHTML instead');\n            return [\n                'span',\n                mergeAttributes({ 'data-type': this.name }, this.options.HTMLAttributes, HTMLAttributes),\n                this.options.renderLabel({\n                    options: this.options,\n                    node,\n                }),\n            ];\n        }\n        const mergedOptions = { ...this.options };\n        mergedOptions.HTMLAttributes = mergeAttributes({ 'data-type': this.name }, this.options.HTMLAttributes, HTMLAttributes);\n        const html = this.options.renderHTML({\n            options: mergedOptions,\n            node,\n        });\n        if (typeof html === 'string') {\n            return [\n                'span',\n                mergeAttributes({ 'data-type': this.name }, this.options.HTMLAttributes, HTMLAttributes),\n                html,\n            ];\n        }\n        return html;\n    },\n    renderText({ node }) {\n        if (this.options.renderLabel !== undefined) {\n            console.warn('renderLabel is deprecated use renderText and renderHTML instead');\n            return this.options.renderLabel({\n                options: this.options,\n                node,\n            });\n        }\n        return this.options.renderText({\n            options: this.options,\n            node,\n        });\n    },\n    addKeyboardShortcuts() {\n        return {\n            Backspace: () => this.editor.commands.command(({ tr, state }) => {\n                let isMention = false;\n                const { selection } = state;\n                const { empty, anchor } = selection;\n                if (!empty) {\n                    return false;\n                }\n                state.doc.nodesBetween(anchor - 1, anchor, (node, pos) => {\n                    if (node.type.name === this.name) {\n                        isMention = true;\n                        tr.insertText(this.options.deleteTriggerWithBackspace ? '' : this.options.suggestion.char || '', pos, pos + node.nodeSize);\n                        return false;\n                    }\n                });\n                return isMention;\n            }),\n        };\n    },\n    addProseMirrorPlugins() {\n        return [\n            Suggestion({\n                editor: this.editor,\n                ...this.options.suggestion,\n            }),\n        ];\n    },\n});\n\nexport { Mention, MentionPluginKey, Mention as default };\n//# sourceMappingURL=index.js.map\n","// tables/index.ts\nexport * from \"prosemirror-tables\";\n","import getDocumentElement from \"./getDocumentElement.js\";\nimport getComputedStyle from \"./getComputedStyle.js\";\nimport getWindowScrollBarX from \"./getWindowScrollBarX.js\";\nimport getWindowScroll from \"./getWindowScroll.js\";\nimport { max } from \"../utils/math.js\"; // Gets the entire size of the scrollable document area, even extending outside\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable\n\nexport default function getDocumentRect(element) {\n  var _element$ownerDocumen;\n\n  var html = getDocumentElement(element);\n  var winScroll = getWindowScroll(element);\n  var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;\n  var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);\n  var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);\n  var x = -winScroll.scrollLeft + getWindowScrollBarX(element);\n  var y = -winScroll.scrollTop;\n\n  if (getComputedStyle(body || html).direction === 'rtl') {\n    x += max(html.clientWidth, body ? body.clientWidth : 0) - width;\n  }\n\n  return {\n    width: width,\n    height: height,\n    x: x,\n    y: y\n  };\n}","import getNodeName from \"./getNodeName.js\";\nexport default function isTableElement(element) {\n  return ['table', 'td', 'th'].indexOf(getNodeName(element)) >= 0;\n}","import RopeSequence from 'rope-sequence';\nimport { Mapping } from 'prosemirror-transform';\nimport { PluginKey, Plugin } from 'prosemirror-state';\n\n// ProseMirror's history isn't simply a way to roll back to a previous\n// state, because ProseMirror supports applying changes without adding\n// them to the history (for example during collaboration).\n//\n// To this end, each 'Branch' (one for the undo history and one for\n// the redo history) keeps an array of 'Items', which can optionally\n// hold a step (an actual undoable change), and always hold a position\n// map (which is needed to move changes below them to apply to the\n// current document).\n//\n// An item that has both a step and a selection bookmark is the start\n// of an 'event'  a group of changes that will be undone or redone at\n// once. (It stores only the bookmark, since that way we don't have to\n// provide a document until the selection is actually applied, which\n// is useful when compressing.)\n// Used to schedule history compression\nconst max_empty_items = 500;\nclass Branch {\n    constructor(items, eventCount) {\n        this.items = items;\n        this.eventCount = eventCount;\n    }\n    // Pop the latest event off the branch's history and apply it\n    // to a document transform.\n    popEvent(state, preserveItems) {\n        if (this.eventCount == 0)\n            return null;\n        let end = this.items.length;\n        for (;; end--) {\n            let next = this.items.get(end - 1);\n            if (next.selection) {\n                --end;\n                break;\n            }\n        }\n        let remap, mapFrom;\n        if (preserveItems) {\n            remap = this.remapping(end, this.items.length);\n            mapFrom = remap.maps.length;\n        }\n        let transform = state.tr;\n        let selection, remaining;\n        let addAfter = [], addBefore = [];\n        this.items.forEach((item, i) => {\n            if (!item.step) {\n                if (!remap) {\n                    remap = this.remapping(end, i + 1);\n                    mapFrom = remap.maps.length;\n                }\n                mapFrom--;\n                addBefore.push(item);\n                return;\n            }\n            if (remap) {\n                addBefore.push(new Item(item.map));\n                let step = item.step.map(remap.slice(mapFrom)), map;\n                if (step && transform.maybeStep(step).doc) {\n                    map = transform.mapping.maps[transform.mapping.maps.length - 1];\n                    addAfter.push(new Item(map, undefined, undefined, addAfter.length + addBefore.length));\n                }\n                mapFrom--;\n                if (map)\n                    remap.appendMap(map, mapFrom);\n            }\n            else {\n                transform.maybeStep(item.step);\n            }\n            if (item.selection) {\n                selection = remap ? item.selection.map(remap.slice(mapFrom)) : item.selection;\n                remaining = new Branch(this.items.slice(0, end).append(addBefore.reverse().concat(addAfter)), this.eventCount - 1);\n                return false;\n            }\n        }, this.items.length, 0);\n        return { remaining: remaining, transform, selection: selection };\n    }\n    // Create a new branch with the given transform added.\n    addTransform(transform, selection, histOptions, preserveItems) {\n        let newItems = [], eventCount = this.eventCount;\n        let oldItems = this.items, lastItem = !preserveItems && oldItems.length ? oldItems.get(oldItems.length - 1) : null;\n        for (let i = 0; i < transform.steps.length; i++) {\n            let step = transform.steps[i].invert(transform.docs[i]);\n            let item = new Item(transform.mapping.maps[i], step, selection), merged;\n            if (merged = lastItem && lastItem.merge(item)) {\n                item = merged;\n                if (i)\n                    newItems.pop();\n                else\n                    oldItems = oldItems.slice(0, oldItems.length - 1);\n            }\n            newItems.push(item);\n            if (selection) {\n                eventCount++;\n                selection = undefined;\n            }\n            if (!preserveItems)\n                lastItem = item;\n        }\n        let overflow = eventCount - histOptions.depth;\n        if (overflow > DEPTH_OVERFLOW) {\n            oldItems = cutOffEvents(oldItems, overflow);\n            eventCount -= overflow;\n        }\n        return new Branch(oldItems.append(newItems), eventCount);\n    }\n    remapping(from, to) {\n        let maps = new Mapping;\n        this.items.forEach((item, i) => {\n            let mirrorPos = item.mirrorOffset != null && i - item.mirrorOffset >= from\n                ? maps.maps.length - item.mirrorOffset : undefined;\n            maps.appendMap(item.map, mirrorPos);\n        }, from, to);\n        return maps;\n    }\n    addMaps(array) {\n        if (this.eventCount == 0)\n            return this;\n        return new Branch(this.items.append(array.map(map => new Item(map))), this.eventCount);\n    }\n    // When the collab module receives remote changes, the history has\n    // to know about those, so that it can adjust the steps that were\n    // rebased on top of the remote changes, and include the position\n    // maps for the remote changes in its array of items.\n    rebased(rebasedTransform, rebasedCount) {\n        if (!this.eventCount)\n            return this;\n        let rebasedItems = [], start = Math.max(0, this.items.length - rebasedCount);\n        let mapping = rebasedTransform.mapping;\n        let newUntil = rebasedTransform.steps.length;\n        let eventCount = this.eventCount;\n        this.items.forEach(item => { if (item.selection)\n            eventCount--; }, start);\n        let iRebased = rebasedCount;\n        this.items.forEach(item => {\n            let pos = mapping.getMirror(--iRebased);\n            if (pos == null)\n                return;\n            newUntil = Math.min(newUntil, pos);\n            let map = mapping.maps[pos];\n            if (item.step) {\n                let step = rebasedTransform.steps[pos].invert(rebasedTransform.docs[pos]);\n                let selection = item.selection && item.selection.map(mapping.slice(iRebased + 1, pos));\n                if (selection)\n                    eventCount++;\n                rebasedItems.push(new Item(map, step, selection));\n            }\n            else {\n                rebasedItems.push(new Item(map));\n            }\n        }, start);\n        let newMaps = [];\n        for (let i = rebasedCount; i < newUntil; i++)\n            newMaps.push(new Item(mapping.maps[i]));\n        let items = this.items.slice(0, start).append(newMaps).append(rebasedItems);\n        let branch = new Branch(items, eventCount);\n        if (branch.emptyItemCount() > max_empty_items)\n            branch = branch.compress(this.items.length - rebasedItems.length);\n        return branch;\n    }\n    emptyItemCount() {\n        let count = 0;\n        this.items.forEach(item => { if (!item.step)\n            count++; });\n        return count;\n    }\n    // Compressing a branch means rewriting it to push the air (map-only\n    // items) out. During collaboration, these naturally accumulate\n    // because each remote change adds one. The `upto` argument is used\n    // to ensure that only the items below a given level are compressed,\n    // because `rebased` relies on a clean, untouched set of items in\n    // order to associate old items with rebased steps.\n    compress(upto = this.items.length) {\n        let remap = this.remapping(0, upto), mapFrom = remap.maps.length;\n        let items = [], events = 0;\n        this.items.forEach((item, i) => {\n            if (i >= upto) {\n                items.push(item);\n                if (item.selection)\n                    events++;\n            }\n            else if (item.step) {\n                let step = item.step.map(remap.slice(mapFrom)), map = step && step.getMap();\n                mapFrom--;\n                if (map)\n                    remap.appendMap(map, mapFrom);\n                if (step) {\n                    let selection = item.selection && item.selection.map(remap.slice(mapFrom));\n                    if (selection)\n                        events++;\n                    let newItem = new Item(map.invert(), step, selection), merged, last = items.length - 1;\n                    if (merged = items.length && items[last].merge(newItem))\n                        items[last] = merged;\n                    else\n                        items.push(newItem);\n                }\n            }\n            else if (item.map) {\n                mapFrom--;\n            }\n        }, this.items.length, 0);\n        return new Branch(RopeSequence.from(items.reverse()), events);\n    }\n}\nBranch.empty = new Branch(RopeSequence.empty, 0);\nfunction cutOffEvents(items, n) {\n    let cutPoint;\n    items.forEach((item, i) => {\n        if (item.selection && (n-- == 0)) {\n            cutPoint = i;\n            return false;\n        }\n    });\n    return items.slice(cutPoint);\n}\nclass Item {\n    constructor(\n    // The (forward) step map for this item.\n    map, \n    // The inverted step\n    step, \n    // If this is non-null, this item is the start of a group, and\n    // this selection is the starting selection for the group (the one\n    // that was active before the first step was applied)\n    selection, \n    // If this item is the inverse of a previous mapping on the stack,\n    // this points at the inverse's offset\n    mirrorOffset) {\n        this.map = map;\n        this.step = step;\n        this.selection = selection;\n        this.mirrorOffset = mirrorOffset;\n    }\n    merge(other) {\n        if (this.step && other.step && !other.selection) {\n            let step = other.step.merge(this.step);\n            if (step)\n                return new Item(step.getMap().invert(), step, this.selection);\n        }\n    }\n}\n// The value of the state field that tracks undo/redo history for that\n// state. Will be stored in the plugin state when the history plugin\n// is active.\nclass HistoryState {\n    constructor(done, undone, prevRanges, prevTime, prevComposition) {\n        this.done = done;\n        this.undone = undone;\n        this.prevRanges = prevRanges;\n        this.prevTime = prevTime;\n        this.prevComposition = prevComposition;\n    }\n}\nconst DEPTH_OVERFLOW = 20;\n// Record a transformation in undo history.\nfunction applyTransaction(history, state, tr, options) {\n    let historyTr = tr.getMeta(historyKey), rebased;\n    if (historyTr)\n        return historyTr.historyState;\n    if (tr.getMeta(closeHistoryKey))\n        history = new HistoryState(history.done, history.undone, null, 0, -1);\n    let appended = tr.getMeta(\"appendedTransaction\");\n    if (tr.steps.length == 0) {\n        return history;\n    }\n    else if (appended && appended.getMeta(historyKey)) {\n        if (appended.getMeta(historyKey).redo)\n            return new HistoryState(history.done.addTransform(tr, undefined, options, mustPreserveItems(state)), history.undone, rangesFor(tr.mapping.maps), history.prevTime, history.prevComposition);\n        else\n            return new HistoryState(history.done, history.undone.addTransform(tr, undefined, options, mustPreserveItems(state)), null, history.prevTime, history.prevComposition);\n    }\n    else if (tr.getMeta(\"addToHistory\") !== false && !(appended && appended.getMeta(\"addToHistory\") === false)) {\n        // Group transforms that occur in quick succession into one event.\n        let composition = tr.getMeta(\"composition\");\n        let newGroup = history.prevTime == 0 ||\n            (!appended && history.prevComposition != composition &&\n                (history.prevTime < (tr.time || 0) - options.newGroupDelay || !isAdjacentTo(tr, history.prevRanges)));\n        let prevRanges = appended ? mapRanges(history.prevRanges, tr.mapping) : rangesFor(tr.mapping.maps);\n        return new HistoryState(history.done.addTransform(tr, newGroup ? state.selection.getBookmark() : undefined, options, mustPreserveItems(state)), Branch.empty, prevRanges, tr.time, composition == null ? history.prevComposition : composition);\n    }\n    else if (rebased = tr.getMeta(\"rebased\")) {\n        // Used by the collab module to tell the history that some of its\n        // content has been rebased.\n        return new HistoryState(history.done.rebased(tr, rebased), history.undone.rebased(tr, rebased), mapRanges(history.prevRanges, tr.mapping), history.prevTime, history.prevComposition);\n    }\n    else {\n        return new HistoryState(history.done.addMaps(tr.mapping.maps), history.undone.addMaps(tr.mapping.maps), mapRanges(history.prevRanges, tr.mapping), history.prevTime, history.prevComposition);\n    }\n}\nfunction isAdjacentTo(transform, prevRanges) {\n    if (!prevRanges)\n        return false;\n    if (!transform.docChanged)\n        return true;\n    let adjacent = false;\n    transform.mapping.maps[0].forEach((start, end) => {\n        for (let i = 0; i < prevRanges.length; i += 2)\n            if (start <= prevRanges[i + 1] && end >= prevRanges[i])\n                adjacent = true;\n    });\n    return adjacent;\n}\nfunction rangesFor(maps) {\n    let result = [];\n    for (let i = maps.length - 1; i >= 0 && result.length == 0; i--)\n        maps[i].forEach((_from, _to, from, to) => result.push(from, to));\n    return result;\n}\nfunction mapRanges(ranges, mapping) {\n    if (!ranges)\n        return null;\n    let result = [];\n    for (let i = 0; i < ranges.length; i += 2) {\n        let from = mapping.map(ranges[i], 1), to = mapping.map(ranges[i + 1], -1);\n        if (from <= to)\n            result.push(from, to);\n    }\n    return result;\n}\n// Apply the latest event from one branch to the document and shift the event\n// onto the other branch.\nfunction histTransaction(history, state, redo) {\n    let preserveItems = mustPreserveItems(state);\n    let histOptions = historyKey.get(state).spec.config;\n    let pop = (redo ? history.undone : history.done).popEvent(state, preserveItems);\n    if (!pop)\n        return null;\n    let selection = pop.selection.resolve(pop.transform.doc);\n    let added = (redo ? history.done : history.undone).addTransform(pop.transform, state.selection.getBookmark(), histOptions, preserveItems);\n    let newHist = new HistoryState(redo ? added : pop.remaining, redo ? pop.remaining : added, null, 0, -1);\n    return pop.transform.setSelection(selection).setMeta(historyKey, { redo, historyState: newHist });\n}\nlet cachedPreserveItems = false, cachedPreserveItemsPlugins = null;\n// Check whether any plugin in the given state has a\n// `historyPreserveItems` property in its spec, in which case we must\n// preserve steps exactly as they came in, so that they can be\n// rebased.\nfunction mustPreserveItems(state) {\n    let plugins = state.plugins;\n    if (cachedPreserveItemsPlugins != plugins) {\n        cachedPreserveItems = false;\n        cachedPreserveItemsPlugins = plugins;\n        for (let i = 0; i < plugins.length; i++)\n            if (plugins[i].spec.historyPreserveItems) {\n                cachedPreserveItems = true;\n                break;\n            }\n    }\n    return cachedPreserveItems;\n}\n/**\nSet a flag on the given transaction that will prevent further steps\nfrom being appended to an existing history event (so that they\nrequire a separate undo command to undo).\n*/\nfunction closeHistory(tr) {\n    return tr.setMeta(closeHistoryKey, true);\n}\nconst historyKey = new PluginKey(\"history\");\nconst closeHistoryKey = new PluginKey(\"closeHistory\");\n/**\nReturns a plugin that enables the undo history for an editor. The\nplugin will track undo and redo stacks, which can be used with the\n[`undo`](https://prosemirror.net/docs/ref/#history.undo) and [`redo`](https://prosemirror.net/docs/ref/#history.redo) commands.\n\nYou can set an `\"addToHistory\"` [metadata\nproperty](https://prosemirror.net/docs/ref/#state.Transaction.setMeta) of `false` on a transaction\nto prevent it from being rolled back by undo.\n*/\nfunction history(config = {}) {\n    config = { depth: config.depth || 100,\n        newGroupDelay: config.newGroupDelay || 500 };\n    return new Plugin({\n        key: historyKey,\n        state: {\n            init() {\n                return new HistoryState(Branch.empty, Branch.empty, null, 0, -1);\n            },\n            apply(tr, hist, state) {\n                return applyTransaction(hist, state, tr, config);\n            }\n        },\n        config,\n        props: {\n            handleDOMEvents: {\n                beforeinput(view, e) {\n                    let inputType = e.inputType;\n                    let command = inputType == \"historyUndo\" ? undo : inputType == \"historyRedo\" ? redo : null;\n                    if (!command)\n                        return false;\n                    e.preventDefault();\n                    return command(view.state, view.dispatch);\n                }\n            }\n        }\n    });\n}\nfunction buildCommand(redo, scroll) {\n    return (state, dispatch) => {\n        let hist = historyKey.getState(state);\n        if (!hist || (redo ? hist.undone : hist.done).eventCount == 0)\n            return false;\n        if (dispatch) {\n            let tr = histTransaction(hist, state, redo);\n            if (tr)\n                dispatch(scroll ? tr.scrollIntoView() : tr);\n        }\n        return true;\n    };\n}\n/**\nA command function that undoes the last change, if any.\n*/\nconst undo = buildCommand(false, true);\n/**\nA command function that redoes the last undone change, if any.\n*/\nconst redo = buildCommand(true, true);\n/**\nA command function that undoes the last change. Don't scroll the\nselection into view.\n*/\nconst undoNoScroll = buildCommand(false, false);\n/**\nA command function that redoes the last undone change. Don't\nscroll the selection into view.\n*/\nconst redoNoScroll = buildCommand(true, false);\n/**\nThe amount of undoable events available in a given state.\n*/\nfunction undoDepth(state) {\n    let hist = historyKey.getState(state);\n    return hist ? hist.done.eventCount : 0;\n}\n/**\nThe amount of redoable events available in a given editor state.\n*/\nfunction redoDepth(state) {\n    let hist = historyKey.getState(state);\n    return hist ? hist.undone.eventCount : 0;\n}\n\nexport { closeHistory, history, redo, redoDepth, redoNoScroll, undo, undoDepth, undoNoScroll };\n","import { color } from '../color/index.js';\nimport { number } from '../numbers/index.js';\nimport { isString, floatRegex, colorRegex, sanitize } from '../utils.js';\n\nvar colorToken = '${c}';\nvar numberToken = '${n}';\nfunction test(v) {\n    var _a, _b, _c, _d;\n    return (isNaN(v) &&\n        isString(v) &&\n        ((_b = (_a = v.match(floatRegex)) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0) + ((_d = (_c = v.match(colorRegex)) === null || _c === void 0 ? void 0 : _c.length) !== null && _d !== void 0 ? _d : 0) > 0);\n}\nfunction analyse(v) {\n    var values = [];\n    var numColors = 0;\n    var colors = v.match(colorRegex);\n    if (colors) {\n        numColors = colors.length;\n        v = v.replace(colorRegex, colorToken);\n        values.push.apply(values, colors.map(color.parse));\n    }\n    var numbers = v.match(floatRegex);\n    if (numbers) {\n        v = v.replace(floatRegex, numberToken);\n        values.push.apply(values, numbers.map(number.parse));\n    }\n    return { values: values, numColors: numColors, tokenised: v };\n}\nfunction parse(v) {\n    return analyse(v).values;\n}\nfunction createTransformer(v) {\n    var _a = analyse(v), values = _a.values, numColors = _a.numColors, tokenised = _a.tokenised;\n    var numValues = values.length;\n    return function (v) {\n        var output = tokenised;\n        for (var i = 0; i < numValues; i++) {\n            output = output.replace(i < numColors ? colorToken : numberToken, i < numColors ? color.transform(v[i]) : sanitize(v[i]));\n        }\n        return output;\n    };\n}\nvar convertNumbersToZero = function (v) {\n    return typeof v === 'number' ? 0 : v;\n};\nfunction getAnimatableNone(v) {\n    var parsed = parse(v);\n    var transformer = createTransformer(v);\n    return transformer(parsed.map(convertNumbersToZero));\n}\nvar complex = { test: test, parse: parse, createTransformer: createTransformer, getAnimatableNone: getAnimatableNone };\n\nexport { complex };\n","export var max = Math.max;\nexport var min = Math.min;\nexport var round = Math.round;","import { isElement } from \"./instanceOf.js\";\nexport default function getDocumentElement(element) {\n  // $FlowFixMe[incompatible-return]: assume body is always available\n  return ((isElement(element) ? element.ownerDocument : // $FlowFixMe[prop-missing]\n  element.document) || window.document).documentElement;\n}","import { Mark, mergeAttributes, getMarkAttributes } from '@tiptap/core';\n\n/**\n * This extension allows you to create text styles. It is required by default\n * for the `textColor` and `backgroundColor` extensions.\n * @see https://www.tiptap.dev/api/marks/text-style\n */\nconst TextStyle = Mark.create({\n    name: 'textStyle',\n    addOptions() {\n        return {\n            HTMLAttributes: {},\n        };\n    },\n    parseHTML() {\n        return [\n            {\n                tag: 'span',\n                getAttrs: element => {\n                    const hasStyles = element.hasAttribute('style');\n                    if (!hasStyles) {\n                        return false;\n                    }\n                    return {};\n                },\n            },\n        ];\n    },\n    renderHTML({ HTMLAttributes }) {\n        return ['span', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];\n    },\n    addCommands() {\n        return {\n            removeEmptyTextStyle: () => ({ state, commands }) => {\n                const attributes = getMarkAttributes(state, this.type);\n                const hasStyles = Object.entries(attributes).some(([, value]) => !!value);\n                if (hasStyles) {\n                    return true;\n                }\n                return commands.unsetMark(this.name);\n            },\n        };\n    },\n});\n\nexport { TextStyle, TextStyle as default };\n//# sourceMappingURL=index.js.map\n","import { isString, singleColorRegex, floatRegex } from '../utils.js';\n\nvar isColorString = function (type, testProp) { return function (v) {\n    return Boolean((isString(v) && singleColorRegex.test(v) && v.startsWith(type)) ||\n        (testProp && Object.prototype.hasOwnProperty.call(v, testProp)));\n}; };\nvar splitColor = function (aName, bName, cName) { return function (v) {\n    var _a;\n    if (!isString(v))\n        return v;\n    var _b = v.match(floatRegex), a = _b[0], b = _b[1], c = _b[2], alpha = _b[3];\n    return _a = {},\n        _a[aName] = parseFloat(a),\n        _a[bName] = parseFloat(b),\n        _a[cName] = parseFloat(c),\n        _a.alpha = alpha !== undefined ? parseFloat(alpha) : 1,\n        _a;\n}; };\n\nexport { isColorString, splitColor };\n","// ----\n// Heads up!\n// These constants are global and will be shared between Griffel instances.\n// Any change in them should happen only in a MAJOR version. If it happens,\n// please change \"__NAMESPACE_PREFIX__\" to include a version.\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst __GLOBAL__ = typeof window === 'undefined' ? global : window;\nconst __NAMESPACE_PREFIX__ = '@griffel/';\nfunction getGlobalVar(name, defaultValue) {\n  if (!__GLOBAL__[Symbol.for(__NAMESPACE_PREFIX__ + name)]) {\n    __GLOBAL__[Symbol.for(__NAMESPACE_PREFIX__ + name)] = defaultValue;\n  }\n  return __GLOBAL__[Symbol.for(__NAMESPACE_PREFIX__ + name)];\n}\n/** @internal */\nconst DEBUG_RESET_CLASSES = /*#__PURE__*/getGlobalVar('DEBUG_RESET_CLASSES', {});\n/** @internal */\nconst DEFINITION_LOOKUP_TABLE = /*#__PURE__*/getGlobalVar('DEFINITION_LOOKUP_TABLE', {});\n// ----\n/** @internal */\nconst DATA_BUCKET_ATTR = 'data-make-styles-bucket';\n/** @internal */\nconst DATA_PRIORITY_ATTR = 'data-priority';\n/** @internal */\nconst HASH_PREFIX = 'f';\n/** @internal */\nconst RESET_HASH_PREFIX = 'r';\n/** @internal */\nconst SEQUENCE_HASH_LENGTH = 7;\n/** @internal */\nconst SEQUENCE_PREFIX = '___';\n/** @internal */\nconst DEBUG_SEQUENCE_SEPARATOR = '_';\n/** @internal */\nconst SEQUENCE_SIZE = process.env.NODE_ENV === 'production' ? SEQUENCE_PREFIX.length + SEQUENCE_HASH_LENGTH : SEQUENCE_PREFIX.length + SEQUENCE_HASH_LENGTH + DEBUG_SEQUENCE_SEPARATOR.length + SEQUENCE_HASH_LENGTH;\n// indexes for values in LookupItem tuple\n/** @internal */\nconst LOOKUP_DEFINITIONS_INDEX = 0;\n/** @internal */\nconst LOOKUP_DIR_INDEX = 1;\n// This collection is a map simply for faster access when checking if a CSS property is unsupported\n/** @internal */\nconst UNSUPPORTED_CSS_PROPERTIES = {\n  all: 1,\n  borderColor: 1,\n  borderStyle: 1,\n  borderWidth: 1,\n  borderBlock: 1,\n  borderBlockEnd: 1,\n  borderBlockStart: 1,\n  borderInline: 1,\n  borderInlineEnd: 1,\n  borderInlineStart: 1\n};\n/**\n * Removes a CSS property from the style object.\n *\n * @link https://griffel.js.org/react/api/make-styles\n *\n * Do not use the value directly, use `RESET` constant instead.\n */\nconst RESET = 'DO_NOT_USE_DIRECTLY: @griffel/reset-value';\n\nexport { DATA_BUCKET_ATTR, DATA_PRIORITY_ATTR, DEBUG_RESET_CLASSES, DEBUG_SEQUENCE_SEPARATOR, DEFINITION_LOOKUP_TABLE, HASH_PREFIX, LOOKUP_DEFINITIONS_INDEX, LOOKUP_DIR_INDEX, RESET, RESET_HASH_PREFIX, SEQUENCE_HASH_LENGTH, SEQUENCE_PREFIX, SEQUENCE_SIZE, UNSUPPORTED_CSS_PROPERTIES };\n//# sourceMappingURL=constants.esm.js.map\n","/**\n * Returns whether provided week days are contiguous.\n * @param days - list of days in a week\n * @param isSingleWeek - decides whether the contiguous logic applies across week boundaries or not\n * @param firstDayOfWeek - decides which day of week is the first one in the order.\n */\nexport var isContiguous = function (days, isSingleWeek, firstDayOfWeek) {\n    var daySet = new Set(days);\n    var amountOfNoNeighbors = 0;\n    for (var _i = 0, days_1 = days; _i < days_1.length; _i++) {\n        var day = days_1[_i];\n        var nextDay = (day + 1) % 7;\n        if (!(daySet.has(nextDay) && (!isSingleWeek || firstDayOfWeek !== nextDay))) {\n            amountOfNoNeighbors++;\n        }\n    }\n    // In case the full week is provided, then each day has a neighbor\n    //, otherwise the last day does not have a neighbor.\n    return amountOfNoNeighbors < 2;\n};\n//# sourceMappingURL=isContiguous.js.map","import { Node, mergeAttributes, textblockTypeInputRule } from '@tiptap/core';\nimport { Selection, Plugin, PluginKey, TextSelection } from '@tiptap/pm/state';\n\n/**\n * Matches a code block with backticks.\n */\nconst backtickInputRegex = /^```([a-z]+)?[\\s\\n]$/;\n/**\n * Matches a code block with tildes.\n */\nconst tildeInputRegex = /^~~~([a-z]+)?[\\s\\n]$/;\n/**\n * This extension allows you to create code blocks.\n * @see https://tiptap.dev/api/nodes/code-block\n */\nconst CodeBlock = Node.create({\n    name: 'codeBlock',\n    addOptions() {\n        return {\n            languageClassPrefix: 'language-',\n            exitOnTripleEnter: true,\n            exitOnArrowDown: true,\n            defaultLanguage: null,\n            HTMLAttributes: {},\n        };\n    },\n    content: 'text*',\n    marks: '',\n    group: 'block',\n    code: true,\n    defining: true,\n    addAttributes() {\n        return {\n            language: {\n                default: this.options.defaultLanguage,\n                parseHTML: element => {\n                    var _a;\n                    const { languageClassPrefix } = this.options;\n                    const classNames = [...(((_a = element.firstElementChild) === null || _a === void 0 ? void 0 : _a.classList) || [])];\n                    const languages = classNames\n                        .filter(className => className.startsWith(languageClassPrefix))\n                        .map(className => className.replace(languageClassPrefix, ''));\n                    const language = languages[0];\n                    if (!language) {\n                        return null;\n                    }\n                    return language;\n                },\n                rendered: false,\n            },\n        };\n    },\n    parseHTML() {\n        return [\n            {\n                tag: 'pre',\n                preserveWhitespace: 'full',\n            },\n        ];\n    },\n    renderHTML({ node, HTMLAttributes }) {\n        return [\n            'pre',\n            mergeAttributes(this.options.HTMLAttributes, HTMLAttributes),\n            [\n                'code',\n                {\n                    class: node.attrs.language\n                        ? this.options.languageClassPrefix + node.attrs.language\n                        : null,\n                },\n                0,\n            ],\n        ];\n    },\n    addCommands() {\n        return {\n            setCodeBlock: attributes => ({ commands }) => {\n                return commands.setNode(this.name, attributes);\n            },\n            toggleCodeBlock: attributes => ({ commands }) => {\n                return commands.toggleNode(this.name, 'paragraph', attributes);\n            },\n        };\n    },\n    addKeyboardShortcuts() {\n        return {\n            'Mod-Alt-c': () => this.editor.commands.toggleCodeBlock(),\n            // remove code block when at start of document or code block is empty\n            Backspace: () => {\n                const { empty, $anchor } = this.editor.state.selection;\n                const isAtStart = $anchor.pos === 1;\n                if (!empty || $anchor.parent.type.name !== this.name) {\n                    return false;\n                }\n                if (isAtStart || !$anchor.parent.textContent.length) {\n                    return this.editor.commands.clearNodes();\n                }\n                return false;\n            },\n            // exit node on triple enter\n            Enter: ({ editor }) => {\n                if (!this.options.exitOnTripleEnter) {\n                    return false;\n                }\n                const { state } = editor;\n                const { selection } = state;\n                const { $from, empty } = selection;\n                if (!empty || $from.parent.type !== this.type) {\n                    return false;\n                }\n                const isAtEnd = $from.parentOffset === $from.parent.nodeSize - 2;\n                const endsWithDoubleNewline = $from.parent.textContent.endsWith('\\n\\n');\n                if (!isAtEnd || !endsWithDoubleNewline) {\n                    return false;\n                }\n                return editor\n                    .chain()\n                    .command(({ tr }) => {\n                    tr.delete($from.pos - 2, $from.pos);\n                    return true;\n                })\n                    .exitCode()\n                    .run();\n            },\n            // exit node on arrow down\n            ArrowDown: ({ editor }) => {\n                if (!this.options.exitOnArrowDown) {\n                    return false;\n                }\n                const { state } = editor;\n                const { selection, doc } = state;\n                const { $from, empty } = selection;\n                if (!empty || $from.parent.type !== this.type) {\n                    return false;\n                }\n                const isAtEnd = $from.parentOffset === $from.parent.nodeSize - 2;\n                if (!isAtEnd) {\n                    return false;\n                }\n                const after = $from.after();\n                if (after === undefined) {\n                    return false;\n                }\n                const nodeAfter = doc.nodeAt(after);\n                if (nodeAfter) {\n                    return editor.commands.command(({ tr }) => {\n                        tr.setSelection(Selection.near(doc.resolve(after)));\n                        return true;\n                    });\n                }\n                return editor.commands.exitCode();\n            },\n        };\n    },\n    addInputRules() {\n        return [\n            textblockTypeInputRule({\n                find: backtickInputRegex,\n                type: this.type,\n                getAttributes: match => ({\n                    language: match[1],\n                }),\n            }),\n            textblockTypeInputRule({\n                find: tildeInputRegex,\n                type: this.type,\n                getAttributes: match => ({\n                    language: match[1],\n                }),\n            }),\n        ];\n    },\n    addProseMirrorPlugins() {\n        return [\n            // this plugin creates a code block for pasted content from VS Code\n            // we can also detect the copied code language\n            new Plugin({\n                key: new PluginKey('codeBlockVSCodeHandler'),\n                props: {\n                    handlePaste: (view, event) => {\n                        if (!event.clipboardData) {\n                            return false;\n                        }\n                        // dont create a new code block within code blocks\n                        if (this.editor.isActive(this.type.name)) {\n                            return false;\n                        }\n                        const text = event.clipboardData.getData('text/plain');\n                        const vscode = event.clipboardData.getData('vscode-editor-data');\n                        const vscodeData = vscode ? JSON.parse(vscode) : undefined;\n                        const language = vscodeData === null || vscodeData === void 0 ? void 0 : vscodeData.mode;\n                        if (!text || !language) {\n                            return false;\n                        }\n                        const { tr, schema } = view.state;\n                        // prepare a text node\n                        // strip carriage return chars from text pasted as code\n                        // see: https://github.com/ProseMirror/prosemirror-view/commit/a50a6bcceb4ce52ac8fcc6162488d8875613aacd\n                        const textNode = schema.text(text.replace(/\\r\\n?/g, '\\n'));\n                        // create a code block with the text node\n                        // replace selection with the code block\n                        tr.replaceSelectionWith(this.type.create({ language }, textNode));\n                        if (tr.selection.$from.parent.type !== this.type) {\n                            // put cursor inside the newly created code block\n                            tr.setSelection(TextSelection.near(tr.doc.resolve(Math.max(0, tr.selection.from - 2))));\n                        }\n                        // store meta information\n                        // this is useful for other plugins that depends on the paste event\n                        // like the paste rule plugin\n                        tr.setMeta('paste', true);\n                        view.dispatch(tr);\n                        return true;\n                    },\n                },\n            }),\n        ];\n    },\n});\n\nexport { CodeBlock, backtickInputRegex, CodeBlock as default, tildeInputRegex };\n//# sourceMappingURL=index.js.map\n","import REGEX from './regex.js';\n\nfunction validate(uuid) {\n  return typeof uuid === 'string' && REGEX.test(uuid);\n}\n\nexport default validate;","import { Depths } from './FluentDepths';\nexport var DefaultEffects = {\n    elevation4: Depths.depth4,\n    elevation8: Depths.depth8,\n    elevation16: Depths.depth16,\n    elevation64: Depths.depth64,\n    roundedCorner2: '2px',\n    roundedCorner4: '4px',\n    roundedCorner6: '6px',\n};\n//# sourceMappingURL=DefaultEffects.js.map","import { extractStyleParts } from './extractStyleParts';\nimport { isShadowConfig } from './shadowConfig';\nimport { getStyleOptions } from './StyleOptionsState';\nimport { Stylesheet } from './Stylesheet';\nimport { styleToClassName } from './styleToClassName';\n/**\n * Concatenation helper, which can merge class names together. Skips over falsey values.\n *\n * @public\n */\nexport function mergeStyles() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    return mergeCss(args, getStyleOptions());\n}\n/**\n * Concatenation helper, which can merge class names together. Skips over falsey values.\n * Accepts a set of options that will be used when calculating styles.\n *\n * @public\n */\nexport function mergeCss(args, options) {\n    var styleArgs = args instanceof Array ? args : [args];\n    var opts = options || {};\n    var hasShadowConfig = isShadowConfig(styleArgs[0]);\n    if (hasShadowConfig) {\n        opts.shadowConfig = styleArgs[0];\n    }\n    opts.stylesheet = Stylesheet.getInstance(opts.shadowConfig);\n    var _a = extractStyleParts(opts.stylesheet, styleArgs), classes = _a.classes, objects = _a.objects;\n    if (objects.length) {\n        classes.push(styleToClassName(opts, objects));\n    }\n    return classes.join(' ');\n}\n//# sourceMappingURL=mergeStyles.js.map","// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\nlet getRandomValues;\nconst rnds8 = new Uint8Array(16);\nexport default function rng() {\n  // lazy load so that environments that need to polyfill have a chance to do so\n  if (!getRandomValues) {\n    // getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation.\n    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);\n\n    if (!getRandomValues) {\n      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n    }\n  }\n\n  return getRandomValues(rnds8);\n}","import { Mark, mergeAttributes, markInputRule, markPasteRule } from '@tiptap/core';\n\n/**\n * Matches a strike to a ~~strike~~ on input.\n */\nconst inputRegex = /(?:^|\\s)(~~(?!\\s+~~)((?:[^~]+))~~(?!\\s+~~))$/;\n/**\n * Matches a strike to a ~~strike~~ on paste.\n */\nconst pasteRegex = /(?:^|\\s)(~~(?!\\s+~~)((?:[^~]+))~~(?!\\s+~~))/g;\n/**\n * This extension allows you to create strike text.\n * @see https://www.tiptap.dev/api/marks/strike\n */\nconst Strike = Mark.create({\n    name: 'strike',\n    addOptions() {\n        return {\n            HTMLAttributes: {},\n        };\n    },\n    parseHTML() {\n        return [\n            {\n                tag: 's',\n            },\n            {\n                tag: 'del',\n            },\n            {\n                tag: 'strike',\n            },\n            {\n                style: 'text-decoration',\n                consuming: false,\n                getAttrs: style => (style.includes('line-through') ? {} : false),\n            },\n        ];\n    },\n    renderHTML({ HTMLAttributes }) {\n        return ['s', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];\n    },\n    addCommands() {\n        return {\n            setStrike: () => ({ commands }) => {\n                return commands.setMark(this.name);\n            },\n            toggleStrike: () => ({ commands }) => {\n                return commands.toggleMark(this.name);\n            },\n            unsetStrike: () => ({ commands }) => {\n                return commands.unsetMark(this.name);\n            },\n        };\n    },\n    addKeyboardShortcuts() {\n        return {\n            'Mod-Shift-s': () => this.editor.commands.toggleStrike(),\n        };\n    },\n    addInputRules() {\n        return [\n            markInputRule({\n                find: inputRegex,\n                type: this.type,\n            }),\n        ];\n    },\n    addPasteRules() {\n        return [\n            markPasteRule({\n                find: pasteRegex,\n                type: this.type,\n            }),\n        ];\n    },\n});\n\nexport { Strike, Strike as default, inputRegex, pasteRegex };\n//# sourceMappingURL=index.js.map\n","import { __rest, __assign } from 'tslib';\nimport { findSpring, calcAngularFreq } from '../utils/find-spring.js';\n\nvar durationKeys = [\"duration\", \"bounce\"];\nvar physicsKeys = [\"stiffness\", \"damping\", \"mass\"];\nfunction isSpringType(options, keys) {\n    return keys.some(function (key) { return options[key] !== undefined; });\n}\nfunction getSpringOptions(options) {\n    var springOptions = __assign({ velocity: 0.0, stiffness: 100, damping: 10, mass: 1.0, isResolvedFromDuration: false }, options);\n    if (!isSpringType(options, physicsKeys) &&\n        isSpringType(options, durationKeys)) {\n        var derived = findSpring(options);\n        springOptions = __assign(__assign(__assign({}, springOptions), derived), { velocity: 0.0, mass: 1.0 });\n        springOptions.isResolvedFromDuration = true;\n    }\n    return springOptions;\n}\nfunction spring(_a) {\n    var _b = _a.from, from = _b === void 0 ? 0.0 : _b, _c = _a.to, to = _c === void 0 ? 1.0 : _c, _d = _a.restSpeed, restSpeed = _d === void 0 ? 2 : _d, restDelta = _a.restDelta, options = __rest(_a, [\"from\", \"to\", \"restSpeed\", \"restDelta\"]);\n    var state = { done: false, value: from };\n    var _e = getSpringOptions(options), stiffness = _e.stiffness, damping = _e.damping, mass = _e.mass, velocity = _e.velocity, duration = _e.duration, isResolvedFromDuration = _e.isResolvedFromDuration;\n    var resolveSpring = zero;\n    var resolveVelocity = zero;\n    function createSpring() {\n        var initialVelocity = velocity ? -(velocity / 1000) : 0.0;\n        var initialDelta = to - from;\n        var dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));\n        var undampedAngularFreq = Math.sqrt(stiffness / mass) / 1000;\n        restDelta !== null && restDelta !== void 0 ? restDelta : (restDelta = Math.abs(to - from) <= 1 ? 0.01 : 0.4);\n        if (dampingRatio < 1) {\n            var angularFreq_1 = calcAngularFreq(undampedAngularFreq, dampingRatio);\n            resolveSpring = function (t) {\n                var envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n                return (to -\n                    envelope *\n                        (((initialVelocity +\n                            dampingRatio * undampedAngularFreq * initialDelta) /\n                            angularFreq_1) *\n                            Math.sin(angularFreq_1 * t) +\n                            initialDelta * Math.cos(angularFreq_1 * t)));\n            };\n            resolveVelocity = function (t) {\n                var envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n                return (dampingRatio *\n                    undampedAngularFreq *\n                    envelope *\n                    ((Math.sin(angularFreq_1 * t) *\n                        (initialVelocity +\n                            dampingRatio *\n                                undampedAngularFreq *\n                                initialDelta)) /\n                        angularFreq_1 +\n                        initialDelta * Math.cos(angularFreq_1 * t)) -\n                    envelope *\n                        (Math.cos(angularFreq_1 * t) *\n                            (initialVelocity +\n                                dampingRatio *\n                                    undampedAngularFreq *\n                                    initialDelta) -\n                            angularFreq_1 *\n                                initialDelta *\n                                Math.sin(angularFreq_1 * t)));\n            };\n        }\n        else if (dampingRatio === 1) {\n            resolveSpring = function (t) {\n                return to -\n                    Math.exp(-undampedAngularFreq * t) *\n                        (initialDelta +\n                            (initialVelocity + undampedAngularFreq * initialDelta) *\n                                t);\n            };\n        }\n        else {\n            var dampedAngularFreq_1 = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);\n            resolveSpring = function (t) {\n                var envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);\n                var freqForT = Math.min(dampedAngularFreq_1 * t, 300);\n                return (to -\n                    (envelope *\n                        ((initialVelocity +\n                            dampingRatio * undampedAngularFreq * initialDelta) *\n                            Math.sinh(freqForT) +\n                            dampedAngularFreq_1 *\n                                initialDelta *\n                                Math.cosh(freqForT))) /\n                        dampedAngularFreq_1);\n            };\n        }\n    }\n    createSpring();\n    return {\n        next: function (t) {\n            var current = resolveSpring(t);\n            if (!isResolvedFromDuration) {\n                var currentVelocity = resolveVelocity(t) * 1000;\n                var isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;\n                var isBelowDisplacementThreshold = Math.abs(to - current) <= restDelta;\n                state.done =\n                    isBelowVelocityThreshold && isBelowDisplacementThreshold;\n            }\n            else {\n                state.done = t >= duration;\n            }\n            state.value = state.done ? to : current;\n            return state;\n        },\n        flipTarget: function () {\n            var _a;\n            velocity = -velocity;\n            _a = [to, from], from = _a[0], to = _a[1];\n            createSpring();\n        },\n    };\n}\nspring.needsInterpolation = function (a, b) {\n    return typeof a === \"string\" || typeof b === \"string\";\n};\nvar zero = function (_t) { return 0; };\n\nexport { spring };\n","export var Depths;\n(function (Depths) {\n    Depths.depth0 = '0 0 0 0 transparent';\n    Depths.depth4 = '0 1.6px 3.6px 0 rgba(0, 0, 0, 0.132), 0 0.3px 0.9px 0 rgba(0, 0, 0, 0.108)';\n    Depths.depth8 = '0 3.2px 7.2px 0 rgba(0, 0, 0, 0.132), 0 0.6px 1.8px 0 rgba(0, 0, 0, 0.108)';\n    Depths.depth16 = '0 6.4px 14.4px 0 rgba(0, 0, 0, 0.132), 0 1.2px 3.6px 0 rgba(0, 0, 0, 0.108)';\n    Depths.depth64 = '0 25.6px 57.6px 0 rgba(0, 0, 0, 0.22), 0 4.8px 14.4px 0 rgba(0, 0, 0, 0.18)';\n})(Depths || (Depths = {}));\n//# sourceMappingURL=FluentDepths.js.map","/* eslint-disable */\n// Inspired by https://github.com/garycourt/murmurhash-js\n// Ported from https://github.com/aappleby/smhasher/blob/61a0530f28277f2e850bfc39600ce61d02b518de/src/MurmurHash2.cpp#L37-L86\nfunction murmur2(str) {\n  // 'm' and 'r' are mixing constants generated offline.\n  // They're not really 'magic', they just happen to work well.\n  // const m = 0x5bd1e995;\n  // const r = 24;\n  // Initialize the hash\n  var h = 0; // Mix 4 bytes at a time into the hash\n\n  var k,\n      i = 0,\n      len = str.length;\n\n  for (; len >= 4; ++i, len -= 4) {\n    k = str.charCodeAt(i) & 0xff | (str.charCodeAt(++i) & 0xff) << 8 | (str.charCodeAt(++i) & 0xff) << 16 | (str.charCodeAt(++i) & 0xff) << 24;\n    k =\n    /* Math.imul(k, m): */\n    (k & 0xffff) * 0x5bd1e995 + ((k >>> 16) * 0xe995 << 16);\n    k ^=\n    /* k >>> r: */\n    k >>> 24;\n    h =\n    /* Math.imul(k, m): */\n    (k & 0xffff) * 0x5bd1e995 + ((k >>> 16) * 0xe995 << 16) ^\n    /* Math.imul(h, m): */\n    (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);\n  } // Handle the last few bytes of the input array\n\n\n  switch (len) {\n    case 3:\n      h ^= (str.charCodeAt(i + 2) & 0xff) << 16;\n\n    case 2:\n      h ^= (str.charCodeAt(i + 1) & 0xff) << 8;\n\n    case 1:\n      h ^= str.charCodeAt(i) & 0xff;\n      h =\n      /* Math.imul(h, m): */\n      (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);\n  } // Do a few final mixes of the hash to ensure the last few\n  // bytes are well-incorporated.\n\n\n  h ^= h >>> 13;\n  h =\n  /* Math.imul(h, m): */\n  (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);\n  return ((h ^ h >>> 15) >>> 0).toString(36);\n}\n\nexport { murmur2 as default };\n","// gapcursor/index.ts\nexport * from \"prosemirror-gapcursor\";\n","var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n","export var top = 'top';\nexport var bottom = 'bottom';\nexport var right = 'right';\nexport var left = 'left';\nexport var auto = 'auto';\nexport var basePlacements = [top, bottom, right, left];\nexport var start = 'start';\nexport var end = 'end';\nexport var clippingParents = 'clippingParents';\nexport var viewport = 'viewport';\nexport var popper = 'popper';\nexport var reference = 'reference';\nexport var variationPlacements = /*#__PURE__*/basePlacements.reduce(function (acc, placement) {\n  return acc.concat([placement + \"-\" + start, placement + \"-\" + end]);\n}, []);\nexport var placements = /*#__PURE__*/[].concat(basePlacements, [auto]).reduce(function (acc, placement) {\n  return acc.concat([placement, placement + \"-\" + start, placement + \"-\" + end]);\n}, []); // modifiers that need to read the DOM\n\nexport var beforeRead = 'beforeRead';\nexport var read = 'read';\nexport var afterRead = 'afterRead'; // pure-logic modifiers\n\nexport var beforeMain = 'beforeMain';\nexport var main = 'main';\nexport var afterMain = 'afterMain'; // modifier with the purpose to write to the DOM (or write into a framework state)\n\nexport var beforeWrite = 'beforeWrite';\nexport var write = 'write';\nexport var afterWrite = 'afterWrite';\nexport var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];","/**\n * Determines whether or not an element has the virtual hierarchy extension.\n *\n * @public\n */\nexport function isVirtualElement(element) {\n    return element && !!element._virtual;\n}\n//# sourceMappingURL=isVirtualElement.js.map","import hashString from '@emotion/hash';\nimport { SEQUENCE_PREFIX, DEBUG_SEQUENCE_SEPARATOR, SEQUENCE_HASH_LENGTH } from '../../constants.esm.js';\n\nfunction padEndHash(value) {\n  const hashLength = value.length;\n  if (hashLength === SEQUENCE_HASH_LENGTH) {\n    return value;\n  }\n  for (let i = hashLength; i < SEQUENCE_HASH_LENGTH; i++) {\n    value += '0';\n  }\n  return value;\n}\nfunction hashSequence(classes, dir, sequenceIds = []) {\n  if (process.env.NODE_ENV === 'production') {\n    return SEQUENCE_PREFIX + padEndHash(hashString(classes + dir));\n  }\n  return SEQUENCE_PREFIX + padEndHash(hashString(classes + dir)) + DEBUG_SEQUENCE_SEPARATOR + padEndHash(hashString(sequenceIds.join('')));\n}\n\nexport { hashSequence };\n//# sourceMappingURL=hashSequence.esm.js.map\n","// A packages cache that makes sure that we don't inject the same packageName twice in the same bundle -\n// this cache is local to the module closure inside this bundle\nvar packagesCache = {};\n// Cache access to window to avoid IE11 memory leak.\nvar _win = undefined;\ntry {\n    _win = window;\n}\ncatch (e) {\n    /* no-op */\n}\nexport function setVersion(packageName, packageVersion) {\n    if (typeof _win !== 'undefined') {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        var packages = (_win.__packages__ = _win.__packages__ || {});\n        // We allow either the global packages or local packages caches to invalidate so testing can\n        // just clear the global to set this state\n        if (!packages[packageName] || !packagesCache[packageName]) {\n            packagesCache[packageName] = packageVersion;\n            var versions = (packages[packageName] = packages[packageName] || []);\n            versions.push(packageVersion);\n        }\n    }\n}\n//# sourceMappingURL=setVersion.js.map","import { SEQUENCE_PREFIX } from '../constants.esm.js';\nimport { getDebugTree } from './getDebugTree.esm.js';\n\nfunction injectDevTools(document) {\n  const window = document.defaultView;\n  if (!window || window.__GRIFFEL_DEVTOOLS__) {\n    return;\n  }\n  const devtools = {\n    getInfo: element => {\n      const rootDebugSequenceHash = Array.from(element.classList).find(className => className.startsWith(SEQUENCE_PREFIX));\n      if (rootDebugSequenceHash === undefined) {\n        return undefined;\n      }\n      return getDebugTree(rootDebugSequenceHash);\n    }\n  };\n  Object.defineProperty(window, '__GRIFFEL_DEVTOOLS__', {\n    configurable: false,\n    enumerable: false,\n    get() {\n      return devtools;\n    }\n  });\n}\n\nexport { injectDevTools };\n//# sourceMappingURL=injectDevTools.esm.js.map\n","import _extends from '@babel/runtime/helpers/esm/extends';\n\n/**\r\n * Actions represent the type of change to a location value.\r\n *\r\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#action\r\n */\nvar Action;\n\n(function (Action) {\n  /**\r\n   * A POP indicates a change to an arbitrary index in the history stack, such\r\n   * as a back or forward navigation. It does not describe the direction of the\r\n   * navigation, only that the current index changed.\r\n   *\r\n   * Note: This is the default action for newly created history objects.\r\n   */\n  Action[\"Pop\"] = \"POP\";\n  /**\r\n   * A PUSH indicates a new entry being added to the history stack, such as when\r\n   * a link is clicked and a new page loads. When this happens, all subsequent\r\n   * entries in the stack are lost.\r\n   */\n\n  Action[\"Push\"] = \"PUSH\";\n  /**\r\n   * A REPLACE indicates the entry at the current index in the history stack\r\n   * being replaced by a new one.\r\n   */\n\n  Action[\"Replace\"] = \"REPLACE\";\n})(Action || (Action = {}));\n\nvar readOnly = process.env.NODE_ENV !== \"production\" ? function (obj) {\n  return Object.freeze(obj);\n} : function (obj) {\n  return obj;\n};\n\nfunction warning(cond, message) {\n  if (!cond) {\n    // eslint-disable-next-line no-console\n    if (typeof console !== 'undefined') console.warn(message);\n\n    try {\n      // Welcome to debugging history!\n      //\n      // This error is thrown as a convenience so you can more easily\n      // find the source for a warning that appears in the console by\n      // enabling \"pause on exceptions\" in your JavaScript debugger.\n      throw new Error(message); // eslint-disable-next-line no-empty\n    } catch (e) {}\n  }\n}\n\nvar BeforeUnloadEventType = 'beforeunload';\nvar HashChangeEventType = 'hashchange';\nvar PopStateEventType = 'popstate';\n/**\r\n * Browser history stores the location in regular URLs. This is the standard for\r\n * most web apps, but it requires some configuration on the server to ensure you\r\n * serve the same app at multiple URLs.\r\n *\r\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createbrowserhistory\r\n */\n\nfunction createBrowserHistory(options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _options = options,\n      _options$window = _options.window,\n      window = _options$window === void 0 ? document.defaultView : _options$window;\n  var globalHistory = window.history;\n\n  function getIndexAndLocation() {\n    var _window$location = window.location,\n        pathname = _window$location.pathname,\n        search = _window$location.search,\n        hash = _window$location.hash;\n    var state = globalHistory.state || {};\n    return [state.idx, readOnly({\n      pathname: pathname,\n      search: search,\n      hash: hash,\n      state: state.usr || null,\n      key: state.key || 'default'\n    })];\n  }\n\n  var blockedPopTx = null;\n\n  function handlePop() {\n    if (blockedPopTx) {\n      blockers.call(blockedPopTx);\n      blockedPopTx = null;\n    } else {\n      var nextAction = Action.Pop;\n\n      var _getIndexAndLocation = getIndexAndLocation(),\n          nextIndex = _getIndexAndLocation[0],\n          nextLocation = _getIndexAndLocation[1];\n\n      if (blockers.length) {\n        if (nextIndex != null) {\n          var delta = index - nextIndex;\n\n          if (delta) {\n            // Revert the POP\n            blockedPopTx = {\n              action: nextAction,\n              location: nextLocation,\n              retry: function retry() {\n                go(delta * -1);\n              }\n            };\n            go(delta);\n          }\n        } else {\n          // Trying to POP to a location with no index. We did not create\n          // this location, so we can't effectively block the navigation.\n          process.env.NODE_ENV !== \"production\" ? warning(false, // TODO: Write up a doc that explains our blocking strategy in\n          // detail and link to it here so people can understand better what\n          // is going on and how to avoid it.\n          \"You are trying to block a POP navigation to a location that was not \" + \"created by the history library. The block will fail silently in \" + \"production, but in general you should do all navigation with the \" + \"history library (instead of using window.history.pushState directly) \" + \"to avoid this situation.\") : void 0;\n        }\n      } else {\n        applyTx(nextAction);\n      }\n    }\n  }\n\n  window.addEventListener(PopStateEventType, handlePop);\n  var action = Action.Pop;\n\n  var _getIndexAndLocation2 = getIndexAndLocation(),\n      index = _getIndexAndLocation2[0],\n      location = _getIndexAndLocation2[1];\n\n  var listeners = createEvents();\n  var blockers = createEvents();\n\n  if (index == null) {\n    index = 0;\n    globalHistory.replaceState(_extends({}, globalHistory.state, {\n      idx: index\n    }), '');\n  }\n\n  function createHref(to) {\n    return typeof to === 'string' ? to : createPath(to);\n  } // state defaults to `null` because `window.history.state` does\n\n\n  function getNextLocation(to, state) {\n    if (state === void 0) {\n      state = null;\n    }\n\n    return readOnly(_extends({\n      pathname: location.pathname,\n      hash: '',\n      search: ''\n    }, typeof to === 'string' ? parsePath(to) : to, {\n      state: state,\n      key: createKey()\n    }));\n  }\n\n  function getHistoryStateAndUrl(nextLocation, index) {\n    return [{\n      usr: nextLocation.state,\n      key: nextLocation.key,\n      idx: index\n    }, createHref(nextLocation)];\n  }\n\n  function allowTx(action, location, retry) {\n    return !blockers.length || (blockers.call({\n      action: action,\n      location: location,\n      retry: retry\n    }), false);\n  }\n\n  function applyTx(nextAction) {\n    action = nextAction;\n\n    var _getIndexAndLocation3 = getIndexAndLocation();\n\n    index = _getIndexAndLocation3[0];\n    location = _getIndexAndLocation3[1];\n    listeners.call({\n      action: action,\n      location: location\n    });\n  }\n\n  function push(to, state) {\n    var nextAction = Action.Push;\n    var nextLocation = getNextLocation(to, state);\n\n    function retry() {\n      push(to, state);\n    }\n\n    if (allowTx(nextAction, nextLocation, retry)) {\n      var _getHistoryStateAndUr = getHistoryStateAndUrl(nextLocation, index + 1),\n          historyState = _getHistoryStateAndUr[0],\n          url = _getHistoryStateAndUr[1]; // TODO: Support forced reloading\n      // try...catch because iOS limits us to 100 pushState calls :/\n\n\n      try {\n        globalHistory.pushState(historyState, '', url);\n      } catch (error) {\n        // They are going to lose state here, but there is no real\n        // way to warn them about it since the page will refresh...\n        window.location.assign(url);\n      }\n\n      applyTx(nextAction);\n    }\n  }\n\n  function replace(to, state) {\n    var nextAction = Action.Replace;\n    var nextLocation = getNextLocation(to, state);\n\n    function retry() {\n      replace(to, state);\n    }\n\n    if (allowTx(nextAction, nextLocation, retry)) {\n      var _getHistoryStateAndUr2 = getHistoryStateAndUrl(nextLocation, index),\n          historyState = _getHistoryStateAndUr2[0],\n          url = _getHistoryStateAndUr2[1]; // TODO: Support forced reloading\n\n\n      globalHistory.replaceState(historyState, '', url);\n      applyTx(nextAction);\n    }\n  }\n\n  function go(delta) {\n    globalHistory.go(delta);\n  }\n\n  var history = {\n    get action() {\n      return action;\n    },\n\n    get location() {\n      return location;\n    },\n\n    createHref: createHref,\n    push: push,\n    replace: replace,\n    go: go,\n    back: function back() {\n      go(-1);\n    },\n    forward: function forward() {\n      go(1);\n    },\n    listen: function listen(listener) {\n      return listeners.push(listener);\n    },\n    block: function block(blocker) {\n      var unblock = blockers.push(blocker);\n\n      if (blockers.length === 1) {\n        window.addEventListener(BeforeUnloadEventType, promptBeforeUnload);\n      }\n\n      return function () {\n        unblock(); // Remove the beforeunload listener so the document may\n        // still be salvageable in the pagehide event.\n        // See https://html.spec.whatwg.org/#unloading-documents\n\n        if (!blockers.length) {\n          window.removeEventListener(BeforeUnloadEventType, promptBeforeUnload);\n        }\n      };\n    }\n  };\n  return history;\n}\n/**\r\n * Hash history stores the location in window.location.hash. This makes it ideal\r\n * for situations where you don't want to send the location to the server for\r\n * some reason, either because you do cannot configure it or the URL space is\r\n * reserved for something else.\r\n *\r\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createhashhistory\r\n */\n\nfunction createHashHistory(options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _options2 = options,\n      _options2$window = _options2.window,\n      window = _options2$window === void 0 ? document.defaultView : _options2$window;\n  var globalHistory = window.history;\n\n  function getIndexAndLocation() {\n    var _parsePath = parsePath(window.location.hash.substr(1)),\n        _parsePath$pathname = _parsePath.pathname,\n        pathname = _parsePath$pathname === void 0 ? '/' : _parsePath$pathname,\n        _parsePath$search = _parsePath.search,\n        search = _parsePath$search === void 0 ? '' : _parsePath$search,\n        _parsePath$hash = _parsePath.hash,\n        hash = _parsePath$hash === void 0 ? '' : _parsePath$hash;\n\n    var state = globalHistory.state || {};\n    return [state.idx, readOnly({\n      pathname: pathname,\n      search: search,\n      hash: hash,\n      state: state.usr || null,\n      key: state.key || 'default'\n    })];\n  }\n\n  var blockedPopTx = null;\n\n  function handlePop() {\n    if (blockedPopTx) {\n      blockers.call(blockedPopTx);\n      blockedPopTx = null;\n    } else {\n      var nextAction = Action.Pop;\n\n      var _getIndexAndLocation4 = getIndexAndLocation(),\n          nextIndex = _getIndexAndLocation4[0],\n          nextLocation = _getIndexAndLocation4[1];\n\n      if (blockers.length) {\n        if (nextIndex != null) {\n          var delta = index - nextIndex;\n\n          if (delta) {\n            // Revert the POP\n            blockedPopTx = {\n              action: nextAction,\n              location: nextLocation,\n              retry: function retry() {\n                go(delta * -1);\n              }\n            };\n            go(delta);\n          }\n        } else {\n          // Trying to POP to a location with no index. We did not create\n          // this location, so we can't effectively block the navigation.\n          process.env.NODE_ENV !== \"production\" ? warning(false, // TODO: Write up a doc that explains our blocking strategy in\n          // detail and link to it here so people can understand better\n          // what is going on and how to avoid it.\n          \"You are trying to block a POP navigation to a location that was not \" + \"created by the history library. The block will fail silently in \" + \"production, but in general you should do all navigation with the \" + \"history library (instead of using window.history.pushState directly) \" + \"to avoid this situation.\") : void 0;\n        }\n      } else {\n        applyTx(nextAction);\n      }\n    }\n  }\n\n  window.addEventListener(PopStateEventType, handlePop); // popstate does not fire on hashchange in IE 11 and old (trident) Edge\n  // https://developer.mozilla.org/de/docs/Web/API/Window/popstate_event\n\n  window.addEventListener(HashChangeEventType, function () {\n    var _getIndexAndLocation5 = getIndexAndLocation(),\n        nextLocation = _getIndexAndLocation5[1]; // Ignore extraneous hashchange events.\n\n\n    if (createPath(nextLocation) !== createPath(location)) {\n      handlePop();\n    }\n  });\n  var action = Action.Pop;\n\n  var _getIndexAndLocation6 = getIndexAndLocation(),\n      index = _getIndexAndLocation6[0],\n      location = _getIndexAndLocation6[1];\n\n  var listeners = createEvents();\n  var blockers = createEvents();\n\n  if (index == null) {\n    index = 0;\n    globalHistory.replaceState(_extends({}, globalHistory.state, {\n      idx: index\n    }), '');\n  }\n\n  function getBaseHref() {\n    var base = document.querySelector('base');\n    var href = '';\n\n    if (base && base.getAttribute('href')) {\n      var url = window.location.href;\n      var hashIndex = url.indexOf('#');\n      href = hashIndex === -1 ? url : url.slice(0, hashIndex);\n    }\n\n    return href;\n  }\n\n  function createHref(to) {\n    return getBaseHref() + '#' + (typeof to === 'string' ? to : createPath(to));\n  }\n\n  function getNextLocation(to, state) {\n    if (state === void 0) {\n      state = null;\n    }\n\n    return readOnly(_extends({\n      pathname: location.pathname,\n      hash: '',\n      search: ''\n    }, typeof to === 'string' ? parsePath(to) : to, {\n      state: state,\n      key: createKey()\n    }));\n  }\n\n  function getHistoryStateAndUrl(nextLocation, index) {\n    return [{\n      usr: nextLocation.state,\n      key: nextLocation.key,\n      idx: index\n    }, createHref(nextLocation)];\n  }\n\n  function allowTx(action, location, retry) {\n    return !blockers.length || (blockers.call({\n      action: action,\n      location: location,\n      retry: retry\n    }), false);\n  }\n\n  function applyTx(nextAction) {\n    action = nextAction;\n\n    var _getIndexAndLocation7 = getIndexAndLocation();\n\n    index = _getIndexAndLocation7[0];\n    location = _getIndexAndLocation7[1];\n    listeners.call({\n      action: action,\n      location: location\n    });\n  }\n\n  function push(to, state) {\n    var nextAction = Action.Push;\n    var nextLocation = getNextLocation(to, state);\n\n    function retry() {\n      push(to, state);\n    }\n\n    process.env.NODE_ENV !== \"production\" ? warning(nextLocation.pathname.charAt(0) === '/', \"Relative pathnames are not supported in hash history.push(\" + JSON.stringify(to) + \")\") : void 0;\n\n    if (allowTx(nextAction, nextLocation, retry)) {\n      var _getHistoryStateAndUr3 = getHistoryStateAndUrl(nextLocation, index + 1),\n          historyState = _getHistoryStateAndUr3[0],\n          url = _getHistoryStateAndUr3[1]; // TODO: Support forced reloading\n      // try...catch because iOS limits us to 100 pushState calls :/\n\n\n      try {\n        globalHistory.pushState(historyState, '', url);\n      } catch (error) {\n        // They are going to lose state here, but there is no real\n        // way to warn them about it since the page will refresh...\n        window.location.assign(url);\n      }\n\n      applyTx(nextAction);\n    }\n  }\n\n  function replace(to, state) {\n    var nextAction = Action.Replace;\n    var nextLocation = getNextLocation(to, state);\n\n    function retry() {\n      replace(to, state);\n    }\n\n    process.env.NODE_ENV !== \"production\" ? warning(nextLocation.pathname.charAt(0) === '/', \"Relative pathnames are not supported in hash history.replace(\" + JSON.stringify(to) + \")\") : void 0;\n\n    if (allowTx(nextAction, nextLocation, retry)) {\n      var _getHistoryStateAndUr4 = getHistoryStateAndUrl(nextLocation, index),\n          historyState = _getHistoryStateAndUr4[0],\n          url = _getHistoryStateAndUr4[1]; // TODO: Support forced reloading\n\n\n      globalHistory.replaceState(historyState, '', url);\n      applyTx(nextAction);\n    }\n  }\n\n  function go(delta) {\n    globalHistory.go(delta);\n  }\n\n  var history = {\n    get action() {\n      return action;\n    },\n\n    get location() {\n      return location;\n    },\n\n    createHref: createHref,\n    push: push,\n    replace: replace,\n    go: go,\n    back: function back() {\n      go(-1);\n    },\n    forward: function forward() {\n      go(1);\n    },\n    listen: function listen(listener) {\n      return listeners.push(listener);\n    },\n    block: function block(blocker) {\n      var unblock = blockers.push(blocker);\n\n      if (blockers.length === 1) {\n        window.addEventListener(BeforeUnloadEventType, promptBeforeUnload);\n      }\n\n      return function () {\n        unblock(); // Remove the beforeunload listener so the document may\n        // still be salvageable in the pagehide event.\n        // See https://html.spec.whatwg.org/#unloading-documents\n\n        if (!blockers.length) {\n          window.removeEventListener(BeforeUnloadEventType, promptBeforeUnload);\n        }\n      };\n    }\n  };\n  return history;\n}\n/**\r\n * Memory history stores the current location in memory. It is designed for use\r\n * in stateful non-browser environments like tests and React Native.\r\n *\r\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#creatememoryhistory\r\n */\n\nfunction createMemoryHistory(options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _options3 = options,\n      _options3$initialEntr = _options3.initialEntries,\n      initialEntries = _options3$initialEntr === void 0 ? ['/'] : _options3$initialEntr,\n      initialIndex = _options3.initialIndex;\n  var entries = initialEntries.map(function (entry) {\n    var location = readOnly(_extends({\n      pathname: '/',\n      search: '',\n      hash: '',\n      state: null,\n      key: createKey()\n    }, typeof entry === 'string' ? parsePath(entry) : entry));\n    process.env.NODE_ENV !== \"production\" ? warning(location.pathname.charAt(0) === '/', \"Relative pathnames are not supported in createMemoryHistory({ initialEntries }) (invalid entry: \" + JSON.stringify(entry) + \")\") : void 0;\n    return location;\n  });\n  var index = clamp(initialIndex == null ? entries.length - 1 : initialIndex, 0, entries.length - 1);\n  var action = Action.Pop;\n  var location = entries[index];\n  var listeners = createEvents();\n  var blockers = createEvents();\n\n  function createHref(to) {\n    return typeof to === 'string' ? to : createPath(to);\n  }\n\n  function getNextLocation(to, state) {\n    if (state === void 0) {\n      state = null;\n    }\n\n    return readOnly(_extends({\n      pathname: location.pathname,\n      search: '',\n      hash: ''\n    }, typeof to === 'string' ? parsePath(to) : to, {\n      state: state,\n      key: createKey()\n    }));\n  }\n\n  function allowTx(action, location, retry) {\n    return !blockers.length || (blockers.call({\n      action: action,\n      location: location,\n      retry: retry\n    }), false);\n  }\n\n  function applyTx(nextAction, nextLocation) {\n    action = nextAction;\n    location = nextLocation;\n    listeners.call({\n      action: action,\n      location: location\n    });\n  }\n\n  function push(to, state) {\n    var nextAction = Action.Push;\n    var nextLocation = getNextLocation(to, state);\n\n    function retry() {\n      push(to, state);\n    }\n\n    process.env.NODE_ENV !== \"production\" ? warning(location.pathname.charAt(0) === '/', \"Relative pathnames are not supported in memory history.push(\" + JSON.stringify(to) + \")\") : void 0;\n\n    if (allowTx(nextAction, nextLocation, retry)) {\n      index += 1;\n      entries.splice(index, entries.length, nextLocation);\n      applyTx(nextAction, nextLocation);\n    }\n  }\n\n  function replace(to, state) {\n    var nextAction = Action.Replace;\n    var nextLocation = getNextLocation(to, state);\n\n    function retry() {\n      replace(to, state);\n    }\n\n    process.env.NODE_ENV !== \"production\" ? warning(location.pathname.charAt(0) === '/', \"Relative pathnames are not supported in memory history.replace(\" + JSON.stringify(to) + \")\") : void 0;\n\n    if (allowTx(nextAction, nextLocation, retry)) {\n      entries[index] = nextLocation;\n      applyTx(nextAction, nextLocation);\n    }\n  }\n\n  function go(delta) {\n    var nextIndex = clamp(index + delta, 0, entries.length - 1);\n    var nextAction = Action.Pop;\n    var nextLocation = entries[nextIndex];\n\n    function retry() {\n      go(delta);\n    }\n\n    if (allowTx(nextAction, nextLocation, retry)) {\n      index = nextIndex;\n      applyTx(nextAction, nextLocation);\n    }\n  }\n\n  var history = {\n    get index() {\n      return index;\n    },\n\n    get action() {\n      return action;\n    },\n\n    get location() {\n      return location;\n    },\n\n    createHref: createHref,\n    push: push,\n    replace: replace,\n    go: go,\n    back: function back() {\n      go(-1);\n    },\n    forward: function forward() {\n      go(1);\n    },\n    listen: function listen(listener) {\n      return listeners.push(listener);\n    },\n    block: function block(blocker) {\n      return blockers.push(blocker);\n    }\n  };\n  return history;\n} ////////////////////////////////////////////////////////////////////////////////\n// UTILS\n////////////////////////////////////////////////////////////////////////////////\n\nfunction clamp(n, lowerBound, upperBound) {\n  return Math.min(Math.max(n, lowerBound), upperBound);\n}\n\nfunction promptBeforeUnload(event) {\n  // Cancel the event.\n  event.preventDefault(); // Chrome (and legacy IE) requires returnValue to be set.\n\n  event.returnValue = '';\n}\n\nfunction createEvents() {\n  var handlers = [];\n  return {\n    get length() {\n      return handlers.length;\n    },\n\n    push: function push(fn) {\n      handlers.push(fn);\n      return function () {\n        handlers = handlers.filter(function (handler) {\n          return handler !== fn;\n        });\n      };\n    },\n    call: function call(arg) {\n      handlers.forEach(function (fn) {\n        return fn && fn(arg);\n      });\n    }\n  };\n}\n\nfunction createKey() {\n  return Math.random().toString(36).substr(2, 8);\n}\n/**\r\n * Creates a string URL path from the given pathname, search, and hash components.\r\n *\r\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createpath\r\n */\n\n\nfunction createPath(_ref) {\n  var _ref$pathname = _ref.pathname,\n      pathname = _ref$pathname === void 0 ? '/' : _ref$pathname,\n      _ref$search = _ref.search,\n      search = _ref$search === void 0 ? '' : _ref$search,\n      _ref$hash = _ref.hash,\n      hash = _ref$hash === void 0 ? '' : _ref$hash;\n  if (search && search !== '?') pathname += search.charAt(0) === '?' ? search : '?' + search;\n  if (hash && hash !== '#') pathname += hash.charAt(0) === '#' ? hash : '#' + hash;\n  return pathname;\n}\n/**\r\n * Parses a string URL path into its separate pathname, search, and hash components.\r\n *\r\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#parsepath\r\n */\n\nfunction parsePath(path) {\n  var parsedPath = {};\n\n  if (path) {\n    var hashIndex = path.indexOf('#');\n\n    if (hashIndex >= 0) {\n      parsedPath.hash = path.substr(hashIndex);\n      path = path.substr(0, hashIndex);\n    }\n\n    var searchIndex = path.indexOf('?');\n\n    if (searchIndex >= 0) {\n      parsedPath.search = path.substr(searchIndex);\n      path = path.substr(0, searchIndex);\n    }\n\n    if (path) {\n      parsedPath.pathname = path;\n    }\n  }\n\n  return parsedPath;\n}\n\nexport { Action, createBrowserHistory, createHashHistory, createMemoryHistory, createPath, parsePath };\n//# sourceMappingURL=index.js.map\n","import { liftTarget, replaceStep, ReplaceStep, canJoin, joinPoint, canSplit, ReplaceAroundStep, findWrapping } from 'prosemirror-transform';\nimport { Slice, Fragment } from 'prosemirror-model';\nimport { NodeSelection, Selection, TextSelection, AllSelection, SelectionRange } from 'prosemirror-state';\n\n/**\nDelete the selection, if there is one.\n*/\nconst deleteSelection = (state, dispatch) => {\n    if (state.selection.empty)\n        return false;\n    if (dispatch)\n        dispatch(state.tr.deleteSelection().scrollIntoView());\n    return true;\n};\nfunction atBlockStart(state, view) {\n    let { $cursor } = state.selection;\n    if (!$cursor || (view ? !view.endOfTextblock(\"backward\", state)\n        : $cursor.parentOffset > 0))\n        return null;\n    return $cursor;\n}\n/**\nIf the selection is empty and at the start of a textblock, try to\nreduce the distance between that block and the one before itif\nthere's a block directly before it that can be joined, join them.\nIf not, try to move the selected block closer to the next one in\nthe document structure by lifting it out of its parent or moving it\ninto a parent of the previous block. Will use the view for accurate\n(bidi-aware) start-of-textblock detection if given.\n*/\nconst joinBackward = (state, dispatch, view) => {\n    let $cursor = atBlockStart(state, view);\n    if (!$cursor)\n        return false;\n    let $cut = findCutBefore($cursor);\n    // If there is no node before this, try to lift\n    if (!$cut) {\n        let range = $cursor.blockRange(), target = range && liftTarget(range);\n        if (target == null)\n            return false;\n        if (dispatch)\n            dispatch(state.tr.lift(range, target).scrollIntoView());\n        return true;\n    }\n    let before = $cut.nodeBefore;\n    // Apply the joining algorithm\n    if (deleteBarrier(state, $cut, dispatch, -1))\n        return true;\n    // If the node below has no content and the node above is\n    // selectable, delete the node below and select the one above.\n    if ($cursor.parent.content.size == 0 &&\n        (textblockAt(before, \"end\") || NodeSelection.isSelectable(before))) {\n        for (let depth = $cursor.depth;; depth--) {\n            let delStep = replaceStep(state.doc, $cursor.before(depth), $cursor.after(depth), Slice.empty);\n            if (delStep && delStep.slice.size < delStep.to - delStep.from) {\n                if (dispatch) {\n                    let tr = state.tr.step(delStep);\n                    tr.setSelection(textblockAt(before, \"end\")\n                        ? Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos, -1)), -1)\n                        : NodeSelection.create(tr.doc, $cut.pos - before.nodeSize));\n                    dispatch(tr.scrollIntoView());\n                }\n                return true;\n            }\n            if (depth == 1 || $cursor.node(depth - 1).childCount > 1)\n                break;\n        }\n    }\n    // If the node before is an atom, delete it\n    if (before.isAtom && $cut.depth == $cursor.depth - 1) {\n        if (dispatch)\n            dispatch(state.tr.delete($cut.pos - before.nodeSize, $cut.pos).scrollIntoView());\n        return true;\n    }\n    return false;\n};\n/**\nA more limited form of [`joinBackward`]($commands.joinBackward)\nthat only tries to join the current textblock to the one before\nit, if the cursor is at the start of a textblock.\n*/\nconst joinTextblockBackward = (state, dispatch, view) => {\n    let $cursor = atBlockStart(state, view);\n    if (!$cursor)\n        return false;\n    let $cut = findCutBefore($cursor);\n    return $cut ? joinTextblocksAround(state, $cut, dispatch) : false;\n};\n/**\nA more limited form of [`joinForward`]($commands.joinForward)\nthat only tries to join the current textblock to the one after\nit, if the cursor is at the end of a textblock.\n*/\nconst joinTextblockForward = (state, dispatch, view) => {\n    let $cursor = atBlockEnd(state, view);\n    if (!$cursor)\n        return false;\n    let $cut = findCutAfter($cursor);\n    return $cut ? joinTextblocksAround(state, $cut, dispatch) : false;\n};\nfunction joinTextblocksAround(state, $cut, dispatch) {\n    let before = $cut.nodeBefore, beforeText = before, beforePos = $cut.pos - 1;\n    for (; !beforeText.isTextblock; beforePos--) {\n        if (beforeText.type.spec.isolating)\n            return false;\n        let child = beforeText.lastChild;\n        if (!child)\n            return false;\n        beforeText = child;\n    }\n    let after = $cut.nodeAfter, afterText = after, afterPos = $cut.pos + 1;\n    for (; !afterText.isTextblock; afterPos++) {\n        if (afterText.type.spec.isolating)\n            return false;\n        let child = afterText.firstChild;\n        if (!child)\n            return false;\n        afterText = child;\n    }\n    let step = replaceStep(state.doc, beforePos, afterPos, Slice.empty);\n    if (!step || step.from != beforePos ||\n        step instanceof ReplaceStep && step.slice.size >= afterPos - beforePos)\n        return false;\n    if (dispatch) {\n        let tr = state.tr.step(step);\n        tr.setSelection(TextSelection.create(tr.doc, beforePos));\n        dispatch(tr.scrollIntoView());\n    }\n    return true;\n}\nfunction textblockAt(node, side, only = false) {\n    for (let scan = node; scan; scan = (side == \"start\" ? scan.firstChild : scan.lastChild)) {\n        if (scan.isTextblock)\n            return true;\n        if (only && scan.childCount != 1)\n            return false;\n    }\n    return false;\n}\n/**\nWhen the selection is empty and at the start of a textblock, select\nthe node before that textblock, if possible. This is intended to be\nbound to keys like backspace, after\n[`joinBackward`](https://prosemirror.net/docs/ref/#commands.joinBackward) or other deleting\ncommands, as a fall-back behavior when the schema doesn't allow\ndeletion at the selected point.\n*/\nconst selectNodeBackward = (state, dispatch, view) => {\n    let { $head, empty } = state.selection, $cut = $head;\n    if (!empty)\n        return false;\n    if ($head.parent.isTextblock) {\n        if (view ? !view.endOfTextblock(\"backward\", state) : $head.parentOffset > 0)\n            return false;\n        $cut = findCutBefore($head);\n    }\n    let node = $cut && $cut.nodeBefore;\n    if (!node || !NodeSelection.isSelectable(node))\n        return false;\n    if (dispatch)\n        dispatch(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos - node.nodeSize)).scrollIntoView());\n    return true;\n};\nfunction findCutBefore($pos) {\n    if (!$pos.parent.type.spec.isolating)\n        for (let i = $pos.depth - 1; i >= 0; i--) {\n            if ($pos.index(i) > 0)\n                return $pos.doc.resolve($pos.before(i + 1));\n            if ($pos.node(i).type.spec.isolating)\n                break;\n        }\n    return null;\n}\nfunction atBlockEnd(state, view) {\n    let { $cursor } = state.selection;\n    if (!$cursor || (view ? !view.endOfTextblock(\"forward\", state)\n        : $cursor.parentOffset < $cursor.parent.content.size))\n        return null;\n    return $cursor;\n}\n/**\nIf the selection is empty and the cursor is at the end of a\ntextblock, try to reduce or remove the boundary between that block\nand the one after it, either by joining them or by moving the other\nblock closer to this one in the tree structure. Will use the view\nfor accurate start-of-textblock detection if given.\n*/\nconst joinForward = (state, dispatch, view) => {\n    let $cursor = atBlockEnd(state, view);\n    if (!$cursor)\n        return false;\n    let $cut = findCutAfter($cursor);\n    // If there is no node after this, there's nothing to do\n    if (!$cut)\n        return false;\n    let after = $cut.nodeAfter;\n    // Try the joining algorithm\n    if (deleteBarrier(state, $cut, dispatch, 1))\n        return true;\n    // If the node above has no content and the node below is\n    // selectable, delete the node above and select the one below.\n    if ($cursor.parent.content.size == 0 &&\n        (textblockAt(after, \"start\") || NodeSelection.isSelectable(after))) {\n        let delStep = replaceStep(state.doc, $cursor.before(), $cursor.after(), Slice.empty);\n        if (delStep && delStep.slice.size < delStep.to - delStep.from) {\n            if (dispatch) {\n                let tr = state.tr.step(delStep);\n                tr.setSelection(textblockAt(after, \"start\") ? Selection.findFrom(tr.doc.resolve(tr.mapping.map($cut.pos)), 1)\n                    : NodeSelection.create(tr.doc, tr.mapping.map($cut.pos)));\n                dispatch(tr.scrollIntoView());\n            }\n            return true;\n        }\n    }\n    // If the next node is an atom, delete it\n    if (after.isAtom && $cut.depth == $cursor.depth - 1) {\n        if (dispatch)\n            dispatch(state.tr.delete($cut.pos, $cut.pos + after.nodeSize).scrollIntoView());\n        return true;\n    }\n    return false;\n};\n/**\nWhen the selection is empty and at the end of a textblock, select\nthe node coming after that textblock, if possible. This is intended\nto be bound to keys like delete, after\n[`joinForward`](https://prosemirror.net/docs/ref/#commands.joinForward) and similar deleting\ncommands, to provide a fall-back behavior when the schema doesn't\nallow deletion at the selected point.\n*/\nconst selectNodeForward = (state, dispatch, view) => {\n    let { $head, empty } = state.selection, $cut = $head;\n    if (!empty)\n        return false;\n    if ($head.parent.isTextblock) {\n        if (view ? !view.endOfTextblock(\"forward\", state) : $head.parentOffset < $head.parent.content.size)\n            return false;\n        $cut = findCutAfter($head);\n    }\n    let node = $cut && $cut.nodeAfter;\n    if (!node || !NodeSelection.isSelectable(node))\n        return false;\n    if (dispatch)\n        dispatch(state.tr.setSelection(NodeSelection.create(state.doc, $cut.pos)).scrollIntoView());\n    return true;\n};\nfunction findCutAfter($pos) {\n    if (!$pos.parent.type.spec.isolating)\n        for (let i = $pos.depth - 1; i >= 0; i--) {\n            let parent = $pos.node(i);\n            if ($pos.index(i) + 1 < parent.childCount)\n                return $pos.doc.resolve($pos.after(i + 1));\n            if (parent.type.spec.isolating)\n                break;\n        }\n    return null;\n}\n/**\nJoin the selected block or, if there is a text selection, the\nclosest ancestor block of the selection that can be joined, with\nthe sibling above it.\n*/\nconst joinUp = (state, dispatch) => {\n    let sel = state.selection, nodeSel = sel instanceof NodeSelection, point;\n    if (nodeSel) {\n        if (sel.node.isTextblock || !canJoin(state.doc, sel.from))\n            return false;\n        point = sel.from;\n    }\n    else {\n        point = joinPoint(state.doc, sel.from, -1);\n        if (point == null)\n            return false;\n    }\n    if (dispatch) {\n        let tr = state.tr.join(point);\n        if (nodeSel)\n            tr.setSelection(NodeSelection.create(tr.doc, point - state.doc.resolve(point).nodeBefore.nodeSize));\n        dispatch(tr.scrollIntoView());\n    }\n    return true;\n};\n/**\nJoin the selected block, or the closest ancestor of the selection\nthat can be joined, with the sibling after it.\n*/\nconst joinDown = (state, dispatch) => {\n    let sel = state.selection, point;\n    if (sel instanceof NodeSelection) {\n        if (sel.node.isTextblock || !canJoin(state.doc, sel.to))\n            return false;\n        point = sel.to;\n    }\n    else {\n        point = joinPoint(state.doc, sel.to, 1);\n        if (point == null)\n            return false;\n    }\n    if (dispatch)\n        dispatch(state.tr.join(point).scrollIntoView());\n    return true;\n};\n/**\nLift the selected block, or the closest ancestor block of the\nselection that can be lifted, out of its parent node.\n*/\nconst lift = (state, dispatch) => {\n    let { $from, $to } = state.selection;\n    let range = $from.blockRange($to), target = range && liftTarget(range);\n    if (target == null)\n        return false;\n    if (dispatch)\n        dispatch(state.tr.lift(range, target).scrollIntoView());\n    return true;\n};\n/**\nIf the selection is in a node whose type has a truthy\n[`code`](https://prosemirror.net/docs/ref/#model.NodeSpec.code) property in its spec, replace the\nselection with a newline character.\n*/\nconst newlineInCode = (state, dispatch) => {\n    let { $head, $anchor } = state.selection;\n    if (!$head.parent.type.spec.code || !$head.sameParent($anchor))\n        return false;\n    if (dispatch)\n        dispatch(state.tr.insertText(\"\\n\").scrollIntoView());\n    return true;\n};\nfunction defaultBlockAt(match) {\n    for (let i = 0; i < match.edgeCount; i++) {\n        let { type } = match.edge(i);\n        if (type.isTextblock && !type.hasRequiredAttrs())\n            return type;\n    }\n    return null;\n}\n/**\nWhen the selection is in a node with a truthy\n[`code`](https://prosemirror.net/docs/ref/#model.NodeSpec.code) property in its spec, create a\ndefault block after the code block, and move the cursor there.\n*/\nconst exitCode = (state, dispatch) => {\n    let { $head, $anchor } = state.selection;\n    if (!$head.parent.type.spec.code || !$head.sameParent($anchor))\n        return false;\n    let above = $head.node(-1), after = $head.indexAfter(-1), type = defaultBlockAt(above.contentMatchAt(after));\n    if (!type || !above.canReplaceWith(after, after, type))\n        return false;\n    if (dispatch) {\n        let pos = $head.after(), tr = state.tr.replaceWith(pos, pos, type.createAndFill());\n        tr.setSelection(Selection.near(tr.doc.resolve(pos), 1));\n        dispatch(tr.scrollIntoView());\n    }\n    return true;\n};\n/**\nIf a block node is selected, create an empty paragraph before (if\nit is its parent's first child) or after it.\n*/\nconst createParagraphNear = (state, dispatch) => {\n    let sel = state.selection, { $from, $to } = sel;\n    if (sel instanceof AllSelection || $from.parent.inlineContent || $to.parent.inlineContent)\n        return false;\n    let type = defaultBlockAt($to.parent.contentMatchAt($to.indexAfter()));\n    if (!type || !type.isTextblock)\n        return false;\n    if (dispatch) {\n        let side = (!$from.parentOffset && $to.index() < $to.parent.childCount ? $from : $to).pos;\n        let tr = state.tr.insert(side, type.createAndFill());\n        tr.setSelection(TextSelection.create(tr.doc, side + 1));\n        dispatch(tr.scrollIntoView());\n    }\n    return true;\n};\n/**\nIf the cursor is in an empty textblock that can be lifted, lift the\nblock.\n*/\nconst liftEmptyBlock = (state, dispatch) => {\n    let { $cursor } = state.selection;\n    if (!$cursor || $cursor.parent.content.size)\n        return false;\n    if ($cursor.depth > 1 && $cursor.after() != $cursor.end(-1)) {\n        let before = $cursor.before();\n        if (canSplit(state.doc, before)) {\n            if (dispatch)\n                dispatch(state.tr.split(before).scrollIntoView());\n            return true;\n        }\n    }\n    let range = $cursor.blockRange(), target = range && liftTarget(range);\n    if (target == null)\n        return false;\n    if (dispatch)\n        dispatch(state.tr.lift(range, target).scrollIntoView());\n    return true;\n};\n/**\nCreate a variant of [`splitBlock`](https://prosemirror.net/docs/ref/#commands.splitBlock) that uses\na custom function to determine the type of the newly split off block.\n*/\nfunction splitBlockAs(splitNode) {\n    return (state, dispatch) => {\n        let { $from, $to } = state.selection;\n        if (state.selection instanceof NodeSelection && state.selection.node.isBlock) {\n            if (!$from.parentOffset || !canSplit(state.doc, $from.pos))\n                return false;\n            if (dispatch)\n                dispatch(state.tr.split($from.pos).scrollIntoView());\n            return true;\n        }\n        if (!$from.parent.isBlock)\n            return false;\n        if (dispatch) {\n            let atEnd = $to.parentOffset == $to.parent.content.size;\n            let tr = state.tr;\n            if (state.selection instanceof TextSelection || state.selection instanceof AllSelection)\n                tr.deleteSelection();\n            let deflt = $from.depth == 0 ? null : defaultBlockAt($from.node(-1).contentMatchAt($from.indexAfter(-1)));\n            let splitType = splitNode && splitNode($to.parent, atEnd, $from);\n            let types = splitType ? [splitType] : atEnd && deflt ? [{ type: deflt }] : undefined;\n            let can = canSplit(tr.doc, tr.mapping.map($from.pos), 1, types);\n            if (!types && !can && canSplit(tr.doc, tr.mapping.map($from.pos), 1, deflt ? [{ type: deflt }] : undefined)) {\n                if (deflt)\n                    types = [{ type: deflt }];\n                can = true;\n            }\n            if (can) {\n                tr.split(tr.mapping.map($from.pos), 1, types);\n                if (!atEnd && !$from.parentOffset && $from.parent.type != deflt) {\n                    let first = tr.mapping.map($from.before()), $first = tr.doc.resolve(first);\n                    if (deflt && $from.node(-1).canReplaceWith($first.index(), $first.index() + 1, deflt))\n                        tr.setNodeMarkup(tr.mapping.map($from.before()), deflt);\n                }\n            }\n            dispatch(tr.scrollIntoView());\n        }\n        return true;\n    };\n}\n/**\nSplit the parent block of the selection. If the selection is a text\nselection, also delete its content.\n*/\nconst splitBlock = splitBlockAs();\n/**\nActs like [`splitBlock`](https://prosemirror.net/docs/ref/#commands.splitBlock), but without\nresetting the set of active marks at the cursor.\n*/\nconst splitBlockKeepMarks = (state, dispatch) => {\n    return splitBlock(state, dispatch && (tr => {\n        let marks = state.storedMarks || (state.selection.$to.parentOffset && state.selection.$from.marks());\n        if (marks)\n            tr.ensureMarks(marks);\n        dispatch(tr);\n    }));\n};\n/**\nMove the selection to the node wrapping the current selection, if\nany. (Will not select the document node.)\n*/\nconst selectParentNode = (state, dispatch) => {\n    let { $from, to } = state.selection, pos;\n    let same = $from.sharedDepth(to);\n    if (same == 0)\n        return false;\n    pos = $from.before(same);\n    if (dispatch)\n        dispatch(state.tr.setSelection(NodeSelection.create(state.doc, pos)));\n    return true;\n};\n/**\nSelect the whole document.\n*/\nconst selectAll = (state, dispatch) => {\n    if (dispatch)\n        dispatch(state.tr.setSelection(new AllSelection(state.doc)));\n    return true;\n};\nfunction joinMaybeClear(state, $pos, dispatch) {\n    let before = $pos.nodeBefore, after = $pos.nodeAfter, index = $pos.index();\n    if (!before || !after || !before.type.compatibleContent(after.type))\n        return false;\n    if (!before.content.size && $pos.parent.canReplace(index - 1, index)) {\n        if (dispatch)\n            dispatch(state.tr.delete($pos.pos - before.nodeSize, $pos.pos).scrollIntoView());\n        return true;\n    }\n    if (!$pos.parent.canReplace(index, index + 1) || !(after.isTextblock || canJoin(state.doc, $pos.pos)))\n        return false;\n    if (dispatch)\n        dispatch(state.tr\n            .clearIncompatible($pos.pos, before.type, before.contentMatchAt(before.childCount))\n            .join($pos.pos)\n            .scrollIntoView());\n    return true;\n}\nfunction deleteBarrier(state, $cut, dispatch, dir) {\n    let before = $cut.nodeBefore, after = $cut.nodeAfter, conn, match;\n    let isolated = before.type.spec.isolating || after.type.spec.isolating;\n    if (!isolated && joinMaybeClear(state, $cut, dispatch))\n        return true;\n    let canDelAfter = !isolated && $cut.parent.canReplace($cut.index(), $cut.index() + 1);\n    if (canDelAfter &&\n        (conn = (match = before.contentMatchAt(before.childCount)).findWrapping(after.type)) &&\n        match.matchType(conn[0] || after.type).validEnd) {\n        if (dispatch) {\n            let end = $cut.pos + after.nodeSize, wrap = Fragment.empty;\n            for (let i = conn.length - 1; i >= 0; i--)\n                wrap = Fragment.from(conn[i].create(null, wrap));\n            wrap = Fragment.from(before.copy(wrap));\n            let tr = state.tr.step(new ReplaceAroundStep($cut.pos - 1, end, $cut.pos, end, new Slice(wrap, 1, 0), conn.length, true));\n            let joinAt = end + 2 * conn.length;\n            if (canJoin(tr.doc, joinAt))\n                tr.join(joinAt);\n            dispatch(tr.scrollIntoView());\n        }\n        return true;\n    }\n    let selAfter = after.type.spec.isolating || (dir > 0 && isolated) ? null : Selection.findFrom($cut, 1);\n    let range = selAfter && selAfter.$from.blockRange(selAfter.$to), target = range && liftTarget(range);\n    if (target != null && target >= $cut.depth) {\n        if (dispatch)\n            dispatch(state.tr.lift(range, target).scrollIntoView());\n        return true;\n    }\n    if (canDelAfter && textblockAt(after, \"start\", true) && textblockAt(before, \"end\")) {\n        let at = before, wrap = [];\n        for (;;) {\n            wrap.push(at);\n            if (at.isTextblock)\n                break;\n            at = at.lastChild;\n        }\n        let afterText = after, afterDepth = 1;\n        for (; !afterText.isTextblock; afterText = afterText.firstChild)\n            afterDepth++;\n        if (at.canReplace(at.childCount, at.childCount, afterText.content)) {\n            if (dispatch) {\n                let end = Fragment.empty;\n                for (let i = wrap.length - 1; i >= 0; i--)\n                    end = Fragment.from(wrap[i].copy(end));\n                let tr = state.tr.step(new ReplaceAroundStep($cut.pos - wrap.length, $cut.pos + after.nodeSize, $cut.pos + afterDepth, $cut.pos + after.nodeSize - afterDepth, new Slice(end, wrap.length, 0), 0, true));\n                dispatch(tr.scrollIntoView());\n            }\n            return true;\n        }\n    }\n    return false;\n}\nfunction selectTextblockSide(side) {\n    return function (state, dispatch) {\n        let sel = state.selection, $pos = side < 0 ? sel.$from : sel.$to;\n        let depth = $pos.depth;\n        while ($pos.node(depth).isInline) {\n            if (!depth)\n                return false;\n            depth--;\n        }\n        if (!$pos.node(depth).isTextblock)\n            return false;\n        if (dispatch)\n            dispatch(state.tr.setSelection(TextSelection.create(state.doc, side < 0 ? $pos.start(depth) : $pos.end(depth))));\n        return true;\n    };\n}\n/**\nMoves the cursor to the start of current text block.\n*/\nconst selectTextblockStart = selectTextblockSide(-1);\n/**\nMoves the cursor to the end of current text block.\n*/\nconst selectTextblockEnd = selectTextblockSide(1);\n// Parameterized commands\n/**\nWrap the selection in a node of the given type with the given\nattributes.\n*/\nfunction wrapIn(nodeType, attrs = null) {\n    return function (state, dispatch) {\n        let { $from, $to } = state.selection;\n        let range = $from.blockRange($to), wrapping = range && findWrapping(range, nodeType, attrs);\n        if (!wrapping)\n            return false;\n        if (dispatch)\n            dispatch(state.tr.wrap(range, wrapping).scrollIntoView());\n        return true;\n    };\n}\n/**\nReturns a command that tries to set the selected textblocks to the\ngiven node type with the given attributes.\n*/\nfunction setBlockType(nodeType, attrs = null) {\n    return function (state, dispatch) {\n        let applicable = false;\n        for (let i = 0; i < state.selection.ranges.length && !applicable; i++) {\n            let { $from: { pos: from }, $to: { pos: to } } = state.selection.ranges[i];\n            state.doc.nodesBetween(from, to, (node, pos) => {\n                if (applicable)\n                    return false;\n                if (!node.isTextblock || node.hasMarkup(nodeType, attrs))\n                    return;\n                if (node.type == nodeType) {\n                    applicable = true;\n                }\n                else {\n                    let $pos = state.doc.resolve(pos), index = $pos.index();\n                    applicable = $pos.parent.canReplaceWith(index, index + 1, nodeType);\n                }\n            });\n        }\n        if (!applicable)\n            return false;\n        if (dispatch) {\n            let tr = state.tr;\n            for (let i = 0; i < state.selection.ranges.length; i++) {\n                let { $from: { pos: from }, $to: { pos: to } } = state.selection.ranges[i];\n                tr.setBlockType(from, to, nodeType, attrs);\n            }\n            dispatch(tr.scrollIntoView());\n        }\n        return true;\n    };\n}\nfunction markApplies(doc, ranges, type, enterAtoms) {\n    for (let i = 0; i < ranges.length; i++) {\n        let { $from, $to } = ranges[i];\n        let can = $from.depth == 0 ? doc.inlineContent && doc.type.allowsMarkType(type) : false;\n        doc.nodesBetween($from.pos, $to.pos, (node, pos) => {\n            if (can || !enterAtoms && node.isAtom && node.isInline && pos >= $from.pos && pos + node.nodeSize <= $to.pos)\n                return false;\n            can = node.inlineContent && node.type.allowsMarkType(type);\n        });\n        if (can)\n            return true;\n    }\n    return false;\n}\nfunction removeInlineAtoms(ranges) {\n    let result = [];\n    for (let i = 0; i < ranges.length; i++) {\n        let { $from, $to } = ranges[i];\n        $from.doc.nodesBetween($from.pos, $to.pos, (node, pos) => {\n            if (node.isAtom && node.content.size && node.isInline && pos >= $from.pos && pos + node.nodeSize <= $to.pos) {\n                if (pos + 1 > $from.pos)\n                    result.push(new SelectionRange($from, $from.doc.resolve(pos + 1)));\n                $from = $from.doc.resolve(pos + 1 + node.content.size);\n                return false;\n            }\n        });\n        if ($from.pos < $to.pos)\n            result.push(new SelectionRange($from, $to));\n    }\n    return result;\n}\n/**\nCreate a command function that toggles the given mark with the\ngiven attributes. Will return `false` when the current selection\ndoesn't support that mark. This will remove the mark if any marks\nof that type exist in the selection, or add it otherwise. If the\nselection is empty, this applies to the [stored\nmarks](https://prosemirror.net/docs/ref/#state.EditorState.storedMarks) instead of a range of the\ndocument.\n*/\nfunction toggleMark(markType, attrs = null, options) {\n    let removeWhenPresent = (options && options.removeWhenPresent) !== false;\n    let enterAtoms = (options && options.enterInlineAtoms) !== false;\n    return function (state, dispatch) {\n        let { empty, $cursor, ranges } = state.selection;\n        if ((empty && !$cursor) || !markApplies(state.doc, ranges, markType, enterAtoms))\n            return false;\n        if (dispatch) {\n            if ($cursor) {\n                if (markType.isInSet(state.storedMarks || $cursor.marks()))\n                    dispatch(state.tr.removeStoredMark(markType));\n                else\n                    dispatch(state.tr.addStoredMark(markType.create(attrs)));\n            }\n            else {\n                let add, tr = state.tr;\n                if (!enterAtoms)\n                    ranges = removeInlineAtoms(ranges);\n                if (removeWhenPresent) {\n                    add = !ranges.some(r => state.doc.rangeHasMark(r.$from.pos, r.$to.pos, markType));\n                }\n                else {\n                    add = !ranges.every(r => {\n                        let missing = false;\n                        tr.doc.nodesBetween(r.$from.pos, r.$to.pos, (node, pos, parent) => {\n                            if (missing)\n                                return false;\n                            missing = !markType.isInSet(node.marks) && !!parent && parent.type.allowsMarkType(markType) &&\n                                !(node.isText && /^\\s*$/.test(node.textBetween(Math.max(0, r.$from.pos - pos), Math.min(node.nodeSize, r.$to.pos - pos))));\n                        });\n                        return !missing;\n                    });\n                }\n                for (let i = 0; i < ranges.length; i++) {\n                    let { $from, $to } = ranges[i];\n                    if (!add) {\n                        tr.removeMark($from.pos, $to.pos, markType);\n                    }\n                    else {\n                        let from = $from.pos, to = $to.pos, start = $from.nodeAfter, end = $to.nodeBefore;\n                        let spaceStart = start && start.isText ? /^\\s*/.exec(start.text)[0].length : 0;\n                        let spaceEnd = end && end.isText ? /\\s*$/.exec(end.text)[0].length : 0;\n                        if (from + spaceStart < to) {\n                            from += spaceStart;\n                            to -= spaceEnd;\n                        }\n                        tr.addMark(from, to, markType.create(attrs));\n                    }\n                }\n                dispatch(tr.scrollIntoView());\n            }\n        }\n        return true;\n    };\n}\nfunction wrapDispatchForJoin(dispatch, isJoinable) {\n    return (tr) => {\n        if (!tr.isGeneric)\n            return dispatch(tr);\n        let ranges = [];\n        for (let i = 0; i < tr.mapping.maps.length; i++) {\n            let map = tr.mapping.maps[i];\n            for (let j = 0; j < ranges.length; j++)\n                ranges[j] = map.map(ranges[j]);\n            map.forEach((_s, _e, from, to) => ranges.push(from, to));\n        }\n        // Figure out which joinable points exist inside those ranges,\n        // by checking all node boundaries in their parent nodes.\n        let joinable = [];\n        for (let i = 0; i < ranges.length; i += 2) {\n            let from = ranges[i], to = ranges[i + 1];\n            let $from = tr.doc.resolve(from), depth = $from.sharedDepth(to), parent = $from.node(depth);\n            for (let index = $from.indexAfter(depth), pos = $from.after(depth + 1); pos <= to; ++index) {\n                let after = parent.maybeChild(index);\n                if (!after)\n                    break;\n                if (index && joinable.indexOf(pos) == -1) {\n                    let before = parent.child(index - 1);\n                    if (before.type == after.type && isJoinable(before, after))\n                        joinable.push(pos);\n                }\n                pos += after.nodeSize;\n            }\n        }\n        // Join the joinable points\n        joinable.sort((a, b) => a - b);\n        for (let i = joinable.length - 1; i >= 0; i--) {\n            if (canJoin(tr.doc, joinable[i]))\n                tr.join(joinable[i]);\n        }\n        dispatch(tr);\n    };\n}\n/**\nWrap a command so that, when it produces a transform that causes\ntwo joinable nodes to end up next to each other, those are joined.\nNodes are considered joinable when they are of the same type and\nwhen the `isJoinable` predicate returns true for them or, if an\narray of strings was passed, if their node type name is in that\narray.\n*/\nfunction autoJoin(command, isJoinable) {\n    let canJoin = Array.isArray(isJoinable) ? (node) => isJoinable.indexOf(node.type.name) > -1\n        : isJoinable;\n    return (state, dispatch, view) => command(state, dispatch && wrapDispatchForJoin(dispatch, canJoin), view);\n}\n/**\nCombine a number of command functions into a single function (which\ncalls them one by one until one returns true).\n*/\nfunction chainCommands(...commands) {\n    return function (state, dispatch, view) {\n        for (let i = 0; i < commands.length; i++)\n            if (commands[i](state, dispatch, view))\n                return true;\n        return false;\n    };\n}\nlet backspace = chainCommands(deleteSelection, joinBackward, selectNodeBackward);\nlet del = chainCommands(deleteSelection, joinForward, selectNodeForward);\n/**\nA basic keymap containing bindings not specific to any schema.\nBinds the following keys (when multiple commands are listed, they\nare chained with [`chainCommands`](https://prosemirror.net/docs/ref/#commands.chainCommands)):\n\n* **Enter** to `newlineInCode`, `createParagraphNear`, `liftEmptyBlock`, `splitBlock`\n* **Mod-Enter** to `exitCode`\n* **Backspace** and **Mod-Backspace** to `deleteSelection`, `joinBackward`, `selectNodeBackward`\n* **Delete** and **Mod-Delete** to `deleteSelection`, `joinForward`, `selectNodeForward`\n* **Mod-Delete** to `deleteSelection`, `joinForward`, `selectNodeForward`\n* **Mod-a** to `selectAll`\n*/\nconst pcBaseKeymap = {\n    \"Enter\": chainCommands(newlineInCode, createParagraphNear, liftEmptyBlock, splitBlock),\n    \"Mod-Enter\": exitCode,\n    \"Backspace\": backspace,\n    \"Mod-Backspace\": backspace,\n    \"Shift-Backspace\": backspace,\n    \"Delete\": del,\n    \"Mod-Delete\": del,\n    \"Mod-a\": selectAll\n};\n/**\nA copy of `pcBaseKeymap` that also binds **Ctrl-h** like Backspace,\n**Ctrl-d** like Delete, **Alt-Backspace** like Ctrl-Backspace, and\n**Ctrl-Alt-Backspace**, **Alt-Delete**, and **Alt-d** like\nCtrl-Delete.\n*/\nconst macBaseKeymap = {\n    \"Ctrl-h\": pcBaseKeymap[\"Backspace\"],\n    \"Alt-Backspace\": pcBaseKeymap[\"Mod-Backspace\"],\n    \"Ctrl-d\": pcBaseKeymap[\"Delete\"],\n    \"Ctrl-Alt-Backspace\": pcBaseKeymap[\"Mod-Delete\"],\n    \"Alt-Delete\": pcBaseKeymap[\"Mod-Delete\"],\n    \"Alt-d\": pcBaseKeymap[\"Mod-Delete\"],\n    \"Ctrl-a\": selectTextblockStart,\n    \"Ctrl-e\": selectTextblockEnd\n};\nfor (let key in pcBaseKeymap)\n    macBaseKeymap[key] = pcBaseKeymap[key];\nconst mac = typeof navigator != \"undefined\" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform)\n    // @ts-ignore\n    : typeof os != \"undefined\" && os.platform ? os.platform() == \"darwin\" : false;\n/**\nDepending on the detected platform, this will hold\n[`pcBasekeymap`](https://prosemirror.net/docs/ref/#commands.pcBaseKeymap) or\n[`macBaseKeymap`](https://prosemirror.net/docs/ref/#commands.macBaseKeymap).\n*/\nconst baseKeymap = mac ? macBaseKeymap : pcBaseKeymap;\n\nexport { autoJoin, baseKeymap, chainCommands, createParagraphNear, deleteSelection, exitCode, joinBackward, joinDown, joinForward, joinTextblockBackward, joinTextblockForward, joinUp, lift, liftEmptyBlock, macBaseKeymap, newlineInCode, pcBaseKeymap, selectAll, selectNodeBackward, selectNodeForward, selectParentNode, selectTextblockEnd, selectTextblockStart, setBlockType, splitBlock, splitBlockAs, splitBlockKeepMarks, toggleMark, wrapIn };\n","export var base = {\n  8: \"Backspace\",\n  9: \"Tab\",\n  10: \"Enter\",\n  12: \"NumLock\",\n  13: \"Enter\",\n  16: \"Shift\",\n  17: \"Control\",\n  18: \"Alt\",\n  20: \"CapsLock\",\n  27: \"Escape\",\n  32: \" \",\n  33: \"PageUp\",\n  34: \"PageDown\",\n  35: \"End\",\n  36: \"Home\",\n  37: \"ArrowLeft\",\n  38: \"ArrowUp\",\n  39: \"ArrowRight\",\n  40: \"ArrowDown\",\n  44: \"PrintScreen\",\n  45: \"Insert\",\n  46: \"Delete\",\n  59: \";\",\n  61: \"=\",\n  91: \"Meta\",\n  92: \"Meta\",\n  106: \"*\",\n  107: \"+\",\n  108: \",\",\n  109: \"-\",\n  110: \".\",\n  111: \"/\",\n  144: \"NumLock\",\n  145: \"ScrollLock\",\n  160: \"Shift\",\n  161: \"Shift\",\n  162: \"Control\",\n  163: \"Control\",\n  164: \"Alt\",\n  165: \"Alt\",\n  173: \"-\",\n  186: \";\",\n  187: \"=\",\n  188: \",\",\n  189: \"-\",\n  190: \".\",\n  191: \"/\",\n  192: \"`\",\n  219: \"[\",\n  220: \"\\\\\",\n  221: \"]\",\n  222: \"'\"\n}\n\nexport var shift = {\n  48: \")\",\n  49: \"!\",\n  50: \"@\",\n  51: \"#\",\n  52: \"$\",\n  53: \"%\",\n  54: \"^\",\n  55: \"&\",\n  56: \"*\",\n  57: \"(\",\n  59: \":\",\n  61: \"+\",\n  173: \"_\",\n  186: \":\",\n  187: \"+\",\n  188: \"<\",\n  189: \"_\",\n  190: \">\",\n  191: \"?\",\n  192: \"~\",\n  219: \"{\",\n  220: \"|\",\n  221: \"}\",\n  222: \"\\\"\"\n}\n\nvar mac = typeof navigator != \"undefined\" && /Mac/.test(navigator.platform)\nvar ie = typeof navigator != \"undefined\" && /MSIE \\d|Trident\\/(?:[7-9]|\\d{2,})\\..*rv:(\\d+)/.exec(navigator.userAgent)\n\n// Fill in the digit keys\nfor (var i = 0; i < 10; i++) base[48 + i] = base[96 + i] = String(i)\n\n// The function keys\nfor (var i = 1; i <= 24; i++) base[i + 111] = \"F\" + i\n\n// And the alphabetic keys\nfor (var i = 65; i <= 90; i++) {\n  base[i] = String.fromCharCode(i + 32)\n  shift[i] = String.fromCharCode(i)\n}\n\n// For each code that doesn't have a shift-equivalent, copy the base name\nfor (var code in base) if (!shift.hasOwnProperty(code)) shift[code] = base[code]\n\nexport function keyName(event) {\n  // On macOS, keys held with Shift and Cmd don't reflect the effect of Shift in `.key`.\n  // On IE, shift effect is never included in `.key`.\n  var ignoreKey = mac && event.metaKey && event.shiftKey && !event.ctrlKey && !event.altKey ||\n      ie && event.shiftKey && event.key && event.key.length == 1 ||\n      event.key == \"Unidentified\"\n  var name = (!ignoreKey && event.key) ||\n    (event.shiftKey ? shift : base)[event.keyCode] ||\n    event.key || \"Unidentified\"\n  // Edge sometimes produces wrong names (Issue #3)\n  if (name == \"Esc\") name = \"Escape\"\n  if (name == \"Del\") name = \"Delete\"\n  // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/8860571/\n  if (name == \"Left\") name = \"ArrowLeft\"\n  if (name == \"Up\") name = \"ArrowUp\"\n  if (name == \"Right\") name = \"ArrowRight\"\n  if (name == \"Down\") name = \"ArrowDown\"\n  return name\n}\n","function _typeof(o) {\n  \"@babel/helpers - typeof\";\n\n  return (module.exports = _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) {\n    return typeof o;\n  } : function (o) {\n    return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n  }, module.exports.__esModule = true, module.exports[\"default\"] = module.exports), _typeof(o);\n}\nmodule.exports = _typeof, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","export default function getUAString() {\n  var uaData = navigator.userAgentData;\n\n  if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {\n    return uaData.brands.map(function (item) {\n      return item.brand + \"/\" + item.version;\n    }).join(' ');\n  }\n\n  return navigator.userAgent;\n}","/**!\n* tippy.js v6.3.7\n* (c) 2017-2021 atomiks\n* MIT License\n*/\nimport { createPopper, applyStyles } from '@popperjs/core';\n\nvar ROUND_ARROW = '<svg width=\"16\" height=\"6\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M0 6s1.796-.013 4.67-3.615C5.851.9 6.93.006 8 0c1.07-.006 2.148.887 3.343 2.385C14.233 6.005 16 6 16 6H0z\"></svg>';\nvar BOX_CLASS = \"tippy-box\";\nvar CONTENT_CLASS = \"tippy-content\";\nvar BACKDROP_CLASS = \"tippy-backdrop\";\nvar ARROW_CLASS = \"tippy-arrow\";\nvar SVG_ARROW_CLASS = \"tippy-svg-arrow\";\nvar TOUCH_OPTIONS = {\n  passive: true,\n  capture: true\n};\nvar TIPPY_DEFAULT_APPEND_TO = function TIPPY_DEFAULT_APPEND_TO() {\n  return document.body;\n};\n\nfunction hasOwnProperty(obj, key) {\n  return {}.hasOwnProperty.call(obj, key);\n}\nfunction getValueAtIndexOrReturn(value, index, defaultValue) {\n  if (Array.isArray(value)) {\n    var v = value[index];\n    return v == null ? Array.isArray(defaultValue) ? defaultValue[index] : defaultValue : v;\n  }\n\n  return value;\n}\nfunction isType(value, type) {\n  var str = {}.toString.call(value);\n  return str.indexOf('[object') === 0 && str.indexOf(type + \"]\") > -1;\n}\nfunction invokeWithArgsOrReturn(value, args) {\n  return typeof value === 'function' ? value.apply(void 0, args) : value;\n}\nfunction debounce(fn, ms) {\n  // Avoid wrapping in `setTimeout` if ms is 0 anyway\n  if (ms === 0) {\n    return fn;\n  }\n\n  var timeout;\n  return function (arg) {\n    clearTimeout(timeout);\n    timeout = setTimeout(function () {\n      fn(arg);\n    }, ms);\n  };\n}\nfunction removeProperties(obj, keys) {\n  var clone = Object.assign({}, obj);\n  keys.forEach(function (key) {\n    delete clone[key];\n  });\n  return clone;\n}\nfunction splitBySpaces(value) {\n  return value.split(/\\s+/).filter(Boolean);\n}\nfunction normalizeToArray(value) {\n  return [].concat(value);\n}\nfunction pushIfUnique(arr, value) {\n  if (arr.indexOf(value) === -1) {\n    arr.push(value);\n  }\n}\nfunction unique(arr) {\n  return arr.filter(function (item, index) {\n    return arr.indexOf(item) === index;\n  });\n}\nfunction getBasePlacement(placement) {\n  return placement.split('-')[0];\n}\nfunction arrayFrom(value) {\n  return [].slice.call(value);\n}\nfunction removeUndefinedProps(obj) {\n  return Object.keys(obj).reduce(function (acc, key) {\n    if (obj[key] !== undefined) {\n      acc[key] = obj[key];\n    }\n\n    return acc;\n  }, {});\n}\n\nfunction div() {\n  return document.createElement('div');\n}\nfunction isElement(value) {\n  return ['Element', 'Fragment'].some(function (type) {\n    return isType(value, type);\n  });\n}\nfunction isNodeList(value) {\n  return isType(value, 'NodeList');\n}\nfunction isMouseEvent(value) {\n  return isType(value, 'MouseEvent');\n}\nfunction isReferenceElement(value) {\n  return !!(value && value._tippy && value._tippy.reference === value);\n}\nfunction getArrayOfElements(value) {\n  if (isElement(value)) {\n    return [value];\n  }\n\n  if (isNodeList(value)) {\n    return arrayFrom(value);\n  }\n\n  if (Array.isArray(value)) {\n    return value;\n  }\n\n  return arrayFrom(document.querySelectorAll(value));\n}\nfunction setTransitionDuration(els, value) {\n  els.forEach(function (el) {\n    if (el) {\n      el.style.transitionDuration = value + \"ms\";\n    }\n  });\n}\nfunction setVisibilityState(els, state) {\n  els.forEach(function (el) {\n    if (el) {\n      el.setAttribute('data-state', state);\n    }\n  });\n}\nfunction getOwnerDocument(elementOrElements) {\n  var _element$ownerDocumen;\n\n  var _normalizeToArray = normalizeToArray(elementOrElements),\n      element = _normalizeToArray[0]; // Elements created via a <template> have an ownerDocument with no reference to the body\n\n\n  return element != null && (_element$ownerDocumen = element.ownerDocument) != null && _element$ownerDocumen.body ? element.ownerDocument : document;\n}\nfunction isCursorOutsideInteractiveBorder(popperTreeData, event) {\n  var clientX = event.clientX,\n      clientY = event.clientY;\n  return popperTreeData.every(function (_ref) {\n    var popperRect = _ref.popperRect,\n        popperState = _ref.popperState,\n        props = _ref.props;\n    var interactiveBorder = props.interactiveBorder;\n    var basePlacement = getBasePlacement(popperState.placement);\n    var offsetData = popperState.modifiersData.offset;\n\n    if (!offsetData) {\n      return true;\n    }\n\n    var topDistance = basePlacement === 'bottom' ? offsetData.top.y : 0;\n    var bottomDistance = basePlacement === 'top' ? offsetData.bottom.y : 0;\n    var leftDistance = basePlacement === 'right' ? offsetData.left.x : 0;\n    var rightDistance = basePlacement === 'left' ? offsetData.right.x : 0;\n    var exceedsTop = popperRect.top - clientY + topDistance > interactiveBorder;\n    var exceedsBottom = clientY - popperRect.bottom - bottomDistance > interactiveBorder;\n    var exceedsLeft = popperRect.left - clientX + leftDistance > interactiveBorder;\n    var exceedsRight = clientX - popperRect.right - rightDistance > interactiveBorder;\n    return exceedsTop || exceedsBottom || exceedsLeft || exceedsRight;\n  });\n}\nfunction updateTransitionEndListener(box, action, listener) {\n  var method = action + \"EventListener\"; // some browsers apparently support `transition` (unprefixed) but only fire\n  // `webkitTransitionEnd`...\n\n  ['transitionend', 'webkitTransitionEnd'].forEach(function (event) {\n    box[method](event, listener);\n  });\n}\n/**\n * Compared to xxx.contains, this function works for dom structures with shadow\n * dom\n */\n\nfunction actualContains(parent, child) {\n  var target = child;\n\n  while (target) {\n    var _target$getRootNode;\n\n    if (parent.contains(target)) {\n      return true;\n    }\n\n    target = target.getRootNode == null ? void 0 : (_target$getRootNode = target.getRootNode()) == null ? void 0 : _target$getRootNode.host;\n  }\n\n  return false;\n}\n\nvar currentInput = {\n  isTouch: false\n};\nvar lastMouseMoveTime = 0;\n/**\n * When a `touchstart` event is fired, it's assumed the user is using touch\n * input. We'll bind a `mousemove` event listener to listen for mouse input in\n * the future. This way, the `isTouch` property is fully dynamic and will handle\n * hybrid devices that use a mix of touch + mouse input.\n */\n\nfunction onDocumentTouchStart() {\n  if (currentInput.isTouch) {\n    return;\n  }\n\n  currentInput.isTouch = true;\n\n  if (window.performance) {\n    document.addEventListener('mousemove', onDocumentMouseMove);\n  }\n}\n/**\n * When two `mousemove` event are fired consecutively within 20ms, it's assumed\n * the user is using mouse input again. `mousemove` can fire on touch devices as\n * well, but very rarely that quickly.\n */\n\nfunction onDocumentMouseMove() {\n  var now = performance.now();\n\n  if (now - lastMouseMoveTime < 20) {\n    currentInput.isTouch = false;\n    document.removeEventListener('mousemove', onDocumentMouseMove);\n  }\n\n  lastMouseMoveTime = now;\n}\n/**\n * When an element is in focus and has a tippy, leaving the tab/window and\n * returning causes it to show again. For mouse users this is unexpected, but\n * for keyboard use it makes sense.\n * TODO: find a better technique to solve this problem\n */\n\nfunction onWindowBlur() {\n  var activeElement = document.activeElement;\n\n  if (isReferenceElement(activeElement)) {\n    var instance = activeElement._tippy;\n\n    if (activeElement.blur && !instance.state.isVisible) {\n      activeElement.blur();\n    }\n  }\n}\nfunction bindGlobalEventListeners() {\n  document.addEventListener('touchstart', onDocumentTouchStart, TOUCH_OPTIONS);\n  window.addEventListener('blur', onWindowBlur);\n}\n\nvar isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';\nvar isIE11 = isBrowser ? // @ts-ignore\n!!window.msCrypto : false;\n\nfunction createMemoryLeakWarning(method) {\n  var txt = method === 'destroy' ? 'n already-' : ' ';\n  return [method + \"() was called on a\" + txt + \"destroyed instance. This is a no-op but\", 'indicates a potential memory leak.'].join(' ');\n}\nfunction clean(value) {\n  var spacesAndTabs = /[ \\t]{2,}/g;\n  var lineStartWithSpaces = /^[ \\t]*/gm;\n  return value.replace(spacesAndTabs, ' ').replace(lineStartWithSpaces, '').trim();\n}\n\nfunction getDevMessage(message) {\n  return clean(\"\\n  %ctippy.js\\n\\n  %c\" + clean(message) + \"\\n\\n  %c\\uD83D\\uDC77\\u200D This is a development-only message. It will be removed in production.\\n  \");\n}\n\nfunction getFormattedMessage(message) {\n  return [getDevMessage(message), // title\n  'color: #00C584; font-size: 1.3em; font-weight: bold;', // message\n  'line-height: 1.5', // footer\n  'color: #a6a095;'];\n} // Assume warnings and errors never have the same message\n\nvar visitedMessages;\n\nif (process.env.NODE_ENV !== \"production\") {\n  resetVisitedMessages();\n}\n\nfunction resetVisitedMessages() {\n  visitedMessages = new Set();\n}\nfunction warnWhen(condition, message) {\n  if (condition && !visitedMessages.has(message)) {\n    var _console;\n\n    visitedMessages.add(message);\n\n    (_console = console).warn.apply(_console, getFormattedMessage(message));\n  }\n}\nfunction errorWhen(condition, message) {\n  if (condition && !visitedMessages.has(message)) {\n    var _console2;\n\n    visitedMessages.add(message);\n\n    (_console2 = console).error.apply(_console2, getFormattedMessage(message));\n  }\n}\nfunction validateTargets(targets) {\n  var didPassFalsyValue = !targets;\n  var didPassPlainObject = Object.prototype.toString.call(targets) === '[object Object]' && !targets.addEventListener;\n  errorWhen(didPassFalsyValue, ['tippy() was passed', '`' + String(targets) + '`', 'as its targets (first) argument. Valid types are: String, Element,', 'Element[], or NodeList.'].join(' '));\n  errorWhen(didPassPlainObject, ['tippy() was passed a plain object which is not supported as an argument', 'for virtual positioning. Use props.getReferenceClientRect instead.'].join(' '));\n}\n\nvar pluginProps = {\n  animateFill: false,\n  followCursor: false,\n  inlinePositioning: false,\n  sticky: false\n};\nvar renderProps = {\n  allowHTML: false,\n  animation: 'fade',\n  arrow: true,\n  content: '',\n  inertia: false,\n  maxWidth: 350,\n  role: 'tooltip',\n  theme: '',\n  zIndex: 9999\n};\nvar defaultProps = Object.assign({\n  appendTo: TIPPY_DEFAULT_APPEND_TO,\n  aria: {\n    content: 'auto',\n    expanded: 'auto'\n  },\n  delay: 0,\n  duration: [300, 250],\n  getReferenceClientRect: null,\n  hideOnClick: true,\n  ignoreAttributes: false,\n  interactive: false,\n  interactiveBorder: 2,\n  interactiveDebounce: 0,\n  moveTransition: '',\n  offset: [0, 10],\n  onAfterUpdate: function onAfterUpdate() {},\n  onBeforeUpdate: function onBeforeUpdate() {},\n  onCreate: function onCreate() {},\n  onDestroy: function onDestroy() {},\n  onHidden: function onHidden() {},\n  onHide: function onHide() {},\n  onMount: function onMount() {},\n  onShow: function onShow() {},\n  onShown: function onShown() {},\n  onTrigger: function onTrigger() {},\n  onUntrigger: function onUntrigger() {},\n  onClickOutside: function onClickOutside() {},\n  placement: 'top',\n  plugins: [],\n  popperOptions: {},\n  render: null,\n  showOnCreate: false,\n  touch: true,\n  trigger: 'mouseenter focus',\n  triggerTarget: null\n}, pluginProps, renderProps);\nvar defaultKeys = Object.keys(defaultProps);\nvar setDefaultProps = function setDefaultProps(partialProps) {\n  /* istanbul ignore else */\n  if (process.env.NODE_ENV !== \"production\") {\n    validateProps(partialProps, []);\n  }\n\n  var keys = Object.keys(partialProps);\n  keys.forEach(function (key) {\n    defaultProps[key] = partialProps[key];\n  });\n};\nfunction getExtendedPassedProps(passedProps) {\n  var plugins = passedProps.plugins || [];\n  var pluginProps = plugins.reduce(function (acc, plugin) {\n    var name = plugin.name,\n        defaultValue = plugin.defaultValue;\n\n    if (name) {\n      var _name;\n\n      acc[name] = passedProps[name] !== undefined ? passedProps[name] : (_name = defaultProps[name]) != null ? _name : defaultValue;\n    }\n\n    return acc;\n  }, {});\n  return Object.assign({}, passedProps, pluginProps);\n}\nfunction getDataAttributeProps(reference, plugins) {\n  var propKeys = plugins ? Object.keys(getExtendedPassedProps(Object.assign({}, defaultProps, {\n    plugins: plugins\n  }))) : defaultKeys;\n  var props = propKeys.reduce(function (acc, key) {\n    var valueAsString = (reference.getAttribute(\"data-tippy-\" + key) || '').trim();\n\n    if (!valueAsString) {\n      return acc;\n    }\n\n    if (key === 'content') {\n      acc[key] = valueAsString;\n    } else {\n      try {\n        acc[key] = JSON.parse(valueAsString);\n      } catch (e) {\n        acc[key] = valueAsString;\n      }\n    }\n\n    return acc;\n  }, {});\n  return props;\n}\nfunction evaluateProps(reference, props) {\n  var out = Object.assign({}, props, {\n    content: invokeWithArgsOrReturn(props.content, [reference])\n  }, props.ignoreAttributes ? {} : getDataAttributeProps(reference, props.plugins));\n  out.aria = Object.assign({}, defaultProps.aria, out.aria);\n  out.aria = {\n    expanded: out.aria.expanded === 'auto' ? props.interactive : out.aria.expanded,\n    content: out.aria.content === 'auto' ? props.interactive ? null : 'describedby' : out.aria.content\n  };\n  return out;\n}\nfunction validateProps(partialProps, plugins) {\n  if (partialProps === void 0) {\n    partialProps = {};\n  }\n\n  if (plugins === void 0) {\n    plugins = [];\n  }\n\n  var keys = Object.keys(partialProps);\n  keys.forEach(function (prop) {\n    var nonPluginProps = removeProperties(defaultProps, Object.keys(pluginProps));\n    var didPassUnknownProp = !hasOwnProperty(nonPluginProps, prop); // Check if the prop exists in `plugins`\n\n    if (didPassUnknownProp) {\n      didPassUnknownProp = plugins.filter(function (plugin) {\n        return plugin.name === prop;\n      }).length === 0;\n    }\n\n    warnWhen(didPassUnknownProp, [\"`\" + prop + \"`\", \"is not a valid prop. You may have spelled it incorrectly, or if it's\", 'a plugin, forgot to pass it in an array as props.plugins.', '\\n\\n', 'All props: https://atomiks.github.io/tippyjs/v6/all-props/\\n', 'Plugins: https://atomiks.github.io/tippyjs/v6/plugins/'].join(' '));\n  });\n}\n\nvar innerHTML = function innerHTML() {\n  return 'innerHTML';\n};\n\nfunction dangerouslySetInnerHTML(element, html) {\n  element[innerHTML()] = html;\n}\n\nfunction createArrowElement(value) {\n  var arrow = div();\n\n  if (value === true) {\n    arrow.className = ARROW_CLASS;\n  } else {\n    arrow.className = SVG_ARROW_CLASS;\n\n    if (isElement(value)) {\n      arrow.appendChild(value);\n    } else {\n      dangerouslySetInnerHTML(arrow, value);\n    }\n  }\n\n  return arrow;\n}\n\nfunction setContent(content, props) {\n  if (isElement(props.content)) {\n    dangerouslySetInnerHTML(content, '');\n    content.appendChild(props.content);\n  } else if (typeof props.content !== 'function') {\n    if (props.allowHTML) {\n      dangerouslySetInnerHTML(content, props.content);\n    } else {\n      content.textContent = props.content;\n    }\n  }\n}\nfunction getChildren(popper) {\n  var box = popper.firstElementChild;\n  var boxChildren = arrayFrom(box.children);\n  return {\n    box: box,\n    content: boxChildren.find(function (node) {\n      return node.classList.contains(CONTENT_CLASS);\n    }),\n    arrow: boxChildren.find(function (node) {\n      return node.classList.contains(ARROW_CLASS) || node.classList.contains(SVG_ARROW_CLASS);\n    }),\n    backdrop: boxChildren.find(function (node) {\n      return node.classList.contains(BACKDROP_CLASS);\n    })\n  };\n}\nfunction render(instance) {\n  var popper = div();\n  var box = div();\n  box.className = BOX_CLASS;\n  box.setAttribute('data-state', 'hidden');\n  box.setAttribute('tabindex', '-1');\n  var content = div();\n  content.className = CONTENT_CLASS;\n  content.setAttribute('data-state', 'hidden');\n  setContent(content, instance.props);\n  popper.appendChild(box);\n  box.appendChild(content);\n  onUpdate(instance.props, instance.props);\n\n  function onUpdate(prevProps, nextProps) {\n    var _getChildren = getChildren(popper),\n        box = _getChildren.box,\n        content = _getChildren.content,\n        arrow = _getChildren.arrow;\n\n    if (nextProps.theme) {\n      box.setAttribute('data-theme', nextProps.theme);\n    } else {\n      box.removeAttribute('data-theme');\n    }\n\n    if (typeof nextProps.animation === 'string') {\n      box.setAttribute('data-animation', nextProps.animation);\n    } else {\n      box.removeAttribute('data-animation');\n    }\n\n    if (nextProps.inertia) {\n      box.setAttribute('data-inertia', '');\n    } else {\n      box.removeAttribute('data-inertia');\n    }\n\n    box.style.maxWidth = typeof nextProps.maxWidth === 'number' ? nextProps.maxWidth + \"px\" : nextProps.maxWidth;\n\n    if (nextProps.role) {\n      box.setAttribute('role', nextProps.role);\n    } else {\n      box.removeAttribute('role');\n    }\n\n    if (prevProps.content !== nextProps.content || prevProps.allowHTML !== nextProps.allowHTML) {\n      setContent(content, instance.props);\n    }\n\n    if (nextProps.arrow) {\n      if (!arrow) {\n        box.appendChild(createArrowElement(nextProps.arrow));\n      } else if (prevProps.arrow !== nextProps.arrow) {\n        box.removeChild(arrow);\n        box.appendChild(createArrowElement(nextProps.arrow));\n      }\n    } else if (arrow) {\n      box.removeChild(arrow);\n    }\n  }\n\n  return {\n    popper: popper,\n    onUpdate: onUpdate\n  };\n} // Runtime check to identify if the render function is the default one; this\n// way we can apply default CSS transitions logic and it can be tree-shaken away\n\nrender.$$tippy = true;\n\nvar idCounter = 1;\nvar mouseMoveListeners = []; // Used by `hideAll()`\n\nvar mountedInstances = [];\nfunction createTippy(reference, passedProps) {\n  var props = evaluateProps(reference, Object.assign({}, defaultProps, getExtendedPassedProps(removeUndefinedProps(passedProps)))); // ===========================================================================\n  //  Private members\n  // ===========================================================================\n\n  var showTimeout;\n  var hideTimeout;\n  var scheduleHideAnimationFrame;\n  var isVisibleFromClick = false;\n  var didHideDueToDocumentMouseDown = false;\n  var didTouchMove = false;\n  var ignoreOnFirstUpdate = false;\n  var lastTriggerEvent;\n  var currentTransitionEndListener;\n  var onFirstUpdate;\n  var listeners = [];\n  var debouncedOnMouseMove = debounce(onMouseMove, props.interactiveDebounce);\n  var currentTarget; // ===========================================================================\n  //  Public members\n  // ===========================================================================\n\n  var id = idCounter++;\n  var popperInstance = null;\n  var plugins = unique(props.plugins);\n  var state = {\n    // Is the instance currently enabled?\n    isEnabled: true,\n    // Is the tippy currently showing and not transitioning out?\n    isVisible: false,\n    // Has the instance been destroyed?\n    isDestroyed: false,\n    // Is the tippy currently mounted to the DOM?\n    isMounted: false,\n    // Has the tippy finished transitioning in?\n    isShown: false\n  };\n  var instance = {\n    // properties\n    id: id,\n    reference: reference,\n    popper: div(),\n    popperInstance: popperInstance,\n    props: props,\n    state: state,\n    plugins: plugins,\n    // methods\n    clearDelayTimeouts: clearDelayTimeouts,\n    setProps: setProps,\n    setContent: setContent,\n    show: show,\n    hide: hide,\n    hideWithInteractivity: hideWithInteractivity,\n    enable: enable,\n    disable: disable,\n    unmount: unmount,\n    destroy: destroy\n  }; // TODO: Investigate why this early return causes a TDZ error in the tests \n  // it doesn't seem to happen in the browser\n\n  /* istanbul ignore if */\n\n  if (!props.render) {\n    if (process.env.NODE_ENV !== \"production\") {\n      errorWhen(true, 'render() function has not been supplied.');\n    }\n\n    return instance;\n  } // ===========================================================================\n  // Initial mutations\n  // ===========================================================================\n\n\n  var _props$render = props.render(instance),\n      popper = _props$render.popper,\n      onUpdate = _props$render.onUpdate;\n\n  popper.setAttribute('data-tippy-root', '');\n  popper.id = \"tippy-\" + instance.id;\n  instance.popper = popper;\n  reference._tippy = instance;\n  popper._tippy = instance;\n  var pluginsHooks = plugins.map(function (plugin) {\n    return plugin.fn(instance);\n  });\n  var hasAriaExpanded = reference.hasAttribute('aria-expanded');\n  addListeners();\n  handleAriaExpandedAttribute();\n  handleStyles();\n  invokeHook('onCreate', [instance]);\n\n  if (props.showOnCreate) {\n    scheduleShow();\n  } // Prevent a tippy with a delay from hiding if the cursor left then returned\n  // before it started hiding\n\n\n  popper.addEventListener('mouseenter', function () {\n    if (instance.props.interactive && instance.state.isVisible) {\n      instance.clearDelayTimeouts();\n    }\n  });\n  popper.addEventListener('mouseleave', function () {\n    if (instance.props.interactive && instance.props.trigger.indexOf('mouseenter') >= 0) {\n      getDocument().addEventListener('mousemove', debouncedOnMouseMove);\n    }\n  });\n  return instance; // ===========================================================================\n  //  Private methods\n  // ===========================================================================\n\n  function getNormalizedTouchSettings() {\n    var touch = instance.props.touch;\n    return Array.isArray(touch) ? touch : [touch, 0];\n  }\n\n  function getIsCustomTouchBehavior() {\n    return getNormalizedTouchSettings()[0] === 'hold';\n  }\n\n  function getIsDefaultRenderFn() {\n    var _instance$props$rende;\n\n    // @ts-ignore\n    return !!((_instance$props$rende = instance.props.render) != null && _instance$props$rende.$$tippy);\n  }\n\n  function getCurrentTarget() {\n    return currentTarget || reference;\n  }\n\n  function getDocument() {\n    var parent = getCurrentTarget().parentNode;\n    return parent ? getOwnerDocument(parent) : document;\n  }\n\n  function getDefaultTemplateChildren() {\n    return getChildren(popper);\n  }\n\n  function getDelay(isShow) {\n    // For touch or keyboard input, force `0` delay for UX reasons\n    // Also if the instance is mounted but not visible (transitioning out),\n    // ignore delay\n    if (instance.state.isMounted && !instance.state.isVisible || currentInput.isTouch || lastTriggerEvent && lastTriggerEvent.type === 'focus') {\n      return 0;\n    }\n\n    return getValueAtIndexOrReturn(instance.props.delay, isShow ? 0 : 1, defaultProps.delay);\n  }\n\n  function handleStyles(fromHide) {\n    if (fromHide === void 0) {\n      fromHide = false;\n    }\n\n    popper.style.pointerEvents = instance.props.interactive && !fromHide ? '' : 'none';\n    popper.style.zIndex = \"\" + instance.props.zIndex;\n  }\n\n  function invokeHook(hook, args, shouldInvokePropsHook) {\n    if (shouldInvokePropsHook === void 0) {\n      shouldInvokePropsHook = true;\n    }\n\n    pluginsHooks.forEach(function (pluginHooks) {\n      if (pluginHooks[hook]) {\n        pluginHooks[hook].apply(pluginHooks, args);\n      }\n    });\n\n    if (shouldInvokePropsHook) {\n      var _instance$props;\n\n      (_instance$props = instance.props)[hook].apply(_instance$props, args);\n    }\n  }\n\n  function handleAriaContentAttribute() {\n    var aria = instance.props.aria;\n\n    if (!aria.content) {\n      return;\n    }\n\n    var attr = \"aria-\" + aria.content;\n    var id = popper.id;\n    var nodes = normalizeToArray(instance.props.triggerTarget || reference);\n    nodes.forEach(function (node) {\n      var currentValue = node.getAttribute(attr);\n\n      if (instance.state.isVisible) {\n        node.setAttribute(attr, currentValue ? currentValue + \" \" + id : id);\n      } else {\n        var nextValue = currentValue && currentValue.replace(id, '').trim();\n\n        if (nextValue) {\n          node.setAttribute(attr, nextValue);\n        } else {\n          node.removeAttribute(attr);\n        }\n      }\n    });\n  }\n\n  function handleAriaExpandedAttribute() {\n    if (hasAriaExpanded || !instance.props.aria.expanded) {\n      return;\n    }\n\n    var nodes = normalizeToArray(instance.props.triggerTarget || reference);\n    nodes.forEach(function (node) {\n      if (instance.props.interactive) {\n        node.setAttribute('aria-expanded', instance.state.isVisible && node === getCurrentTarget() ? 'true' : 'false');\n      } else {\n        node.removeAttribute('aria-expanded');\n      }\n    });\n  }\n\n  function cleanupInteractiveMouseListeners() {\n    getDocument().removeEventListener('mousemove', debouncedOnMouseMove);\n    mouseMoveListeners = mouseMoveListeners.filter(function (listener) {\n      return listener !== debouncedOnMouseMove;\n    });\n  }\n\n  function onDocumentPress(event) {\n    // Moved finger to scroll instead of an intentional tap outside\n    if (currentInput.isTouch) {\n      if (didTouchMove || event.type === 'mousedown') {\n        return;\n      }\n    }\n\n    var actualTarget = event.composedPath && event.composedPath()[0] || event.target; // Clicked on interactive popper\n\n    if (instance.props.interactive && actualContains(popper, actualTarget)) {\n      return;\n    } // Clicked on the event listeners target\n\n\n    if (normalizeToArray(instance.props.triggerTarget || reference).some(function (el) {\n      return actualContains(el, actualTarget);\n    })) {\n      if (currentInput.isTouch) {\n        return;\n      }\n\n      if (instance.state.isVisible && instance.props.trigger.indexOf('click') >= 0) {\n        return;\n      }\n    } else {\n      invokeHook('onClickOutside', [instance, event]);\n    }\n\n    if (instance.props.hideOnClick === true) {\n      instance.clearDelayTimeouts();\n      instance.hide(); // `mousedown` event is fired right before `focus` if pressing the\n      // currentTarget. This lets a tippy with `focus` trigger know that it\n      // should not show\n\n      didHideDueToDocumentMouseDown = true;\n      setTimeout(function () {\n        didHideDueToDocumentMouseDown = false;\n      }); // The listener gets added in `scheduleShow()`, but this may be hiding it\n      // before it shows, and hide()'s early bail-out behavior can prevent it\n      // from being cleaned up\n\n      if (!instance.state.isMounted) {\n        removeDocumentPress();\n      }\n    }\n  }\n\n  function onTouchMove() {\n    didTouchMove = true;\n  }\n\n  function onTouchStart() {\n    didTouchMove = false;\n  }\n\n  function addDocumentPress() {\n    var doc = getDocument();\n    doc.addEventListener('mousedown', onDocumentPress, true);\n    doc.addEventListener('touchend', onDocumentPress, TOUCH_OPTIONS);\n    doc.addEventListener('touchstart', onTouchStart, TOUCH_OPTIONS);\n    doc.addEventListener('touchmove', onTouchMove, TOUCH_OPTIONS);\n  }\n\n  function removeDocumentPress() {\n    var doc = getDocument();\n    doc.removeEventListener('mousedown', onDocumentPress, true);\n    doc.removeEventListener('touchend', onDocumentPress, TOUCH_OPTIONS);\n    doc.removeEventListener('touchstart', onTouchStart, TOUCH_OPTIONS);\n    doc.removeEventListener('touchmove', onTouchMove, TOUCH_OPTIONS);\n  }\n\n  function onTransitionedOut(duration, callback) {\n    onTransitionEnd(duration, function () {\n      if (!instance.state.isVisible && popper.parentNode && popper.parentNode.contains(popper)) {\n        callback();\n      }\n    });\n  }\n\n  function onTransitionedIn(duration, callback) {\n    onTransitionEnd(duration, callback);\n  }\n\n  function onTransitionEnd(duration, callback) {\n    var box = getDefaultTemplateChildren().box;\n\n    function listener(event) {\n      if (event.target === box) {\n        updateTransitionEndListener(box, 'remove', listener);\n        callback();\n      }\n    } // Make callback synchronous if duration is 0\n    // `transitionend` won't fire otherwise\n\n\n    if (duration === 0) {\n      return callback();\n    }\n\n    updateTransitionEndListener(box, 'remove', currentTransitionEndListener);\n    updateTransitionEndListener(box, 'add', listener);\n    currentTransitionEndListener = listener;\n  }\n\n  function on(eventType, handler, options) {\n    if (options === void 0) {\n      options = false;\n    }\n\n    var nodes = normalizeToArray(instance.props.triggerTarget || reference);\n    nodes.forEach(function (node) {\n      node.addEventListener(eventType, handler, options);\n      listeners.push({\n        node: node,\n        eventType: eventType,\n        handler: handler,\n        options: options\n      });\n    });\n  }\n\n  function addListeners() {\n    if (getIsCustomTouchBehavior()) {\n      on('touchstart', onTrigger, {\n        passive: true\n      });\n      on('touchend', onMouseLeave, {\n        passive: true\n      });\n    }\n\n    splitBySpaces(instance.props.trigger).forEach(function (eventType) {\n      if (eventType === 'manual') {\n        return;\n      }\n\n      on(eventType, onTrigger);\n\n      switch (eventType) {\n        case 'mouseenter':\n          on('mouseleave', onMouseLeave);\n          break;\n\n        case 'focus':\n          on(isIE11 ? 'focusout' : 'blur', onBlurOrFocusOut);\n          break;\n\n        case 'focusin':\n          on('focusout', onBlurOrFocusOut);\n          break;\n      }\n    });\n  }\n\n  function removeListeners() {\n    listeners.forEach(function (_ref) {\n      var node = _ref.node,\n          eventType = _ref.eventType,\n          handler = _ref.handler,\n          options = _ref.options;\n      node.removeEventListener(eventType, handler, options);\n    });\n    listeners = [];\n  }\n\n  function onTrigger(event) {\n    var _lastTriggerEvent;\n\n    var shouldScheduleClickHide = false;\n\n    if (!instance.state.isEnabled || isEventListenerStopped(event) || didHideDueToDocumentMouseDown) {\n      return;\n    }\n\n    var wasFocused = ((_lastTriggerEvent = lastTriggerEvent) == null ? void 0 : _lastTriggerEvent.type) === 'focus';\n    lastTriggerEvent = event;\n    currentTarget = event.currentTarget;\n    handleAriaExpandedAttribute();\n\n    if (!instance.state.isVisible && isMouseEvent(event)) {\n      // If scrolling, `mouseenter` events can be fired if the cursor lands\n      // over a new target, but `mousemove` events don't get fired. This\n      // causes interactive tooltips to get stuck open until the cursor is\n      // moved\n      mouseMoveListeners.forEach(function (listener) {\n        return listener(event);\n      });\n    } // Toggle show/hide when clicking click-triggered tooltips\n\n\n    if (event.type === 'click' && (instance.props.trigger.indexOf('mouseenter') < 0 || isVisibleFromClick) && instance.props.hideOnClick !== false && instance.state.isVisible) {\n      shouldScheduleClickHide = true;\n    } else {\n      scheduleShow(event);\n    }\n\n    if (event.type === 'click') {\n      isVisibleFromClick = !shouldScheduleClickHide;\n    }\n\n    if (shouldScheduleClickHide && !wasFocused) {\n      scheduleHide(event);\n    }\n  }\n\n  function onMouseMove(event) {\n    var target = event.target;\n    var isCursorOverReferenceOrPopper = getCurrentTarget().contains(target) || popper.contains(target);\n\n    if (event.type === 'mousemove' && isCursorOverReferenceOrPopper) {\n      return;\n    }\n\n    var popperTreeData = getNestedPopperTree().concat(popper).map(function (popper) {\n      var _instance$popperInsta;\n\n      var instance = popper._tippy;\n      var state = (_instance$popperInsta = instance.popperInstance) == null ? void 0 : _instance$popperInsta.state;\n\n      if (state) {\n        return {\n          popperRect: popper.getBoundingClientRect(),\n          popperState: state,\n          props: props\n        };\n      }\n\n      return null;\n    }).filter(Boolean);\n\n    if (isCursorOutsideInteractiveBorder(popperTreeData, event)) {\n      cleanupInteractiveMouseListeners();\n      scheduleHide(event);\n    }\n  }\n\n  function onMouseLeave(event) {\n    var shouldBail = isEventListenerStopped(event) || instance.props.trigger.indexOf('click') >= 0 && isVisibleFromClick;\n\n    if (shouldBail) {\n      return;\n    }\n\n    if (instance.props.interactive) {\n      instance.hideWithInteractivity(event);\n      return;\n    }\n\n    scheduleHide(event);\n  }\n\n  function onBlurOrFocusOut(event) {\n    if (instance.props.trigger.indexOf('focusin') < 0 && event.target !== getCurrentTarget()) {\n      return;\n    } // If focus was moved to within the popper\n\n\n    if (instance.props.interactive && event.relatedTarget && popper.contains(event.relatedTarget)) {\n      return;\n    }\n\n    scheduleHide(event);\n  }\n\n  function isEventListenerStopped(event) {\n    return currentInput.isTouch ? getIsCustomTouchBehavior() !== event.type.indexOf('touch') >= 0 : false;\n  }\n\n  function createPopperInstance() {\n    destroyPopperInstance();\n    var _instance$props2 = instance.props,\n        popperOptions = _instance$props2.popperOptions,\n        placement = _instance$props2.placement,\n        offset = _instance$props2.offset,\n        getReferenceClientRect = _instance$props2.getReferenceClientRect,\n        moveTransition = _instance$props2.moveTransition;\n    var arrow = getIsDefaultRenderFn() ? getChildren(popper).arrow : null;\n    var computedReference = getReferenceClientRect ? {\n      getBoundingClientRect: getReferenceClientRect,\n      contextElement: getReferenceClientRect.contextElement || getCurrentTarget()\n    } : reference;\n    var tippyModifier = {\n      name: '$$tippy',\n      enabled: true,\n      phase: 'beforeWrite',\n      requires: ['computeStyles'],\n      fn: function fn(_ref2) {\n        var state = _ref2.state;\n\n        if (getIsDefaultRenderFn()) {\n          var _getDefaultTemplateCh = getDefaultTemplateChildren(),\n              box = _getDefaultTemplateCh.box;\n\n          ['placement', 'reference-hidden', 'escaped'].forEach(function (attr) {\n            if (attr === 'placement') {\n              box.setAttribute('data-placement', state.placement);\n            } else {\n              if (state.attributes.popper[\"data-popper-\" + attr]) {\n                box.setAttribute(\"data-\" + attr, '');\n              } else {\n                box.removeAttribute(\"data-\" + attr);\n              }\n            }\n          });\n          state.attributes.popper = {};\n        }\n      }\n    };\n    var modifiers = [{\n      name: 'offset',\n      options: {\n        offset: offset\n      }\n    }, {\n      name: 'preventOverflow',\n      options: {\n        padding: {\n          top: 2,\n          bottom: 2,\n          left: 5,\n          right: 5\n        }\n      }\n    }, {\n      name: 'flip',\n      options: {\n        padding: 5\n      }\n    }, {\n      name: 'computeStyles',\n      options: {\n        adaptive: !moveTransition\n      }\n    }, tippyModifier];\n\n    if (getIsDefaultRenderFn() && arrow) {\n      modifiers.push({\n        name: 'arrow',\n        options: {\n          element: arrow,\n          padding: 3\n        }\n      });\n    }\n\n    modifiers.push.apply(modifiers, (popperOptions == null ? void 0 : popperOptions.modifiers) || []);\n    instance.popperInstance = createPopper(computedReference, popper, Object.assign({}, popperOptions, {\n      placement: placement,\n      onFirstUpdate: onFirstUpdate,\n      modifiers: modifiers\n    }));\n  }\n\n  function destroyPopperInstance() {\n    if (instance.popperInstance) {\n      instance.popperInstance.destroy();\n      instance.popperInstance = null;\n    }\n  }\n\n  function mount() {\n    var appendTo = instance.props.appendTo;\n    var parentNode; // By default, we'll append the popper to the triggerTargets's parentNode so\n    // it's directly after the reference element so the elements inside the\n    // tippy can be tabbed to\n    // If there are clipping issues, the user can specify a different appendTo\n    // and ensure focus management is handled correctly manually\n\n    var node = getCurrentTarget();\n\n    if (instance.props.interactive && appendTo === TIPPY_DEFAULT_APPEND_TO || appendTo === 'parent') {\n      parentNode = node.parentNode;\n    } else {\n      parentNode = invokeWithArgsOrReturn(appendTo, [node]);\n    } // The popper element needs to exist on the DOM before its position can be\n    // updated as Popper needs to read its dimensions\n\n\n    if (!parentNode.contains(popper)) {\n      parentNode.appendChild(popper);\n    }\n\n    instance.state.isMounted = true;\n    createPopperInstance();\n    /* istanbul ignore else */\n\n    if (process.env.NODE_ENV !== \"production\") {\n      // Accessibility check\n      warnWhen(instance.props.interactive && appendTo === defaultProps.appendTo && node.nextElementSibling !== popper, ['Interactive tippy element may not be accessible via keyboard', 'navigation because it is not directly after the reference element', 'in the DOM source order.', '\\n\\n', 'Using a wrapper <div> or <span> tag around the reference element', 'solves this by creating a new parentNode context.', '\\n\\n', 'Specifying `appendTo: document.body` silences this warning, but it', 'assumes you are using a focus management solution to handle', 'keyboard navigation.', '\\n\\n', 'See: https://atomiks.github.io/tippyjs/v6/accessibility/#interactivity'].join(' '));\n    }\n  }\n\n  function getNestedPopperTree() {\n    return arrayFrom(popper.querySelectorAll('[data-tippy-root]'));\n  }\n\n  function scheduleShow(event) {\n    instance.clearDelayTimeouts();\n\n    if (event) {\n      invokeHook('onTrigger', [instance, event]);\n    }\n\n    addDocumentPress();\n    var delay = getDelay(true);\n\n    var _getNormalizedTouchSe = getNormalizedTouchSettings(),\n        touchValue = _getNormalizedTouchSe[0],\n        touchDelay = _getNormalizedTouchSe[1];\n\n    if (currentInput.isTouch && touchValue === 'hold' && touchDelay) {\n      delay = touchDelay;\n    }\n\n    if (delay) {\n      showTimeout = setTimeout(function () {\n        instance.show();\n      }, delay);\n    } else {\n      instance.show();\n    }\n  }\n\n  function scheduleHide(event) {\n    instance.clearDelayTimeouts();\n    invokeHook('onUntrigger', [instance, event]);\n\n    if (!instance.state.isVisible) {\n      removeDocumentPress();\n      return;\n    } // For interactive tippies, scheduleHide is added to a document.body handler\n    // from onMouseLeave so must intercept scheduled hides from mousemove/leave\n    // events when trigger contains mouseenter and click, and the tip is\n    // currently shown as a result of a click.\n\n\n    if (instance.props.trigger.indexOf('mouseenter') >= 0 && instance.props.trigger.indexOf('click') >= 0 && ['mouseleave', 'mousemove'].indexOf(event.type) >= 0 && isVisibleFromClick) {\n      return;\n    }\n\n    var delay = getDelay(false);\n\n    if (delay) {\n      hideTimeout = setTimeout(function () {\n        if (instance.state.isVisible) {\n          instance.hide();\n        }\n      }, delay);\n    } else {\n      // Fixes a `transitionend` problem when it fires 1 frame too\n      // late sometimes, we don't want hide() to be called.\n      scheduleHideAnimationFrame = requestAnimationFrame(function () {\n        instance.hide();\n      });\n    }\n  } // ===========================================================================\n  //  Public methods\n  // ===========================================================================\n\n\n  function enable() {\n    instance.state.isEnabled = true;\n  }\n\n  function disable() {\n    // Disabling the instance should also hide it\n    // https://github.com/atomiks/tippy.js-react/issues/106\n    instance.hide();\n    instance.state.isEnabled = false;\n  }\n\n  function clearDelayTimeouts() {\n    clearTimeout(showTimeout);\n    clearTimeout(hideTimeout);\n    cancelAnimationFrame(scheduleHideAnimationFrame);\n  }\n\n  function setProps(partialProps) {\n    /* istanbul ignore else */\n    if (process.env.NODE_ENV !== \"production\") {\n      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('setProps'));\n    }\n\n    if (instance.state.isDestroyed) {\n      return;\n    }\n\n    invokeHook('onBeforeUpdate', [instance, partialProps]);\n    removeListeners();\n    var prevProps = instance.props;\n    var nextProps = evaluateProps(reference, Object.assign({}, prevProps, removeUndefinedProps(partialProps), {\n      ignoreAttributes: true\n    }));\n    instance.props = nextProps;\n    addListeners();\n\n    if (prevProps.interactiveDebounce !== nextProps.interactiveDebounce) {\n      cleanupInteractiveMouseListeners();\n      debouncedOnMouseMove = debounce(onMouseMove, nextProps.interactiveDebounce);\n    } // Ensure stale aria-expanded attributes are removed\n\n\n    if (prevProps.triggerTarget && !nextProps.triggerTarget) {\n      normalizeToArray(prevProps.triggerTarget).forEach(function (node) {\n        node.removeAttribute('aria-expanded');\n      });\n    } else if (nextProps.triggerTarget) {\n      reference.removeAttribute('aria-expanded');\n    }\n\n    handleAriaExpandedAttribute();\n    handleStyles();\n\n    if (onUpdate) {\n      onUpdate(prevProps, nextProps);\n    }\n\n    if (instance.popperInstance) {\n      createPopperInstance(); // Fixes an issue with nested tippies if they are all getting re-rendered,\n      // and the nested ones get re-rendered first.\n      // https://github.com/atomiks/tippyjs-react/issues/177\n      // TODO: find a cleaner / more efficient solution(!)\n\n      getNestedPopperTree().forEach(function (nestedPopper) {\n        // React (and other UI libs likely) requires a rAF wrapper as it flushes\n        // its work in one\n        requestAnimationFrame(nestedPopper._tippy.popperInstance.forceUpdate);\n      });\n    }\n\n    invokeHook('onAfterUpdate', [instance, partialProps]);\n  }\n\n  function setContent(content) {\n    instance.setProps({\n      content: content\n    });\n  }\n\n  function show() {\n    /* istanbul ignore else */\n    if (process.env.NODE_ENV !== \"production\") {\n      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('show'));\n    } // Early bail-out\n\n\n    var isAlreadyVisible = instance.state.isVisible;\n    var isDestroyed = instance.state.isDestroyed;\n    var isDisabled = !instance.state.isEnabled;\n    var isTouchAndTouchDisabled = currentInput.isTouch && !instance.props.touch;\n    var duration = getValueAtIndexOrReturn(instance.props.duration, 0, defaultProps.duration);\n\n    if (isAlreadyVisible || isDestroyed || isDisabled || isTouchAndTouchDisabled) {\n      return;\n    } // Normalize `disabled` behavior across browsers.\n    // Firefox allows events on disabled elements, but Chrome doesn't.\n    // Using a wrapper element (i.e. <span>) is recommended.\n\n\n    if (getCurrentTarget().hasAttribute('disabled')) {\n      return;\n    }\n\n    invokeHook('onShow', [instance], false);\n\n    if (instance.props.onShow(instance) === false) {\n      return;\n    }\n\n    instance.state.isVisible = true;\n\n    if (getIsDefaultRenderFn()) {\n      popper.style.visibility = 'visible';\n    }\n\n    handleStyles();\n    addDocumentPress();\n\n    if (!instance.state.isMounted) {\n      popper.style.transition = 'none';\n    } // If flipping to the opposite side after hiding at least once, the\n    // animation will use the wrong placement without resetting the duration\n\n\n    if (getIsDefaultRenderFn()) {\n      var _getDefaultTemplateCh2 = getDefaultTemplateChildren(),\n          box = _getDefaultTemplateCh2.box,\n          content = _getDefaultTemplateCh2.content;\n\n      setTransitionDuration([box, content], 0);\n    }\n\n    onFirstUpdate = function onFirstUpdate() {\n      var _instance$popperInsta2;\n\n      if (!instance.state.isVisible || ignoreOnFirstUpdate) {\n        return;\n      }\n\n      ignoreOnFirstUpdate = true; // reflow\n\n      void popper.offsetHeight;\n      popper.style.transition = instance.props.moveTransition;\n\n      if (getIsDefaultRenderFn() && instance.props.animation) {\n        var _getDefaultTemplateCh3 = getDefaultTemplateChildren(),\n            _box = _getDefaultTemplateCh3.box,\n            _content = _getDefaultTemplateCh3.content;\n\n        setTransitionDuration([_box, _content], duration);\n        setVisibilityState([_box, _content], 'visible');\n      }\n\n      handleAriaContentAttribute();\n      handleAriaExpandedAttribute();\n      pushIfUnique(mountedInstances, instance); // certain modifiers (e.g. `maxSize`) require a second update after the\n      // popper has been positioned for the first time\n\n      (_instance$popperInsta2 = instance.popperInstance) == null ? void 0 : _instance$popperInsta2.forceUpdate();\n      invokeHook('onMount', [instance]);\n\n      if (instance.props.animation && getIsDefaultRenderFn()) {\n        onTransitionedIn(duration, function () {\n          instance.state.isShown = true;\n          invokeHook('onShown', [instance]);\n        });\n      }\n    };\n\n    mount();\n  }\n\n  function hide() {\n    /* istanbul ignore else */\n    if (process.env.NODE_ENV !== \"production\") {\n      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('hide'));\n    } // Early bail-out\n\n\n    var isAlreadyHidden = !instance.state.isVisible;\n    var isDestroyed = instance.state.isDestroyed;\n    var isDisabled = !instance.state.isEnabled;\n    var duration = getValueAtIndexOrReturn(instance.props.duration, 1, defaultProps.duration);\n\n    if (isAlreadyHidden || isDestroyed || isDisabled) {\n      return;\n    }\n\n    invokeHook('onHide', [instance], false);\n\n    if (instance.props.onHide(instance) === false) {\n      return;\n    }\n\n    instance.state.isVisible = false;\n    instance.state.isShown = false;\n    ignoreOnFirstUpdate = false;\n    isVisibleFromClick = false;\n\n    if (getIsDefaultRenderFn()) {\n      popper.style.visibility = 'hidden';\n    }\n\n    cleanupInteractiveMouseListeners();\n    removeDocumentPress();\n    handleStyles(true);\n\n    if (getIsDefaultRenderFn()) {\n      var _getDefaultTemplateCh4 = getDefaultTemplateChildren(),\n          box = _getDefaultTemplateCh4.box,\n          content = _getDefaultTemplateCh4.content;\n\n      if (instance.props.animation) {\n        setTransitionDuration([box, content], duration);\n        setVisibilityState([box, content], 'hidden');\n      }\n    }\n\n    handleAriaContentAttribute();\n    handleAriaExpandedAttribute();\n\n    if (instance.props.animation) {\n      if (getIsDefaultRenderFn()) {\n        onTransitionedOut(duration, instance.unmount);\n      }\n    } else {\n      instance.unmount();\n    }\n  }\n\n  function hideWithInteractivity(event) {\n    /* istanbul ignore else */\n    if (process.env.NODE_ENV !== \"production\") {\n      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('hideWithInteractivity'));\n    }\n\n    getDocument().addEventListener('mousemove', debouncedOnMouseMove);\n    pushIfUnique(mouseMoveListeners, debouncedOnMouseMove);\n    debouncedOnMouseMove(event);\n  }\n\n  function unmount() {\n    /* istanbul ignore else */\n    if (process.env.NODE_ENV !== \"production\") {\n      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('unmount'));\n    }\n\n    if (instance.state.isVisible) {\n      instance.hide();\n    }\n\n    if (!instance.state.isMounted) {\n      return;\n    }\n\n    destroyPopperInstance(); // If a popper is not interactive, it will be appended outside the popper\n    // tree by default. This seems mainly for interactive tippies, but we should\n    // find a workaround if possible\n\n    getNestedPopperTree().forEach(function (nestedPopper) {\n      nestedPopper._tippy.unmount();\n    });\n\n    if (popper.parentNode) {\n      popper.parentNode.removeChild(popper);\n    }\n\n    mountedInstances = mountedInstances.filter(function (i) {\n      return i !== instance;\n    });\n    instance.state.isMounted = false;\n    invokeHook('onHidden', [instance]);\n  }\n\n  function destroy() {\n    /* istanbul ignore else */\n    if (process.env.NODE_ENV !== \"production\") {\n      warnWhen(instance.state.isDestroyed, createMemoryLeakWarning('destroy'));\n    }\n\n    if (instance.state.isDestroyed) {\n      return;\n    }\n\n    instance.clearDelayTimeouts();\n    instance.unmount();\n    removeListeners();\n    delete reference._tippy;\n    instance.state.isDestroyed = true;\n    invokeHook('onDestroy', [instance]);\n  }\n}\n\nfunction tippy(targets, optionalProps) {\n  if (optionalProps === void 0) {\n    optionalProps = {};\n  }\n\n  var plugins = defaultProps.plugins.concat(optionalProps.plugins || []);\n  /* istanbul ignore else */\n\n  if (process.env.NODE_ENV !== \"production\") {\n    validateTargets(targets);\n    validateProps(optionalProps, plugins);\n  }\n\n  bindGlobalEventListeners();\n  var passedProps = Object.assign({}, optionalProps, {\n    plugins: plugins\n  });\n  var elements = getArrayOfElements(targets);\n  /* istanbul ignore else */\n\n  if (process.env.NODE_ENV !== \"production\") {\n    var isSingleContentElement = isElement(passedProps.content);\n    var isMoreThanOneReferenceElement = elements.length > 1;\n    warnWhen(isSingleContentElement && isMoreThanOneReferenceElement, ['tippy() was passed an Element as the `content` prop, but more than', 'one tippy instance was created by this invocation. This means the', 'content element will only be appended to the last tippy instance.', '\\n\\n', 'Instead, pass the .innerHTML of the element, or use a function that', 'returns a cloned version of the element instead.', '\\n\\n', '1) content: element.innerHTML\\n', '2) content: () => element.cloneNode(true)'].join(' '));\n  }\n\n  var instances = elements.reduce(function (acc, reference) {\n    var instance = reference && createTippy(reference, passedProps);\n\n    if (instance) {\n      acc.push(instance);\n    }\n\n    return acc;\n  }, []);\n  return isElement(targets) ? instances[0] : instances;\n}\n\ntippy.defaultProps = defaultProps;\ntippy.setDefaultProps = setDefaultProps;\ntippy.currentInput = currentInput;\nvar hideAll = function hideAll(_temp) {\n  var _ref = _temp === void 0 ? {} : _temp,\n      excludedReferenceOrInstance = _ref.exclude,\n      duration = _ref.duration;\n\n  mountedInstances.forEach(function (instance) {\n    var isExcluded = false;\n\n    if (excludedReferenceOrInstance) {\n      isExcluded = isReferenceElement(excludedReferenceOrInstance) ? instance.reference === excludedReferenceOrInstance : instance.popper === excludedReferenceOrInstance.popper;\n    }\n\n    if (!isExcluded) {\n      var originalDuration = instance.props.duration;\n      instance.setProps({\n        duration: duration\n      });\n      instance.hide();\n\n      if (!instance.state.isDestroyed) {\n        instance.setProps({\n          duration: originalDuration\n        });\n      }\n    }\n  });\n};\n\n// every time the popper is destroyed (i.e. a new target), removing the styles\n// and causing transitions to break for singletons when the console is open, but\n// most notably for non-transform styles being used, `gpuAcceleration: false`.\n\nvar applyStylesModifier = Object.assign({}, applyStyles, {\n  effect: function effect(_ref) {\n    var state = _ref.state;\n    var initialStyles = {\n      popper: {\n        position: state.options.strategy,\n        left: '0',\n        top: '0',\n        margin: '0'\n      },\n      arrow: {\n        position: 'absolute'\n      },\n      reference: {}\n    };\n    Object.assign(state.elements.popper.style, initialStyles.popper);\n    state.styles = initialStyles;\n\n    if (state.elements.arrow) {\n      Object.assign(state.elements.arrow.style, initialStyles.arrow);\n    } // intentionally return no cleanup function\n    // return () => { ... }\n\n  }\n});\n\nvar createSingleton = function createSingleton(tippyInstances, optionalProps) {\n  var _optionalProps$popper;\n\n  if (optionalProps === void 0) {\n    optionalProps = {};\n  }\n\n  /* istanbul ignore else */\n  if (process.env.NODE_ENV !== \"production\") {\n    errorWhen(!Array.isArray(tippyInstances), ['The first argument passed to createSingleton() must be an array of', 'tippy instances. The passed value was', String(tippyInstances)].join(' '));\n  }\n\n  var individualInstances = tippyInstances;\n  var references = [];\n  var triggerTargets = [];\n  var currentTarget;\n  var overrides = optionalProps.overrides;\n  var interceptSetPropsCleanups = [];\n  var shownOnCreate = false;\n\n  function setTriggerTargets() {\n    triggerTargets = individualInstances.map(function (instance) {\n      return normalizeToArray(instance.props.triggerTarget || instance.reference);\n    }).reduce(function (acc, item) {\n      return acc.concat(item);\n    }, []);\n  }\n\n  function setReferences() {\n    references = individualInstances.map(function (instance) {\n      return instance.reference;\n    });\n  }\n\n  function enableInstances(isEnabled) {\n    individualInstances.forEach(function (instance) {\n      if (isEnabled) {\n        instance.enable();\n      } else {\n        instance.disable();\n      }\n    });\n  }\n\n  function interceptSetProps(singleton) {\n    return individualInstances.map(function (instance) {\n      var originalSetProps = instance.setProps;\n\n      instance.setProps = function (props) {\n        originalSetProps(props);\n\n        if (instance.reference === currentTarget) {\n          singleton.setProps(props);\n        }\n      };\n\n      return function () {\n        instance.setProps = originalSetProps;\n      };\n    });\n  } // have to pass singleton, as it maybe undefined on first call\n\n\n  function prepareInstance(singleton, target) {\n    var index = triggerTargets.indexOf(target); // bail-out\n\n    if (target === currentTarget) {\n      return;\n    }\n\n    currentTarget = target;\n    var overrideProps = (overrides || []).concat('content').reduce(function (acc, prop) {\n      acc[prop] = individualInstances[index].props[prop];\n      return acc;\n    }, {});\n    singleton.setProps(Object.assign({}, overrideProps, {\n      getReferenceClientRect: typeof overrideProps.getReferenceClientRect === 'function' ? overrideProps.getReferenceClientRect : function () {\n        var _references$index;\n\n        return (_references$index = references[index]) == null ? void 0 : _references$index.getBoundingClientRect();\n      }\n    }));\n  }\n\n  enableInstances(false);\n  setReferences();\n  setTriggerTargets();\n  var plugin = {\n    fn: function fn() {\n      return {\n        onDestroy: function onDestroy() {\n          enableInstances(true);\n        },\n        onHidden: function onHidden() {\n          currentTarget = null;\n        },\n        onClickOutside: function onClickOutside(instance) {\n          if (instance.props.showOnCreate && !shownOnCreate) {\n            shownOnCreate = true;\n            currentTarget = null;\n          }\n        },\n        onShow: function onShow(instance) {\n          if (instance.props.showOnCreate && !shownOnCreate) {\n            shownOnCreate = true;\n            prepareInstance(instance, references[0]);\n          }\n        },\n        onTrigger: function onTrigger(instance, event) {\n          prepareInstance(instance, event.currentTarget);\n        }\n      };\n    }\n  };\n  var singleton = tippy(div(), Object.assign({}, removeProperties(optionalProps, ['overrides']), {\n    plugins: [plugin].concat(optionalProps.plugins || []),\n    triggerTarget: triggerTargets,\n    popperOptions: Object.assign({}, optionalProps.popperOptions, {\n      modifiers: [].concat(((_optionalProps$popper = optionalProps.popperOptions) == null ? void 0 : _optionalProps$popper.modifiers) || [], [applyStylesModifier])\n    })\n  }));\n  var originalShow = singleton.show;\n\n  singleton.show = function (target) {\n    originalShow(); // first time, showOnCreate or programmatic call with no params\n    // default to showing first instance\n\n    if (!currentTarget && target == null) {\n      return prepareInstance(singleton, references[0]);\n    } // triggered from event (do nothing as prepareInstance already called by onTrigger)\n    // programmatic call with no params when already visible (do nothing again)\n\n\n    if (currentTarget && target == null) {\n      return;\n    } // target is index of instance\n\n\n    if (typeof target === 'number') {\n      return references[target] && prepareInstance(singleton, references[target]);\n    } // target is a child tippy instance\n\n\n    if (individualInstances.indexOf(target) >= 0) {\n      var ref = target.reference;\n      return prepareInstance(singleton, ref);\n    } // target is a ReferenceElement\n\n\n    if (references.indexOf(target) >= 0) {\n      return prepareInstance(singleton, target);\n    }\n  };\n\n  singleton.showNext = function () {\n    var first = references[0];\n\n    if (!currentTarget) {\n      return singleton.show(0);\n    }\n\n    var index = references.indexOf(currentTarget);\n    singleton.show(references[index + 1] || first);\n  };\n\n  singleton.showPrevious = function () {\n    var last = references[references.length - 1];\n\n    if (!currentTarget) {\n      return singleton.show(last);\n    }\n\n    var index = references.indexOf(currentTarget);\n    var target = references[index - 1] || last;\n    singleton.show(target);\n  };\n\n  var originalSetProps = singleton.setProps;\n\n  singleton.setProps = function (props) {\n    overrides = props.overrides || overrides;\n    originalSetProps(props);\n  };\n\n  singleton.setInstances = function (nextInstances) {\n    enableInstances(true);\n    interceptSetPropsCleanups.forEach(function (fn) {\n      return fn();\n    });\n    individualInstances = nextInstances;\n    enableInstances(false);\n    setReferences();\n    setTriggerTargets();\n    interceptSetPropsCleanups = interceptSetProps(singleton);\n    singleton.setProps({\n      triggerTarget: triggerTargets\n    });\n  };\n\n  interceptSetPropsCleanups = interceptSetProps(singleton);\n  return singleton;\n};\n\nvar BUBBLING_EVENTS_MAP = {\n  mouseover: 'mouseenter',\n  focusin: 'focus',\n  click: 'click'\n};\n/**\n * Creates a delegate instance that controls the creation of tippy instances\n * for child elements (`target` CSS selector).\n */\n\nfunction delegate(targets, props) {\n  /* istanbul ignore else */\n  if (process.env.NODE_ENV !== \"production\") {\n    errorWhen(!(props && props.target), ['You must specity a `target` prop indicating a CSS selector string matching', 'the target elements that should receive a tippy.'].join(' '));\n  }\n\n  var listeners = [];\n  var childTippyInstances = [];\n  var disabled = false;\n  var target = props.target;\n  var nativeProps = removeProperties(props, ['target']);\n  var parentProps = Object.assign({}, nativeProps, {\n    trigger: 'manual',\n    touch: false\n  });\n  var childProps = Object.assign({\n    touch: defaultProps.touch\n  }, nativeProps, {\n    showOnCreate: true\n  });\n  var returnValue = tippy(targets, parentProps);\n  var normalizedReturnValue = normalizeToArray(returnValue);\n\n  function onTrigger(event) {\n    if (!event.target || disabled) {\n      return;\n    }\n\n    var targetNode = event.target.closest(target);\n\n    if (!targetNode) {\n      return;\n    } // Get relevant trigger with fallbacks:\n    // 1. Check `data-tippy-trigger` attribute on target node\n    // 2. Fallback to `trigger` passed to `delegate()`\n    // 3. Fallback to `defaultProps.trigger`\n\n\n    var trigger = targetNode.getAttribute('data-tippy-trigger') || props.trigger || defaultProps.trigger; // @ts-ignore\n\n    if (targetNode._tippy) {\n      return;\n    }\n\n    if (event.type === 'touchstart' && typeof childProps.touch === 'boolean') {\n      return;\n    }\n\n    if (event.type !== 'touchstart' && trigger.indexOf(BUBBLING_EVENTS_MAP[event.type]) < 0) {\n      return;\n    }\n\n    var instance = tippy(targetNode, childProps);\n\n    if (instance) {\n      childTippyInstances = childTippyInstances.concat(instance);\n    }\n  }\n\n  function on(node, eventType, handler, options) {\n    if (options === void 0) {\n      options = false;\n    }\n\n    node.addEventListener(eventType, handler, options);\n    listeners.push({\n      node: node,\n      eventType: eventType,\n      handler: handler,\n      options: options\n    });\n  }\n\n  function addEventListeners(instance) {\n    var reference = instance.reference;\n    on(reference, 'touchstart', onTrigger, TOUCH_OPTIONS);\n    on(reference, 'mouseover', onTrigger);\n    on(reference, 'focusin', onTrigger);\n    on(reference, 'click', onTrigger);\n  }\n\n  function removeEventListeners() {\n    listeners.forEach(function (_ref) {\n      var node = _ref.node,\n          eventType = _ref.eventType,\n          handler = _ref.handler,\n          options = _ref.options;\n      node.removeEventListener(eventType, handler, options);\n    });\n    listeners = [];\n  }\n\n  function applyMutations(instance) {\n    var originalDestroy = instance.destroy;\n    var originalEnable = instance.enable;\n    var originalDisable = instance.disable;\n\n    instance.destroy = function (shouldDestroyChildInstances) {\n      if (shouldDestroyChildInstances === void 0) {\n        shouldDestroyChildInstances = true;\n      }\n\n      if (shouldDestroyChildInstances) {\n        childTippyInstances.forEach(function (instance) {\n          instance.destroy();\n        });\n      }\n\n      childTippyInstances = [];\n      removeEventListeners();\n      originalDestroy();\n    };\n\n    instance.enable = function () {\n      originalEnable();\n      childTippyInstances.forEach(function (instance) {\n        return instance.enable();\n      });\n      disabled = false;\n    };\n\n    instance.disable = function () {\n      originalDisable();\n      childTippyInstances.forEach(function (instance) {\n        return instance.disable();\n      });\n      disabled = true;\n    };\n\n    addEventListeners(instance);\n  }\n\n  normalizedReturnValue.forEach(applyMutations);\n  return returnValue;\n}\n\nvar animateFill = {\n  name: 'animateFill',\n  defaultValue: false,\n  fn: function fn(instance) {\n    var _instance$props$rende;\n\n    // @ts-ignore\n    if (!((_instance$props$rende = instance.props.render) != null && _instance$props$rende.$$tippy)) {\n      if (process.env.NODE_ENV !== \"production\") {\n        errorWhen(instance.props.animateFill, 'The `animateFill` plugin requires the default render function.');\n      }\n\n      return {};\n    }\n\n    var _getChildren = getChildren(instance.popper),\n        box = _getChildren.box,\n        content = _getChildren.content;\n\n    var backdrop = instance.props.animateFill ? createBackdropElement() : null;\n    return {\n      onCreate: function onCreate() {\n        if (backdrop) {\n          box.insertBefore(backdrop, box.firstElementChild);\n          box.setAttribute('data-animatefill', '');\n          box.style.overflow = 'hidden';\n          instance.setProps({\n            arrow: false,\n            animation: 'shift-away'\n          });\n        }\n      },\n      onMount: function onMount() {\n        if (backdrop) {\n          var transitionDuration = box.style.transitionDuration;\n          var duration = Number(transitionDuration.replace('ms', '')); // The content should fade in after the backdrop has mostly filled the\n          // tooltip element. `clip-path` is the other alternative but is not\n          // well-supported and is buggy on some devices.\n\n          content.style.transitionDelay = Math.round(duration / 10) + \"ms\";\n          backdrop.style.transitionDuration = transitionDuration;\n          setVisibilityState([backdrop], 'visible');\n        }\n      },\n      onShow: function onShow() {\n        if (backdrop) {\n          backdrop.style.transitionDuration = '0ms';\n        }\n      },\n      onHide: function onHide() {\n        if (backdrop) {\n          setVisibilityState([backdrop], 'hidden');\n        }\n      }\n    };\n  }\n};\n\nfunction createBackdropElement() {\n  var backdrop = div();\n  backdrop.className = BACKDROP_CLASS;\n  setVisibilityState([backdrop], 'hidden');\n  return backdrop;\n}\n\nvar mouseCoords = {\n  clientX: 0,\n  clientY: 0\n};\nvar activeInstances = [];\n\nfunction storeMouseCoords(_ref) {\n  var clientX = _ref.clientX,\n      clientY = _ref.clientY;\n  mouseCoords = {\n    clientX: clientX,\n    clientY: clientY\n  };\n}\n\nfunction addMouseCoordsListener(doc) {\n  doc.addEventListener('mousemove', storeMouseCoords);\n}\n\nfunction removeMouseCoordsListener(doc) {\n  doc.removeEventListener('mousemove', storeMouseCoords);\n}\n\nvar followCursor = {\n  name: 'followCursor',\n  defaultValue: false,\n  fn: function fn(instance) {\n    var reference = instance.reference;\n    var doc = getOwnerDocument(instance.props.triggerTarget || reference);\n    var isInternalUpdate = false;\n    var wasFocusEvent = false;\n    var isUnmounted = true;\n    var prevProps = instance.props;\n\n    function getIsInitialBehavior() {\n      return instance.props.followCursor === 'initial' && instance.state.isVisible;\n    }\n\n    function addListener() {\n      doc.addEventListener('mousemove', onMouseMove);\n    }\n\n    function removeListener() {\n      doc.removeEventListener('mousemove', onMouseMove);\n    }\n\n    function unsetGetReferenceClientRect() {\n      isInternalUpdate = true;\n      instance.setProps({\n        getReferenceClientRect: null\n      });\n      isInternalUpdate = false;\n    }\n\n    function onMouseMove(event) {\n      // If the instance is interactive, avoid updating the position unless it's\n      // over the reference element\n      var isCursorOverReference = event.target ? reference.contains(event.target) : true;\n      var followCursor = instance.props.followCursor;\n      var clientX = event.clientX,\n          clientY = event.clientY;\n      var rect = reference.getBoundingClientRect();\n      var relativeX = clientX - rect.left;\n      var relativeY = clientY - rect.top;\n\n      if (isCursorOverReference || !instance.props.interactive) {\n        instance.setProps({\n          // @ts-ignore - unneeded DOMRect properties\n          getReferenceClientRect: function getReferenceClientRect() {\n            var rect = reference.getBoundingClientRect();\n            var x = clientX;\n            var y = clientY;\n\n            if (followCursor === 'initial') {\n              x = rect.left + relativeX;\n              y = rect.top + relativeY;\n            }\n\n            var top = followCursor === 'horizontal' ? rect.top : y;\n            var right = followCursor === 'vertical' ? rect.right : x;\n            var bottom = followCursor === 'horizontal' ? rect.bottom : y;\n            var left = followCursor === 'vertical' ? rect.left : x;\n            return {\n              width: right - left,\n              height: bottom - top,\n              top: top,\n              right: right,\n              bottom: bottom,\n              left: left\n            };\n          }\n        });\n      }\n    }\n\n    function create() {\n      if (instance.props.followCursor) {\n        activeInstances.push({\n          instance: instance,\n          doc: doc\n        });\n        addMouseCoordsListener(doc);\n      }\n    }\n\n    function destroy() {\n      activeInstances = activeInstances.filter(function (data) {\n        return data.instance !== instance;\n      });\n\n      if (activeInstances.filter(function (data) {\n        return data.doc === doc;\n      }).length === 0) {\n        removeMouseCoordsListener(doc);\n      }\n    }\n\n    return {\n      onCreate: create,\n      onDestroy: destroy,\n      onBeforeUpdate: function onBeforeUpdate() {\n        prevProps = instance.props;\n      },\n      onAfterUpdate: function onAfterUpdate(_, _ref2) {\n        var followCursor = _ref2.followCursor;\n\n        if (isInternalUpdate) {\n          return;\n        }\n\n        if (followCursor !== undefined && prevProps.followCursor !== followCursor) {\n          destroy();\n\n          if (followCursor) {\n            create();\n\n            if (instance.state.isMounted && !wasFocusEvent && !getIsInitialBehavior()) {\n              addListener();\n            }\n          } else {\n            removeListener();\n            unsetGetReferenceClientRect();\n          }\n        }\n      },\n      onMount: function onMount() {\n        if (instance.props.followCursor && !wasFocusEvent) {\n          if (isUnmounted) {\n            onMouseMove(mouseCoords);\n            isUnmounted = false;\n          }\n\n          if (!getIsInitialBehavior()) {\n            addListener();\n          }\n        }\n      },\n      onTrigger: function onTrigger(_, event) {\n        if (isMouseEvent(event)) {\n          mouseCoords = {\n            clientX: event.clientX,\n            clientY: event.clientY\n          };\n        }\n\n        wasFocusEvent = event.type === 'focus';\n      },\n      onHidden: function onHidden() {\n        if (instance.props.followCursor) {\n          unsetGetReferenceClientRect();\n          removeListener();\n          isUnmounted = true;\n        }\n      }\n    };\n  }\n};\n\nfunction getProps(props, modifier) {\n  var _props$popperOptions;\n\n  return {\n    popperOptions: Object.assign({}, props.popperOptions, {\n      modifiers: [].concat((((_props$popperOptions = props.popperOptions) == null ? void 0 : _props$popperOptions.modifiers) || []).filter(function (_ref) {\n        var name = _ref.name;\n        return name !== modifier.name;\n      }), [modifier])\n    })\n  };\n}\n\nvar inlinePositioning = {\n  name: 'inlinePositioning',\n  defaultValue: false,\n  fn: function fn(instance) {\n    var reference = instance.reference;\n\n    function isEnabled() {\n      return !!instance.props.inlinePositioning;\n    }\n\n    var placement;\n    var cursorRectIndex = -1;\n    var isInternalUpdate = false;\n    var triedPlacements = [];\n    var modifier = {\n      name: 'tippyInlinePositioning',\n      enabled: true,\n      phase: 'afterWrite',\n      fn: function fn(_ref2) {\n        var state = _ref2.state;\n\n        if (isEnabled()) {\n          if (triedPlacements.indexOf(state.placement) !== -1) {\n            triedPlacements = [];\n          }\n\n          if (placement !== state.placement && triedPlacements.indexOf(state.placement) === -1) {\n            triedPlacements.push(state.placement);\n            instance.setProps({\n              // @ts-ignore - unneeded DOMRect properties\n              getReferenceClientRect: function getReferenceClientRect() {\n                return _getReferenceClientRect(state.placement);\n              }\n            });\n          }\n\n          placement = state.placement;\n        }\n      }\n    };\n\n    function _getReferenceClientRect(placement) {\n      return getInlineBoundingClientRect(getBasePlacement(placement), reference.getBoundingClientRect(), arrayFrom(reference.getClientRects()), cursorRectIndex);\n    }\n\n    function setInternalProps(partialProps) {\n      isInternalUpdate = true;\n      instance.setProps(partialProps);\n      isInternalUpdate = false;\n    }\n\n    function addModifier() {\n      if (!isInternalUpdate) {\n        setInternalProps(getProps(instance.props, modifier));\n      }\n    }\n\n    return {\n      onCreate: addModifier,\n      onAfterUpdate: addModifier,\n      onTrigger: function onTrigger(_, event) {\n        if (isMouseEvent(event)) {\n          var rects = arrayFrom(instance.reference.getClientRects());\n          var cursorRect = rects.find(function (rect) {\n            return rect.left - 2 <= event.clientX && rect.right + 2 >= event.clientX && rect.top - 2 <= event.clientY && rect.bottom + 2 >= event.clientY;\n          });\n          var index = rects.indexOf(cursorRect);\n          cursorRectIndex = index > -1 ? index : cursorRectIndex;\n        }\n      },\n      onHidden: function onHidden() {\n        cursorRectIndex = -1;\n      }\n    };\n  }\n};\nfunction getInlineBoundingClientRect(currentBasePlacement, boundingRect, clientRects, cursorRectIndex) {\n  // Not an inline element, or placement is not yet known\n  if (clientRects.length < 2 || currentBasePlacement === null) {\n    return boundingRect;\n  } // There are two rects and they are disjoined\n\n\n  if (clientRects.length === 2 && cursorRectIndex >= 0 && clientRects[0].left > clientRects[1].right) {\n    return clientRects[cursorRectIndex] || boundingRect;\n  }\n\n  switch (currentBasePlacement) {\n    case 'top':\n    case 'bottom':\n      {\n        var firstRect = clientRects[0];\n        var lastRect = clientRects[clientRects.length - 1];\n        var isTop = currentBasePlacement === 'top';\n        var top = firstRect.top;\n        var bottom = lastRect.bottom;\n        var left = isTop ? firstRect.left : lastRect.left;\n        var right = isTop ? firstRect.right : lastRect.right;\n        var width = right - left;\n        var height = bottom - top;\n        return {\n          top: top,\n          bottom: bottom,\n          left: left,\n          right: right,\n          width: width,\n          height: height\n        };\n      }\n\n    case 'left':\n    case 'right':\n      {\n        var minLeft = Math.min.apply(Math, clientRects.map(function (rects) {\n          return rects.left;\n        }));\n        var maxRight = Math.max.apply(Math, clientRects.map(function (rects) {\n          return rects.right;\n        }));\n        var measureRects = clientRects.filter(function (rect) {\n          return currentBasePlacement === 'left' ? rect.left === minLeft : rect.right === maxRight;\n        });\n        var _top = measureRects[0].top;\n        var _bottom = measureRects[measureRects.length - 1].bottom;\n        var _left = minLeft;\n        var _right = maxRight;\n\n        var _width = _right - _left;\n\n        var _height = _bottom - _top;\n\n        return {\n          top: _top,\n          bottom: _bottom,\n          left: _left,\n          right: _right,\n          width: _width,\n          height: _height\n        };\n      }\n\n    default:\n      {\n        return boundingRect;\n      }\n  }\n}\n\nvar sticky = {\n  name: 'sticky',\n  defaultValue: false,\n  fn: function fn(instance) {\n    var reference = instance.reference,\n        popper = instance.popper;\n\n    function getReference() {\n      return instance.popperInstance ? instance.popperInstance.state.elements.reference : reference;\n    }\n\n    function shouldCheck(value) {\n      return instance.props.sticky === true || instance.props.sticky === value;\n    }\n\n    var prevRefRect = null;\n    var prevPopRect = null;\n\n    function updatePosition() {\n      var currentRefRect = shouldCheck('reference') ? getReference().getBoundingClientRect() : null;\n      var currentPopRect = shouldCheck('popper') ? popper.getBoundingClientRect() : null;\n\n      if (currentRefRect && areRectsDifferent(prevRefRect, currentRefRect) || currentPopRect && areRectsDifferent(prevPopRect, currentPopRect)) {\n        if (instance.popperInstance) {\n          instance.popperInstance.update();\n        }\n      }\n\n      prevRefRect = currentRefRect;\n      prevPopRect = currentPopRect;\n\n      if (instance.state.isMounted) {\n        requestAnimationFrame(updatePosition);\n      }\n    }\n\n    return {\n      onMount: function onMount() {\n        if (instance.props.sticky) {\n          updatePosition();\n        }\n      }\n    };\n  }\n};\n\nfunction areRectsDifferent(rectA, rectB) {\n  if (rectA && rectB) {\n    return rectA.top !== rectB.top || rectA.right !== rectB.right || rectA.bottom !== rectB.bottom || rectA.left !== rectB.left;\n  }\n\n  return true;\n}\n\ntippy.setDefaultProps({\n  render: render\n});\n\nexport default tippy;\nexport { animateFill, createSingleton, delegate, followCursor, hideAll, inlinePositioning, ROUND_ARROW as roundArrow, sticky };\n//# sourceMappingURL=tippy.esm.js.map\n","import { __assign } from \"tslib\";\nimport * as React from 'react';\nimport { warn, warnControlledUsage, warnConditionallyRequiredProps, warnDeprecations, warnMutuallyExclusive, } from '@fluentui/utilities';\nimport { usePrevious } from './usePrevious';\nimport { useConst } from './useConst';\nvar warningId = 0;\n/**\n * Only in development mode, display console warnings when certain conditions are met.\n * Note that all warnings except `controlledUsage` will only be shown on first render\n * (new `controlledUsage` warnings may be shown later due to prop changes).\n */\nexport function useWarnings(options) {\n    if (process.env.NODE_ENV !== 'production') {\n        var name_1 = options.name, props = options.props, _a = options.other, other = _a === void 0 ? [] : _a, conditionallyRequired = options.conditionallyRequired, deprecations = options.deprecations, mutuallyExclusive = options.mutuallyExclusive, controlledUsage = options.controlledUsage;\n        /* eslint-disable react-hooks/rules-of-hooks -- build-time conditional */\n        var hasWarnedRef = React.useRef(false);\n        var componentId = useConst(function () { return \"useWarnings_\".concat(warningId++); });\n        var oldProps = usePrevious(props);\n        /* eslint-enable react-hooks/rules-of-hooks */\n        // Warn synchronously (not in useEffect) on first render to make debugging easier.\n        if (!hasWarnedRef.current) {\n            hasWarnedRef.current = true;\n            for (var _i = 0, other_1 = other; _i < other_1.length; _i++) {\n                var warning = other_1[_i];\n                warn(warning);\n            }\n            if (conditionallyRequired) {\n                for (var _b = 0, conditionallyRequired_1 = conditionallyRequired; _b < conditionallyRequired_1.length; _b++) {\n                    var req = conditionallyRequired_1[_b];\n                    warnConditionallyRequiredProps(name_1, props, req.requiredProps, req.conditionalPropName, req.condition);\n                }\n            }\n            deprecations && warnDeprecations(name_1, props, deprecations);\n            mutuallyExclusive && warnMutuallyExclusive(name_1, props, mutuallyExclusive);\n        }\n        // Controlled usage warnings may be displayed on either first or subsequent renders due to\n        // prop changes. Note that it's safe to run this synchronously (not in useEffect) even in\n        // concurrent mode because `warnControlledUsage` internally tracks which warnings have been\n        // displayed for each component instance (so nothing will be displayed twice).\n        controlledUsage && warnControlledUsage(__assign(__assign({}, controlledUsage), { componentId: componentId, props: props, componentName: name_1, oldProps: oldProps }));\n    }\n}\n//# sourceMappingURL=useWarnings.js.map","import getBasePlacement from \"./getBasePlacement.js\";\nimport getVariation from \"./getVariation.js\";\nimport getMainAxisFromPlacement from \"./getMainAxisFromPlacement.js\";\nimport { top, right, bottom, left, start, end } from \"../enums.js\";\nexport default function computeOffsets(_ref) {\n  var reference = _ref.reference,\n      element = _ref.element,\n      placement = _ref.placement;\n  var basePlacement = placement ? getBasePlacement(placement) : null;\n  var variation = placement ? getVariation(placement) : null;\n  var commonX = reference.x + reference.width / 2 - element.width / 2;\n  var commonY = reference.y + reference.height / 2 - element.height / 2;\n  var offsets;\n\n  switch (basePlacement) {\n    case top:\n      offsets = {\n        x: commonX,\n        y: reference.y - element.height\n      };\n      break;\n\n    case bottom:\n      offsets = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n\n    case right:\n      offsets = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n\n    case left:\n      offsets = {\n        x: reference.x - element.width,\n        y: commonY\n      };\n      break;\n\n    default:\n      offsets = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n\n  var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;\n\n  if (mainAxis != null) {\n    var len = mainAxis === 'y' ? 'height' : 'width';\n\n    switch (variation) {\n      case start:\n        offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);\n        break;\n\n      case end:\n        offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);\n        break;\n\n      default:\n    }\n  }\n\n  return offsets;\n}","import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport { useState, useEffect, useContext, useRef } from 'react';\nimport { getI18n, getDefaults, ReportNamespaces, I18nContext } from './context';\nimport { warnOnce, loadNamespaces, hasLoadedNamespace } from './utils';\nexport function useTranslation(ns) {\n  var props = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var i18nFromProps = props.i18n;\n\n  var _ref = useContext(I18nContext) || {},\n      i18nFromContext = _ref.i18n,\n      defaultNSFromContext = _ref.defaultNS;\n\n  var i18n = i18nFromProps || i18nFromContext || getI18n();\n  if (i18n && !i18n.reportNamespaces) i18n.reportNamespaces = new ReportNamespaces();\n\n  if (!i18n) {\n    warnOnce('You will need to pass in an i18next instance by using initReactI18next');\n\n    var notReadyT = function notReadyT(k) {\n      return Array.isArray(k) ? k[k.length - 1] : k;\n    };\n\n    var retNotReady = [notReadyT, {}, false];\n    retNotReady.t = notReadyT;\n    retNotReady.i18n = {};\n    retNotReady.ready = false;\n    return retNotReady;\n  }\n\n  if (i18n.options.react && i18n.options.react.wait !== undefined) warnOnce('It seems you are still using the old wait option, you may migrate to the new useSuspense behaviour.');\n\n  var i18nOptions = _objectSpread(_objectSpread(_objectSpread({}, getDefaults()), i18n.options.react), props);\n\n  var useSuspense = i18nOptions.useSuspense,\n      keyPrefix = i18nOptions.keyPrefix;\n  var namespaces = ns || defaultNSFromContext || i18n.options && i18n.options.defaultNS;\n  namespaces = typeof namespaces === 'string' ? [namespaces] : namespaces || ['translation'];\n  if (i18n.reportNamespaces.addUsedNamespaces) i18n.reportNamespaces.addUsedNamespaces(namespaces);\n  var ready = (i18n.isInitialized || i18n.initializedStoreOnce) && namespaces.every(function (n) {\n    return hasLoadedNamespace(n, i18n, i18nOptions);\n  });\n\n  function getT() {\n    return i18n.getFixedT(null, i18nOptions.nsMode === 'fallback' ? namespaces : namespaces[0], keyPrefix);\n  }\n\n  var _useState = useState(getT),\n      _useState2 = _slicedToArray(_useState, 2),\n      t = _useState2[0],\n      setT = _useState2[1];\n\n  var isMounted = useRef(true);\n  useEffect(function () {\n    var bindI18n = i18nOptions.bindI18n,\n        bindI18nStore = i18nOptions.bindI18nStore;\n    isMounted.current = true;\n\n    if (!ready && !useSuspense) {\n      loadNamespaces(i18n, namespaces, function () {\n        if (isMounted.current) setT(getT);\n      });\n    }\n\n    function boundReset() {\n      if (isMounted.current) setT(getT);\n    }\n\n    if (bindI18n && i18n) i18n.on(bindI18n, boundReset);\n    if (bindI18nStore && i18n) i18n.store.on(bindI18nStore, boundReset);\n    return function () {\n      isMounted.current = false;\n      if (bindI18n && i18n) bindI18n.split(' ').forEach(function (e) {\n        return i18n.off(e, boundReset);\n      });\n      if (bindI18nStore && i18n) bindI18nStore.split(' ').forEach(function (e) {\n        return i18n.store.off(e, boundReset);\n      });\n    };\n  }, [i18n, namespaces.join()]);\n  var isInitial = useRef(true);\n  useEffect(function () {\n    if (isMounted.current && !isInitial.current) {\n      setT(getT);\n    }\n\n    isInitial.current = false;\n  }, [i18n]);\n  var ret = [t, i18n, ready];\n  ret.t = t;\n  ret.i18n = i18n;\n  ret.ready = ready;\n  if (ready) return ret;\n  if (!ready && !useSuspense) return ret;\n  throw new Promise(function (resolve) {\n    loadNamespaces(i18n, namespaces, function () {\n      resolve();\n    });\n  });\n}","import * as React from 'react';\nimport { useConst } from './useConst';\nexport function useControllableValue(controlledValue, defaultUncontrolledValue, onChange) {\n    var _a = React.useState(defaultUncontrolledValue), value = _a[0], setValue = _a[1];\n    var isControlled = useConst(controlledValue !== undefined);\n    var currentValue = isControlled ? controlledValue : value;\n    // Duplicate the current value and onChange in refs so they're accessible from\n    // setValueOrCallOnChange without creating a new callback every time\n    var valueRef = React.useRef(currentValue);\n    var onChangeRef = React.useRef(onChange);\n    React.useEffect(function () {\n        valueRef.current = currentValue;\n        onChangeRef.current = onChange;\n    });\n    // To match the behavior of the setter returned by React.useState, this callback's identity\n    // should never change. This means it MUST NOT directly reference variables that can change.\n    var setValueOrCallOnChange = useConst(function () { return function (update, ev) {\n        // Assuming here that TValue is not a function, because a controllable value will typically\n        // be something a user can enter as input\n        var newValue = typeof update === 'function' ? update(valueRef.current) : update;\n        if (onChangeRef.current) {\n            onChangeRef.current(ev, newValue);\n        }\n        if (!isControlled) {\n            setValue(newValue);\n        }\n    }; });\n    return [currentValue, setValueOrCallOnChange];\n}\n//# sourceMappingURL=useControllableValue.js.map","var GOOD_LEAF_SIZE = 200;\n\n// :: class<T> A rope sequence is a persistent sequence data structure\n// that supports appending, prepending, and slicing without doing a\n// full copy. It is represented as a mostly-balanced tree.\nvar RopeSequence = function RopeSequence () {};\n\nRopeSequence.prototype.append = function append (other) {\n  if (!other.length) { return this }\n  other = RopeSequence.from(other);\n\n  return (!this.length && other) ||\n    (other.length < GOOD_LEAF_SIZE && this.leafAppend(other)) ||\n    (this.length < GOOD_LEAF_SIZE && other.leafPrepend(this)) ||\n    this.appendInner(other)\n};\n\n// :: (union<[T], RopeSequence<T>>)  RopeSequence<T>\n// Prepend an array or other rope to this one, returning a new rope.\nRopeSequence.prototype.prepend = function prepend (other) {\n  if (!other.length) { return this }\n  return RopeSequence.from(other).append(this)\n};\n\nRopeSequence.prototype.appendInner = function appendInner (other) {\n  return new Append(this, other)\n};\n\n// :: (?number, ?number)  RopeSequence<T>\n// Create a rope repesenting a sub-sequence of this rope.\nRopeSequence.prototype.slice = function slice (from, to) {\n    if ( from === void 0 ) from = 0;\n    if ( to === void 0 ) to = this.length;\n\n  if (from >= to) { return RopeSequence.empty }\n  return this.sliceInner(Math.max(0, from), Math.min(this.length, to))\n};\n\n// :: (number)  T\n// Retrieve the element at the given position from this rope.\nRopeSequence.prototype.get = function get (i) {\n  if (i < 0 || i >= this.length) { return undefined }\n  return this.getInner(i)\n};\n\n// :: ((element: T, index: number)  ?bool, ?number, ?number)\n// Call the given function for each element between the given\n// indices. This tends to be more efficient than looping over the\n// indices and calling `get`, because it doesn't have to descend the\n// tree for every element.\nRopeSequence.prototype.forEach = function forEach (f, from, to) {\n    if ( from === void 0 ) from = 0;\n    if ( to === void 0 ) to = this.length;\n\n  if (from <= to)\n    { this.forEachInner(f, from, to, 0); }\n  else\n    { this.forEachInvertedInner(f, from, to, 0); }\n};\n\n// :: ((element: T, index: number)  U, ?number, ?number)  [U]\n// Map the given functions over the elements of the rope, producing\n// a flat array.\nRopeSequence.prototype.map = function map (f, from, to) {\n    if ( from === void 0 ) from = 0;\n    if ( to === void 0 ) to = this.length;\n\n  var result = [];\n  this.forEach(function (elt, i) { return result.push(f(elt, i)); }, from, to);\n  return result\n};\n\n// :: (?union<[T], RopeSequence<T>>)  RopeSequence<T>\n// Create a rope representing the given array, or return the rope\n// itself if a rope was given.\nRopeSequence.from = function from (values) {\n  if (values instanceof RopeSequence) { return values }\n  return values && values.length ? new Leaf(values) : RopeSequence.empty\n};\n\nvar Leaf = /*@__PURE__*/(function (RopeSequence) {\n  function Leaf(values) {\n    RopeSequence.call(this);\n    this.values = values;\n  }\n\n  if ( RopeSequence ) Leaf.__proto__ = RopeSequence;\n  Leaf.prototype = Object.create( RopeSequence && RopeSequence.prototype );\n  Leaf.prototype.constructor = Leaf;\n\n  var prototypeAccessors = { length: { configurable: true },depth: { configurable: true } };\n\n  Leaf.prototype.flatten = function flatten () {\n    return this.values\n  };\n\n  Leaf.prototype.sliceInner = function sliceInner (from, to) {\n    if (from == 0 && to == this.length) { return this }\n    return new Leaf(this.values.slice(from, to))\n  };\n\n  Leaf.prototype.getInner = function getInner (i) {\n    return this.values[i]\n  };\n\n  Leaf.prototype.forEachInner = function forEachInner (f, from, to, start) {\n    for (var i = from; i < to; i++)\n      { if (f(this.values[i], start + i) === false) { return false } }\n  };\n\n  Leaf.prototype.forEachInvertedInner = function forEachInvertedInner (f, from, to, start) {\n    for (var i = from - 1; i >= to; i--)\n      { if (f(this.values[i], start + i) === false) { return false } }\n  };\n\n  Leaf.prototype.leafAppend = function leafAppend (other) {\n    if (this.length + other.length <= GOOD_LEAF_SIZE)\n      { return new Leaf(this.values.concat(other.flatten())) }\n  };\n\n  Leaf.prototype.leafPrepend = function leafPrepend (other) {\n    if (this.length + other.length <= GOOD_LEAF_SIZE)\n      { return new Leaf(other.flatten().concat(this.values)) }\n  };\n\n  prototypeAccessors.length.get = function () { return this.values.length };\n\n  prototypeAccessors.depth.get = function () { return 0 };\n\n  Object.defineProperties( Leaf.prototype, prototypeAccessors );\n\n  return Leaf;\n}(RopeSequence));\n\n// :: RopeSequence\n// The empty rope sequence.\nRopeSequence.empty = new Leaf([]);\n\nvar Append = /*@__PURE__*/(function (RopeSequence) {\n  function Append(left, right) {\n    RopeSequence.call(this);\n    this.left = left;\n    this.right = right;\n    this.length = left.length + right.length;\n    this.depth = Math.max(left.depth, right.depth) + 1;\n  }\n\n  if ( RopeSequence ) Append.__proto__ = RopeSequence;\n  Append.prototype = Object.create( RopeSequence && RopeSequence.prototype );\n  Append.prototype.constructor = Append;\n\n  Append.prototype.flatten = function flatten () {\n    return this.left.flatten().concat(this.right.flatten())\n  };\n\n  Append.prototype.getInner = function getInner (i) {\n    return i < this.left.length ? this.left.get(i) : this.right.get(i - this.left.length)\n  };\n\n  Append.prototype.forEachInner = function forEachInner (f, from, to, start) {\n    var leftLen = this.left.length;\n    if (from < leftLen &&\n        this.left.forEachInner(f, from, Math.min(to, leftLen), start) === false)\n      { return false }\n    if (to > leftLen &&\n        this.right.forEachInner(f, Math.max(from - leftLen, 0), Math.min(this.length, to) - leftLen, start + leftLen) === false)\n      { return false }\n  };\n\n  Append.prototype.forEachInvertedInner = function forEachInvertedInner (f, from, to, start) {\n    var leftLen = this.left.length;\n    if (from > leftLen &&\n        this.right.forEachInvertedInner(f, from - leftLen, Math.max(to, leftLen) - leftLen, start + leftLen) === false)\n      { return false }\n    if (to < leftLen &&\n        this.left.forEachInvertedInner(f, Math.min(from, leftLen), to, start) === false)\n      { return false }\n  };\n\n  Append.prototype.sliceInner = function sliceInner (from, to) {\n    if (from == 0 && to == this.length) { return this }\n    var leftLen = this.left.length;\n    if (to <= leftLen) { return this.left.slice(from, to) }\n    if (from >= leftLen) { return this.right.slice(from - leftLen, to - leftLen) }\n    return this.left.slice(from, leftLen).append(this.right.slice(0, to - leftLen))\n  };\n\n  Append.prototype.leafAppend = function leafAppend (other) {\n    var inner = this.right.leafAppend(other);\n    if (inner) { return new Append(this.left, inner) }\n  };\n\n  Append.prototype.leafPrepend = function leafPrepend (other) {\n    var inner = this.left.leafPrepend(other);\n    if (inner) { return new Append(inner, this.right) }\n  };\n\n  Append.prototype.appendInner = function appendInner (other) {\n    if (this.left.depth >= Math.max(this.right.depth, other.depth) + 1)\n      { return new Append(this.left, new Append(this.right, other)) }\n    return new Append(this, other)\n  };\n\n  return Append;\n}(RopeSequence));\n\nexport default RopeSequence;\n","import {mergeProps as $bx7SL$mergeProps, useSyncRef as $bx7SL$useSyncRef, useGlobalListeners as $bx7SL$useGlobalListeners, isVirtualClick as $bx7SL$isVirtualClick, focusWithoutScrolling as $bx7SL$focusWithoutScrolling, isVirtualPointerEvent as $bx7SL$isVirtualPointerEvent, isIOS as $bx7SL$isIOS, runAfterTransition as $bx7SL$runAfterTransition, useLayoutEffect as $bx7SL$useLayoutEffect, isMac as $bx7SL$isMac, useEvent as $bx7SL$useEvent, useDescription as $bx7SL$useDescription} from \"@react-aria/utils\";\nimport $bx7SL$react, {useRef as $bx7SL$useRef, useContext as $bx7SL$useContext, useState as $bx7SL$useState, useMemo as $bx7SL$useMemo, useEffect as $bx7SL$useEffect, useCallback as $bx7SL$useCallback} from \"react\";\n\n\n\n// Note that state only matters here for iOS. Non-iOS gets user-select: none applied to the target element\n// rather than at the document level so we just need to apply/remove user-select: none for each pressed element individually\nlet $14c0b72509d70225$var$state = 'default';\nlet $14c0b72509d70225$var$savedUserSelect = '';\nlet $14c0b72509d70225$var$modifiedElementMap = new WeakMap();\nfunction $14c0b72509d70225$export$16a4697467175487(target) {\n    if ($bx7SL$isIOS()) {\n        if ($14c0b72509d70225$var$state === 'default') {\n            $14c0b72509d70225$var$savedUserSelect = document.documentElement.style.webkitUserSelect;\n            document.documentElement.style.webkitUserSelect = 'none';\n        }\n        $14c0b72509d70225$var$state = 'disabled';\n    } else if (target instanceof HTMLElement || target instanceof SVGElement) {\n        // If not iOS, store the target's original user-select and change to user-select: none\n        // Ignore state since it doesn't apply for non iOS\n        $14c0b72509d70225$var$modifiedElementMap.set(target, target.style.userSelect);\n        target.style.userSelect = 'none';\n    }\n}\nfunction $14c0b72509d70225$export$b0d6fa1ab32e3295(target) {\n    if ($bx7SL$isIOS()) {\n        // If the state is already default, there's nothing to do.\n        // If it is restoring, then there's no need to queue a second restore.\n        if ($14c0b72509d70225$var$state !== 'disabled') return;\n        $14c0b72509d70225$var$state = 'restoring';\n        // There appears to be a delay on iOS where selection still might occur\n        // after pointer up, so wait a bit before removing user-select.\n        setTimeout(()=>{\n            // Wait for any CSS transitions to complete so we don't recompute style\n            // for the whole page in the middle of the animation and cause jank.\n            $bx7SL$runAfterTransition(()=>{\n                // Avoid race conditions\n                if ($14c0b72509d70225$var$state === 'restoring') {\n                    if (document.documentElement.style.webkitUserSelect === 'none') document.documentElement.style.webkitUserSelect = $14c0b72509d70225$var$savedUserSelect || '';\n                    $14c0b72509d70225$var$savedUserSelect = '';\n                    $14c0b72509d70225$var$state = 'default';\n                }\n            });\n        }, 300);\n    } else if (target instanceof HTMLElement || target instanceof SVGElement) // If not iOS, restore the target's original user-select if any\n    // Ignore state since it doesn't apply for non iOS\n    {\n        if (target && $14c0b72509d70225$var$modifiedElementMap.has(target)) {\n            let targetOldUserSelect = $14c0b72509d70225$var$modifiedElementMap.get(target);\n            if (target.style.userSelect === 'none') target.style.userSelect = targetOldUserSelect;\n            if (target.getAttribute('style') === '') target.removeAttribute('style');\n            $14c0b72509d70225$var$modifiedElementMap.delete(target);\n        }\n    }\n}\n\n\n\n\nconst $ae1eeba8b9eafd08$export$5165eccb35aaadb5 = $bx7SL$react.createContext(null);\n$ae1eeba8b9eafd08$export$5165eccb35aaadb5.displayName = 'PressResponderContext';\n\n\n\nfunction $f6c31cce2adf654f$var$usePressResponderContext(props) {\n    // Consume context from <PressResponder> and merge with props.\n    let context = $bx7SL$useContext($ae1eeba8b9eafd08$export$5165eccb35aaadb5);\n    if (context) {\n        let { register: register , ...contextProps } = context;\n        props = $bx7SL$mergeProps(contextProps, props);\n        register();\n    }\n    $bx7SL$useSyncRef(context, props.ref);\n    return props;\n}\nfunction $f6c31cce2adf654f$export$45712eceda6fad21(props) {\n    let { onPress: onPress1 , onPressChange: onPressChange1 , onPressStart: onPressStart1 , onPressEnd: onPressEnd1 , onPressUp: onPressUp1 , isDisabled: isDisabled1 , isPressed: isPressedProp , preventFocusOnPress: preventFocusOnPress , shouldCancelOnPointerExit: shouldCancelOnPointerExit , allowTextSelectionOnPress: allowTextSelectionOnPress , // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    ref: _ , ...domProps } = $f6c31cce2adf654f$var$usePressResponderContext(props);\n    let propsRef = $bx7SL$useRef(null);\n    propsRef.current = {\n        onPress: onPress1,\n        onPressChange: onPressChange1,\n        onPressStart: onPressStart1,\n        onPressEnd: onPressEnd1,\n        onPressUp: onPressUp1,\n        isDisabled: isDisabled1,\n        shouldCancelOnPointerExit: shouldCancelOnPointerExit\n    };\n    let [isPressed, setPressed] = $bx7SL$useState(false);\n    let ref = $bx7SL$useRef({\n        isPressed: false,\n        ignoreEmulatedMouseEvents: false,\n        ignoreClickAfterPress: false,\n        didFirePressStart: false,\n        activePointerId: null,\n        target: null,\n        isOverTarget: false,\n        pointerType: null\n    });\n    let { addGlobalListener: addGlobalListener , removeAllGlobalListeners: removeAllGlobalListeners  } = $bx7SL$useGlobalListeners();\n    let pressProps1 = $bx7SL$useMemo(()=>{\n        let state = ref.current;\n        let triggerPressStart = (originalEvent, pointerType)=>{\n            let { onPressStart: onPressStart , onPressChange: onPressChange , isDisabled: isDisabled  } = propsRef.current;\n            if (isDisabled || state.didFirePressStart) return;\n            if (onPressStart) onPressStart({\n                type: 'pressstart',\n                pointerType: pointerType,\n                target: originalEvent.currentTarget,\n                shiftKey: originalEvent.shiftKey,\n                metaKey: originalEvent.metaKey,\n                ctrlKey: originalEvent.ctrlKey,\n                altKey: originalEvent.altKey\n            });\n            if (onPressChange) onPressChange(true);\n            state.didFirePressStart = true;\n            setPressed(true);\n        };\n        let triggerPressEnd = (originalEvent, pointerType, wasPressed = true)=>{\n            let { onPressEnd: onPressEnd , onPressChange: onPressChange , onPress: onPress , isDisabled: isDisabled  } = propsRef.current;\n            if (!state.didFirePressStart) return;\n            state.ignoreClickAfterPress = true;\n            state.didFirePressStart = false;\n            if (onPressEnd) onPressEnd({\n                type: 'pressend',\n                pointerType: pointerType,\n                target: originalEvent.currentTarget,\n                shiftKey: originalEvent.shiftKey,\n                metaKey: originalEvent.metaKey,\n                ctrlKey: originalEvent.ctrlKey,\n                altKey: originalEvent.altKey\n            });\n            if (onPressChange) onPressChange(false);\n            setPressed(false);\n            if (onPress && wasPressed && !isDisabled) onPress({\n                type: 'press',\n                pointerType: pointerType,\n                target: originalEvent.currentTarget,\n                shiftKey: originalEvent.shiftKey,\n                metaKey: originalEvent.metaKey,\n                ctrlKey: originalEvent.ctrlKey,\n                altKey: originalEvent.altKey\n            });\n        };\n        let triggerPressUp = (originalEvent, pointerType)=>{\n            let { onPressUp: onPressUp , isDisabled: isDisabled  } = propsRef.current;\n            if (isDisabled) return;\n            if (onPressUp) onPressUp({\n                type: 'pressup',\n                pointerType: pointerType,\n                target: originalEvent.currentTarget,\n                shiftKey: originalEvent.shiftKey,\n                metaKey: originalEvent.metaKey,\n                ctrlKey: originalEvent.ctrlKey,\n                altKey: originalEvent.altKey\n            });\n        };\n        let cancel = (e)=>{\n            if (state.isPressed) {\n                if (state.isOverTarget) triggerPressEnd($f6c31cce2adf654f$var$createEvent(state.target, e), state.pointerType, false);\n                state.isPressed = false;\n                state.isOverTarget = false;\n                state.activePointerId = null;\n                state.pointerType = null;\n                removeAllGlobalListeners();\n                if (!allowTextSelectionOnPress) $14c0b72509d70225$export$b0d6fa1ab32e3295(state.target);\n            }\n        };\n        let pressProps = {\n            onKeyDown (e) {\n                if ($f6c31cce2adf654f$var$isValidKeyboardEvent(e.nativeEvent, e.currentTarget) && e.currentTarget.contains(e.target)) {\n                    if ($f6c31cce2adf654f$var$shouldPreventDefaultKeyboard(e.target, e.key)) e.preventDefault();\n                    e.stopPropagation();\n                    // If the event is repeating, it may have started on a different element\n                    // after which focus moved to the current element. Ignore these events and\n                    // only handle the first key down event.\n                    if (!state.isPressed && !e.repeat) {\n                        state.target = e.currentTarget;\n                        state.isPressed = true;\n                        triggerPressStart(e, 'keyboard');\n                        // Focus may move before the key up event, so register the event on the document\n                        // instead of the same element where the key down event occurred.\n                        addGlobalListener(document, 'keyup', onKeyUp, false);\n                    }\n                } else if (e.key === 'Enter' && $f6c31cce2adf654f$var$isHTMLAnchorLink(e.currentTarget)) // If the target is a link, we won't have handled this above because we want the default\n                // browser behavior to open the link when pressing Enter. But we still need to prevent\n                // default so that elements above do not also handle it (e.g. table row).\n                e.stopPropagation();\n            },\n            onKeyUp (e) {\n                if ($f6c31cce2adf654f$var$isValidKeyboardEvent(e.nativeEvent, e.currentTarget) && !e.repeat && e.currentTarget.contains(e.target)) triggerPressUp($f6c31cce2adf654f$var$createEvent(state.target, e), 'keyboard');\n            },\n            onClick (e) {\n                if (e && !e.currentTarget.contains(e.target)) return;\n                if (e && e.button === 0) {\n                    e.stopPropagation();\n                    if (isDisabled1) e.preventDefault();\n                    // If triggered from a screen reader or by using element.click(),\n                    // trigger as if it were a keyboard click.\n                    if (!state.ignoreClickAfterPress && !state.ignoreEmulatedMouseEvents && (state.pointerType === 'virtual' || $bx7SL$isVirtualClick(e.nativeEvent))) {\n                        // Ensure the element receives focus (VoiceOver on iOS does not do this)\n                        if (!isDisabled1 && !preventFocusOnPress) $bx7SL$focusWithoutScrolling(e.currentTarget);\n                        triggerPressStart(e, 'virtual');\n                        triggerPressUp(e, 'virtual');\n                        triggerPressEnd(e, 'virtual');\n                    }\n                    state.ignoreEmulatedMouseEvents = false;\n                    state.ignoreClickAfterPress = false;\n                }\n            }\n        };\n        let onKeyUp = (e)=>{\n            if (state.isPressed && $f6c31cce2adf654f$var$isValidKeyboardEvent(e, state.target)) {\n                if ($f6c31cce2adf654f$var$shouldPreventDefaultKeyboard(e.target, e.key)) e.preventDefault();\n                e.stopPropagation();\n                state.isPressed = false;\n                let target = e.target;\n                triggerPressEnd($f6c31cce2adf654f$var$createEvent(state.target, e), 'keyboard', state.target.contains(target));\n                removeAllGlobalListeners();\n                // If the target is a link, trigger the click method to open the URL,\n                // but defer triggering pressEnd until onClick event handler.\n                if (state.target instanceof HTMLElement && state.target.contains(target) && ($f6c31cce2adf654f$var$isHTMLAnchorLink(state.target) || state.target.getAttribute('role') === 'link')) state.target.click();\n            }\n        };\n        if (typeof PointerEvent !== 'undefined') {\n            pressProps.onPointerDown = (e)=>{\n                // Only handle left clicks, and ignore events that bubbled through portals.\n                if (e.button !== 0 || !e.currentTarget.contains(e.target)) return;\n                // iOS safari fires pointer events from VoiceOver with incorrect coordinates/target.\n                // Ignore and let the onClick handler take care of it instead.\n                // https://bugs.webkit.org/show_bug.cgi?id=222627\n                // https://bugs.webkit.org/show_bug.cgi?id=223202\n                if ($bx7SL$isVirtualPointerEvent(e.nativeEvent)) {\n                    state.pointerType = 'virtual';\n                    return;\n                }\n                // Due to browser inconsistencies, especially on mobile browsers, we prevent\n                // default on pointer down and handle focusing the pressable element ourselves.\n                if ($f6c31cce2adf654f$var$shouldPreventDefault(e.currentTarget)) e.preventDefault();\n                state.pointerType = e.pointerType;\n                e.stopPropagation();\n                if (!state.isPressed) {\n                    state.isPressed = true;\n                    state.isOverTarget = true;\n                    state.activePointerId = e.pointerId;\n                    state.target = e.currentTarget;\n                    if (!isDisabled1 && !preventFocusOnPress) $bx7SL$focusWithoutScrolling(e.currentTarget);\n                    if (!allowTextSelectionOnPress) $14c0b72509d70225$export$16a4697467175487(state.target);\n                    triggerPressStart(e, state.pointerType);\n                    addGlobalListener(document, 'pointermove', onPointerMove, false);\n                    addGlobalListener(document, 'pointerup', onPointerUp, false);\n                    addGlobalListener(document, 'pointercancel', onPointerCancel, false);\n                }\n            };\n            pressProps.onMouseDown = (e)=>{\n                if (!e.currentTarget.contains(e.target)) return;\n                if (e.button === 0) {\n                    // Chrome and Firefox on touch Windows devices require mouse down events\n                    // to be canceled in addition to pointer events, or an extra asynchronous\n                    // focus event will be fired.\n                    if ($f6c31cce2adf654f$var$shouldPreventDefault(e.currentTarget)) e.preventDefault();\n                    e.stopPropagation();\n                }\n            };\n            pressProps.onPointerUp = (e)=>{\n                // iOS fires pointerup with zero width and height, so check the pointerType recorded during pointerdown.\n                if (!e.currentTarget.contains(e.target) || state.pointerType === 'virtual') return;\n                // Only handle left clicks\n                // Safari on iOS sometimes fires pointerup events, even\n                // when the touch isn't over the target, so double check.\n                if (e.button === 0 && $f6c31cce2adf654f$var$isOverTarget(e, e.currentTarget)) triggerPressUp(e, state.pointerType || e.pointerType);\n            };\n            // Safari on iOS < 13.2 does not implement pointerenter/pointerleave events correctly.\n            // Use pointer move events instead to implement our own hit testing.\n            // See https://bugs.webkit.org/show_bug.cgi?id=199803\n            let onPointerMove = (e)=>{\n                if (e.pointerId !== state.activePointerId) return;\n                if ($f6c31cce2adf654f$var$isOverTarget(e, state.target)) {\n                    if (!state.isOverTarget) {\n                        state.isOverTarget = true;\n                        triggerPressStart($f6c31cce2adf654f$var$createEvent(state.target, e), state.pointerType);\n                    }\n                } else if (state.isOverTarget) {\n                    state.isOverTarget = false;\n                    triggerPressEnd($f6c31cce2adf654f$var$createEvent(state.target, e), state.pointerType, false);\n                    if (propsRef.current.shouldCancelOnPointerExit) cancel(e);\n                }\n            };\n            let onPointerUp = (e)=>{\n                if (e.pointerId === state.activePointerId && state.isPressed && e.button === 0) {\n                    if ($f6c31cce2adf654f$var$isOverTarget(e, state.target)) triggerPressEnd($f6c31cce2adf654f$var$createEvent(state.target, e), state.pointerType);\n                    else if (state.isOverTarget) triggerPressEnd($f6c31cce2adf654f$var$createEvent(state.target, e), state.pointerType, false);\n                    state.isPressed = false;\n                    state.isOverTarget = false;\n                    state.activePointerId = null;\n                    state.pointerType = null;\n                    removeAllGlobalListeners();\n                    if (!allowTextSelectionOnPress) $14c0b72509d70225$export$b0d6fa1ab32e3295(state.target);\n                }\n            };\n            let onPointerCancel = (e)=>{\n                cancel(e);\n            };\n            pressProps.onDragStart = (e)=>{\n                if (!e.currentTarget.contains(e.target)) return;\n                // Safari does not call onPointerCancel when a drag starts, whereas Chrome and Firefox do.\n                cancel(e);\n            };\n        } else {\n            pressProps.onMouseDown = (e)=>{\n                // Only handle left clicks\n                if (e.button !== 0 || !e.currentTarget.contains(e.target)) return;\n                // Due to browser inconsistencies, especially on mobile browsers, we prevent\n                // default on mouse down and handle focusing the pressable element ourselves.\n                if ($f6c31cce2adf654f$var$shouldPreventDefault(e.currentTarget)) e.preventDefault();\n                e.stopPropagation();\n                if (state.ignoreEmulatedMouseEvents) return;\n                state.isPressed = true;\n                state.isOverTarget = true;\n                state.target = e.currentTarget;\n                state.pointerType = $bx7SL$isVirtualClick(e.nativeEvent) ? 'virtual' : 'mouse';\n                if (!isDisabled1 && !preventFocusOnPress) $bx7SL$focusWithoutScrolling(e.currentTarget);\n                triggerPressStart(e, state.pointerType);\n                addGlobalListener(document, 'mouseup', onMouseUp, false);\n            };\n            pressProps.onMouseEnter = (e)=>{\n                if (!e.currentTarget.contains(e.target)) return;\n                e.stopPropagation();\n                if (state.isPressed && !state.ignoreEmulatedMouseEvents) {\n                    state.isOverTarget = true;\n                    triggerPressStart(e, state.pointerType);\n                }\n            };\n            pressProps.onMouseLeave = (e)=>{\n                if (!e.currentTarget.contains(e.target)) return;\n                e.stopPropagation();\n                if (state.isPressed && !state.ignoreEmulatedMouseEvents) {\n                    state.isOverTarget = false;\n                    triggerPressEnd(e, state.pointerType, false);\n                    if (propsRef.current.shouldCancelOnPointerExit) cancel(e);\n                }\n            };\n            pressProps.onMouseUp = (e)=>{\n                if (!e.currentTarget.contains(e.target)) return;\n                if (!state.ignoreEmulatedMouseEvents && e.button === 0) triggerPressUp(e, state.pointerType);\n            };\n            let onMouseUp = (e)=>{\n                // Only handle left clicks\n                if (e.button !== 0) return;\n                state.isPressed = false;\n                removeAllGlobalListeners();\n                if (state.ignoreEmulatedMouseEvents) {\n                    state.ignoreEmulatedMouseEvents = false;\n                    return;\n                }\n                if ($f6c31cce2adf654f$var$isOverTarget(e, state.target)) triggerPressEnd($f6c31cce2adf654f$var$createEvent(state.target, e), state.pointerType);\n                else if (state.isOverTarget) triggerPressEnd($f6c31cce2adf654f$var$createEvent(state.target, e), state.pointerType, false);\n                state.isOverTarget = false;\n            };\n            pressProps.onTouchStart = (e)=>{\n                if (!e.currentTarget.contains(e.target)) return;\n                e.stopPropagation();\n                let touch = $f6c31cce2adf654f$var$getTouchFromEvent(e.nativeEvent);\n                if (!touch) return;\n                state.activePointerId = touch.identifier;\n                state.ignoreEmulatedMouseEvents = true;\n                state.isOverTarget = true;\n                state.isPressed = true;\n                state.target = e.currentTarget;\n                state.pointerType = 'touch';\n                // Due to browser inconsistencies, especially on mobile browsers, we prevent default\n                // on the emulated mouse event and handle focusing the pressable element ourselves.\n                if (!isDisabled1 && !preventFocusOnPress) $bx7SL$focusWithoutScrolling(e.currentTarget);\n                if (!allowTextSelectionOnPress) $14c0b72509d70225$export$16a4697467175487(state.target);\n                triggerPressStart(e, state.pointerType);\n                addGlobalListener(window, 'scroll', onScroll, true);\n            };\n            pressProps.onTouchMove = (e)=>{\n                if (!e.currentTarget.contains(e.target)) return;\n                e.stopPropagation();\n                if (!state.isPressed) return;\n                let touch = $f6c31cce2adf654f$var$getTouchById(e.nativeEvent, state.activePointerId);\n                if (touch && $f6c31cce2adf654f$var$isOverTarget(touch, e.currentTarget)) {\n                    if (!state.isOverTarget) {\n                        state.isOverTarget = true;\n                        triggerPressStart(e, state.pointerType);\n                    }\n                } else if (state.isOverTarget) {\n                    state.isOverTarget = false;\n                    triggerPressEnd(e, state.pointerType, false);\n                    if (propsRef.current.shouldCancelOnPointerExit) cancel(e);\n                }\n            };\n            pressProps.onTouchEnd = (e)=>{\n                if (!e.currentTarget.contains(e.target)) return;\n                e.stopPropagation();\n                if (!state.isPressed) return;\n                let touch = $f6c31cce2adf654f$var$getTouchById(e.nativeEvent, state.activePointerId);\n                if (touch && $f6c31cce2adf654f$var$isOverTarget(touch, e.currentTarget)) {\n                    triggerPressUp(e, state.pointerType);\n                    triggerPressEnd(e, state.pointerType);\n                } else if (state.isOverTarget) triggerPressEnd(e, state.pointerType, false);\n                state.isPressed = false;\n                state.activePointerId = null;\n                state.isOverTarget = false;\n                state.ignoreEmulatedMouseEvents = true;\n                if (!allowTextSelectionOnPress) $14c0b72509d70225$export$b0d6fa1ab32e3295(state.target);\n                removeAllGlobalListeners();\n            };\n            pressProps.onTouchCancel = (e)=>{\n                if (!e.currentTarget.contains(e.target)) return;\n                e.stopPropagation();\n                if (state.isPressed) cancel(e);\n            };\n            let onScroll = (e)=>{\n                if (state.isPressed && e.target.contains(state.target)) cancel({\n                    currentTarget: state.target,\n                    shiftKey: false,\n                    ctrlKey: false,\n                    metaKey: false,\n                    altKey: false\n                });\n            };\n            pressProps.onDragStart = (e)=>{\n                if (!e.currentTarget.contains(e.target)) return;\n                cancel(e);\n            };\n        }\n        return pressProps;\n    }, [\n        addGlobalListener,\n        isDisabled1,\n        preventFocusOnPress,\n        removeAllGlobalListeners,\n        allowTextSelectionOnPress\n    ]);\n    // Remove user-select: none in case component unmounts immediately after pressStart\n    // eslint-disable-next-line arrow-body-style\n    $bx7SL$useEffect(()=>{\n        return ()=>{\n            if (!allowTextSelectionOnPress) $14c0b72509d70225$export$b0d6fa1ab32e3295(ref.current.target);\n        };\n    }, [\n        allowTextSelectionOnPress\n    ]);\n    return {\n        isPressed: isPressedProp || isPressed,\n        pressProps: $bx7SL$mergeProps(domProps, pressProps1)\n    };\n}\nfunction $f6c31cce2adf654f$var$isHTMLAnchorLink(target) {\n    return target.tagName === 'A' && target.hasAttribute('href');\n}\nfunction $f6c31cce2adf654f$var$isValidKeyboardEvent(event, currentTarget) {\n    const { key: key , code: code  } = event;\n    const element = currentTarget;\n    const role = element.getAttribute('role');\n    // Accessibility for keyboards. Space and Enter only.\n    // \"Spacebar\" is for IE 11\n    return (key === 'Enter' || key === ' ' || key === 'Spacebar' || code === 'Space') && !(element instanceof HTMLInputElement && !$f6c31cce2adf654f$var$isValidInputKey(element, key) || element instanceof HTMLTextAreaElement || element.isContentEditable) && (!$f6c31cce2adf654f$var$isHTMLAnchorLink(element) || role === 'button' && key !== 'Enter') && // An element with role='link' should only trigger with Enter key\n    !(role === 'link' && key !== 'Enter');\n}\nfunction $f6c31cce2adf654f$var$getTouchFromEvent(event) {\n    const { targetTouches: targetTouches  } = event;\n    if (targetTouches.length > 0) return targetTouches[0];\n    return null;\n}\nfunction $f6c31cce2adf654f$var$getTouchById(event, pointerId) {\n    const changedTouches = event.changedTouches;\n    for(let i = 0; i < changedTouches.length; i++){\n        const touch = changedTouches[i];\n        if (touch.identifier === pointerId) return touch;\n    }\n    return null;\n}\nfunction $f6c31cce2adf654f$var$createEvent(target, e) {\n    return {\n        currentTarget: target,\n        shiftKey: e.shiftKey,\n        ctrlKey: e.ctrlKey,\n        metaKey: e.metaKey,\n        altKey: e.altKey\n    };\n}\nfunction $f6c31cce2adf654f$var$getPointClientRect(point) {\n    let offsetX = point.width / 2 || point.radiusX || 0;\n    let offsetY = point.height / 2 || point.radiusY || 0;\n    return {\n        top: point.clientY - offsetY,\n        right: point.clientX + offsetX,\n        bottom: point.clientY + offsetY,\n        left: point.clientX - offsetX\n    };\n}\nfunction $f6c31cce2adf654f$var$areRectanglesOverlapping(a, b) {\n    // check if they cannot overlap on x axis\n    if (a.left > b.right || b.left > a.right) return false;\n    // check if they cannot overlap on y axis\n    if (a.top > b.bottom || b.top > a.bottom) return false;\n    return true;\n}\nfunction $f6c31cce2adf654f$var$isOverTarget(point, target) {\n    let rect = target.getBoundingClientRect();\n    let pointRect = $f6c31cce2adf654f$var$getPointClientRect(point);\n    return $f6c31cce2adf654f$var$areRectanglesOverlapping(rect, pointRect);\n}\nfunction $f6c31cce2adf654f$var$shouldPreventDefault(target) {\n    // We cannot prevent default if the target is a draggable element.\n    return !(target instanceof HTMLElement) || !target.draggable;\n}\nfunction $f6c31cce2adf654f$var$shouldPreventDefaultKeyboard(target, key) {\n    if (target instanceof HTMLInputElement) return !$f6c31cce2adf654f$var$isValidInputKey(target, key);\n    if (target instanceof HTMLButtonElement) return target.type !== 'submit';\n    return true;\n}\nconst $f6c31cce2adf654f$var$nonTextInputTypes = new Set([\n    'checkbox',\n    'radio',\n    'range',\n    'color',\n    'file',\n    'image',\n    'button',\n    'submit',\n    'reset'\n]);\nfunction $f6c31cce2adf654f$var$isValidInputKey(target, key) {\n    // Only space should toggle checkboxes and radios, not enter.\n    return target.type === 'checkbox' || target.type === 'radio' ? key === ' ' : $f6c31cce2adf654f$var$nonTextInputTypes.has(target.type);\n}\n\n\n\nconst $3b117e43dc0ca95d$export$27c701ed9e449e99 = /*#__PURE__*/ $bx7SL$react.forwardRef(({ children: children , ...props }, ref)=>{\n    let newRef = $bx7SL$useRef();\n    ref = ref !== null && ref !== void 0 ? ref : newRef;\n    let { pressProps: pressProps  } = $f6c31cce2adf654f$export$45712eceda6fad21({\n        ...props,\n        ref: ref\n    });\n    let child = $bx7SL$react.Children.only(children);\n    return(/*#__PURE__*/ $bx7SL$react.cloneElement(child, // @ts-ignore\n    {\n        ref: ref,\n        ...$bx7SL$mergeProps(child.props, pressProps)\n    }));\n});\n\n\n\n\n\nconst $f1ab8c75478c6f73$export$3351871ee4b288b8 = /*#__PURE__*/ $bx7SL$react.forwardRef(({ children: children , ...props }, ref)=>{\n    let isRegistered = $bx7SL$useRef(false);\n    let prevContext = $bx7SL$useContext($ae1eeba8b9eafd08$export$5165eccb35aaadb5);\n    let context = $bx7SL$mergeProps(prevContext || {\n    }, {\n        ...props,\n        ref: ref || (prevContext === null || prevContext === void 0 ? void 0 : prevContext.ref),\n        register () {\n            isRegistered.current = true;\n            if (prevContext) prevContext.register();\n        }\n    });\n    $bx7SL$useSyncRef(prevContext, ref);\n    $bx7SL$useEffect(()=>{\n        if (!isRegistered.current) console.warn(\"A PressResponder was rendered without a pressable child. Either call the usePress hook, or wrap your DOM node with <Pressable> component.\");\n    }, []);\n    return(/*#__PURE__*/ $bx7SL$react.createElement($ae1eeba8b9eafd08$export$5165eccb35aaadb5.Provider, {\n        value: context\n    }, children));\n});\n\n\n\n\n\nclass $8a9cb279dc87e130$export$905e7fc544a71f36 {\n    isDefaultPrevented() {\n        return this.nativeEvent.defaultPrevented;\n    }\n    preventDefault() {\n        this.defaultPrevented = true;\n        this.nativeEvent.preventDefault();\n    }\n    stopPropagation() {\n        this.nativeEvent.stopPropagation();\n        this.isPropagationStopped = ()=>true\n        ;\n    }\n    isPropagationStopped() {\n        return false;\n    }\n    persist() {\n    }\n    constructor(type, nativeEvent){\n        this.nativeEvent = nativeEvent;\n        this.target = nativeEvent.target;\n        this.currentTarget = nativeEvent.currentTarget;\n        this.relatedTarget = nativeEvent.relatedTarget;\n        this.bubbles = nativeEvent.bubbles;\n        this.cancelable = nativeEvent.cancelable;\n        this.defaultPrevented = nativeEvent.defaultPrevented;\n        this.eventPhase = nativeEvent.eventPhase;\n        this.isTrusted = nativeEvent.isTrusted;\n        this.timeStamp = nativeEvent.timeStamp;\n        this.type = type;\n    }\n}\nfunction $8a9cb279dc87e130$export$715c682d09d639cc(onBlur) {\n    let stateRef = $bx7SL$useRef({\n        isFocused: false,\n        onBlur: onBlur,\n        observer: null\n    });\n    stateRef.current.onBlur = onBlur;\n    // Clean up MutationObserver on unmount. See below.\n    // eslint-disable-next-line arrow-body-style\n    $bx7SL$useLayoutEffect(()=>{\n        const state = stateRef.current;\n        return ()=>{\n            if (state.observer) {\n                state.observer.disconnect();\n                state.observer = null;\n            }\n        };\n    }, []);\n    // This function is called during a React onFocus event.\n    return $bx7SL$useCallback((e1)=>{\n        // React does not fire onBlur when an element is disabled. https://github.com/facebook/react/issues/9142\n        // Most browsers fire a native focusout event in this case, except for Firefox. In that case, we use a\n        // MutationObserver to watch for the disabled attribute, and dispatch these events ourselves.\n        // For browsers that do, focusout fires before the MutationObserver, so onBlur should not fire twice.\n        if (e1.target instanceof HTMLButtonElement || e1.target instanceof HTMLInputElement || e1.target instanceof HTMLTextAreaElement || e1.target instanceof HTMLSelectElement) {\n            stateRef.current.isFocused = true;\n            let target = e1.target;\n            let onBlurHandler = (e)=>{\n                var // For backward compatibility, dispatch a (fake) React synthetic event.\n                _current, ref;\n                stateRef.current.isFocused = false;\n                if (target.disabled) (ref = (_current = stateRef.current).onBlur) === null || ref === void 0 ? void 0 : ref.call(_current, new $8a9cb279dc87e130$export$905e7fc544a71f36('blur', e));\n                // We no longer need the MutationObserver once the target is blurred.\n                if (stateRef.current.observer) {\n                    stateRef.current.observer.disconnect();\n                    stateRef.current.observer = null;\n                }\n            };\n            target.addEventListener('focusout', onBlurHandler, {\n                once: true\n            });\n            stateRef.current.observer = new MutationObserver(()=>{\n                if (stateRef.current.isFocused && target.disabled) {\n                    stateRef.current.observer.disconnect();\n                    target.dispatchEvent(new FocusEvent('blur'));\n                    target.dispatchEvent(new FocusEvent('focusout', {\n                        bubbles: true\n                    }));\n                }\n            });\n            stateRef.current.observer.observe(target, {\n                attributes: true,\n                attributeFilter: [\n                    'disabled'\n                ]\n            });\n        }\n    }, []);\n}\n\n\nfunction $a1ea59d68270f0dd$export$f8168d8dd8fd66e6(props) {\n    let { isDisabled: isDisabled , onFocus: onFocusProp , onBlur: onBlurProp , onFocusChange: onFocusChange  } = props;\n    const onBlur = $bx7SL$useCallback((e)=>{\n        if (e.target === e.currentTarget) {\n            if (onBlurProp) onBlurProp(e);\n            if (onFocusChange) onFocusChange(false);\n            return true;\n        }\n    }, [\n        onBlurProp,\n        onFocusChange\n    ]);\n    const onSyntheticFocus = $8a9cb279dc87e130$export$715c682d09d639cc(onBlur);\n    const onFocus = $bx7SL$useCallback((e)=>{\n        if (e.target === e.currentTarget) {\n            if (onFocusProp) onFocusProp(e);\n            if (onFocusChange) onFocusChange(true);\n            onSyntheticFocus(e);\n        }\n    }, [\n        onFocusChange,\n        onFocusProp,\n        onSyntheticFocus\n    ]);\n    return {\n        focusProps: {\n            onFocus: !isDisabled && (onFocusProp || onFocusChange || onBlurProp) ? onFocus : undefined,\n            onBlur: !isDisabled && (onBlurProp || onFocusChange) ? onBlur : null\n        }\n    };\n}\n\n\n\n\nlet $507fabe10e71c6fb$var$currentModality = null;\nlet $507fabe10e71c6fb$var$changeHandlers = new Set();\nlet $507fabe10e71c6fb$var$hasSetupGlobalListeners = false;\nlet $507fabe10e71c6fb$var$hasEventBeforeFocus = false;\nlet $507fabe10e71c6fb$var$hasBlurredWindowRecently = false;\n// Only Tab or Esc keys will make focus visible on text input elements\nconst $507fabe10e71c6fb$var$FOCUS_VISIBLE_INPUT_KEYS = {\n    Tab: true,\n    Escape: true\n};\nfunction $507fabe10e71c6fb$var$triggerChangeHandlers(modality, e) {\n    for (let handler of $507fabe10e71c6fb$var$changeHandlers)handler(modality, e);\n}\n/**\n * Helper function to determine if a KeyboardEvent is unmodified and could make keyboard focus styles visible.\n */ function $507fabe10e71c6fb$var$isValidKey(e) {\n    // Control and Shift keys trigger when navigating back to the tab with keyboard.\n    return !(e.metaKey || !$bx7SL$isMac() && e.altKey || e.ctrlKey || e.key === 'Control' || e.key === 'Shift' || e.key === 'Meta');\n}\nfunction $507fabe10e71c6fb$var$handleKeyboardEvent(e) {\n    $507fabe10e71c6fb$var$hasEventBeforeFocus = true;\n    if ($507fabe10e71c6fb$var$isValidKey(e)) {\n        $507fabe10e71c6fb$var$currentModality = 'keyboard';\n        $507fabe10e71c6fb$var$triggerChangeHandlers('keyboard', e);\n    }\n}\nfunction $507fabe10e71c6fb$var$handlePointerEvent(e) {\n    $507fabe10e71c6fb$var$currentModality = 'pointer';\n    if (e.type === 'mousedown' || e.type === 'pointerdown') {\n        $507fabe10e71c6fb$var$hasEventBeforeFocus = true;\n        $507fabe10e71c6fb$var$triggerChangeHandlers('pointer', e);\n    }\n}\nfunction $507fabe10e71c6fb$var$handleClickEvent(e) {\n    if ($bx7SL$isVirtualClick(e)) {\n        $507fabe10e71c6fb$var$hasEventBeforeFocus = true;\n        $507fabe10e71c6fb$var$currentModality = 'virtual';\n    }\n}\nfunction $507fabe10e71c6fb$var$handleFocusEvent(e) {\n    // Firefox fires two extra focus events when the user first clicks into an iframe:\n    // first on the window, then on the document. We ignore these events so they don't\n    // cause keyboard focus rings to appear.\n    if (e.target === window || e.target === document) return;\n    // If a focus event occurs without a preceding keyboard or pointer event, switch to virtual modality.\n    // This occurs, for example, when navigating a form with the next/previous buttons on iOS.\n    if (!$507fabe10e71c6fb$var$hasEventBeforeFocus && !$507fabe10e71c6fb$var$hasBlurredWindowRecently) {\n        $507fabe10e71c6fb$var$currentModality = 'virtual';\n        $507fabe10e71c6fb$var$triggerChangeHandlers('virtual', e);\n    }\n    $507fabe10e71c6fb$var$hasEventBeforeFocus = false;\n    $507fabe10e71c6fb$var$hasBlurredWindowRecently = false;\n}\nfunction $507fabe10e71c6fb$var$handleWindowBlur() {\n    // When the window is blurred, reset state. This is necessary when tabbing out of the window,\n    // for example, since a subsequent focus event won't be fired.\n    $507fabe10e71c6fb$var$hasEventBeforeFocus = false;\n    $507fabe10e71c6fb$var$hasBlurredWindowRecently = true;\n}\n/**\n * Setup global event listeners to control when keyboard focus style should be visible.\n */ function $507fabe10e71c6fb$var$setupGlobalFocusEvents() {\n    if (typeof window === 'undefined' || $507fabe10e71c6fb$var$hasSetupGlobalListeners) return;\n    // Programmatic focus() calls shouldn't affect the current input modality.\n    // However, we need to detect other cases when a focus event occurs without\n    // a preceding user event (e.g. screen reader focus). Overriding the focus\n    // method on HTMLElement.prototype is a bit hacky, but works.\n    let focus = HTMLElement.prototype.focus;\n    HTMLElement.prototype.focus = function() {\n        $507fabe10e71c6fb$var$hasEventBeforeFocus = true;\n        focus.apply(this, arguments);\n    };\n    document.addEventListener('keydown', $507fabe10e71c6fb$var$handleKeyboardEvent, true);\n    document.addEventListener('keyup', $507fabe10e71c6fb$var$handleKeyboardEvent, true);\n    document.addEventListener('click', $507fabe10e71c6fb$var$handleClickEvent, true);\n    // Register focus events on the window so they are sure to happen\n    // before React's event listeners (registered on the document).\n    window.addEventListener('focus', $507fabe10e71c6fb$var$handleFocusEvent, true);\n    window.addEventListener('blur', $507fabe10e71c6fb$var$handleWindowBlur, false);\n    if (typeof PointerEvent !== 'undefined') {\n        document.addEventListener('pointerdown', $507fabe10e71c6fb$var$handlePointerEvent, true);\n        document.addEventListener('pointermove', $507fabe10e71c6fb$var$handlePointerEvent, true);\n        document.addEventListener('pointerup', $507fabe10e71c6fb$var$handlePointerEvent, true);\n    } else {\n        document.addEventListener('mousedown', $507fabe10e71c6fb$var$handlePointerEvent, true);\n        document.addEventListener('mousemove', $507fabe10e71c6fb$var$handlePointerEvent, true);\n        document.addEventListener('mouseup', $507fabe10e71c6fb$var$handlePointerEvent, true);\n    }\n    $507fabe10e71c6fb$var$hasSetupGlobalListeners = true;\n}\nif (typeof document !== 'undefined') {\n    if (document.readyState !== 'loading') $507fabe10e71c6fb$var$setupGlobalFocusEvents();\n    else document.addEventListener('DOMContentLoaded', $507fabe10e71c6fb$var$setupGlobalFocusEvents);\n}\nfunction $507fabe10e71c6fb$export$b9b3dfddab17db27() {\n    return $507fabe10e71c6fb$var$currentModality !== 'pointer';\n}\nfunction $507fabe10e71c6fb$export$630ff653c5ada6a9() {\n    return $507fabe10e71c6fb$var$currentModality;\n}\nfunction $507fabe10e71c6fb$export$8397ddfc504fdb9a(modality) {\n    $507fabe10e71c6fb$var$currentModality = modality;\n    $507fabe10e71c6fb$var$triggerChangeHandlers(modality, null);\n}\nfunction $507fabe10e71c6fb$export$98e20ec92f614cfe() {\n    $507fabe10e71c6fb$var$setupGlobalFocusEvents();\n    let [modality, setModality] = $bx7SL$useState($507fabe10e71c6fb$var$currentModality);\n    $bx7SL$useEffect(()=>{\n        let handler = ()=>{\n            setModality($507fabe10e71c6fb$var$currentModality);\n        };\n        $507fabe10e71c6fb$var$changeHandlers.add(handler);\n        return ()=>{\n            $507fabe10e71c6fb$var$changeHandlers.delete(handler);\n        };\n    }, []);\n    return modality;\n}\n/**\n * If this is attached to text input component, return if the event is a focus event (Tab/Escape keys pressed) so that\n * focus visible style can be properly set.\n */ function $507fabe10e71c6fb$var$isKeyboardFocusEvent(isTextInput, modality, e) {\n    return !(isTextInput && modality === 'keyboard' && e instanceof KeyboardEvent && !$507fabe10e71c6fb$var$FOCUS_VISIBLE_INPUT_KEYS[e.key]);\n}\nfunction $507fabe10e71c6fb$export$ffd9e5021c1fb2d6(props = {\n}) {\n    let { isTextInput: isTextInput , autoFocus: autoFocus  } = props;\n    let [isFocusVisibleState, setFocusVisible] = $bx7SL$useState(autoFocus || $507fabe10e71c6fb$export$b9b3dfddab17db27());\n    $507fabe10e71c6fb$export$ec71b4b83ac08ec3(($507fabe10e71c6fb$export$b9b3dfddab17db27)=>{\n        setFocusVisible($507fabe10e71c6fb$export$b9b3dfddab17db27);\n    }, [\n        isTextInput\n    ], {\n        isTextInput: isTextInput\n    });\n    return {\n        isFocusVisible: isFocusVisibleState\n    };\n}\nfunction $507fabe10e71c6fb$export$ec71b4b83ac08ec3(fn, deps, opts) {\n    $507fabe10e71c6fb$var$setupGlobalFocusEvents();\n    $bx7SL$useEffect(()=>{\n        let handler = (modality, e)=>{\n            if (!$507fabe10e71c6fb$var$isKeyboardFocusEvent(opts === null || opts === void 0 ? void 0 : opts.isTextInput, modality, e)) return;\n            fn($507fabe10e71c6fb$export$b9b3dfddab17db27());\n        };\n        $507fabe10e71c6fb$var$changeHandlers.add(handler);\n        return ()=>{\n            $507fabe10e71c6fb$var$changeHandlers.delete(handler);\n        };\n    }, deps);\n}\n\n\n\n\nfunction $9ab94262bd0047c7$export$420e68273165f4ec(props) {\n    let { isDisabled: isDisabled , onBlurWithin: onBlurWithin , onFocusWithin: onFocusWithin , onFocusWithinChange: onFocusWithinChange  } = props;\n    let state = $bx7SL$useRef({\n        isFocusWithin: false\n    });\n    let onBlur = $bx7SL$useCallback((e)=>{\n        // We don't want to trigger onBlurWithin and then immediately onFocusWithin again\n        // when moving focus inside the element. Only trigger if the currentTarget doesn't\n        // include the relatedTarget (where focus is moving).\n        if (state.current.isFocusWithin && !e.currentTarget.contains(e.relatedTarget)) {\n            state.current.isFocusWithin = false;\n            if (onBlurWithin) onBlurWithin(e);\n            if (onFocusWithinChange) onFocusWithinChange(false);\n        }\n    }, [\n        onBlurWithin,\n        onFocusWithinChange,\n        state\n    ]);\n    let onSyntheticFocus = $8a9cb279dc87e130$export$715c682d09d639cc(onBlur);\n    let onFocus = $bx7SL$useCallback((e)=>{\n        if (!state.current.isFocusWithin) {\n            if (onFocusWithin) onFocusWithin(e);\n            if (onFocusWithinChange) onFocusWithinChange(true);\n            state.current.isFocusWithin = true;\n            onSyntheticFocus(e);\n        }\n    }, [\n        onFocusWithin,\n        onFocusWithinChange,\n        onSyntheticFocus\n    ]);\n    if (isDisabled) return {\n        focusWithinProps: {\n            onFocus: null,\n            onBlur: null\n        }\n    };\n    return {\n        focusWithinProps: {\n            onFocus: onFocus,\n            onBlur: onBlur\n        }\n    };\n}\n\n\n\n// iOS fires onPointerEnter twice: once with pointerType=\"touch\" and again with pointerType=\"mouse\".\n// We want to ignore these emulated events so they do not trigger hover behavior.\n// See https://bugs.webkit.org/show_bug.cgi?id=214609.\nlet $6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents = false;\nlet $6179b936705e76d3$var$hoverCount = 0;\nfunction $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents() {\n    $6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents = true;\n    // Clear globalIgnoreEmulatedMouseEvents after a short timeout. iOS fires onPointerEnter\n    // with pointerType=\"mouse\" immediately after onPointerUp and before onFocus. On other\n    // devices that don't have this quirk, we don't want to ignore a mouse hover sometime in\n    // the distant future because a user previously touched the element.\n    setTimeout(()=>{\n        $6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents = false;\n    }, 50);\n}\nfunction $6179b936705e76d3$var$handleGlobalPointerEvent(e) {\n    if (e.pointerType === 'touch') $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents();\n}\nfunction $6179b936705e76d3$var$setupGlobalTouchEvents() {\n    if (typeof document === 'undefined') return;\n    if (typeof PointerEvent !== 'undefined') document.addEventListener('pointerup', $6179b936705e76d3$var$handleGlobalPointerEvent);\n    else document.addEventListener('touchend', $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents);\n    $6179b936705e76d3$var$hoverCount++;\n    return ()=>{\n        $6179b936705e76d3$var$hoverCount--;\n        if ($6179b936705e76d3$var$hoverCount > 0) return;\n        if (typeof PointerEvent !== 'undefined') document.removeEventListener('pointerup', $6179b936705e76d3$var$handleGlobalPointerEvent);\n        else document.removeEventListener('touchend', $6179b936705e76d3$var$setGlobalIgnoreEmulatedMouseEvents);\n    };\n}\nfunction $6179b936705e76d3$export$ae780daf29e6d456(props) {\n    let { onHoverStart: onHoverStart , onHoverChange: onHoverChange , onHoverEnd: onHoverEnd , isDisabled: isDisabled  } = props;\n    let [isHovered, setHovered] = $bx7SL$useState(false);\n    let state = $bx7SL$useRef({\n        isHovered: false,\n        ignoreEmulatedMouseEvents: false,\n        pointerType: '',\n        target: null\n    }).current;\n    $bx7SL$useEffect($6179b936705e76d3$var$setupGlobalTouchEvents, []);\n    let { hoverProps: hoverProps1 , triggerHoverEnd: triggerHoverEnd1  } = $bx7SL$useMemo(()=>{\n        let triggerHoverStart = (event, pointerType)=>{\n            state.pointerType = pointerType;\n            if (isDisabled || pointerType === 'touch' || state.isHovered || !event.currentTarget.contains(event.target)) return;\n            state.isHovered = true;\n            let target = event.currentTarget;\n            state.target = target;\n            if (onHoverStart) onHoverStart({\n                type: 'hoverstart',\n                target: target,\n                pointerType: pointerType\n            });\n            if (onHoverChange) onHoverChange(true);\n            setHovered(true);\n        };\n        let triggerHoverEnd = (event, pointerType)=>{\n            state.pointerType = '';\n            state.target = null;\n            if (pointerType === 'touch' || !state.isHovered) return;\n            state.isHovered = false;\n            let target = event.currentTarget;\n            if (onHoverEnd) onHoverEnd({\n                type: 'hoverend',\n                target: target,\n                pointerType: pointerType\n            });\n            if (onHoverChange) onHoverChange(false);\n            setHovered(false);\n        };\n        let hoverProps = {\n        };\n        if (typeof PointerEvent !== 'undefined') {\n            hoverProps.onPointerEnter = (e)=>{\n                if ($6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents && e.pointerType === 'mouse') return;\n                triggerHoverStart(e, e.pointerType);\n            };\n            hoverProps.onPointerLeave = (e)=>{\n                if (!isDisabled && e.currentTarget.contains(e.target)) triggerHoverEnd(e, e.pointerType);\n            };\n        } else {\n            hoverProps.onTouchStart = ()=>{\n                state.ignoreEmulatedMouseEvents = true;\n            };\n            hoverProps.onMouseEnter = (e)=>{\n                if (!state.ignoreEmulatedMouseEvents && !$6179b936705e76d3$var$globalIgnoreEmulatedMouseEvents) triggerHoverStart(e, 'mouse');\n                state.ignoreEmulatedMouseEvents = false;\n            };\n            hoverProps.onMouseLeave = (e)=>{\n                if (!isDisabled && e.currentTarget.contains(e.target)) triggerHoverEnd(e, 'mouse');\n            };\n        }\n        return {\n            hoverProps: hoverProps,\n            triggerHoverEnd: triggerHoverEnd\n        };\n    }, [\n        onHoverStart,\n        onHoverChange,\n        onHoverEnd,\n        isDisabled,\n        state\n    ]);\n    $bx7SL$useEffect(()=>{\n        // Call the triggerHoverEnd as soon as isDisabled changes to true\n        // Safe to call triggerHoverEnd, it will early return if we aren't currently hovering\n        if (isDisabled) triggerHoverEnd1({\n            currentTarget: state.target\n        }, state.pointerType);\n    }, [\n        isDisabled\n    ]);\n    return {\n        hoverProps: hoverProps1,\n        isHovered: isHovered\n    };\n}\n\n\n\nfunction $e0b6e0b68ec7f50f$export$872b660ac5a1ff98(props) {\n    let { ref: ref , onInteractOutside: onInteractOutside , isDisabled: isDisabled , onInteractOutsideStart: onInteractOutsideStart  } = props;\n    let stateRef = $bx7SL$useRef({\n        isPointerDown: false,\n        ignoreEmulatedMouseEvents: false,\n        onInteractOutside: onInteractOutside,\n        onInteractOutsideStart: onInteractOutsideStart\n    });\n    let state = stateRef.current;\n    state.onInteractOutside = onInteractOutside;\n    state.onInteractOutsideStart = onInteractOutsideStart;\n    $bx7SL$useEffect(()=>{\n        if (isDisabled) return;\n        let onPointerDown = (e)=>{\n            if ($e0b6e0b68ec7f50f$var$isValidEvent(e, ref) && state.onInteractOutside) {\n                if (state.onInteractOutsideStart) state.onInteractOutsideStart(e);\n                state.isPointerDown = true;\n            }\n        };\n        // Use pointer events if available. Otherwise, fall back to mouse and touch events.\n        if (typeof PointerEvent !== 'undefined') {\n            let onPointerUp = (e)=>{\n                if (state.isPointerDown && state.onInteractOutside && $e0b6e0b68ec7f50f$var$isValidEvent(e, ref)) {\n                    state.isPointerDown = false;\n                    state.onInteractOutside(e);\n                }\n            };\n            // changing these to capture phase fixed combobox\n            document.addEventListener('pointerdown', onPointerDown, true);\n            document.addEventListener('pointerup', onPointerUp, true);\n            return ()=>{\n                document.removeEventListener('pointerdown', onPointerDown, true);\n                document.removeEventListener('pointerup', onPointerUp, true);\n            };\n        } else {\n            let onMouseUp = (e)=>{\n                if (state.ignoreEmulatedMouseEvents) state.ignoreEmulatedMouseEvents = false;\n                else if (state.isPointerDown && state.onInteractOutside && $e0b6e0b68ec7f50f$var$isValidEvent(e, ref)) {\n                    state.isPointerDown = false;\n                    state.onInteractOutside(e);\n                }\n            };\n            let onTouchEnd = (e)=>{\n                state.ignoreEmulatedMouseEvents = true;\n                if (state.onInteractOutside && state.isPointerDown && $e0b6e0b68ec7f50f$var$isValidEvent(e, ref)) {\n                    state.isPointerDown = false;\n                    state.onInteractOutside(e);\n                }\n            };\n            document.addEventListener('mousedown', onPointerDown, true);\n            document.addEventListener('mouseup', onMouseUp, true);\n            document.addEventListener('touchstart', onPointerDown, true);\n            document.addEventListener('touchend', onTouchEnd, true);\n            return ()=>{\n                document.removeEventListener('mousedown', onPointerDown, true);\n                document.removeEventListener('mouseup', onMouseUp, true);\n                document.removeEventListener('touchstart', onPointerDown, true);\n                document.removeEventListener('touchend', onTouchEnd, true);\n            };\n        }\n    }, [\n        ref,\n        state,\n        isDisabled\n    ]);\n}\nfunction $e0b6e0b68ec7f50f$var$isValidEvent(event, ref) {\n    if (event.button > 0) return false;\n    // if the event target is no longer in the document\n    if (event.target) {\n        const ownerDocument = event.target.ownerDocument;\n        if (!ownerDocument || !ownerDocument.documentElement.contains(event.target)) return false;\n    }\n    return ref.current && !ref.current.contains(event.target);\n}\n\n\nfunction $93925083ecbb358c$export$48d1ea6320830260(handler) {\n    if (!handler) return;\n    let shouldStopPropagation = true;\n    return (e)=>{\n        let event = {\n            ...e,\n            preventDefault () {\n                e.preventDefault();\n            },\n            isDefaultPrevented () {\n                return e.isDefaultPrevented();\n            },\n            stopPropagation () {\n                console.error('stopPropagation is now the default behavior for events in React Spectrum. You can use continuePropagation() to revert this behavior.');\n            },\n            continuePropagation () {\n                shouldStopPropagation = false;\n            }\n        };\n        handler(event);\n        if (shouldStopPropagation) e.stopPropagation();\n    };\n}\n\n\nfunction $46d819fcbaf35654$export$8f71654801c2f7cd(props) {\n    return {\n        keyboardProps: props.isDisabled ? {\n        } : {\n            onKeyDown: $93925083ecbb358c$export$48d1ea6320830260(props.onKeyDown),\n            onKeyUp: $93925083ecbb358c$export$48d1ea6320830260(props.onKeyUp)\n        }\n    };\n}\n\n\n\n\n\nfunction $e8a7022cf87cba2a$export$36da96379f79f245(props) {\n    let { onMoveStart: onMoveStart , onMove: onMove , onMoveEnd: onMoveEnd  } = props;\n    let state = $bx7SL$useRef({\n        didMove: false,\n        lastPosition: null,\n        id: null\n    });\n    let { addGlobalListener: addGlobalListener , removeGlobalListener: removeGlobalListener  } = $bx7SL$useGlobalListeners();\n    let moveProps1 = $bx7SL$useMemo(()=>{\n        let moveProps = {\n        };\n        let start = ()=>{\n            $14c0b72509d70225$export$16a4697467175487();\n            state.current.didMove = false;\n        };\n        let move = (originalEvent, pointerType, deltaX, deltaY)=>{\n            if (deltaX === 0 && deltaY === 0) return;\n            if (!state.current.didMove) {\n                state.current.didMove = true;\n                onMoveStart === null || onMoveStart === void 0 ? void 0 : onMoveStart({\n                    type: 'movestart',\n                    pointerType: pointerType,\n                    shiftKey: originalEvent.shiftKey,\n                    metaKey: originalEvent.metaKey,\n                    ctrlKey: originalEvent.ctrlKey,\n                    altKey: originalEvent.altKey\n                });\n            }\n            onMove({\n                type: 'move',\n                pointerType: pointerType,\n                deltaX: deltaX,\n                deltaY: deltaY,\n                shiftKey: originalEvent.shiftKey,\n                metaKey: originalEvent.metaKey,\n                ctrlKey: originalEvent.ctrlKey,\n                altKey: originalEvent.altKey\n            });\n        };\n        let end = (originalEvent, pointerType)=>{\n            $14c0b72509d70225$export$b0d6fa1ab32e3295();\n            if (state.current.didMove) onMoveEnd === null || onMoveEnd === void 0 ? void 0 : onMoveEnd({\n                type: 'moveend',\n                pointerType: pointerType,\n                shiftKey: originalEvent.shiftKey,\n                metaKey: originalEvent.metaKey,\n                ctrlKey: originalEvent.ctrlKey,\n                altKey: originalEvent.altKey\n            });\n        };\n        if (typeof PointerEvent === 'undefined') {\n            let onMouseMove = (e)=>{\n                if (e.button === 0) {\n                    move(e, 'mouse', e.pageX - state.current.lastPosition.pageX, e.pageY - state.current.lastPosition.pageY);\n                    state.current.lastPosition = {\n                        pageX: e.pageX,\n                        pageY: e.pageY\n                    };\n                }\n            };\n            let onMouseUp = (e)=>{\n                if (e.button === 0) {\n                    end(e, 'mouse');\n                    removeGlobalListener(window, 'mousemove', onMouseMove, false);\n                    removeGlobalListener(window, 'mouseup', onMouseUp, false);\n                }\n            };\n            moveProps.onMouseDown = (e)=>{\n                if (e.button === 0) {\n                    start();\n                    e.stopPropagation();\n                    e.preventDefault();\n                    state.current.lastPosition = {\n                        pageX: e.pageX,\n                        pageY: e.pageY\n                    };\n                    addGlobalListener(window, 'mousemove', onMouseMove, false);\n                    addGlobalListener(window, 'mouseup', onMouseUp, false);\n                }\n            };\n            let onTouchMove = (e)=>{\n                let touch = [\n                    ...e.changedTouches\n                ].findIndex(({ identifier: identifier  })=>identifier === state.current.id\n                );\n                if (touch >= 0) {\n                    let { pageX: pageX , pageY: pageY  } = e.changedTouches[touch];\n                    move(e, 'touch', pageX - state.current.lastPosition.pageX, pageY - state.current.lastPosition.pageY);\n                    state.current.lastPosition = {\n                        pageX: pageX,\n                        pageY: pageY\n                    };\n                }\n            };\n            let onTouchEnd = (e)=>{\n                let touch = [\n                    ...e.changedTouches\n                ].findIndex(({ identifier: identifier  })=>identifier === state.current.id\n                );\n                if (touch >= 0) {\n                    end(e, 'touch');\n                    state.current.id = null;\n                    removeGlobalListener(window, 'touchmove', onTouchMove);\n                    removeGlobalListener(window, 'touchend', onTouchEnd);\n                    removeGlobalListener(window, 'touchcancel', onTouchEnd);\n                }\n            };\n            moveProps.onTouchStart = (e)=>{\n                if (e.changedTouches.length === 0 || state.current.id != null) return;\n                let { pageX: pageX , pageY: pageY , identifier: identifier  } = e.changedTouches[0];\n                start();\n                e.stopPropagation();\n                e.preventDefault();\n                state.current.lastPosition = {\n                    pageX: pageX,\n                    pageY: pageY\n                };\n                state.current.id = identifier;\n                addGlobalListener(window, 'touchmove', onTouchMove, false);\n                addGlobalListener(window, 'touchend', onTouchEnd, false);\n                addGlobalListener(window, 'touchcancel', onTouchEnd, false);\n            };\n        } else {\n            let onPointerMove = (e)=>{\n                if (e.pointerId === state.current.id) {\n                    let pointerType = e.pointerType || 'mouse';\n                    // Problems with PointerEvent#movementX/movementY:\n                    // 1. it is always 0 on macOS Safari.\n                    // 2. On Chrome Android, it's scaled by devicePixelRatio, but not on Chrome macOS\n                    move(e, pointerType, e.pageX - state.current.lastPosition.pageX, e.pageY - state.current.lastPosition.pageY);\n                    state.current.lastPosition = {\n                        pageX: e.pageX,\n                        pageY: e.pageY\n                    };\n                }\n            };\n            let onPointerUp = (e)=>{\n                if (e.pointerId === state.current.id) {\n                    let pointerType = e.pointerType || 'mouse';\n                    end(e, pointerType);\n                    state.current.id = null;\n                    removeGlobalListener(window, 'pointermove', onPointerMove, false);\n                    removeGlobalListener(window, 'pointerup', onPointerUp, false);\n                    removeGlobalListener(window, 'pointercancel', onPointerUp, false);\n                }\n            };\n            moveProps.onPointerDown = (e)=>{\n                if (e.button === 0 && state.current.id == null) {\n                    start();\n                    e.stopPropagation();\n                    e.preventDefault();\n                    state.current.lastPosition = {\n                        pageX: e.pageX,\n                        pageY: e.pageY\n                    };\n                    state.current.id = e.pointerId;\n                    addGlobalListener(window, 'pointermove', onPointerMove, false);\n                    addGlobalListener(window, 'pointerup', onPointerUp, false);\n                    addGlobalListener(window, 'pointercancel', onPointerUp, false);\n                }\n            };\n        }\n        let triggerKeyboardMove = (e, deltaX, deltaY)=>{\n            start();\n            move(e, 'keyboard', deltaX, deltaY);\n            end(e, 'keyboard');\n        };\n        moveProps.onKeyDown = (e)=>{\n            switch(e.key){\n                case 'Left':\n                case 'ArrowLeft':\n                    e.preventDefault();\n                    e.stopPropagation();\n                    triggerKeyboardMove(e, -1, 0);\n                    break;\n                case 'Right':\n                case 'ArrowRight':\n                    e.preventDefault();\n                    e.stopPropagation();\n                    triggerKeyboardMove(e, 1, 0);\n                    break;\n                case 'Up':\n                case 'ArrowUp':\n                    e.preventDefault();\n                    e.stopPropagation();\n                    triggerKeyboardMove(e, 0, -1);\n                    break;\n                case 'Down':\n                case 'ArrowDown':\n                    e.preventDefault();\n                    e.stopPropagation();\n                    triggerKeyboardMove(e, 0, 1);\n                    break;\n            }\n        };\n        return moveProps;\n    }, [\n        state,\n        onMoveStart,\n        onMove,\n        onMoveEnd,\n        addGlobalListener,\n        removeGlobalListener\n    ]);\n    return {\n        moveProps: moveProps1\n    };\n}\n\n\n\n\n\nfunction $7d0a636d7a4dcefd$export$2123ff2b87c81ca(props, ref) {\n    let { onScroll: onScroll , isDisabled: isDisabled  } = props;\n    let onScrollHandler = $bx7SL$useCallback((e)=>{\n        // If the ctrlKey is pressed, this is a zoom event, do nothing.\n        if (e.ctrlKey) return;\n        // stop scrolling the page\n        e.preventDefault();\n        e.stopPropagation();\n        if (onScroll) onScroll({\n            deltaX: e.deltaX,\n            deltaY: e.deltaY\n        });\n    }, [\n        onScroll\n    ]);\n    $bx7SL$useEvent(ref, 'wheel', isDisabled ? null : onScrollHandler);\n}\n\n\n\n\n\nconst $8a26561d2877236e$var$DEFAULT_THRESHOLD = 500;\nfunction $8a26561d2877236e$export$c24ed0104d07eab9(props) {\n    let { isDisabled: isDisabled , onLongPressStart: onLongPressStart , onLongPressEnd: onLongPressEnd , onLongPress: onLongPress , threshold: threshold = $8a26561d2877236e$var$DEFAULT_THRESHOLD , accessibilityDescription: accessibilityDescription  } = props;\n    const timeRef = $bx7SL$useRef(null);\n    let { addGlobalListener: addGlobalListener , removeGlobalListener: removeGlobalListener  } = $bx7SL$useGlobalListeners();\n    let { pressProps: pressProps  } = $f6c31cce2adf654f$export$45712eceda6fad21({\n        isDisabled: isDisabled,\n        onPressStart (e1) {\n            if (e1.pointerType === 'mouse' || e1.pointerType === 'touch') {\n                if (onLongPressStart) onLongPressStart({\n                    ...e1,\n                    type: 'longpressstart'\n                });\n                timeRef.current = setTimeout(()=>{\n                    // Prevent other usePress handlers from also handling this event.\n                    e1.target.dispatchEvent(new PointerEvent('pointercancel', {\n                        bubbles: true\n                    }));\n                    if (onLongPress) onLongPress({\n                        ...e1,\n                        type: 'longpress'\n                    });\n                    timeRef.current = null;\n                }, threshold);\n                // Prevent context menu, which may be opened on long press on touch devices\n                if (e1.pointerType === 'touch') {\n                    let onContextMenu = (e)=>{\n                        e.preventDefault();\n                    };\n                    addGlobalListener(e1.target, 'contextmenu', onContextMenu, {\n                        once: true\n                    });\n                    addGlobalListener(window, 'pointerup', ()=>{\n                        // If no contextmenu event is fired quickly after pointerup, remove the handler\n                        // so future context menu events outside a long press are not prevented.\n                        setTimeout(()=>{\n                            removeGlobalListener(e1.target, 'contextmenu', onContextMenu);\n                        }, 30);\n                    }, {\n                        once: true\n                    });\n                }\n            }\n        },\n        onPressEnd (e) {\n            if (timeRef.current) clearTimeout(timeRef.current);\n            if (onLongPressEnd && (e.pointerType === 'mouse' || e.pointerType === 'touch')) onLongPressEnd({\n                ...e,\n                type: 'longpressend'\n            });\n        }\n    });\n    let descriptionProps = $bx7SL$useDescription(onLongPress && !isDisabled ? accessibilityDescription : null);\n    return {\n        longPressProps: $bx7SL$mergeProps(pressProps, descriptionProps)\n    };\n}\n\n\n\n\nexport {$3b117e43dc0ca95d$export$27c701ed9e449e99 as Pressable, $f1ab8c75478c6f73$export$3351871ee4b288b8 as PressResponder, $a1ea59d68270f0dd$export$f8168d8dd8fd66e6 as useFocus, $507fabe10e71c6fb$export$b9b3dfddab17db27 as isFocusVisible, $507fabe10e71c6fb$export$630ff653c5ada6a9 as getInteractionModality, $507fabe10e71c6fb$export$8397ddfc504fdb9a as setInteractionModality, $507fabe10e71c6fb$export$98e20ec92f614cfe as useInteractionModality, $507fabe10e71c6fb$export$ffd9e5021c1fb2d6 as useFocusVisible, $507fabe10e71c6fb$export$ec71b4b83ac08ec3 as useFocusVisibleListener, $9ab94262bd0047c7$export$420e68273165f4ec as useFocusWithin, $6179b936705e76d3$export$ae780daf29e6d456 as useHover, $e0b6e0b68ec7f50f$export$872b660ac5a1ff98 as useInteractOutside, $46d819fcbaf35654$export$8f71654801c2f7cd as useKeyboard, $e8a7022cf87cba2a$export$36da96379f79f245 as useMove, $f6c31cce2adf654f$export$45712eceda6fad21 as usePress, $7d0a636d7a4dcefd$export$2123ff2b87c81ca as useScrollWheel, $8a26561d2877236e$export$c24ed0104d07eab9 as useLongPress};\n//# sourceMappingURL=module.js.map\n","import { popperGenerator, detectOverflow } from \"./createPopper.js\";\nimport eventListeners from \"./modifiers/eventListeners.js\";\nimport popperOffsets from \"./modifiers/popperOffsets.js\";\nimport computeStyles from \"./modifiers/computeStyles.js\";\nimport applyStyles from \"./modifiers/applyStyles.js\";\nimport offset from \"./modifiers/offset.js\";\nimport flip from \"./modifiers/flip.js\";\nimport preventOverflow from \"./modifiers/preventOverflow.js\";\nimport arrow from \"./modifiers/arrow.js\";\nimport hide from \"./modifiers/hide.js\";\nvar defaultModifiers = [eventListeners, popperOffsets, computeStyles, applyStyles, offset, flip, preventOverflow, arrow, hide];\nvar createPopper = /*#__PURE__*/popperGenerator({\n  defaultModifiers: defaultModifiers\n}); // eslint-disable-next-line import/no-unused-modules\n\nexport { createPopper, popperGenerator, defaultModifiers, detectOverflow }; // eslint-disable-next-line import/no-unused-modules\n\nexport { createPopper as createPopperLite } from \"./popper-lite.js\"; // eslint-disable-next-line import/no-unused-modules\n\nexport * from \"./modifiers/index.js\";","// history/index.ts\nexport * from \"prosemirror-history\";\n","function _iterableToArrayLimit(r, l) {\n  var t = null == r ? null : \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"];\n  if (null != t) {\n    var e,\n      n,\n      i,\n      u,\n      a = [],\n      f = !0,\n      o = !1;\n    try {\n      if (i = (t = t.call(r)).next, 0 === l) {\n        if (Object(t) !== t) return;\n        f = !1;\n      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);\n    } catch (r) {\n      o = !0, n = r;\n    } finally {\n      try {\n        if (!f && null != t[\"return\"] && (u = t[\"return\"](), Object(u) !== u)) return;\n      } finally {\n        if (o) throw n;\n      }\n    }\n    return a;\n  }\n}\nmodule.exports = _iterableToArrayLimit, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","// This file mimics styles and mixins from _General.Mixins.scss\nexport var normalize = {\n    boxShadow: 'none',\n    margin: 0,\n    padding: 0,\n    boxSizing: 'border-box',\n};\nexport var noWrap = {\n    overflow: 'hidden',\n    textOverflow: 'ellipsis',\n    whiteSpace: 'nowrap',\n};\n//# sourceMappingURL=GeneralStyles.js.map","import { Node, mergeAttributes, isNodeSelection, nodeInputRule } from '@tiptap/core';\nimport { TextSelection, NodeSelection } from '@tiptap/pm/state';\n\n/**\n * This extension allows you to insert horizontal rules.\n * @see https://www.tiptap.dev/api/nodes/horizontal-rule\n */\nconst HorizontalRule = Node.create({\n    name: 'horizontalRule',\n    addOptions() {\n        return {\n            HTMLAttributes: {},\n        };\n    },\n    group: 'block',\n    parseHTML() {\n        return [{ tag: 'hr' }];\n    },\n    renderHTML({ HTMLAttributes }) {\n        return ['hr', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)];\n    },\n    addCommands() {\n        return {\n            setHorizontalRule: () => ({ chain, state }) => {\n                const { selection } = state;\n                const { $from: $originFrom, $to: $originTo } = selection;\n                const currentChain = chain();\n                if ($originFrom.parentOffset === 0) {\n                    currentChain.insertContentAt({\n                        from: Math.max($originFrom.pos - 1, 0),\n                        to: $originTo.pos,\n                    }, {\n                        type: this.name,\n                    });\n                }\n                else if (isNodeSelection(selection)) {\n                    currentChain.insertContentAt($originTo.pos, {\n                        type: this.name,\n                    });\n                }\n                else {\n                    currentChain.insertContent({ type: this.name });\n                }\n                return (currentChain\n                    // set cursor after horizontal rule\n                    .command(({ tr, dispatch }) => {\n                    var _a;\n                    if (dispatch) {\n                        const { $to } = tr.selection;\n                        const posAfter = $to.end();\n                        if ($to.nodeAfter) {\n                            if ($to.nodeAfter.isTextblock) {\n                                tr.setSelection(TextSelection.create(tr.doc, $to.pos + 1));\n                            }\n                            else if ($to.nodeAfter.isBlock) {\n                                tr.setSelection(NodeSelection.create(tr.doc, $to.pos));\n                            }\n                            else {\n                                tr.setSelection(TextSelection.create(tr.doc, $to.pos));\n                            }\n                        }\n                        else {\n                            // add node after horizontal rule if its the end of the document\n                            const node = (_a = $to.parent.type.contentMatch.defaultType) === null || _a === void 0 ? void 0 : _a.create();\n                            if (node) {\n                                tr.insert(posAfter, node);\n                                tr.setSelection(TextSelection.create(tr.doc, posAfter + 1));\n                            }\n                        }\n                        tr.scrollIntoView();\n                    }\n                    return true;\n                })\n                    .run());\n            },\n        };\n    },\n    addInputRules() {\n        return [\n            nodeInputRule({\n                find: /^(?:---|-|___\\s|\\*\\*\\*\\s)$/,\n                type: this.type,\n            }),\n        ];\n    },\n});\n\nexport { HorizontalRule, HorizontalRule as default };\n//# sourceMappingURL=index.js.map\n","export default function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}","var progress = function (from, to, value) {\n    var toFromDifference = to - from;\n    return toFromDifference === 0 ? 1 : (value - from) / toFromDifference;\n};\n\nexport { progress };\n","export default function expandToHashMap(value, keys) {\n  return keys.reduce(function (hashMap, key) {\n    hashMap[key] = value;\n    return hashMap;\n  }, {});\n}","import * as React from 'react';\nimport { useConst } from './useConst';\n/**\n *  Returns a wrapper function for `setTimeout` which automatically handles disposal.\n */\nexport var useSetTimeout = function () {\n    var timeoutIds = useConst({});\n    // Cleanup function.\n    React.useEffect(function () { return function () {\n        for (var _i = 0, _a = Object.keys(timeoutIds); _i < _a.length; _i++) {\n            var id = _a[_i];\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            clearTimeout(id);\n        }\n    }; }, \n    // useConst ensures this will never change, but react-hooks/exhaustive-deps doesn't know that\n    [timeoutIds]);\n    // Return wrapper which will auto cleanup.\n    return useConst({\n        setTimeout: function (func, duration) {\n            var id = setTimeout(func, duration);\n            timeoutIds[id] = 1;\n            return id;\n        },\n        clearTimeout: function (id) {\n            delete timeoutIds[id];\n            clearTimeout(id);\n        },\n    });\n};\n//# sourceMappingURL=useSetTimeout.js.map","import { PluginKey, Plugin } from '@tiptap/pm/state';\nimport { DecorationSet, Decoration } from '@tiptap/pm/view';\nimport { escapeForRegEx } from '@tiptap/core';\n\nfunction findSuggestionMatch(config) {\n    var _a;\n    const { char, allowSpaces, allowedPrefixes, startOfLine, $position, } = config;\n    const escapedChar = escapeForRegEx(char);\n    const suffix = new RegExp(`\\\\s${escapedChar}$`);\n    const prefix = startOfLine ? '^' : '';\n    const regexp = allowSpaces\n        ? new RegExp(`${prefix}${escapedChar}.*?(?=\\\\s${escapedChar}|$)`, 'gm')\n        : new RegExp(`${prefix}(?:^)?${escapedChar}[^\\\\s${escapedChar}]*`, 'gm');\n    const text = ((_a = $position.nodeBefore) === null || _a === void 0 ? void 0 : _a.isText) && $position.nodeBefore.text;\n    if (!text) {\n        return null;\n    }\n    const textFrom = $position.pos - text.length;\n    const match = Array.from(text.matchAll(regexp)).pop();\n    if (!match || match.input === undefined || match.index === undefined) {\n        return null;\n    }\n    // JavaScript doesn't have lookbehinds. This hacks a check that first character\n    // is a space or the start of the line\n    const matchPrefix = match.input.slice(Math.max(0, match.index - 1), match.index);\n    const matchPrefixIsAllowed = new RegExp(`^[${allowedPrefixes === null || allowedPrefixes === void 0 ? void 0 : allowedPrefixes.join('')}\\0]?$`).test(matchPrefix);\n    if (allowedPrefixes !== null && !matchPrefixIsAllowed) {\n        return null;\n    }\n    // The absolute position of the match in the document\n    const from = textFrom + match.index;\n    let to = from + match[0].length;\n    // Edge case handling; if spaces are allowed and we're directly in between\n    // two triggers\n    if (allowSpaces && suffix.test(text.slice(to - 1, to + 1))) {\n        match[0] += ' ';\n        to += 1;\n    }\n    // If the $position is located within the matched substring, return that range\n    if (from < $position.pos && to >= $position.pos) {\n        return {\n            range: {\n                from,\n                to,\n            },\n            query: match[0].slice(char.length),\n            text: match[0],\n        };\n    }\n    return null;\n}\n\nconst SuggestionPluginKey = new PluginKey('suggestion');\n/**\n * This utility allows you to create suggestions.\n * @see https://tiptap.dev/api/utilities/suggestion\n */\nfunction Suggestion({ pluginKey = SuggestionPluginKey, editor, char = '@', allowSpaces = false, allowedPrefixes = [' '], startOfLine = false, decorationTag = 'span', decorationClass = 'suggestion', command = () => null, items = () => [], render = () => ({}), allow = () => true, findSuggestionMatch: findSuggestionMatch$1 = findSuggestionMatch, }) {\n    let props;\n    const renderer = render === null || render === void 0 ? void 0 : render();\n    const plugin = new Plugin({\n        key: pluginKey,\n        view() {\n            return {\n                update: async (view, prevState) => {\n                    var _a, _b, _c, _d, _e, _f, _g;\n                    const prev = (_a = this.key) === null || _a === void 0 ? void 0 : _a.getState(prevState);\n                    const next = (_b = this.key) === null || _b === void 0 ? void 0 : _b.getState(view.state);\n                    // See how the state changed\n                    const moved = prev.active && next.active && prev.range.from !== next.range.from;\n                    const started = !prev.active && next.active;\n                    const stopped = prev.active && !next.active;\n                    const changed = !started && !stopped && prev.query !== next.query;\n                    const handleStart = started;\n                    const handleChange = changed || moved;\n                    const handleExit = stopped;\n                    // Cancel when suggestion isn't active\n                    if (!handleStart && !handleChange && !handleExit) {\n                        return;\n                    }\n                    const state = handleExit && !handleStart ? prev : next;\n                    const decorationNode = view.dom.querySelector(`[data-decoration-id=\"${state.decorationId}\"]`);\n                    props = {\n                        editor,\n                        range: state.range,\n                        query: state.query,\n                        text: state.text,\n                        items: [],\n                        command: commandProps => {\n                            return command({\n                                editor,\n                                range: state.range,\n                                props: commandProps,\n                            });\n                        },\n                        decorationNode,\n                        // virtual node for popper.js or tippy.js\n                        // this can be used for building popups without a DOM node\n                        clientRect: decorationNode\n                            ? () => {\n                                var _a;\n                                // because of `items` can be asynchrounous well search for the current decoration node\n                                const { decorationId } = (_a = this.key) === null || _a === void 0 ? void 0 : _a.getState(editor.state); // eslint-disable-line\n                                const currentDecorationNode = view.dom.querySelector(`[data-decoration-id=\"${decorationId}\"]`);\n                                return (currentDecorationNode === null || currentDecorationNode === void 0 ? void 0 : currentDecorationNode.getBoundingClientRect()) || null;\n                            }\n                            : null,\n                    };\n                    if (handleStart) {\n                        (_c = renderer === null || renderer === void 0 ? void 0 : renderer.onBeforeStart) === null || _c === void 0 ? void 0 : _c.call(renderer, props);\n                    }\n                    if (handleChange) {\n                        (_d = renderer === null || renderer === void 0 ? void 0 : renderer.onBeforeUpdate) === null || _d === void 0 ? void 0 : _d.call(renderer, props);\n                    }\n                    if (handleChange || handleStart) {\n                        props.items = await items({\n                            editor,\n                            query: state.query,\n                        });\n                    }\n                    if (handleExit) {\n                        (_e = renderer === null || renderer === void 0 ? void 0 : renderer.onExit) === null || _e === void 0 ? void 0 : _e.call(renderer, props);\n                    }\n                    if (handleChange) {\n                        (_f = renderer === null || renderer === void 0 ? void 0 : renderer.onUpdate) === null || _f === void 0 ? void 0 : _f.call(renderer, props);\n                    }\n                    if (handleStart) {\n                        (_g = renderer === null || renderer === void 0 ? void 0 : renderer.onStart) === null || _g === void 0 ? void 0 : _g.call(renderer, props);\n                    }\n                },\n                destroy: () => {\n                    var _a;\n                    if (!props) {\n                        return;\n                    }\n                    (_a = renderer === null || renderer === void 0 ? void 0 : renderer.onExit) === null || _a === void 0 ? void 0 : _a.call(renderer, props);\n                },\n            };\n        },\n        state: {\n            // Initialize the plugin's internal state.\n            init() {\n                const state = {\n                    active: false,\n                    range: {\n                        from: 0,\n                        to: 0,\n                    },\n                    query: null,\n                    text: null,\n                    composing: false,\n                };\n                return state;\n            },\n            // Apply changes to the plugin state from a view transaction.\n            apply(transaction, prev, _oldState, state) {\n                const { isEditable } = editor;\n                const { composing } = editor.view;\n                const { selection } = transaction;\n                const { empty, from } = selection;\n                const next = { ...prev };\n                next.composing = composing;\n                // We can only be suggesting if the view is editable, and:\n                //   * there is no selection, or\n                //   * a composition is active (see: https://github.com/ueberdosis/tiptap/issues/1449)\n                if (isEditable && (empty || editor.view.composing)) {\n                    // Reset active state if we just left the previous suggestion range\n                    if ((from < prev.range.from || from > prev.range.to) && !composing && !prev.composing) {\n                        next.active = false;\n                    }\n                    // Try to match against where our cursor currently is\n                    const match = findSuggestionMatch$1({\n                        char,\n                        allowSpaces,\n                        allowedPrefixes,\n                        startOfLine,\n                        $position: selection.$from,\n                    });\n                    const decorationId = `id_${Math.floor(Math.random() * 0xffffffff)}`;\n                    // If we found a match, update the current state to show it\n                    if (match && allow({\n                        editor, state, range: match.range, isActive: prev.active,\n                    })) {\n                        next.active = true;\n                        next.decorationId = prev.decorationId ? prev.decorationId : decorationId;\n                        next.range = match.range;\n                        next.query = match.query;\n                        next.text = match.text;\n                    }\n                    else {\n                        next.active = false;\n                    }\n                }\n                else {\n                    next.active = false;\n                }\n                // Make sure to empty the range if suggestion is inactive\n                if (!next.active) {\n                    next.decorationId = null;\n                    next.range = { from: 0, to: 0 };\n                    next.query = null;\n                    next.text = null;\n                }\n                return next;\n            },\n        },\n        props: {\n            // Call the keydown hook if suggestion is active.\n            handleKeyDown(view, event) {\n                var _a;\n                const { active, range } = plugin.getState(view.state);\n                if (!active) {\n                    return false;\n                }\n                return ((_a = renderer === null || renderer === void 0 ? void 0 : renderer.onKeyDown) === null || _a === void 0 ? void 0 : _a.call(renderer, { view, event, range })) || false;\n            },\n            // Setup decorator on the currently active suggestion.\n            decorations(state) {\n                const { active, range, decorationId } = plugin.getState(state);\n                if (!active) {\n                    return null;\n                }\n                return DecorationSet.create(state.doc, [\n                    Decoration.inline(range.from, range.to, {\n                        nodeName: decorationTag,\n                        class: decorationClass,\n                        'data-decoration-id': decorationId,\n                    }),\n                ]);\n            },\n        },\n    });\n    return plugin;\n}\n\nexport { Suggestion, SuggestionPluginKey, Suggestion as default, findSuggestionMatch };\n//# sourceMappingURL=index.js.map\n","import { BubbleMenuPlugin } from '@tiptap/extension-bubble-menu';\nimport React, { forwardRef, useState, useEffect, useDebugValue, useRef, createContext, useContext } from 'react';\nimport ReactDOM, { flushSync } from 'react-dom';\nimport { Editor as Editor$1, NodeView } from '@tiptap/core';\nexport * from '@tiptap/core';\nimport { FloatingMenuPlugin } from '@tiptap/extension-floating-menu';\n\nconst mergeRefs = (...refs) => {\n    return (node) => {\n        refs.forEach(ref => {\n            if (typeof ref === 'function') {\n                ref(node);\n            }\n            else if (ref) {\n                ref.current = node;\n            }\n        });\n    };\n};\nconst Portals = ({ renderers }) => {\n    return (React.createElement(React.Fragment, null, Object.entries(renderers).map(([key, renderer]) => {\n        return ReactDOM.createPortal(renderer.reactElement, renderer.element, key);\n    })));\n};\nclass PureEditorContent extends React.Component {\n    constructor(props) {\n        super(props);\n        this.editorContentRef = React.createRef();\n        this.initialized = false;\n        this.state = {\n            renderers: {},\n        };\n    }\n    componentDidMount() {\n        this.init();\n    }\n    componentDidUpdate() {\n        this.init();\n    }\n    init() {\n        const { editor } = this.props;\n        if (editor && !editor.isDestroyed && editor.options.element) {\n            if (editor.contentComponent) {\n                return;\n            }\n            const element = this.editorContentRef.current;\n            element.append(...editor.options.element.childNodes);\n            editor.setOptions({\n                element,\n            });\n            editor.contentComponent = this;\n            editor.createNodeViews();\n            this.initialized = true;\n        }\n    }\n    maybeFlushSync(fn) {\n        // Avoid calling flushSync until the editor is initialized.\n        // Initialization happens during the componentDidMount or componentDidUpdate\n        // lifecycle methods, and React doesn't allow calling flushSync from inside\n        // a lifecycle method.\n        if (this.initialized) {\n            flushSync(fn);\n        }\n        else {\n            fn();\n        }\n    }\n    setRenderer(id, renderer) {\n        this.maybeFlushSync(() => {\n            this.setState(({ renderers }) => ({\n                renderers: {\n                    ...renderers,\n                    [id]: renderer,\n                },\n            }));\n        });\n    }\n    removeRenderer(id) {\n        this.maybeFlushSync(() => {\n            this.setState(({ renderers }) => {\n                const nextRenderers = { ...renderers };\n                delete nextRenderers[id];\n                return { renderers: nextRenderers };\n            });\n        });\n    }\n    componentWillUnmount() {\n        const { editor } = this.props;\n        if (!editor) {\n            return;\n        }\n        this.initialized = false;\n        if (!editor.isDestroyed) {\n            editor.view.setProps({\n                nodeViews: {},\n            });\n        }\n        editor.contentComponent = null;\n        if (!editor.options.element.firstChild) {\n            return;\n        }\n        const newElement = document.createElement('div');\n        newElement.append(...editor.options.element.childNodes);\n        editor.setOptions({\n            element: newElement,\n        });\n    }\n    render() {\n        const { editor, innerRef, ...rest } = this.props;\n        return (React.createElement(React.Fragment, null,\n            React.createElement(\"div\", { ref: mergeRefs(innerRef, this.editorContentRef), ...rest }),\n            React.createElement(Portals, { renderers: this.state.renderers })));\n    }\n}\n// EditorContent should be re-created whenever the Editor instance changes\nconst EditorContentWithKey = forwardRef((props, ref) => {\n    const key = React.useMemo(() => {\n        return Math.floor(Math.random() * 0xFFFFFFFF).toString();\n    }, [props.editor]);\n    // Can't use JSX here because it conflicts with the type definition of Vue's JSX, so use createElement\n    return React.createElement(PureEditorContent, {\n        key,\n        innerRef: ref,\n        ...props,\n    });\n});\nconst EditorContent = React.memo(EditorContentWithKey);\n\nvar shim = {exports: {}};\n\nvar useSyncExternalStoreShim_production_min = {};\n\n/**\n * @license React\n * use-sync-external-store-shim.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar hasRequiredUseSyncExternalStoreShim_production_min;\n\nfunction requireUseSyncExternalStoreShim_production_min () {\n\tif (hasRequiredUseSyncExternalStoreShim_production_min) return useSyncExternalStoreShim_production_min;\n\thasRequiredUseSyncExternalStoreShim_production_min = 1;\nvar e=React;function h(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}var k=\"function\"===typeof Object.is?Object.is:h,l=e.useState,m=e.useEffect,n=e.useLayoutEffect,p=e.useDebugValue;function q(a,b){var d=b(),f=l({inst:{value:d,getSnapshot:b}}),c=f[0].inst,g=f[1];n(function(){c.value=d;c.getSnapshot=b;r(c)&&g({inst:c});},[a,d,b]);m(function(){r(c)&&g({inst:c});return a(function(){r(c)&&g({inst:c});})},[a]);p(d);return d}\n\tfunction r(a){var b=a.getSnapshot;a=a.value;try{var d=b();return !k(a,d)}catch(f){return !0}}function t(a,b){return b()}var u=\"undefined\"===typeof window||\"undefined\"===typeof window.document||\"undefined\"===typeof window.document.createElement?t:q;useSyncExternalStoreShim_production_min.useSyncExternalStore=void 0!==e.useSyncExternalStore?e.useSyncExternalStore:u;\n\treturn useSyncExternalStoreShim_production_min;\n}\n\nvar useSyncExternalStoreShim_development = {};\n\n/**\n * @license React\n * use-sync-external-store-shim.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar hasRequiredUseSyncExternalStoreShim_development;\n\nfunction requireUseSyncExternalStoreShim_development () {\n\tif (hasRequiredUseSyncExternalStoreShim_development) return useSyncExternalStoreShim_development;\n\thasRequiredUseSyncExternalStoreShim_development = 1;\n\n\tif (process.env.NODE_ENV !== \"production\") {\n\t  (function() {\n\n\t/* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\n\tif (\n\t  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&\n\t  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart ===\n\t    'function'\n\t) {\n\t  __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());\n\t}\n\t          var React$1 = React;\n\n\tvar ReactSharedInternals = React$1.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\n\tfunction error(format) {\n\t  {\n\t    {\n\t      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n\t        args[_key2 - 1] = arguments[_key2];\n\t      }\n\n\t      printWarning('error', format, args);\n\t    }\n\t  }\n\t}\n\n\tfunction printWarning(level, format, args) {\n\t  // When changing this logic, you might want to also\n\t  // update consoleWithStackDev.www.js as well.\n\t  {\n\t    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n\t    var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n\t    if (stack !== '') {\n\t      format += '%s';\n\t      args = args.concat([stack]);\n\t    } // eslint-disable-next-line react-internal/safe-string-coercion\n\n\n\t    var argsWithFormat = args.map(function (item) {\n\t      return String(item);\n\t    }); // Careful: RN currently depends on this prefix\n\n\t    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n\t    // breaks IE9: https://github.com/facebook/react/issues/13610\n\t    // eslint-disable-next-line react-internal/no-production-logging\n\n\t    Function.prototype.apply.call(console[level], console, argsWithFormat);\n\t  }\n\t}\n\n\t/**\n\t * inlined Object.is polyfill to avoid requiring consumers ship their own\n\t * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n\t */\n\tfunction is(x, y) {\n\t  return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare\n\t  ;\n\t}\n\n\tvar objectIs = typeof Object.is === 'function' ? Object.is : is;\n\n\t// dispatch for CommonJS interop named imports.\n\n\tvar useState = React$1.useState,\n\t    useEffect = React$1.useEffect,\n\t    useLayoutEffect = React$1.useLayoutEffect,\n\t    useDebugValue = React$1.useDebugValue;\n\tvar didWarnOld18Alpha = false;\n\tvar didWarnUncachedGetSnapshot = false; // Disclaimer: This shim breaks many of the rules of React, and only works\n\t// because of a very particular set of implementation details and assumptions\n\t// -- change any one of them and it will break. The most important assumption\n\t// is that updates are always synchronous, because concurrent rendering is\n\t// only available in versions of React that also have a built-in\n\t// useSyncExternalStore API. And we only use this shim when the built-in API\n\t// does not exist.\n\t//\n\t// Do not assume that the clever hacks used by this hook also work in general.\n\t// The point of this shim is to replace the need for hacks by other libraries.\n\n\tfunction useSyncExternalStore(subscribe, getSnapshot, // Note: The shim does not use getServerSnapshot, because pre-18 versions of\n\t// React do not expose a way to check if we're hydrating. So users of the shim\n\t// will need to track that themselves and return the correct value\n\t// from `getSnapshot`.\n\tgetServerSnapshot) {\n\t  {\n\t    if (!didWarnOld18Alpha) {\n\t      if (React$1.startTransition !== undefined) {\n\t        didWarnOld18Alpha = true;\n\n\t        error('You are using an outdated, pre-release alpha of React 18 that ' + 'does not support useSyncExternalStore. The ' + 'use-sync-external-store shim will not work correctly. Upgrade ' + 'to a newer pre-release.');\n\t      }\n\t    }\n\t  } // Read the current snapshot from the store on every render. Again, this\n\t  // breaks the rules of React, and only works here because of specific\n\t  // implementation details, most importantly that updates are\n\t  // always synchronous.\n\n\n\t  var value = getSnapshot();\n\n\t  {\n\t    if (!didWarnUncachedGetSnapshot) {\n\t      var cachedValue = getSnapshot();\n\n\t      if (!objectIs(value, cachedValue)) {\n\t        error('The result of getSnapshot should be cached to avoid an infinite loop');\n\n\t        didWarnUncachedGetSnapshot = true;\n\t      }\n\t    }\n\t  } // Because updates are synchronous, we don't queue them. Instead we force a\n\t  // re-render whenever the subscribed state changes by updating an some\n\t  // arbitrary useState hook. Then, during render, we call getSnapshot to read\n\t  // the current value.\n\t  //\n\t  // Because we don't actually use the state returned by the useState hook, we\n\t  // can save a bit of memory by storing other stuff in that slot.\n\t  //\n\t  // To implement the early bailout, we need to track some things on a mutable\n\t  // object. Usually, we would put that in a useRef hook, but we can stash it in\n\t  // our useState hook instead.\n\t  //\n\t  // To force a re-render, we call forceUpdate({inst}). That works because the\n\t  // new object always fails an equality check.\n\n\n\t  var _useState = useState({\n\t    inst: {\n\t      value: value,\n\t      getSnapshot: getSnapshot\n\t    }\n\t  }),\n\t      inst = _useState[0].inst,\n\t      forceUpdate = _useState[1]; // Track the latest getSnapshot function with a ref. This needs to be updated\n\t  // in the layout phase so we can access it during the tearing check that\n\t  // happens on subscribe.\n\n\n\t  useLayoutEffect(function () {\n\t    inst.value = value;\n\t    inst.getSnapshot = getSnapshot; // Whenever getSnapshot or subscribe changes, we need to check in the\n\t    // commit phase if there was an interleaved mutation. In concurrent mode\n\t    // this can happen all the time, but even in synchronous mode, an earlier\n\t    // effect may have mutated the store.\n\n\t    if (checkIfSnapshotChanged(inst)) {\n\t      // Force a re-render.\n\t      forceUpdate({\n\t        inst: inst\n\t      });\n\t    }\n\t  }, [subscribe, value, getSnapshot]);\n\t  useEffect(function () {\n\t    // Check for changes right before subscribing. Subsequent changes will be\n\t    // detected in the subscription handler.\n\t    if (checkIfSnapshotChanged(inst)) {\n\t      // Force a re-render.\n\t      forceUpdate({\n\t        inst: inst\n\t      });\n\t    }\n\n\t    var handleStoreChange = function () {\n\t      // TODO: Because there is no cross-renderer API for batching updates, it's\n\t      // up to the consumer of this library to wrap their subscription event\n\t      // with unstable_batchedUpdates. Should we try to detect when this isn't\n\t      // the case and print a warning in development?\n\t      // The store changed. Check if the snapshot changed since the last time we\n\t      // read from the store.\n\t      if (checkIfSnapshotChanged(inst)) {\n\t        // Force a re-render.\n\t        forceUpdate({\n\t          inst: inst\n\t        });\n\t      }\n\t    }; // Subscribe to the store and return a clean-up function.\n\n\n\t    return subscribe(handleStoreChange);\n\t  }, [subscribe]);\n\t  useDebugValue(value);\n\t  return value;\n\t}\n\n\tfunction checkIfSnapshotChanged(inst) {\n\t  var latestGetSnapshot = inst.getSnapshot;\n\t  var prevValue = inst.value;\n\n\t  try {\n\t    var nextValue = latestGetSnapshot();\n\t    return !objectIs(prevValue, nextValue);\n\t  } catch (error) {\n\t    return true;\n\t  }\n\t}\n\n\tfunction useSyncExternalStore$1(subscribe, getSnapshot, getServerSnapshot) {\n\t  // Note: The shim does not use getServerSnapshot, because pre-18 versions of\n\t  // React do not expose a way to check if we're hydrating. So users of the shim\n\t  // will need to track that themselves and return the correct value\n\t  // from `getSnapshot`.\n\t  return getSnapshot();\n\t}\n\n\tvar canUseDOM = !!(typeof window !== 'undefined' && typeof window.document !== 'undefined' && typeof window.document.createElement !== 'undefined');\n\n\tvar isServerEnvironment = !canUseDOM;\n\n\tvar shim = isServerEnvironment ? useSyncExternalStore$1 : useSyncExternalStore;\n\tvar useSyncExternalStore$2 = React$1.useSyncExternalStore !== undefined ? React$1.useSyncExternalStore : shim;\n\n\tuseSyncExternalStoreShim_development.useSyncExternalStore = useSyncExternalStore$2;\n\t          /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\n\tif (\n\t  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&\n\t  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop ===\n\t    'function'\n\t) {\n\t  __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());\n\t}\n\t        \n\t  })();\n\t}\n\treturn useSyncExternalStoreShim_development;\n}\n\nif (process.env.NODE_ENV === 'production') {\n  shim.exports = requireUseSyncExternalStoreShim_production_min();\n} else {\n  shim.exports = requireUseSyncExternalStoreShim_development();\n}\n\nvar shimExports = shim.exports;\n\nclass Editor extends Editor$1 {\n    constructor() {\n        super(...arguments);\n        this.contentComponent = null;\n    }\n}\n\nvar withSelector = {exports: {}};\n\nvar withSelector_production_min = {};\n\n/**\n * @license React\n * use-sync-external-store-shim/with-selector.production.min.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar hasRequiredWithSelector_production_min;\n\nfunction requireWithSelector_production_min () {\n\tif (hasRequiredWithSelector_production_min) return withSelector_production_min;\n\thasRequiredWithSelector_production_min = 1;\nvar h=React,n=shimExports;function p(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}var q=\"function\"===typeof Object.is?Object.is:p,r=n.useSyncExternalStore,t=h.useRef,u=h.useEffect,v=h.useMemo,w=h.useDebugValue;\n\twithSelector_production_min.useSyncExternalStoreWithSelector=function(a,b,e,l,g){var c=t(null);if(null===c.current){var f={hasValue:!1,value:null};c.current=f;}else f=c.current;c=v(function(){function a(a){if(!c){c=!0;d=a;a=l(a);if(void 0!==g&&f.hasValue){var b=f.value;if(g(b,a))return k=b}return k=a}b=k;if(q(d,a))return b;var e=l(a);if(void 0!==g&&g(b,e))return b;d=a;return k=e}var c=!1,d,k,m=void 0===e?null:e;return [function(){return a(b())},null===m?void 0:function(){return a(m())}]},[b,e,l,g]);var d=r(a,c[0],c[1]);\n\tu(function(){f.hasValue=!0;f.value=d;},[d]);w(d);return d};\n\treturn withSelector_production_min;\n}\n\nvar withSelector_development = {};\n\n/**\n * @license React\n * use-sync-external-store-shim/with-selector.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nvar hasRequiredWithSelector_development;\n\nfunction requireWithSelector_development () {\n\tif (hasRequiredWithSelector_development) return withSelector_development;\n\thasRequiredWithSelector_development = 1;\n\n\tif (process.env.NODE_ENV !== \"production\") {\n\t  (function() {\n\n\t/* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\n\tif (\n\t  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&\n\t  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart ===\n\t    'function'\n\t) {\n\t  __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());\n\t}\n\t          var React$1 = React;\n\tvar shim = shimExports;\n\n\t/**\n\t * inlined Object.is polyfill to avoid requiring consumers ship their own\n\t * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n\t */\n\tfunction is(x, y) {\n\t  return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare\n\t  ;\n\t}\n\n\tvar objectIs = typeof Object.is === 'function' ? Object.is : is;\n\n\tvar useSyncExternalStore = shim.useSyncExternalStore;\n\n\t// for CommonJS interop.\n\n\tvar useRef = React$1.useRef,\n\t    useEffect = React$1.useEffect,\n\t    useMemo = React$1.useMemo,\n\t    useDebugValue = React$1.useDebugValue; // Same as useSyncExternalStore, but supports selector and isEqual arguments.\n\n\tfunction useSyncExternalStoreWithSelector(subscribe, getSnapshot, getServerSnapshot, selector, isEqual) {\n\t  // Use this to track the rendered snapshot.\n\t  var instRef = useRef(null);\n\t  var inst;\n\n\t  if (instRef.current === null) {\n\t    inst = {\n\t      hasValue: false,\n\t      value: null\n\t    };\n\t    instRef.current = inst;\n\t  } else {\n\t    inst = instRef.current;\n\t  }\n\n\t  var _useMemo = useMemo(function () {\n\t    // Track the memoized state using closure variables that are local to this\n\t    // memoized instance of a getSnapshot function. Intentionally not using a\n\t    // useRef hook, because that state would be shared across all concurrent\n\t    // copies of the hook/component.\n\t    var hasMemo = false;\n\t    var memoizedSnapshot;\n\t    var memoizedSelection;\n\n\t    var memoizedSelector = function (nextSnapshot) {\n\t      if (!hasMemo) {\n\t        // The first time the hook is called, there is no memoized result.\n\t        hasMemo = true;\n\t        memoizedSnapshot = nextSnapshot;\n\n\t        var _nextSelection = selector(nextSnapshot);\n\n\t        if (isEqual !== undefined) {\n\t          // Even if the selector has changed, the currently rendered selection\n\t          // may be equal to the new selection. We should attempt to reuse the\n\t          // current value if possible, to preserve downstream memoizations.\n\t          if (inst.hasValue) {\n\t            var currentSelection = inst.value;\n\n\t            if (isEqual(currentSelection, _nextSelection)) {\n\t              memoizedSelection = currentSelection;\n\t              return currentSelection;\n\t            }\n\t          }\n\t        }\n\n\t        memoizedSelection = _nextSelection;\n\t        return _nextSelection;\n\t      } // We may be able to reuse the previous invocation's result.\n\n\n\t      // We may be able to reuse the previous invocation's result.\n\t      var prevSnapshot = memoizedSnapshot;\n\t      var prevSelection = memoizedSelection;\n\n\t      if (objectIs(prevSnapshot, nextSnapshot)) {\n\t        // The snapshot is the same as last time. Reuse the previous selection.\n\t        return prevSelection;\n\t      } // The snapshot has changed, so we need to compute a new selection.\n\n\n\t      // The snapshot has changed, so we need to compute a new selection.\n\t      var nextSelection = selector(nextSnapshot); // If a custom isEqual function is provided, use that to check if the data\n\t      // has changed. If it hasn't, return the previous selection. That signals\n\t      // to React that the selections are conceptually equal, and we can bail\n\t      // out of rendering.\n\n\t      // If a custom isEqual function is provided, use that to check if the data\n\t      // has changed. If it hasn't, return the previous selection. That signals\n\t      // to React that the selections are conceptually equal, and we can bail\n\t      // out of rendering.\n\t      if (isEqual !== undefined && isEqual(prevSelection, nextSelection)) {\n\t        return prevSelection;\n\t      }\n\n\t      memoizedSnapshot = nextSnapshot;\n\t      memoizedSelection = nextSelection;\n\t      return nextSelection;\n\t    }; // Assigning this to a constant so that Flow knows it can't change.\n\n\n\t    // Assigning this to a constant so that Flow knows it can't change.\n\t    var maybeGetServerSnapshot = getServerSnapshot === undefined ? null : getServerSnapshot;\n\n\t    var getSnapshotWithSelector = function () {\n\t      return memoizedSelector(getSnapshot());\n\t    };\n\n\t    var getServerSnapshotWithSelector = maybeGetServerSnapshot === null ? undefined : function () {\n\t      return memoizedSelector(maybeGetServerSnapshot());\n\t    };\n\t    return [getSnapshotWithSelector, getServerSnapshotWithSelector];\n\t  }, [getSnapshot, getServerSnapshot, selector, isEqual]),\n\t      getSelection = _useMemo[0],\n\t      getServerSelection = _useMemo[1];\n\n\t  var value = useSyncExternalStore(subscribe, getSelection, getServerSelection);\n\t  useEffect(function () {\n\t    inst.hasValue = true;\n\t    inst.value = value;\n\t  }, [value]);\n\t  useDebugValue(value);\n\t  return value;\n\t}\n\n\twithSelector_development.useSyncExternalStoreWithSelector = useSyncExternalStoreWithSelector;\n\t          /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */\n\tif (\n\t  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' &&\n\t  typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop ===\n\t    'function'\n\t) {\n\t  __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());\n\t}\n\t        \n\t  })();\n\t}\n\treturn withSelector_development;\n}\n\nif (process.env.NODE_ENV === 'production') {\n  withSelector.exports = requireWithSelector_production_min();\n} else {\n  withSelector.exports = requireWithSelector_development();\n}\n\nvar withSelectorExports = withSelector.exports;\n\n/**\n * To synchronize the editor instance with the component state,\n * we need to create a separate instance that is not affected by the component re-renders.\n */\nclass EditorStateManager {\n    constructor(initialEditor) {\n        this.transactionNumber = 0;\n        this.lastTransactionNumber = 0;\n        this.subscribers = new Set();\n        this.editor = initialEditor;\n        this.lastSnapshot = { editor: initialEditor, transactionNumber: 0 };\n        this.getSnapshot = this.getSnapshot.bind(this);\n        this.getServerSnapshot = this.getServerSnapshot.bind(this);\n        this.watch = this.watch.bind(this);\n        this.subscribe = this.subscribe.bind(this);\n    }\n    /**\n     * Get the current editor instance.\n     */\n    getSnapshot() {\n        if (this.transactionNumber === this.lastTransactionNumber) {\n            return this.lastSnapshot;\n        }\n        this.lastTransactionNumber = this.transactionNumber;\n        this.lastSnapshot = { editor: this.editor, transactionNumber: this.transactionNumber };\n        return this.lastSnapshot;\n    }\n    /**\n     * Always disable the editor on the server-side.\n     */\n    getServerSnapshot() {\n        return { editor: null, transactionNumber: 0 };\n    }\n    /**\n     * Subscribe to the editor instance's changes.\n     */\n    subscribe(callback) {\n        this.subscribers.add(callback);\n        return () => {\n            this.subscribers.delete(callback);\n        };\n    }\n    /**\n     * Watch the editor instance for changes.\n     */\n    watch(nextEditor) {\n        this.editor = nextEditor;\n        if (this.editor) {\n            /**\n             * This will force a re-render when the editor state changes.\n             * This is to support things like `editor.can().toggleBold()` in components that `useEditor`.\n             * This could be more efficient, but it's a good trade-off for now.\n             */\n            const fn = () => {\n                this.transactionNumber += 1;\n                this.subscribers.forEach(callback => callback());\n            };\n            const currentEditor = this.editor;\n            currentEditor.on('transaction', fn);\n            return () => {\n                currentEditor.off('transaction', fn);\n            };\n        }\n        return undefined;\n    }\n}\nfunction useEditorState(options) {\n    const [editorInstance] = useState(() => new EditorStateManager(options.editor));\n    // Using the `useSyncExternalStore` hook to sync the editor instance with the component state\n    const selectedState = withSelectorExports.useSyncExternalStoreWithSelector(editorInstance.subscribe, editorInstance.getSnapshot, editorInstance.getServerSnapshot, options.selector, options.equalityFn);\n    useEffect(() => {\n        return editorInstance.watch(options.editor);\n    }, [options.editor, editorInstance]);\n    useDebugValue(selectedState);\n    return selectedState;\n}\n\nconst isDev = process.env.NODE_ENV !== 'production';\nconst isSSR = typeof window === 'undefined';\nconst isNext = isSSR || Boolean(typeof window !== 'undefined' && window.next);\n/**\n * This class handles the creation, destruction, and re-creation of the editor instance.\n */\nclass EditorInstanceManager {\n    constructor(options) {\n        /**\n         * The current editor instance.\n         */\n        this.editor = null;\n        /**\n         * The subscriptions to notify when the editor instance\n         * has been created or destroyed.\n         */\n        this.subscriptions = new Set();\n        /**\n         * Whether the editor has been mounted.\n         */\n        this.isComponentMounted = false;\n        /**\n         * The most recent dependencies array.\n         */\n        this.previousDeps = null;\n        /**\n         * The unique instance ID. This is used to identify the editor instance. And will be re-generated for each new instance.\n         */\n        this.instanceId = '';\n        this.options = options;\n        this.subscriptions = new Set();\n        this.setEditor(this.getInitialEditor());\n        this.getEditor = this.getEditor.bind(this);\n        this.getServerSnapshot = this.getServerSnapshot.bind(this);\n        this.subscribe = this.subscribe.bind(this);\n        this.refreshEditorInstance = this.refreshEditorInstance.bind(this);\n        this.scheduleDestroy = this.scheduleDestroy.bind(this);\n        this.onRender = this.onRender.bind(this);\n        this.createEditor = this.createEditor.bind(this);\n    }\n    setEditor(editor) {\n        this.editor = editor;\n        this.instanceId = Math.random().toString(36).slice(2, 9);\n        // Notify all subscribers that the editor instance has been created\n        this.subscriptions.forEach(cb => cb());\n    }\n    getInitialEditor() {\n        if (this.options.current.immediatelyRender === undefined) {\n            if (isSSR || isNext) {\n                // TODO in the next major release, we should throw an error here\n                if (isDev) {\n                    /**\n                     * Throw an error in development, to make sure the developer is aware that tiptap cannot be SSR'd\n                     * and that they need to set `immediatelyRender` to `false` to avoid hydration mismatches.\n                     */\n                    console.warn('Tiptap Error: SSR has been detected, please set `immediatelyRender` explicitly to `false` to avoid hydration mismatches.');\n                }\n                // Best faith effort in production, run the code in the legacy mode to avoid hydration mismatches and errors in production\n                return null;\n            }\n            // Default to immediately rendering when client-side rendering\n            return this.createEditor();\n        }\n        if (this.options.current.immediatelyRender && isSSR && isDev) {\n            // Warn in development, to make sure the developer is aware that tiptap cannot be SSR'd, set `immediatelyRender` to `false` to avoid hydration mismatches.\n            throw new Error('Tiptap Error: SSR has been detected, and `immediatelyRender` has been set to `true` this is an unsupported configuration that may result in errors, explicitly set `immediatelyRender` to `false` to avoid hydration mismatches.');\n        }\n        if (this.options.current.immediatelyRender) {\n            return this.createEditor();\n        }\n        return null;\n    }\n    /**\n     * Create a new editor instance. And attach event listeners.\n     */\n    createEditor() {\n        const editor = new Editor(this.options.current);\n        // Always call the most recent version of the callback function by default\n        editor.on('beforeCreate', (...args) => { var _a, _b; return (_b = (_a = this.options.current).onBeforeCreate) === null || _b === void 0 ? void 0 : _b.call(_a, ...args); });\n        editor.on('blur', (...args) => { var _a, _b; return (_b = (_a = this.options.current).onBlur) === null || _b === void 0 ? void 0 : _b.call(_a, ...args); });\n        editor.on('create', (...args) => { var _a, _b; return (_b = (_a = this.options.current).onCreate) === null || _b === void 0 ? void 0 : _b.call(_a, ...args); });\n        editor.on('destroy', (...args) => { var _a, _b; return (_b = (_a = this.options.current).onDestroy) === null || _b === void 0 ? void 0 : _b.call(_a, ...args); });\n        editor.on('focus', (...args) => { var _a, _b; return (_b = (_a = this.options.current).onFocus) === null || _b === void 0 ? void 0 : _b.call(_a, ...args); });\n        editor.on('selectionUpdate', (...args) => { var _a, _b; return (_b = (_a = this.options.current).onSelectionUpdate) === null || _b === void 0 ? void 0 : _b.call(_a, ...args); });\n        editor.on('transaction', (...args) => { var _a, _b; return (_b = (_a = this.options.current).onTransaction) === null || _b === void 0 ? void 0 : _b.call(_a, ...args); });\n        editor.on('update', (...args) => { var _a, _b; return (_b = (_a = this.options.current).onUpdate) === null || _b === void 0 ? void 0 : _b.call(_a, ...args); });\n        editor.on('contentError', (...args) => { var _a, _b; return (_b = (_a = this.options.current).onContentError) === null || _b === void 0 ? void 0 : _b.call(_a, ...args); });\n        // no need to keep track of the event listeners, they will be removed when the editor is destroyed\n        return editor;\n    }\n    /**\n     * Get the current editor instance.\n     */\n    getEditor() {\n        return this.editor;\n    }\n    /**\n     * Always disable the editor on the server-side.\n     */\n    getServerSnapshot() {\n        return null;\n    }\n    /**\n     * Subscribe to the editor instance's changes.\n     */\n    subscribe(onStoreChange) {\n        this.subscriptions.add(onStoreChange);\n        return () => {\n            this.subscriptions.delete(onStoreChange);\n        };\n    }\n    /**\n     * On each render, we will create, update, or destroy the editor instance.\n     * @param deps The dependencies to watch for changes\n     * @returns A cleanup function\n     */\n    onRender(deps) {\n        // The returned callback will run on each render\n        return () => {\n            this.isComponentMounted = true;\n            // Cleanup any scheduled destructions, since we are currently rendering\n            clearTimeout(this.scheduledDestructionTimeout);\n            if (this.editor && !this.editor.isDestroyed && deps.length === 0) {\n                // if the editor does exist & deps are empty, we don't need to re-initialize the editor\n                // we can fast-path to update the editor options on the existing instance\n                this.editor.setOptions(this.options.current);\n            }\n            else {\n                // When the editor:\n                // - does not yet exist\n                // - is destroyed\n                // - the deps array changes\n                // We need to destroy the editor instance and re-initialize it\n                this.refreshEditorInstance(deps);\n            }\n            return () => {\n                this.isComponentMounted = false;\n                this.scheduleDestroy();\n            };\n        };\n    }\n    /**\n     * Recreate the editor instance if the dependencies have changed.\n     */\n    refreshEditorInstance(deps) {\n        if (this.editor && !this.editor.isDestroyed) {\n            // Editor instance already exists\n            if (this.previousDeps === null) {\n                // If lastDeps has not yet been initialized, reuse the current editor instance\n                this.previousDeps = deps;\n                return;\n            }\n            const depsAreEqual = this.previousDeps.length === deps.length\n                && this.previousDeps.every((dep, index) => dep === deps[index]);\n            if (depsAreEqual) {\n                // deps exist and are equal, no need to recreate\n                return;\n            }\n        }\n        if (this.editor && !this.editor.isDestroyed) {\n            // Destroy the editor instance if it exists\n            this.editor.destroy();\n        }\n        this.setEditor(this.createEditor());\n        // Update the lastDeps to the current deps\n        this.previousDeps = deps;\n    }\n    /**\n     * Schedule the destruction of the editor instance.\n     * This will only destroy the editor if it was not mounted on the next tick.\n     * This is to avoid destroying the editor instance when it's actually still mounted.\n     */\n    scheduleDestroy() {\n        const currentInstanceId = this.instanceId;\n        const currentEditor = this.editor;\n        // Wait a tick to see if the component is still mounted\n        this.scheduledDestructionTimeout = setTimeout(() => {\n            if (this.isComponentMounted && this.instanceId === currentInstanceId) {\n                // If still mounted on the next tick, with the same instanceId, do not destroy the editor\n                if (currentEditor) {\n                    // just re-apply options as they might have changed\n                    currentEditor.setOptions(this.options.current);\n                }\n                return;\n            }\n            if (currentEditor && !currentEditor.isDestroyed) {\n                currentEditor.destroy();\n                if (this.instanceId === currentInstanceId) {\n                    this.setEditor(null);\n                }\n            }\n        }, 0);\n    }\n}\nfunction useEditor(options = {}, deps = []) {\n    const mostRecentOptions = useRef(options);\n    mostRecentOptions.current = options;\n    const [instanceManager] = useState(() => new EditorInstanceManager(mostRecentOptions));\n    const editor = shimExports.useSyncExternalStore(instanceManager.subscribe, instanceManager.getEditor, instanceManager.getServerSnapshot);\n    useDebugValue(editor);\n    // This effect will handle creating/updating the editor instance\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    useEffect(instanceManager.onRender(deps));\n    // The default behavior is to re-render on each transaction\n    // This is legacy behavior that will be removed in future versions\n    useEditorState({\n        editor,\n        selector: ({ transactionNumber }) => {\n            if (options.shouldRerenderOnTransaction === false) {\n                // This will prevent the editor from re-rendering on each transaction\n                return null;\n            }\n            // This will avoid re-rendering on the first transaction when `immediatelyRender` is set to `true`\n            if (options.immediatelyRender && transactionNumber === 0) {\n                return 0;\n            }\n            return transactionNumber + 1;\n        },\n    });\n    return editor;\n}\n\nconst EditorContext = createContext({\n    editor: null,\n});\nconst EditorConsumer = EditorContext.Consumer;\n/**\n * A hook to get the current editor instance.\n */\nconst useCurrentEditor = () => useContext(EditorContext);\n/**\n * This is the provider component for the editor.\n * It allows the editor to be accessible across the entire component tree\n * with `useCurrentEditor`.\n */\nfunction EditorProvider({ children, slotAfter, slotBefore, ...editorOptions }) {\n    const editor = useEditor(editorOptions);\n    if (!editor) {\n        return null;\n    }\n    return (React.createElement(EditorContext.Provider, { value: { editor } },\n        slotBefore,\n        React.createElement(EditorConsumer, null, ({ editor: currentEditor }) => (React.createElement(EditorContent, { editor: currentEditor }))),\n        children,\n        slotAfter));\n}\n\nconst BubbleMenu = (props) => {\n    const [element, setElement] = useState(null);\n    const { editor: currentEditor } = useCurrentEditor();\n    useEffect(() => {\n        var _a;\n        if (!element) {\n            return;\n        }\n        if (((_a = props.editor) === null || _a === void 0 ? void 0 : _a.isDestroyed) || (currentEditor === null || currentEditor === void 0 ? void 0 : currentEditor.isDestroyed)) {\n            return;\n        }\n        const { pluginKey = 'bubbleMenu', editor, tippyOptions = {}, updateDelay, shouldShow = null, } = props;\n        const menuEditor = editor || currentEditor;\n        if (!menuEditor) {\n            console.warn('BubbleMenu component is not rendered inside of an editor component or does not have editor prop.');\n            return;\n        }\n        const plugin = BubbleMenuPlugin({\n            updateDelay,\n            editor: menuEditor,\n            element,\n            pluginKey,\n            shouldShow,\n            tippyOptions,\n        });\n        menuEditor.registerPlugin(plugin);\n        return () => menuEditor.unregisterPlugin(pluginKey);\n    }, [props.editor, currentEditor, element]);\n    return (React.createElement(\"div\", { ref: setElement, className: props.className, style: { visibility: 'hidden' } }, props.children));\n};\n\nconst FloatingMenu = (props) => {\n    const [element, setElement] = useState(null);\n    const { editor: currentEditor } = useCurrentEditor();\n    useEffect(() => {\n        var _a;\n        if (!element) {\n            return;\n        }\n        if (((_a = props.editor) === null || _a === void 0 ? void 0 : _a.isDestroyed) || (currentEditor === null || currentEditor === void 0 ? void 0 : currentEditor.isDestroyed)) {\n            return;\n        }\n        const { pluginKey = 'floatingMenu', editor, tippyOptions = {}, shouldShow = null, } = props;\n        const menuEditor = editor || currentEditor;\n        if (!menuEditor) {\n            console.warn('FloatingMenu component is not rendered inside of an editor component or does not have editor prop.');\n            return;\n        }\n        const plugin = FloatingMenuPlugin({\n            pluginKey,\n            editor: menuEditor,\n            element,\n            tippyOptions,\n            shouldShow,\n        });\n        menuEditor.registerPlugin(plugin);\n        return () => menuEditor.unregisterPlugin(pluginKey);\n    }, [\n        props.editor,\n        currentEditor,\n        element,\n    ]);\n    return (React.createElement(\"div\", { ref: setElement, className: props.className, style: { visibility: 'hidden' } }, props.children));\n};\n\nconst ReactNodeViewContext = createContext({\n    onDragStart: undefined,\n});\nconst useReactNodeView = () => useContext(ReactNodeViewContext);\n\nconst NodeViewContent = props => {\n    const Tag = props.as || 'div';\n    const { nodeViewContentRef } = useReactNodeView();\n    return (React.createElement(Tag, { ...props, ref: nodeViewContentRef, \"data-node-view-content\": \"\", style: {\n            whiteSpace: 'pre-wrap',\n            ...props.style,\n        } }));\n};\n\nconst NodeViewWrapper = React.forwardRef((props, ref) => {\n    const { onDragStart } = useReactNodeView();\n    const Tag = props.as || 'div';\n    return (React.createElement(Tag, { ...props, ref: ref, \"data-node-view-wrapper\": \"\", onDragStart: onDragStart, style: {\n            whiteSpace: 'normal',\n            ...props.style,\n        } }));\n});\n\n/**\n * Check if a component is a class component.\n * @param Component\n * @returns {boolean}\n */\nfunction isClassComponent(Component) {\n    return !!(typeof Component === 'function'\n        && Component.prototype\n        && Component.prototype.isReactComponent);\n}\n/**\n * Check if a component is a forward ref component.\n * @param Component\n * @returns {boolean}\n */\nfunction isForwardRefComponent(Component) {\n    var _a;\n    return !!(typeof Component === 'object'\n        && ((_a = Component.$$typeof) === null || _a === void 0 ? void 0 : _a.toString()) === 'Symbol(react.forward_ref)');\n}\n/**\n * The ReactRenderer class. It's responsible for rendering React components inside the editor.\n * @example\n * new ReactRenderer(MyComponent, {\n *   editor,\n *   props: {\n *     foo: 'bar',\n *   },\n *   as: 'span',\n * })\n*/\nclass ReactRenderer {\n    constructor(component, { editor, props = {}, as = 'div', className = '', attrs, }) {\n        this.ref = null;\n        this.id = Math.floor(Math.random() * 0xFFFFFFFF).toString();\n        this.component = component;\n        this.editor = editor;\n        this.props = props;\n        this.element = document.createElement(as);\n        this.element.classList.add('react-renderer');\n        if (className) {\n            this.element.classList.add(...className.split(' '));\n        }\n        if (attrs) {\n            Object.keys(attrs).forEach(key => {\n                this.element.setAttribute(key, attrs[key]);\n            });\n        }\n        this.render();\n    }\n    render() {\n        var _a, _b;\n        const Component = this.component;\n        const props = this.props;\n        if (isClassComponent(Component) || isForwardRefComponent(Component)) {\n            props.ref = (ref) => {\n                this.ref = ref;\n            };\n        }\n        this.reactElement = React.createElement(Component, { ...props });\n        (_b = (_a = this.editor) === null || _a === void 0 ? void 0 : _a.contentComponent) === null || _b === void 0 ? void 0 : _b.setRenderer(this.id, this);\n    }\n    updateProps(props = {}) {\n        this.props = {\n            ...this.props,\n            ...props,\n        };\n        this.render();\n    }\n    destroy() {\n        var _a, _b;\n        (_b = (_a = this.editor) === null || _a === void 0 ? void 0 : _a.contentComponent) === null || _b === void 0 ? void 0 : _b.removeRenderer(this.id);\n    }\n}\n\nclass ReactNodeView extends NodeView {\n    mount() {\n        const props = {\n            editor: this.editor,\n            node: this.node,\n            decorations: this.decorations,\n            selected: false,\n            extension: this.extension,\n            getPos: () => this.getPos(),\n            updateAttributes: (attributes = {}) => this.updateAttributes(attributes),\n            deleteNode: () => this.deleteNode(),\n        };\n        if (!this.component.displayName) {\n            const capitalizeFirstChar = (string) => {\n                return string.charAt(0).toUpperCase() + string.substring(1);\n            };\n            this.component.displayName = capitalizeFirstChar(this.extension.name);\n        }\n        const ReactNodeViewProvider = componentProps => {\n            const Component = this.component;\n            const onDragStart = this.onDragStart.bind(this);\n            const nodeViewContentRef = element => {\n                if (element && this.contentDOMElement && element.firstChild !== this.contentDOMElement) {\n                    element.appendChild(this.contentDOMElement);\n                }\n            };\n            return (React.createElement(React.Fragment, null,\n                React.createElement(ReactNodeViewContext.Provider, { value: { onDragStart, nodeViewContentRef } },\n                    React.createElement(Component, { ...componentProps }))));\n        };\n        ReactNodeViewProvider.displayName = 'ReactNodeView';\n        if (this.node.isLeaf) {\n            this.contentDOMElement = null;\n        }\n        else if (this.options.contentDOMElementTag) {\n            this.contentDOMElement = document.createElement(this.options.contentDOMElementTag);\n        }\n        else {\n            this.contentDOMElement = document.createElement(this.node.isInline ? 'span' : 'div');\n        }\n        if (this.contentDOMElement) {\n            // For some reason the whiteSpace prop is not inherited properly in Chrome and Safari\n            // With this fix it seems to work fine\n            // See: https://github.com/ueberdosis/tiptap/issues/1197\n            this.contentDOMElement.style.whiteSpace = 'inherit';\n        }\n        let as = this.node.isInline ? 'span' : 'div';\n        if (this.options.as) {\n            as = this.options.as;\n        }\n        const { className = '' } = this.options;\n        this.handleSelectionUpdate = this.handleSelectionUpdate.bind(this);\n        this.editor.on('selectionUpdate', this.handleSelectionUpdate);\n        this.renderer = new ReactRenderer(ReactNodeViewProvider, {\n            editor: this.editor,\n            props,\n            as,\n            className: `node-${this.node.type.name} ${className}`.trim(),\n            attrs: this.options.attrs,\n        });\n    }\n    get dom() {\n        var _a;\n        if (this.renderer.element.firstElementChild\n            && !((_a = this.renderer.element.firstElementChild) === null || _a === void 0 ? void 0 : _a.hasAttribute('data-node-view-wrapper'))) {\n            throw Error('Please use the NodeViewWrapper component for your node view.');\n        }\n        return this.renderer.element;\n    }\n    get contentDOM() {\n        if (this.node.isLeaf) {\n            return null;\n        }\n        return this.contentDOMElement;\n    }\n    handleSelectionUpdate() {\n        const { from, to } = this.editor.state.selection;\n        if (from <= this.getPos() && to >= this.getPos() + this.node.nodeSize) {\n            if (this.renderer.props.selected) {\n                return;\n            }\n            this.selectNode();\n        }\n        else {\n            if (!this.renderer.props.selected) {\n                return;\n            }\n            this.deselectNode();\n        }\n    }\n    update(node, decorations) {\n        const updateProps = (props) => {\n            this.renderer.updateProps(props);\n        };\n        if (node.type !== this.node.type) {\n            return false;\n        }\n        if (typeof this.options.update === 'function') {\n            const oldNode = this.node;\n            const oldDecorations = this.decorations;\n            this.node = node;\n            this.decorations = decorations;\n            return this.options.update({\n                oldNode,\n                oldDecorations,\n                newNode: node,\n                newDecorations: decorations,\n                updateProps: () => updateProps({ node, decorations }),\n            });\n        }\n        if (node === this.node && this.decorations === decorations) {\n            return true;\n        }\n        this.node = node;\n        this.decorations = decorations;\n        updateProps({ node, decorations });\n        return true;\n    }\n    selectNode() {\n        this.renderer.updateProps({\n            selected: true,\n        });\n        this.renderer.element.classList.add('ProseMirror-selectednode');\n    }\n    deselectNode() {\n        this.renderer.updateProps({\n            selected: false,\n        });\n        this.renderer.element.classList.remove('ProseMirror-selectednode');\n    }\n    destroy() {\n        this.renderer.destroy();\n        this.editor.off('selectionUpdate', this.handleSelectionUpdate);\n        this.contentDOMElement = null;\n    }\n}\nfunction ReactNodeViewRenderer(component, options) {\n    return (props) => {\n        // try to get the parent component\n        // this is important for vue devtools to show the component hierarchy correctly\n        // maybe its `undefined` because <editor-content> isnt rendered yet\n        if (!props.editor.contentComponent) {\n            return {};\n        }\n        return new ReactNodeView(component, props, options);\n    };\n}\n\nexport { BubbleMenu, Editor, EditorConsumer, EditorContent, EditorContext, EditorProvider, FloatingMenu, NodeViewContent, NodeViewWrapper, PureEditorContent, ReactNodeViewContext, ReactNodeViewRenderer, ReactRenderer, useCurrentEditor, useEditor, useEditorState, useReactNodeView };\n//# sourceMappingURL=index.js.map\n","function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\nmodule.exports = _classCallCheck, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","import computeOffsets from \"../utils/computeOffsets.js\";\n\nfunction popperOffsets(_ref) {\n  var state = _ref.state,\n      name = _ref.name;\n  // Offsets are the actual position the popper needs to have to be\n  // properly positioned near its reference element\n  // This is the most basic placement, and will be adjusted by\n  // the modifiers in the next step\n  state.modifiersData[name] = computeOffsets({\n    reference: state.rects.reference,\n    element: state.rects.popper,\n    strategy: 'absolute',\n    placement: state.placement\n  });\n} // eslint-disable-next-line import/no-unused-modules\n\n\nexport default {\n  name: 'popperOffsets',\n  enabled: true,\n  phase: 'read',\n  fn: popperOffsets,\n  data: {}\n};","import { isShadowRoot } from \"./instanceOf.js\";\nexport default function contains(parent, child) {\n  var rootNode = child.getRootNode && child.getRootNode(); // First, attempt with faster native method\n\n  if (parent.contains(child)) {\n    return true;\n  } // then fallback to custom implementation with Shadow DOM support\n  else if (rootNode && isShadowRoot(rootNode)) {\n      var next = child;\n\n      do {\n        if (next && parent.isSameNode(next)) {\n          return true;\n        } // $FlowFixMe[prop-missing]: need a better way to handle this...\n\n\n        next = next.parentNode || next.host;\n      } while (next);\n    } // Give up, the result is false\n\n\n  return false;\n}","import getWindow from \"./getWindow.js\";\nimport getNodeName from \"./getNodeName.js\";\nimport getComputedStyle from \"./getComputedStyle.js\";\nimport { isHTMLElement, isShadowRoot } from \"./instanceOf.js\";\nimport isTableElement from \"./isTableElement.js\";\nimport getParentNode from \"./getParentNode.js\";\nimport getUAString from \"../utils/userAgent.js\";\n\nfunction getTrueOffsetParent(element) {\n  if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837\n  getComputedStyle(element).position === 'fixed') {\n    return null;\n  }\n\n  return element.offsetParent;\n} // `.offsetParent` reports `null` for fixed elements, while absolute elements\n// return the containing block\n\n\nfunction getContainingBlock(element) {\n  var isFirefox = /firefox/i.test(getUAString());\n  var isIE = /Trident/i.test(getUAString());\n\n  if (isIE && isHTMLElement(element)) {\n    // In IE 9, 10 and 11 fixed elements containing block is always established by the viewport\n    var elementCss = getComputedStyle(element);\n\n    if (elementCss.position === 'fixed') {\n      return null;\n    }\n  }\n\n  var currentNode = getParentNode(element);\n\n  if (isShadowRoot(currentNode)) {\n    currentNode = currentNode.host;\n  }\n\n  while (isHTMLElement(currentNode) && ['html', 'body'].indexOf(getNodeName(currentNode)) < 0) {\n    var css = getComputedStyle(currentNode); // This is non-exhaustive but covers the most common CSS properties that\n    // create a containing block.\n    // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n\n    if (css.transform !== 'none' || css.perspective !== 'none' || css.contain === 'paint' || ['transform', 'perspective'].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === 'filter' || isFirefox && css.filter && css.filter !== 'none') {\n      return currentNode;\n    } else {\n      currentNode = currentNode.parentNode;\n    }\n  }\n\n  return null;\n} // Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\n\n\nexport default function getOffsetParent(element) {\n  var window = getWindow(element);\n  var offsetParent = getTrueOffsetParent(element);\n\n  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === 'static') {\n    offsetParent = getTrueOffsetParent(offsetParent);\n  }\n\n  if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle(offsetParent).position === 'static')) {\n    return window;\n  }\n\n  return offsetParent || getContainingBlock(element) || window;\n}","export default function getMainAxisFromPlacement(placement) {\n  return ['top', 'bottom'].indexOf(placement) >= 0 ? 'x' : 'y';\n}","export default function _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n  return _setPrototypeOf(o, p);\n}","import { __assign, __spreadArray } from \"tslib\";\nimport * as React from 'react';\nimport { concatStyleSets } from '@fluentui/style-utilities';\nimport { Customizations, CustomizerContext } from '@fluentui/utilities';\nimport { createFactory } from './slots';\nimport { assign } from './utilities';\n/**\n * Assembles a higher order component based on the following: styles, theme, view, and state.\n * Imposes a separation of concern and centralizes styling processing to increase ease of use and robustness\n * in how components use and apply styling and theming.\n *\n * Automatically merges and applies themes and styles with theme / styleprops having the highest priority.\n * State component, if provided, is passed in props for processing. Props from state / user are automatically processed\n * and styled before finally being passed to view.\n *\n * State components should contain all stateful behavior and should not generate any JSX, but rather simply call\n * the view prop.\n *\n * Views should simply be stateless pure functions that receive all props needed for rendering their output.\n *\n * State component is optional. If state is not provided, created component is essentially a functional\n * stateless component.\n *\n * @param options - component Component options. See IComponentOptions for more detail.\n */\nexport function createComponent(view, options) {\n    if (options === void 0) { options = {}; }\n    var _a = options.factoryOptions, factoryOptions = _a === void 0 ? {} : _a;\n    var defaultProp = factoryOptions.defaultProp;\n    var ResultComponent = function (componentProps) {\n        var settings = _getCustomizations(options.displayName, React.useContext(CustomizerContext), options.fields);\n        var stateReducer = options.state;\n        if (stateReducer) {\n            // Don't assume state will return all props, so spread useState result over component props.\n            componentProps = __assign(__assign({}, componentProps), stateReducer(componentProps));\n        }\n        var theme = componentProps.theme || settings.theme;\n        var tokens = _resolveTokens(componentProps, theme, options.tokens, settings.tokens, componentProps.tokens);\n        var styles = _resolveStyles(componentProps, theme, tokens, options.styles, settings.styles, componentProps.styles);\n        var viewProps = __assign(__assign({}, componentProps), { styles: styles, tokens: tokens, _defaultStyles: styles, theme: theme });\n        return view(viewProps);\n    };\n    ResultComponent.displayName = options.displayName || view.name;\n    // If a shorthand prop is defined, create a factory for the component.\n    // TODO: This shouldn't be a concern of createComponent.. factoryOptions should just be forwarded.\n    //       Need to weigh creating default factories on component creation vs. memoizing them on use in slots.tsx.\n    if (defaultProp) {\n        ResultComponent.create = createFactory(ResultComponent, { defaultProp: defaultProp });\n    }\n    assign(ResultComponent, options.statics);\n    // Later versions of TypeSript should allow us to merge objects in a type safe way and avoid this cast.\n    return ResultComponent;\n}\n/**\n * Resolve all styles functions with both props and tokens and flatten results along with all styles objects.\n */\nfunction _resolveStyles(props, theme, tokens) {\n    var allStyles = [];\n    for (var _i = 3; _i < arguments.length; _i++) {\n        allStyles[_i - 3] = arguments[_i];\n    }\n    return concatStyleSets.apply(void 0, allStyles.map(function (styles) {\n        return typeof styles === 'function' ? styles(props, theme, tokens) : styles;\n    }));\n}\n/**\n * Resolve all tokens functions with props flatten results along with all tokens objects.\n */\nfunction _resolveTokens(props, theme) {\n    var allTokens = [];\n    for (var _i = 2; _i < arguments.length; _i++) {\n        allTokens[_i - 2] = arguments[_i];\n    }\n    var tokens = {};\n    for (var _a = 0, allTokens_1 = allTokens; _a < allTokens_1.length; _a++) {\n        var currentTokens = allTokens_1[_a];\n        if (currentTokens) {\n            // TODO: why is this cast needed? TS seems to think there is a (TToken | Function) union from somewhere.\n            currentTokens =\n                typeof currentTokens === 'function'\n                    ? currentTokens(props, theme)\n                    : currentTokens;\n            if (Array.isArray(currentTokens)) {\n                currentTokens = _resolveTokens.apply(void 0, __spreadArray([props, theme], currentTokens, false));\n            }\n            assign(tokens, currentTokens);\n        }\n    }\n    return tokens;\n}\n/**\n * Helper function for calling Customizations.getSettings falling back to default fields.\n *\n * @param displayName Displayable name for component.\n * @param context React context passed to component containing contextual settings.\n * @param fields Optional list of properties to grab from global store and context.\n */\nfunction _getCustomizations(displayName, context, fields) {\n    // TODO: do we want field props? should fields be part of IComponent and used here?\n    // TODO: should we centrally define DefaultFields? (not exported from styling)\n    // TODO: tie this array to ICustomizationProps, such that each array element is keyof ICustomizationProps\n    var DefaultFields = ['theme', 'styles', 'tokens'];\n    return Customizations.getSettings(fields || DefaultFields, displayName, context.customizations);\n}\n//# sourceMappingURL=createComponent.js.map","import { top, left, right, bottom, end } from \"../enums.js\";\nimport getOffsetParent from \"../dom-utils/getOffsetParent.js\";\nimport getWindow from \"../dom-utils/getWindow.js\";\nimport getDocumentElement from \"../dom-utils/getDocumentElement.js\";\nimport getComputedStyle from \"../dom-utils/getComputedStyle.js\";\nimport getBasePlacement from \"../utils/getBasePlacement.js\";\nimport getVariation from \"../utils/getVariation.js\";\nimport { round } from \"../utils/math.js\"; // eslint-disable-next-line import/no-unused-modules\n\nvar unsetSides = {\n  top: 'auto',\n  right: 'auto',\n  bottom: 'auto',\n  left: 'auto'\n}; // Round the offsets to the nearest suitable subpixel based on the DPR.\n// Zooming can change the DPR, but it seems to report a value that will\n// cleanly divide the values into the appropriate subpixels.\n\nfunction roundOffsetsByDPR(_ref, win) {\n  var x = _ref.x,\n      y = _ref.y;\n  var dpr = win.devicePixelRatio || 1;\n  return {\n    x: round(x * dpr) / dpr || 0,\n    y: round(y * dpr) / dpr || 0\n  };\n}\n\nexport function mapToStyles(_ref2) {\n  var _Object$assign2;\n\n  var popper = _ref2.popper,\n      popperRect = _ref2.popperRect,\n      placement = _ref2.placement,\n      variation = _ref2.variation,\n      offsets = _ref2.offsets,\n      position = _ref2.position,\n      gpuAcceleration = _ref2.gpuAcceleration,\n      adaptive = _ref2.adaptive,\n      roundOffsets = _ref2.roundOffsets,\n      isFixed = _ref2.isFixed;\n  var _offsets$x = offsets.x,\n      x = _offsets$x === void 0 ? 0 : _offsets$x,\n      _offsets$y = offsets.y,\n      y = _offsets$y === void 0 ? 0 : _offsets$y;\n\n  var _ref3 = typeof roundOffsets === 'function' ? roundOffsets({\n    x: x,\n    y: y\n  }) : {\n    x: x,\n    y: y\n  };\n\n  x = _ref3.x;\n  y = _ref3.y;\n  var hasX = offsets.hasOwnProperty('x');\n  var hasY = offsets.hasOwnProperty('y');\n  var sideX = left;\n  var sideY = top;\n  var win = window;\n\n  if (adaptive) {\n    var offsetParent = getOffsetParent(popper);\n    var heightProp = 'clientHeight';\n    var widthProp = 'clientWidth';\n\n    if (offsetParent === getWindow(popper)) {\n      offsetParent = getDocumentElement(popper);\n\n      if (getComputedStyle(offsetParent).position !== 'static' && position === 'absolute') {\n        heightProp = 'scrollHeight';\n        widthProp = 'scrollWidth';\n      }\n    } // $FlowFixMe[incompatible-cast]: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it\n\n\n    offsetParent = offsetParent;\n\n    if (placement === top || (placement === left || placement === right) && variation === end) {\n      sideY = bottom;\n      var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : // $FlowFixMe[prop-missing]\n      offsetParent[heightProp];\n      y -= offsetY - popperRect.height;\n      y *= gpuAcceleration ? 1 : -1;\n    }\n\n    if (placement === left || (placement === top || placement === bottom) && variation === end) {\n      sideX = right;\n      var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : // $FlowFixMe[prop-missing]\n      offsetParent[widthProp];\n      x -= offsetX - popperRect.width;\n      x *= gpuAcceleration ? 1 : -1;\n    }\n  }\n\n  var commonStyles = Object.assign({\n    position: position\n  }, adaptive && unsetSides);\n\n  var _ref4 = roundOffsets === true ? roundOffsetsByDPR({\n    x: x,\n    y: y\n  }, getWindow(popper)) : {\n    x: x,\n    y: y\n  };\n\n  x = _ref4.x;\n  y = _ref4.y;\n\n  if (gpuAcceleration) {\n    var _Object$assign;\n\n    return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? '0' : '', _Object$assign[sideX] = hasX ? '0' : '', _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? \"translate(\" + x + \"px, \" + y + \"px)\" : \"translate3d(\" + x + \"px, \" + y + \"px, 0)\", _Object$assign));\n  }\n\n  return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + \"px\" : '', _Object$assign2[sideX] = hasX ? x + \"px\" : '', _Object$assign2.transform = '', _Object$assign2));\n}\n\nfunction computeStyles(_ref5) {\n  var state = _ref5.state,\n      options = _ref5.options;\n  var _options$gpuAccelerat = options.gpuAcceleration,\n      gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,\n      _options$adaptive = options.adaptive,\n      adaptive = _options$adaptive === void 0 ? true : _options$adaptive,\n      _options$roundOffsets = options.roundOffsets,\n      roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;\n  var commonStyles = {\n    placement: getBasePlacement(state.placement),\n    variation: getVariation(state.placement),\n    popper: state.elements.popper,\n    popperRect: state.rects.popper,\n    gpuAcceleration: gpuAcceleration,\n    isFixed: state.options.strategy === 'fixed'\n  };\n\n  if (state.modifiersData.popperOffsets != null) {\n    state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {\n      offsets: state.modifiersData.popperOffsets,\n      position: state.options.strategy,\n      adaptive: adaptive,\n      roundOffsets: roundOffsets\n    })));\n  }\n\n  if (state.modifiersData.arrow != null) {\n    state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {\n      offsets: state.modifiersData.arrow,\n      position: 'absolute',\n      adaptive: false,\n      roundOffsets: roundOffsets\n    })));\n  }\n\n  state.attributes.popper = Object.assign({}, state.attributes.popper, {\n    'data-popper-placement': state.placement\n  });\n} // eslint-disable-next-line import/no-unused-modules\n\n\nexport default {\n  name: 'computeStyles',\n  enabled: true,\n  phase: 'beforeWrite',\n  fn: computeStyles,\n  data: {}\n};","import * as React from 'react';\nimport { registerIcons, FLUENT_CDN_BASE_URL } from '@fluentui/style-utilities';\nimport { FileTypeIconMap } from './FileTypeIconMap';\nvar PNG_SUFFIX = '_png';\nvar SVG_SUFFIX = '_svg';\nexport var DEFAULT_BASE_URL = \"\".concat(FLUENT_CDN_BASE_URL, \"/assets/item-types/\");\nexport var ICON_SIZES = [16, 20, 24, 32, 40, 48, 64, 96];\nexport function initializeFileTypeIcons(baseUrl, options) {\n    if (baseUrl === void 0) { baseUrl = DEFAULT_BASE_URL; }\n    ICON_SIZES.forEach(function (size) {\n        _initializeIcons(baseUrl, size, options);\n    });\n}\nfunction _initializeIcons(baseUrl, size, options) {\n    var iconTypes = Object.keys(FileTypeIconMap);\n    var fileTypeIcons = {};\n    iconTypes.forEach(function (type) {\n        var baseUrlSizeType = baseUrl + size + '/' + type;\n        fileTypeIcons[type + size + PNG_SUFFIX] = React.createElement(\"img\", { src: baseUrlSizeType + '.png', alt: \"\" });\n        fileTypeIcons[type + size + SVG_SUFFIX] = React.createElement(\"img\", { src: baseUrlSizeType + '.svg', alt: \"\" });\n        // For high resolution screens, register additional versions\n        // Apply height=100% and width=100% to force image to fit into containing element\n        // SVGs scale well, so you can generally use the default image.\n        // 1.5x is a special case where both SVGs and PNGs need a different image.\n        fileTypeIcons[type + size + '_1.5x' + PNG_SUFFIX] = (React.createElement(\"img\", { src: baseUrl + size + '_1.5x/' + type + '.png', height: \"100%\", width: \"100%\", alt: \"\" }));\n        fileTypeIcons[type + size + '_1.5x' + SVG_SUFFIX] = (React.createElement(\"img\", { src: baseUrl + size + '_1.5x/' + type + '.svg', height: \"100%\", width: \"100%\", alt: \"\" }));\n        fileTypeIcons[type + size + '_2x' + PNG_SUFFIX] = (React.createElement(\"img\", { src: baseUrl + size + '_2x/' + type + '.png', height: \"100%\", width: \"100%\", alt: \"\" }));\n        fileTypeIcons[type + size + '_3x' + PNG_SUFFIX] = (React.createElement(\"img\", { src: baseUrl + size + '_3x/' + type + '.png', height: \"100%\", width: \"100%\", alt: \"\" }));\n        fileTypeIcons[type + size + '_4x' + PNG_SUFFIX] = (React.createElement(\"img\", { src: baseUrl + size + '_4x/' + type + '.png', height: \"100%\", width: \"100%\", alt: \"\" }));\n    });\n    registerIcons({\n        fontFace: {},\n        style: {\n            width: size,\n            height: size,\n            overflow: 'hidden',\n        },\n        icons: fileTypeIcons,\n        mergeImageProps: true,\n    }, options);\n}\n//# sourceMappingURL=initializeFileTypeIcons.js.map","var toPropertyKey = require(\"./toPropertyKey.js\");\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, toPropertyKey(descriptor.key), descriptor);\n  }\n}\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  Object.defineProperty(Constructor, \"prototype\", {\n    writable: false\n  });\n  return Constructor;\n}\nmodule.exports = _createClass, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","import { __assign } from \"tslib\";\nimport { Customizations, getWindow } from '@fluentui/utilities';\nimport { loadTheme as legacyLoadTheme } from '@microsoft/load-themed-styles';\nimport { createTheme } from '@fluentui/theme';\nexport { createTheme } from '@fluentui/theme';\nvar _theme = createTheme({});\nvar _onThemeChangeCallbacks = [];\nexport var ThemeSettingName = 'theme';\nexport function initializeThemeInCustomizations() {\n    var _a;\n    var _b, _c;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    var win = getWindow();\n    if ((_b = win === null || win === void 0 ? void 0 : win.FabricConfig) === null || _b === void 0 ? void 0 : _b.legacyTheme) {\n        // does everything the `else` clause does and more, such as invoke legacy theming\n        loadTheme(win.FabricConfig.legacyTheme);\n    }\n    else if (!Customizations.getSettings([ThemeSettingName]).theme) {\n        if ((_c = win === null || win === void 0 ? void 0 : win.FabricConfig) === null || _c === void 0 ? void 0 : _c.theme) {\n            _theme = createTheme(win.FabricConfig.theme);\n        }\n        // Set the default theme.\n        Customizations.applySettings((_a = {}, _a[ThemeSettingName] = _theme, _a));\n    }\n}\ninitializeThemeInCustomizations();\n/**\n * Gets the theme object\n * @param depComments - Whether to include deprecated tags as comments for deprecated slots.\n */\nexport function getTheme(depComments) {\n    if (depComments === void 0) { depComments = false; }\n    if (depComments === true) {\n        _theme = createTheme({}, depComments);\n    }\n    return _theme;\n}\n/**\n * Registers a callback that gets called whenever the theme changes.\n * This should only be used when the component cannot automatically get theme changes through its state.\n * This will not register duplicate callbacks.\n */\nexport function registerOnThemeChangeCallback(callback) {\n    if (_onThemeChangeCallbacks.indexOf(callback) === -1) {\n        _onThemeChangeCallbacks.push(callback);\n    }\n}\n/**\n * See registerOnThemeChangeCallback().\n * Removes previously registered callbacks.\n */\nexport function removeOnThemeChangeCallback(callback) {\n    var i = _onThemeChangeCallbacks.indexOf(callback);\n    if (i === -1) {\n        return;\n    }\n    _onThemeChangeCallbacks.splice(i, 1);\n}\n/**\n * Applies the theme, while filling in missing slots.\n * @param theme - Partial theme object.\n * @param depComments - Whether to include deprecated tags as comments for deprecated slots.\n */\nexport function loadTheme(theme, depComments) {\n    var _a;\n    if (depComments === void 0) { depComments = false; }\n    _theme = createTheme(theme, depComments);\n    // Invoke the legacy method of theming the page as well.\n    legacyLoadTheme(__assign(__assign(__assign(__assign({}, _theme.palette), _theme.semanticColors), _theme.effects), _loadFonts(_theme)));\n    Customizations.applySettings((_a = {}, _a[ThemeSettingName] = _theme, _a));\n    _onThemeChangeCallbacks.forEach(function (callback) {\n        try {\n            callback(_theme);\n        }\n        catch (e) {\n            // don't let a bad callback break everything else\n        }\n    });\n    return _theme;\n}\n/**\n * Loads font variables into a JSON object.\n * @param theme - The theme object\n */\nfunction _loadFonts(theme) {\n    var lines = {};\n    for (var _i = 0, _a = Object.keys(theme.fonts); _i < _a.length; _i++) {\n        var fontName = _a[_i];\n        var font = theme.fonts[fontName];\n        for (var _b = 0, _c = Object.keys(font); _b < _c.length; _b++) {\n            var propName = _c[_b];\n            var name_1 = fontName + propName.charAt(0).toUpperCase() + propName.slice(1);\n            var value = font[propName];\n            if (propName === 'fontSize' && typeof value === 'number') {\n                // if it's a number, convert it to px by default like our theming system does\n                value = value + 'px';\n            }\n            lines[name_1] = value;\n        }\n    }\n    return lines;\n}\n//# sourceMappingURL=theme.js.map","import * as React from 'react';\n\n/**\n * @private\n */\nconst TextDirectionContext = /*#__PURE__*/React.createContext('ltr');\n/**\n * @public\n */\nconst TextDirectionProvider = ({\n  children,\n  dir\n}) => {\n  return /*#__PURE__*/React.createElement(TextDirectionContext.Provider, {\n    value: dir\n  }, children);\n};\n/**\n * Returns current directionality of the element's text.\n *\n * @private\n */\nfunction useTextDirection() {\n  return React.useContext(TextDirectionContext);\n}\n\nexport { TextDirectionProvider, useTextDirection };\n//# sourceMappingURL=TextDirectionContext.esm.js.map\n","import { __assign, __extends } from \"tslib\";\nimport * as React from 'react';\nimport { FocusZoneDirection, FocusZoneTabbableElements } from './FocusZone.types';\nimport { KeyCodes, css, elementContains, getDocument, getElementIndexPath, getFocusableByIndexPath, getId, getNativeProps, getNextElement, getParent, getPreviousElement, getRTL, htmlElementProperties, initializeComponentRef, isElementFocusSubZone, isElementFocusZone, isElementTabbable, shouldWrapFocus, warnDeprecations, portalContainsElement, findScrollableParent, createMergedRef, isElementVisibleAndNotHidden, MergeStylesShadowRootContext, } from '@fluentui/utilities';\nimport { mergeStyles } from '@fluentui/merge-styles';\nimport { getTheme } from '@fluentui/style-utilities';\nvar IS_FOCUSABLE_ATTRIBUTE = 'data-is-focusable';\nvar IS_ENTER_DISABLED_ATTRIBUTE = 'data-disable-click-on-enter';\nvar FOCUSZONE_ID_ATTRIBUTE = 'data-focuszone-id';\nvar TABINDEX = 'tabindex';\nvar NO_VERTICAL_WRAP = 'data-no-vertical-wrap';\nvar NO_HORIZONTAL_WRAP = 'data-no-horizontal-wrap';\nvar LARGE_DISTANCE_FROM_CENTER = 999999999;\nvar LARGE_NEGATIVE_DISTANCE_FROM_CENTER = -999999999;\nvar focusZoneStyles;\nvar focusZoneClass = 'ms-FocusZone';\n/**\n * Raises a click on a target element based on a keyboard event.\n */\nfunction raiseClickFromKeyboardEvent(target, ev) {\n    var event;\n    if (typeof MouseEvent === 'function') {\n        event = new MouseEvent('click', {\n            ctrlKey: ev === null || ev === void 0 ? void 0 : ev.ctrlKey,\n            metaKey: ev === null || ev === void 0 ? void 0 : ev.metaKey,\n            shiftKey: ev === null || ev === void 0 ? void 0 : ev.shiftKey,\n            altKey: ev === null || ev === void 0 ? void 0 : ev.altKey,\n            bubbles: ev === null || ev === void 0 ? void 0 : ev.bubbles,\n            cancelable: ev === null || ev === void 0 ? void 0 : ev.cancelable,\n        });\n    }\n    else {\n        // eslint-disable-next-line no-restricted-globals\n        event = document.createEvent('MouseEvents');\n        // eslint-disable-next-line deprecation/deprecation\n        event.initMouseEvent('click', ev ? ev.bubbles : false, ev ? ev.cancelable : false, \n        // eslint-disable-next-line no-restricted-globals\n        window, // not using getWindow() since this can only be run client side\n        0, // detail\n        0, // screen x\n        0, // screen y\n        0, // client x\n        0, // client y\n        ev ? ev.ctrlKey : false, ev ? ev.altKey : false, ev ? ev.shiftKey : false, ev ? ev.metaKey : false, 0, // button\n        null);\n    }\n    target.dispatchEvent(event);\n}\n// Helper function that will return a class for when the root is focused\nfunction getRootClass() {\n    if (!focusZoneStyles) {\n        focusZoneStyles = mergeStyles({\n            selectors: {\n                ':focus': {\n                    outline: 'none',\n                },\n            },\n        }, focusZoneClass);\n    }\n    return focusZoneStyles;\n}\nvar _allInstances = {};\nvar _outerZones = new Set();\nvar ALLOWED_INPUT_TYPES = ['text', 'number', 'password', 'email', 'tel', 'url', 'search', 'textarea'];\nvar ALLOW_VIRTUAL_ELEMENTS = false;\nexport var FocusZone = /** @class */ (function (_super) {\n    __extends(FocusZone, _super);\n    function FocusZone(props) {\n        var _this = this;\n        var _a, _b, _c, _d;\n        _this = _super.call(this, props) || this;\n        _this._root = React.createRef();\n        _this._mergedRef = createMergedRef();\n        _this._onFocus = function (ev) {\n            var _a;\n            if (_this._portalContainsElement(ev.target)) {\n                // If the event target is inside a portal do not process the event.\n                return;\n            }\n            var onActiveElementChanged = (_a = _this.props, _a.onActiveElementChanged), \n            // eslint-disable-next-line deprecation/deprecation\n            doNotAllowFocusEventToPropagate = _a.doNotAllowFocusEventToPropagate, stopFocusPropagation = _a.stopFocusPropagation, \n            // eslint-disable-next-line deprecation/deprecation\n            onFocusNotification = _a.onFocusNotification, onFocus = _a.onFocus, shouldFocusInnerElementWhenReceivedFocus = _a.shouldFocusInnerElementWhenReceivedFocus, defaultTabbableElement = _a.defaultTabbableElement;\n            var isImmediateDescendant = _this._isImmediateDescendantOfZone(ev.target);\n            var newActiveElement;\n            if (isImmediateDescendant) {\n                newActiveElement = ev.target;\n            }\n            else {\n                var parentElement = ev.target;\n                while (parentElement && parentElement !== _this._root.current) {\n                    if (isElementTabbable(parentElement, undefined, _this._inShadowRoot) &&\n                        _this._isImmediateDescendantOfZone(parentElement)) {\n                        newActiveElement = parentElement;\n                        break;\n                    }\n                    parentElement = getParent(parentElement, ALLOW_VIRTUAL_ELEMENTS);\n                }\n            }\n            // If an inner focusable element should be focused when FocusZone container receives focus\n            if (shouldFocusInnerElementWhenReceivedFocus && ev.target === _this._root.current) {\n                var maybeElementToFocus = defaultTabbableElement &&\n                    typeof defaultTabbableElement === 'function' &&\n                    _this._root.current &&\n                    defaultTabbableElement(_this._root.current);\n                // try to focus defaultTabbable element\n                if (maybeElementToFocus && isElementTabbable(maybeElementToFocus, undefined, _this._inShadowRoot)) {\n                    newActiveElement = maybeElementToFocus;\n                    maybeElementToFocus.focus();\n                }\n                else {\n                    // force focus on first focusable element\n                    _this.focus(true);\n                    if (_this._activeElement) {\n                        // set to null as new active element was handled in method above\n                        newActiveElement = null;\n                    }\n                }\n            }\n            var initialElementFocused = !_this._activeElement;\n            // If the new active element is a child of this zone and received focus,\n            // update alignment an immediate descendant\n            if (newActiveElement && newActiveElement !== _this._activeElement) {\n                if (isImmediateDescendant || initialElementFocused) {\n                    _this._setFocusAlignment(newActiveElement, true, true);\n                }\n                _this._activeElement = newActiveElement;\n                if (initialElementFocused) {\n                    _this._updateTabIndexes();\n                }\n            }\n            if (onActiveElementChanged) {\n                onActiveElementChanged(_this._activeElement, ev);\n            }\n            if (stopFocusPropagation || doNotAllowFocusEventToPropagate) {\n                ev.stopPropagation();\n            }\n            if (onFocus) {\n                onFocus(ev);\n            }\n            else if (onFocusNotification) {\n                onFocusNotification();\n            }\n        };\n        _this._onBlur = function () {\n            _this._setParkedFocus(false);\n        };\n        _this._onMouseDown = function (ev) {\n            if (_this._portalContainsElement(ev.target)) {\n                // If the event target is inside a portal do not process the event.\n                return;\n            }\n            var disabled = _this.props.disabled;\n            if (disabled) {\n                return;\n            }\n            var target = ev.target;\n            var path = [];\n            while (target && target !== _this._root.current) {\n                path.push(target);\n                target = getParent(target, ALLOW_VIRTUAL_ELEMENTS);\n            }\n            while (path.length) {\n                target = path.pop();\n                if (target && isElementTabbable(target, undefined, _this._inShadowRoot)) {\n                    _this._setActiveElement(target, true);\n                }\n                if (isElementFocusZone(target)) {\n                    // Stop here since the focus zone will take care of its own children.\n                    break;\n                }\n            }\n        };\n        /**\n         * Handle the keystrokes.\n         */\n        _this._onKeyDown = function (ev, theme) {\n            var _a;\n            if (_this._portalContainsElement(ev.target)) {\n                // If the event target is inside a portal do not process the event.\n                return;\n            }\n            // eslint-disable-next-line deprecation/deprecation\n            var direction = (_a = _this.props, _a.direction), disabled = _a.disabled, isInnerZoneKeystroke = _a.isInnerZoneKeystroke, pagingSupportDisabled = _a.pagingSupportDisabled, shouldEnterInnerZone = _a.shouldEnterInnerZone;\n            if (disabled) {\n                return;\n            }\n            if (_this.props.onKeyDown) {\n                _this.props.onKeyDown(ev);\n            }\n            // If the default has been prevented, do not process keyboard events.\n            if (ev.isDefaultPrevented()) {\n                return;\n            }\n            if (_this._getDocument().activeElement === _this._root.current && _this._isInnerZone) {\n                // If this element has focus, it is being controlled by a parent.\n                // Ignore the keystroke.\n                return;\n            }\n            if (((shouldEnterInnerZone && shouldEnterInnerZone(ev)) || (isInnerZoneKeystroke && isInnerZoneKeystroke(ev))) &&\n                _this._isImmediateDescendantOfZone(ev.target)) {\n                // Try to focus\n                var innerZone = _this._getFirstInnerZone();\n                if (innerZone) {\n                    if (!innerZone.focus(true)) {\n                        return;\n                    }\n                }\n                else if (isElementFocusSubZone(ev.target)) {\n                    if (!_this.focusElement(getNextElement(ev.target, ev.target.firstChild, true))) {\n                        return;\n                    }\n                }\n                else {\n                    return;\n                }\n            }\n            else if (ev.altKey) {\n                return;\n            }\n            else {\n                // eslint-disable-next-line @fluentui/deprecated-keyboard-event-props, deprecation/deprecation\n                switch (ev.which) {\n                    case KeyCodes.space:\n                        if (_this._shouldRaiseClicksOnSpace && _this._tryInvokeClickForFocusable(ev.target, ev)) {\n                            break;\n                        }\n                        return;\n                    case KeyCodes.left:\n                        if (direction !== FocusZoneDirection.vertical) {\n                            _this._preventDefaultWhenHandled(ev);\n                            if (_this._moveFocusLeft(theme)) {\n                                break;\n                            }\n                        }\n                        return;\n                    case KeyCodes.right:\n                        if (direction !== FocusZoneDirection.vertical) {\n                            _this._preventDefaultWhenHandled(ev);\n                            if (_this._moveFocusRight(theme)) {\n                                break;\n                            }\n                        }\n                        return;\n                    case KeyCodes.up:\n                        if (direction !== FocusZoneDirection.horizontal) {\n                            _this._preventDefaultWhenHandled(ev);\n                            if (_this._moveFocusUp()) {\n                                break;\n                            }\n                        }\n                        return;\n                    case KeyCodes.down:\n                        if (direction !== FocusZoneDirection.horizontal) {\n                            _this._preventDefaultWhenHandled(ev);\n                            if (_this._moveFocusDown()) {\n                                break;\n                            }\n                        }\n                        return;\n                    case KeyCodes.pageDown:\n                        if (!pagingSupportDisabled && _this._moveFocusPaging(true)) {\n                            break;\n                        }\n                        return;\n                    case KeyCodes.pageUp:\n                        if (!pagingSupportDisabled && _this._moveFocusPaging(false)) {\n                            break;\n                        }\n                        return;\n                    case KeyCodes.tab:\n                        if (\n                        // eslint-disable-next-line deprecation/deprecation\n                        _this.props.allowTabKey ||\n                            _this.props.handleTabKey === FocusZoneTabbableElements.all ||\n                            (_this.props.handleTabKey === FocusZoneTabbableElements.inputOnly &&\n                                _this._isElementInput(ev.target))) {\n                            var focusChanged = false;\n                            _this._processingTabKey = true;\n                            if (direction === FocusZoneDirection.vertical ||\n                                !_this._shouldWrapFocus(_this._activeElement, NO_HORIZONTAL_WRAP)) {\n                                focusChanged = ev.shiftKey ? _this._moveFocusUp() : _this._moveFocusDown();\n                            }\n                            else {\n                                var tabWithDirection = getRTL(theme) ? !ev.shiftKey : ev.shiftKey;\n                                focusChanged = tabWithDirection ? _this._moveFocusLeft(theme) : _this._moveFocusRight(theme);\n                            }\n                            _this._processingTabKey = false;\n                            if (focusChanged) {\n                                break;\n                            }\n                            else if (_this.props.shouldResetActiveElementWhenTabFromZone) {\n                                _this._activeElement = null;\n                            }\n                        }\n                        return;\n                    case KeyCodes.home:\n                        if (_this._isContentEditableElement(ev.target) ||\n                            (_this._isElementInput(ev.target) &&\n                                !_this._shouldInputLoseFocus(ev.target, false))) {\n                            return false;\n                        }\n                        var firstChild = _this._root.current && _this._root.current.firstChild;\n                        if (_this._root.current &&\n                            firstChild &&\n                            _this.focusElement(getNextElement(_this._root.current, firstChild, true))) {\n                            break;\n                        }\n                        return;\n                    case KeyCodes.end:\n                        if (_this._isContentEditableElement(ev.target) ||\n                            (_this._isElementInput(ev.target) &&\n                                !_this._shouldInputLoseFocus(ev.target, true))) {\n                            return false;\n                        }\n                        var lastChild = _this._root.current && _this._root.current.lastChild;\n                        if (_this._root.current &&\n                            _this.focusElement(getPreviousElement(_this._root.current, lastChild, true, true, true))) {\n                            break;\n                        }\n                        return;\n                    case KeyCodes.enter:\n                        if (_this._shouldRaiseClicksOnEnter && _this._tryInvokeClickForFocusable(ev.target, ev)) {\n                            break;\n                        }\n                        return;\n                    default:\n                        return;\n                }\n            }\n            ev.preventDefault();\n            ev.stopPropagation();\n        };\n        _this._getHorizontalDistanceFromCenter = function (isForward, \n        // eslint-disable-next-line deprecation/deprecation\n        activeRect, \n        // eslint-disable-next-line deprecation/deprecation\n        targetRect) {\n            // eslint-disable-next-line deprecation/deprecation\n            var leftAlignment = _this._focusAlignment.left || _this._focusAlignment.x || 0;\n            // ClientRect values can be floats that differ by very small fractions of a decimal.\n            // If the difference between top and bottom are within a pixel then we should treat\n            // them as equivalent by using Math.floor. For instance 5.2222 and 5.222221 should be equivalent,\n            // but without Math.Floor they will be handled incorrectly.\n            var targetRectTop = Math.floor(targetRect.top);\n            var activeRectBottom = Math.floor(activeRect.bottom);\n            var targetRectBottom = Math.floor(targetRect.bottom);\n            var activeRectTop = Math.floor(activeRect.top);\n            var isValidCandidateOnpagingDown = isForward && targetRectTop > activeRectBottom;\n            var isValidCandidateOnpagingUp = !isForward && targetRectBottom < activeRectTop;\n            if (isValidCandidateOnpagingDown || isValidCandidateOnpagingUp) {\n                if (leftAlignment >= targetRect.left && leftAlignment <= targetRect.left + targetRect.width) {\n                    return 0;\n                }\n                return Math.abs(targetRect.left + targetRect.width / 2 - leftAlignment);\n            }\n            if (!_this._shouldWrapFocus(_this._activeElement, NO_VERTICAL_WRAP)) {\n                return LARGE_NEGATIVE_DISTANCE_FROM_CENTER;\n            }\n            return LARGE_DISTANCE_FROM_CENTER;\n        };\n        // Manage componentRef resolution.\n        initializeComponentRef(_this);\n        if (process.env.NODE_ENV !== 'production') {\n            warnDeprecations('FocusZone', props, {\n                rootProps: undefined,\n                allowTabKey: 'handleTabKey',\n                elementType: 'as',\n                ariaDescribedBy: 'aria-describedby',\n                ariaLabelledBy: 'aria-labelledby',\n            });\n        }\n        _this._id = getId('FocusZone');\n        _this._focusAlignment = {\n            left: 0,\n            top: 0,\n        };\n        _this._processingTabKey = false;\n        var shouldRaiseClicksFallback = (_b = (_a = props.shouldRaiseClicks) !== null && _a !== void 0 ? _a : FocusZone.defaultProps.shouldRaiseClicks) !== null && _b !== void 0 ? _b : true;\n        _this._shouldRaiseClicksOnEnter = (_c = props.shouldRaiseClicksOnEnter) !== null && _c !== void 0 ? _c : shouldRaiseClicksFallback;\n        _this._shouldRaiseClicksOnSpace = (_d = props.shouldRaiseClicksOnSpace) !== null && _d !== void 0 ? _d : shouldRaiseClicksFallback;\n        return _this;\n    }\n    /** Used for testing purposes only. */\n    FocusZone.getOuterZones = function () {\n        return _outerZones.size;\n    };\n    /**\n     * Handle global tab presses so that we can patch tabindexes on the fly.\n     * HEADS UP: This must not be an arrow function in order to be referentially equal among instances\n     * for ref counting to work correctly!\n     */\n    FocusZone._onKeyDownCapture = function (ev) {\n        // eslint-disable-next-line deprecation/deprecation, @fluentui/deprecated-keyboard-event-props\n        if (ev.which === KeyCodes.tab) {\n            _outerZones.forEach(function (zone) { return zone._updateTabIndexes(); });\n        }\n    };\n    FocusZone.prototype.componentDidMount = function () {\n        var _a;\n        var root = this._root.current;\n        this._inShadowRoot = !!((_a = this.context) === null || _a === void 0 ? void 0 : _a.shadowRoot);\n        _allInstances[this._id] = this;\n        if (root) {\n            var parentElement = getParent(root, ALLOW_VIRTUAL_ELEMENTS);\n            while (parentElement && parentElement !== this._getDocument().body && parentElement.nodeType === 1) {\n                if (isElementFocusZone(parentElement)) {\n                    this._isInnerZone = true;\n                    break;\n                }\n                parentElement = getParent(parentElement, ALLOW_VIRTUAL_ELEMENTS);\n            }\n            if (!this._isInnerZone) {\n                _outerZones.add(this);\n                this._root.current && this._root.current.addEventListener('keydown', FocusZone._onKeyDownCapture, true);\n            }\n            this._root.current && this._root.current.addEventListener('blur', this._onBlur, true);\n            // Assign initial tab indexes so that we can set initial focus as appropriate.\n            this._updateTabIndexes();\n            if (this.props.defaultTabbableElement && typeof this.props.defaultTabbableElement === 'string') {\n                this._activeElement = this._getDocument().querySelector(this.props.defaultTabbableElement);\n                // eslint-disable-next-line deprecation/deprecation\n            }\n            else if (this.props.defaultActiveElement) {\n                // eslint-disable-next-line deprecation/deprecation\n                this._activeElement = this._getDocument().querySelector(this.props.defaultActiveElement);\n            }\n            if (this.props.shouldFocusOnMount) {\n                this.focus();\n            }\n        }\n    };\n    FocusZone.prototype.componentDidUpdate = function () {\n        var _a;\n        var root = this._root.current;\n        var doc = this._getDocument();\n        this._inShadowRoot = !!((_a = this.context) === null || _a === void 0 ? void 0 : _a.shadowRoot);\n        // If either _activeElement or _defaultFocusElement are no longer contained by _root,\n        // reset those variables (and update tab indexes) to avoid memory leaks\n        if ((this._activeElement && !elementContains(this._root.current, this._activeElement, ALLOW_VIRTUAL_ELEMENTS)) ||\n            (this._defaultFocusElement &&\n                !elementContains(this._root.current, this._defaultFocusElement, ALLOW_VIRTUAL_ELEMENTS))) {\n            this._activeElement = null;\n            this._defaultFocusElement = null;\n            this._updateTabIndexes();\n        }\n        if (!this.props.preventFocusRestoration &&\n            doc &&\n            this._lastIndexPath &&\n            (doc.activeElement === doc.body || doc.activeElement === null || doc.activeElement === root)) {\n            // The element has been removed after the render, attempt to restore focus.\n            var elementToFocus = getFocusableByIndexPath(root, this._lastIndexPath);\n            if (elementToFocus) {\n                this._setActiveElement(elementToFocus, true);\n                elementToFocus.focus();\n                this._setParkedFocus(false);\n            }\n            else {\n                // We had a focus path to restore, but now that path is unresolvable. Park focus\n                // on the container until we can try again.\n                this._setParkedFocus(true);\n            }\n        }\n    };\n    FocusZone.prototype.componentWillUnmount = function () {\n        delete _allInstances[this._id];\n        if (!this._isInnerZone) {\n            _outerZones.delete(this);\n            this._root.current && this._root.current.removeEventListener('keydown', FocusZone._onKeyDownCapture, true);\n        }\n        if (this._root.current) {\n            this._root.current.removeEventListener('blur', this._onBlur, true);\n        }\n        this._activeElement = null;\n        this._defaultFocusElement = null;\n    };\n    FocusZone.prototype.render = function () {\n        var _a;\n        var _this = this;\n        // eslint-disable-next-line deprecation/deprecation\n        var tag = (_a = this.props, _a.as), elementType = _a.elementType, rootProps = _a.rootProps, ariaDescribedBy = _a.ariaDescribedBy, ariaLabelledBy = _a.ariaLabelledBy, className = _a.className;\n        var divProps = getNativeProps(this.props, htmlElementProperties);\n        var Tag = tag || elementType || 'div';\n        // Note, right before rendering/reconciling proceeds, we need to record if focus\n        // was in the zone before the update. This helper will track this and, if focus\n        // was actually in the zone, what the index path to the element is at this time.\n        // Then, later in componentDidUpdate, we can evaluate if we need to restore it in\n        // the case the element was removed.\n        this._evaluateFocusBeforeRender();\n        // Only support RTL defined in global theme, not contextual theme/RTL.\n        var theme = getTheme();\n        return (React.createElement(Tag, __assign({ \"aria-labelledby\": ariaLabelledBy, \"aria-describedby\": ariaDescribedBy }, divProps, rootProps, { \n            // Once the getClassName correctly memoizes inputs this should\n            // be replaced so that className is passed to getRootClass and is included there so\n            // the class names will always be in the same order.\n            className: css(getRootClass(), className), \n            // eslint-disable-next-line deprecation/deprecation\n            ref: this._mergedRef(this.props.elementRef, this._root), \"data-focuszone-id\": this._id, \n            // eslint-disable-next-line react/jsx-no-bind\n            onKeyDown: function (ev) { return _this._onKeyDown(ev, theme); }, onFocus: this._onFocus, onMouseDownCapture: this._onMouseDown }), this.props.children));\n    };\n    /**\n     * Sets focus to the first tabbable item in the zone.\n     * @param forceIntoFirstElement - If true, focus will be forced into the first element, even\n     * if focus is already in the focus zone.\n     * @param bypassHiddenElements - If true, focus will be not be set on hidden elements.\n     * @returns True if focus could be set to an active element, false if no operation was taken.\n     */\n    FocusZone.prototype.focus = function (forceIntoFirstElement, bypassHiddenElements) {\n        if (forceIntoFirstElement === void 0) { forceIntoFirstElement = false; }\n        if (bypassHiddenElements === void 0) { bypassHiddenElements = false; }\n        if (this._root.current) {\n            if (!forceIntoFirstElement &&\n                this._root.current.getAttribute(IS_FOCUSABLE_ATTRIBUTE) === 'true' &&\n                this._isInnerZone) {\n                var ownerZoneElement = this._getOwnerZone(this._root.current);\n                if (ownerZoneElement !== this._root.current) {\n                    var ownerZone = _allInstances[ownerZoneElement.getAttribute(FOCUSZONE_ID_ATTRIBUTE)];\n                    return !!ownerZone && ownerZone.focusElement(this._root.current);\n                }\n                return false;\n            }\n            else if (!forceIntoFirstElement &&\n                this._activeElement &&\n                elementContains(this._root.current, this._activeElement) &&\n                isElementTabbable(this._activeElement, undefined, this._inShadowRoot) &&\n                (!bypassHiddenElements || isElementVisibleAndNotHidden(this._activeElement))) {\n                this._activeElement.focus();\n                return true;\n            }\n            else {\n                var firstChild = this._root.current.firstChild;\n                return this.focusElement(getNextElement(this._root.current, firstChild, true, undefined, undefined, undefined, undefined, undefined, bypassHiddenElements));\n            }\n        }\n        return false;\n    };\n    /**\n     * Sets focus to the last tabbable item in the zone.\n     * @returns True if focus could be set to an active element, false if no operation was taken.\n     */\n    FocusZone.prototype.focusLast = function () {\n        if (this._root.current) {\n            var lastChild = this._root.current && this._root.current.lastChild;\n            return this.focusElement(getPreviousElement(this._root.current, lastChild, true, true, true));\n        }\n        return false;\n    };\n    /**\n     * Sets focus to a specific child element within the zone. This can be used in conjunction with\n     * shouldReceiveFocus to create delayed focus scenarios (like animate the scroll position to the correct\n     * location and then focus.)\n     * @param element - The child element within the zone to focus.\n     * @param forceAlignment - If true, focus alignment will be set according to the element provided.\n     * @returns True if focus could be set to an active element, false if no operation was taken.\n     */\n    FocusZone.prototype.focusElement = function (element, forceAlignment) {\n        var _a;\n        // eslint-disable-next-line deprecation/deprecation\n        var onBeforeFocus = (_a = this.props, _a.onBeforeFocus), shouldReceiveFocus = _a.shouldReceiveFocus;\n        if ((shouldReceiveFocus && !shouldReceiveFocus(element)) || (onBeforeFocus && !onBeforeFocus(element))) {\n            return false;\n        }\n        if (element) {\n            // when we set focus to a specific child, we should recalculate the alignment depending on its position.\n            this._setActiveElement(element, forceAlignment);\n            if (this._activeElement) {\n                this._activeElement.focus();\n            }\n            return true;\n        }\n        return false;\n    };\n    /**\n     * Forces horizontal alignment in the context of vertical arrowing to use specific point as the reference,\n     * rather than a center based on the last horizontal motion.\n     * @param point - the new reference point.\n     */\n    FocusZone.prototype.setFocusAlignment = function (point) {\n        this._focusAlignment = point;\n    };\n    Object.defineProperty(FocusZone.prototype, \"defaultFocusElement\", {\n        get: function () {\n            return this._defaultFocusElement;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(FocusZone.prototype, \"activeElement\", {\n        get: function () {\n            return this._activeElement;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    FocusZone.prototype._evaluateFocusBeforeRender = function () {\n        var root = this._root.current;\n        var doc = this._getDocument();\n        if (doc) {\n            var focusedElement = doc.activeElement;\n            // Only update the index path if we are not parked on the root.\n            if (focusedElement !== root) {\n                var shouldRestoreFocus = elementContains(root, focusedElement, false);\n                this._lastIndexPath = shouldRestoreFocus ? getElementIndexPath(root, focusedElement) : undefined;\n            }\n        }\n    };\n    /**\n     * When focus is in the zone at render time but then all focusable elements are removed,\n     * we \"park\" focus temporarily on the root. Once we update with focusable children, we restore\n     * focus to the closest path from previous. If the user tabs away from the parked container,\n     * we restore focusability to the pre-parked state.\n     */\n    FocusZone.prototype._setParkedFocus = function (isParked) {\n        var root = this._root.current;\n        if (root && this._isParked !== isParked) {\n            this._isParked = isParked;\n            if (isParked) {\n                if (!this.props.allowFocusRoot) {\n                    this._parkedTabIndex = root.getAttribute('tabindex');\n                    root.setAttribute('tabindex', '-1');\n                }\n                root.focus();\n            }\n            else if (!this.props.allowFocusRoot) {\n                if (this._parkedTabIndex) {\n                    root.setAttribute('tabindex', this._parkedTabIndex);\n                    this._parkedTabIndex = undefined;\n                }\n                else {\n                    root.removeAttribute('tabindex');\n                }\n            }\n        }\n    };\n    FocusZone.prototype._setActiveElement = function (element, forceAlignment) {\n        var previousActiveElement = this._activeElement;\n        this._activeElement = element;\n        if (previousActiveElement) {\n            if (isElementFocusZone(previousActiveElement)) {\n                this._updateTabIndexes(previousActiveElement);\n            }\n            previousActiveElement.tabIndex = -1;\n        }\n        if (this._activeElement) {\n            if (!this._focusAlignment || forceAlignment) {\n                this._setFocusAlignment(element, true, true);\n            }\n            this._activeElement.tabIndex = 0;\n        }\n    };\n    FocusZone.prototype._preventDefaultWhenHandled = function (ev) {\n        this.props.preventDefaultWhenHandled && ev.preventDefault();\n    };\n    /**\n     * Walk up the dom try to find a focusable element.\n     */\n    FocusZone.prototype._tryInvokeClickForFocusable = function (targetElement, ev) {\n        var target = targetElement;\n        if (target === this._root.current) {\n            return false;\n        }\n        do {\n            if (target.tagName === 'BUTTON' ||\n                target.tagName === 'A' ||\n                target.tagName === 'INPUT' ||\n                target.tagName === 'TEXTAREA' ||\n                target.tagName === 'SUMMARY') {\n                return false;\n            }\n            if (this._isImmediateDescendantOfZone(target) &&\n                target.getAttribute(IS_FOCUSABLE_ATTRIBUTE) === 'true' &&\n                target.getAttribute(IS_ENTER_DISABLED_ATTRIBUTE) !== 'true') {\n                raiseClickFromKeyboardEvent(target, ev);\n                return true;\n            }\n            target = getParent(target, ALLOW_VIRTUAL_ELEMENTS);\n        } while (target !== this._root.current);\n        return false;\n    };\n    /**\n     * Traverse to find first child zone.\n     */\n    FocusZone.prototype._getFirstInnerZone = function (rootElement) {\n        rootElement = rootElement || this._activeElement || this._root.current;\n        if (!rootElement) {\n            return null;\n        }\n        if (isElementFocusZone(rootElement)) {\n            return _allInstances[rootElement.getAttribute(FOCUSZONE_ID_ATTRIBUTE)];\n        }\n        var child = rootElement.firstElementChild;\n        while (child) {\n            if (isElementFocusZone(child)) {\n                return _allInstances[child.getAttribute(FOCUSZONE_ID_ATTRIBUTE)];\n            }\n            var match = this._getFirstInnerZone(child);\n            if (match) {\n                return match;\n            }\n            child = child.nextElementSibling;\n        }\n        return null;\n    };\n    FocusZone.prototype._moveFocus = function (isForward, \n    // eslint-disable-next-line deprecation/deprecation\n    getDistanceFromCenter, ev, useDefaultWrap) {\n        if (useDefaultWrap === void 0) { useDefaultWrap = true; }\n        var element = this._activeElement;\n        var candidateDistance = -1;\n        var candidateElement = undefined;\n        var changedFocus = false;\n        var isBidirectional = this.props.direction === FocusZoneDirection.bidirectional;\n        if (!element || !this._root.current) {\n            return false;\n        }\n        if (this._isElementInput(element)) {\n            if (!this._shouldInputLoseFocus(element, isForward)) {\n                return false;\n            }\n        }\n        var activeRect = isBidirectional ? element.getBoundingClientRect() : null;\n        do {\n            element = (isForward ? getNextElement(this._root.current, element) : getPreviousElement(this._root.current, element));\n            if (isBidirectional) {\n                if (element) {\n                    var targetRect = element.getBoundingClientRect();\n                    // eslint-disable-next-line deprecation/deprecation\n                    var elementDistance = getDistanceFromCenter(activeRect, targetRect);\n                    if (elementDistance === -1 && candidateDistance === -1) {\n                        candidateElement = element;\n                        break;\n                    }\n                    if (elementDistance > -1 && (candidateDistance === -1 || elementDistance < candidateDistance)) {\n                        candidateDistance = elementDistance;\n                        candidateElement = element;\n                    }\n                    if (candidateDistance >= 0 && elementDistance < 0) {\n                        break;\n                    }\n                }\n            }\n            else {\n                candidateElement = element;\n                break;\n            }\n        } while (element);\n        // Focus the closest candidate\n        if (candidateElement && candidateElement !== this._activeElement) {\n            changedFocus = true;\n            this.focusElement(candidateElement);\n        }\n        else if (this.props.isCircularNavigation && useDefaultWrap) {\n            if (isForward) {\n                return this.focusElement(getNextElement(this._root.current, this._root.current.firstElementChild, true));\n            }\n            else {\n                return this.focusElement(getPreviousElement(this._root.current, this._root.current.lastElementChild, true, true, true));\n            }\n        }\n        return changedFocus;\n    };\n    FocusZone.prototype._moveFocusDown = function () {\n        var _this = this;\n        var targetTop = -1;\n        // eslint-disable-next-line deprecation/deprecation\n        var leftAlignment = this._focusAlignment.left || this._focusAlignment.x || 0;\n        if (\n        // eslint-disable-next-line deprecation/deprecation\n        this._moveFocus(true, function (activeRect, targetRect) {\n            var distance = -1;\n            // ClientRect values can be floats that differ by very small fractions of a decimal.\n            // If the difference between top and bottom are within a pixel then we should treat\n            // them as equivalent by using Math.floor. For instance 5.2222 and 5.222221 should be equivalent,\n            // but without Math.Floor they will be handled incorrectly.\n            var targetRectTop = Math.floor(targetRect.top);\n            var activeRectBottom = Math.floor(activeRect.bottom);\n            if (targetRectTop < activeRectBottom) {\n                if (!_this._shouldWrapFocus(_this._activeElement, NO_VERTICAL_WRAP)) {\n                    return LARGE_NEGATIVE_DISTANCE_FROM_CENTER;\n                }\n                return LARGE_DISTANCE_FROM_CENTER;\n            }\n            if ((targetTop === -1 && targetRectTop >= activeRectBottom) || targetRectTop === targetTop) {\n                targetTop = targetRectTop;\n                if (leftAlignment >= targetRect.left && leftAlignment <= targetRect.left + targetRect.width) {\n                    distance = 0;\n                }\n                else {\n                    distance = Math.abs(targetRect.left + targetRect.width / 2 - leftAlignment);\n                }\n            }\n            return distance;\n        })) {\n            this._setFocusAlignment(this._activeElement, false, true);\n            return true;\n        }\n        return false;\n    };\n    FocusZone.prototype._moveFocusUp = function () {\n        var _this = this;\n        var targetTop = -1;\n        // eslint-disable-next-line deprecation/deprecation\n        var leftAlignment = this._focusAlignment.left || this._focusAlignment.x || 0;\n        if (\n        // eslint-disable-next-line deprecation/deprecation\n        this._moveFocus(false, function (activeRect, targetRect) {\n            var distance = -1;\n            // ClientRect values can be floats that differ by very small fractions of a decimal.\n            // If the difference between top and bottom are within a pixel then we should treat\n            // them as equivalent by using Math.floor. For instance 5.2222 and 5.222221 should be equivalent,\n            // but without Math.Floor they will be handled incorrectly.\n            var targetRectBottom = Math.floor(targetRect.bottom);\n            var targetRectTop = Math.floor(targetRect.top);\n            var activeRectTop = Math.floor(activeRect.top);\n            if (targetRectBottom > activeRectTop) {\n                if (!_this._shouldWrapFocus(_this._activeElement, NO_VERTICAL_WRAP)) {\n                    return LARGE_NEGATIVE_DISTANCE_FROM_CENTER;\n                }\n                return LARGE_DISTANCE_FROM_CENTER;\n            }\n            if ((targetTop === -1 && targetRectBottom <= activeRectTop) || targetRectTop === targetTop) {\n                targetTop = targetRectTop;\n                if (leftAlignment >= targetRect.left && leftAlignment <= targetRect.left + targetRect.width) {\n                    distance = 0;\n                }\n                else {\n                    distance = Math.abs(targetRect.left + targetRect.width / 2 - leftAlignment);\n                }\n            }\n            return distance;\n        })) {\n            this._setFocusAlignment(this._activeElement, false, true);\n            return true;\n        }\n        return false;\n    };\n    FocusZone.prototype._moveFocusLeft = function (theme) {\n        var _this = this;\n        var shouldWrap = this._shouldWrapFocus(this._activeElement, NO_HORIZONTAL_WRAP);\n        if (this._moveFocus(getRTL(theme), \n        // eslint-disable-next-line deprecation/deprecation\n        function (activeRect, targetRect) {\n            var distance = -1;\n            var topBottomComparison;\n            if (getRTL(theme)) {\n                // When in RTL, this comparison should be the same as the one in _moveFocusRight for LTR.\n                // Going left at a leftmost rectangle will go down a line instead of up a line like in LTR.\n                // This is important, because we want to be comparing the top of the target rect\n                // with the bottom of the active rect.\n                topBottomComparison = parseFloat(targetRect.top.toFixed(3)) < parseFloat(activeRect.bottom.toFixed(3));\n            }\n            else {\n                topBottomComparison = parseFloat(targetRect.bottom.toFixed(3)) > parseFloat(activeRect.top.toFixed(3));\n            }\n            if (topBottomComparison &&\n                targetRect.right <= activeRect.right &&\n                _this.props.direction !== FocusZoneDirection.vertical) {\n                distance = activeRect.right - targetRect.right;\n            }\n            else if (!shouldWrap) {\n                distance = LARGE_NEGATIVE_DISTANCE_FROM_CENTER;\n            }\n            return distance;\n        }, undefined /*ev*/, shouldWrap)) {\n            this._setFocusAlignment(this._activeElement, true, false);\n            return true;\n        }\n        return false;\n    };\n    FocusZone.prototype._moveFocusRight = function (theme) {\n        var _this = this;\n        var shouldWrap = this._shouldWrapFocus(this._activeElement, NO_HORIZONTAL_WRAP);\n        if (this._moveFocus(!getRTL(theme), \n        // eslint-disable-next-line deprecation/deprecation\n        function (activeRect, targetRect) {\n            var distance = -1;\n            var topBottomComparison;\n            if (getRTL(theme)) {\n                // When in RTL, this comparison should be the same as the one in _moveFocusLeft for LTR.\n                // Going right at a rightmost rectangle will go up a line instead of down a line like in LTR.\n                // This is important, because we want to be comparing the bottom of the target rect\n                // with the top of the active rect.\n                topBottomComparison = parseFloat(targetRect.bottom.toFixed(3)) > parseFloat(activeRect.top.toFixed(3));\n            }\n            else {\n                topBottomComparison = parseFloat(targetRect.top.toFixed(3)) < parseFloat(activeRect.bottom.toFixed(3));\n            }\n            if (topBottomComparison &&\n                targetRect.left >= activeRect.left &&\n                _this.props.direction !== FocusZoneDirection.vertical) {\n                distance = targetRect.left - activeRect.left;\n            }\n            else if (!shouldWrap) {\n                distance = LARGE_NEGATIVE_DISTANCE_FROM_CENTER;\n            }\n            return distance;\n        }, undefined /*ev*/, shouldWrap)) {\n            this._setFocusAlignment(this._activeElement, true, false);\n            return true;\n        }\n        return false;\n    };\n    FocusZone.prototype._moveFocusPaging = function (isForward, useDefaultWrap) {\n        if (useDefaultWrap === void 0) { useDefaultWrap = true; }\n        var element = this._activeElement;\n        if (!element || !this._root.current) {\n            return false;\n        }\n        if (this._isElementInput(element)) {\n            if (!this._shouldInputLoseFocus(element, isForward)) {\n                return false;\n            }\n        }\n        var scrollableParent = findScrollableParent(element);\n        if (!scrollableParent) {\n            return false;\n        }\n        var candidateDistance = -1;\n        var candidateElement = undefined;\n        var targetTop = -1;\n        var targetBottom = -1;\n        var pagesize = scrollableParent.clientHeight;\n        var activeRect = element.getBoundingClientRect();\n        do {\n            element = isForward\n                ? getNextElement(this._root.current, element)\n                : getPreviousElement(this._root.current, element);\n            if (element) {\n                var targetRect = element.getBoundingClientRect();\n                var targetRectTop = Math.floor(targetRect.top);\n                var activeRectBottom = Math.floor(activeRect.bottom);\n                var targetRectBottom = Math.floor(targetRect.bottom);\n                var activeRectTop = Math.floor(activeRect.top);\n                var elementDistance = this._getHorizontalDistanceFromCenter(isForward, activeRect, targetRect);\n                var isElementPassedPageSizeOnPagingDown = isForward && targetRectTop > activeRectBottom + pagesize;\n                var isElementPassedPageSizeOnPagingUp = !isForward && targetRectBottom < activeRectTop - pagesize;\n                if (isElementPassedPageSizeOnPagingDown || isElementPassedPageSizeOnPagingUp) {\n                    break;\n                }\n                if (elementDistance > -1) {\n                    // for paging down\n                    if (isForward && targetRectTop > targetTop) {\n                        targetTop = targetRectTop;\n                        candidateDistance = elementDistance;\n                        candidateElement = element;\n                    }\n                    else if (!isForward && targetRectBottom < targetBottom) {\n                        // for paging up\n                        targetBottom = targetRectBottom;\n                        candidateDistance = elementDistance;\n                        candidateElement = element;\n                    }\n                    else if (candidateDistance === -1 || elementDistance <= candidateDistance) {\n                        candidateDistance = elementDistance;\n                        candidateElement = element;\n                    }\n                }\n            }\n        } while (element);\n        var changedFocus = false;\n        // Focus the closest candidate\n        if (candidateElement && candidateElement !== this._activeElement) {\n            changedFocus = true;\n            this.focusElement(candidateElement);\n            this._setFocusAlignment(candidateElement, false, true);\n        }\n        else if (this.props.isCircularNavigation && useDefaultWrap) {\n            if (isForward) {\n                return this.focusElement(getNextElement(this._root.current, this._root.current.firstElementChild, true));\n            }\n            return this.focusElement(getPreviousElement(this._root.current, this._root.current.lastElementChild, true, true, true));\n        }\n        return changedFocus;\n    };\n    FocusZone.prototype._setFocusAlignment = function (element, isHorizontal, isVertical) {\n        if (this.props.direction === FocusZoneDirection.bidirectional &&\n            (!this._focusAlignment || isHorizontal || isVertical)) {\n            var rect = element.getBoundingClientRect();\n            var left = rect.left + rect.width / 2;\n            var top_1 = rect.top + rect.height / 2;\n            if (!this._focusAlignment) {\n                this._focusAlignment = { left: left, top: top_1 };\n            }\n            if (isHorizontal) {\n                this._focusAlignment.left = left;\n            }\n            if (isVertical) {\n                this._focusAlignment.top = top_1;\n            }\n        }\n    };\n    FocusZone.prototype._isImmediateDescendantOfZone = function (element) {\n        return this._getOwnerZone(element) === this._root.current;\n    };\n    FocusZone.prototype._getOwnerZone = function (element) {\n        var parentElement = getParent(element, ALLOW_VIRTUAL_ELEMENTS);\n        while (parentElement && parentElement !== this._root.current && parentElement !== this._getDocument().body) {\n            if (isElementFocusZone(parentElement)) {\n                return parentElement;\n            }\n            parentElement = getParent(parentElement, ALLOW_VIRTUAL_ELEMENTS);\n        }\n        return parentElement;\n    };\n    FocusZone.prototype._updateTabIndexes = function (element) {\n        if (!this._activeElement &&\n            this.props.defaultTabbableElement &&\n            typeof this.props.defaultTabbableElement === 'function') {\n            this._activeElement = this.props.defaultTabbableElement(this._root.current);\n        }\n        if (!element && this._root.current) {\n            this._defaultFocusElement = null;\n            element = this._root.current;\n            if (this._activeElement && !elementContains(element, this._activeElement)) {\n                this._activeElement = null;\n            }\n        }\n        // If active element changes state to disabled, set it to null.\n        // Otherwise, we lose keyboard accessibility to other elements in focus zone.\n        if (this._activeElement && !isElementTabbable(this._activeElement, undefined, this._inShadowRoot)) {\n            this._activeElement = null;\n        }\n        var childNodes = element && element.children;\n        for (var childIndex = 0; childNodes && childIndex < childNodes.length; childIndex++) {\n            var child = childNodes[childIndex];\n            if (!isElementFocusZone(child)) {\n                // If the item is explicitly set to not be focusable then TABINDEX needs to be set to -1.\n                if (child.getAttribute && child.getAttribute(IS_FOCUSABLE_ATTRIBUTE) === 'false') {\n                    child.setAttribute(TABINDEX, '-1');\n                }\n                if (isElementTabbable(child, undefined, this._inShadowRoot)) {\n                    if (this.props.disabled) {\n                        child.setAttribute(TABINDEX, '-1');\n                    }\n                    else if (!this._isInnerZone &&\n                        ((!this._activeElement && !this._defaultFocusElement) || this._activeElement === child)) {\n                        this._defaultFocusElement = child;\n                        if (child.getAttribute(TABINDEX) !== '0') {\n                            child.setAttribute(TABINDEX, '0');\n                        }\n                    }\n                    else if (child.getAttribute(TABINDEX) !== '-1') {\n                        child.setAttribute(TABINDEX, '-1');\n                    }\n                }\n                else if (child.tagName === 'svg' && child.getAttribute('focusable') !== 'false') {\n                    // Disgusting IE hack. Sad face.\n                    child.setAttribute('focusable', 'false');\n                }\n            }\n            else if (child.getAttribute(IS_FOCUSABLE_ATTRIBUTE) === 'true') {\n                if (!this._isInnerZone &&\n                    ((!this._activeElement && !this._defaultFocusElement) || this._activeElement === child)) {\n                    this._defaultFocusElement = child;\n                    if (child.getAttribute(TABINDEX) !== '0') {\n                        child.setAttribute(TABINDEX, '0');\n                    }\n                }\n                else if (child.getAttribute(TABINDEX) !== '-1') {\n                    child.setAttribute(TABINDEX, '-1');\n                }\n            }\n            this._updateTabIndexes(child);\n        }\n    };\n    FocusZone.prototype._isContentEditableElement = function (element) {\n        return element && element.getAttribute('contenteditable') === 'true';\n    };\n    FocusZone.prototype._isElementInput = function (element) {\n        if (element &&\n            element.tagName &&\n            (element.tagName.toLowerCase() === 'input' || element.tagName.toLowerCase() === 'textarea')) {\n            return true;\n        }\n        return false;\n    };\n    FocusZone.prototype._shouldInputLoseFocus = function (element, isForward) {\n        // If a tab was used, we want to focus on the next element.\n        if (!this._processingTabKey &&\n            element &&\n            element.type &&\n            ALLOWED_INPUT_TYPES.indexOf(element.type.toLowerCase()) > -1) {\n            var selectionStart = element.selectionStart;\n            var selectionEnd = element.selectionEnd;\n            var isRangeSelected = selectionStart !== selectionEnd;\n            var inputValue = element.value;\n            var isReadonly = element.readOnly;\n            // We shouldn't lose focus in the following cases:\n            // 1. There is range selected.\n            // 2. When selection start is larger than 0 and it is backward and not readOnly.\n            // 3. when selection start is not the end of length, it is forward and not readOnly.\n            // 4. We press any of the arrow keys when our handleTabKey isn't none or undefined (only losing focus if we hit\n            // tab) and if shouldInputLoseFocusOnArrowKey is defined, if scenario prefers to not loose the focus which is\n            // determined by calling the callback shouldInputLoseFocusOnArrowKey\n            if (isRangeSelected ||\n                (selectionStart > 0 && !isForward && !isReadonly) ||\n                (selectionStart !== inputValue.length && isForward && !isReadonly) ||\n                (!!this.props.handleTabKey &&\n                    !(this.props.shouldInputLoseFocusOnArrowKey && this.props.shouldInputLoseFocusOnArrowKey(element)))) {\n                return false;\n            }\n        }\n        return true;\n    };\n    FocusZone.prototype._shouldWrapFocus = function (element, noWrapDataAttribute) {\n        return this.props.checkForNoWrap ? shouldWrapFocus(element, noWrapDataAttribute) : true;\n    };\n    /**\n     * Returns true if the element is a descendant of the FocusZone through a React portal.\n     */\n    FocusZone.prototype._portalContainsElement = function (element) {\n        return element && !!this._root.current && portalContainsElement(element, this._root.current);\n    };\n    FocusZone.prototype._getDocument = function () {\n        return getDocument(this._root.current);\n    };\n    FocusZone.contextType = MergeStylesShadowRootContext;\n    FocusZone.defaultProps = {\n        isCircularNavigation: false,\n        direction: FocusZoneDirection.bidirectional,\n        shouldRaiseClicks: true,\n        // Hardcoding uncontrolled flag for proper interop with FluentUI V9.\n        'data-tabster': '{\"uncontrolled\": {}}',\n    };\n    return FocusZone;\n}(React.Component));\n//# sourceMappingURL=FocusZone.js.map","/**\n * Split a string into tokens separated by whitespace, except all text within parentheses\n * is treated as a single token (whitespace is ignored within parentheses).\n *\n * Unlike String.split(' '), multiple consecutive space characters are collapsed and\n * removed from the returned array (including leading and trailing spaces).\n *\n * For example:\n * `tokenizeWithParentheses(\"3px calc(var(--x) / 2) 9px    0 \")`\n *   => `[\"3px\", \"calc(var(--x) / 2)\", \"9px\", \"0\"]`\n *\n * @returns The array of tokens. Returns an empty array if the string was empty or contained only whitespace.\n */\nexport function tokenizeWithParentheses(value) {\n    var parts = [];\n    var partStart = 0;\n    var parens = 0;\n    for (var i = 0; i < value.length; i++) {\n        switch (value[i]) {\n            case '(':\n                parens++;\n                break;\n            case ')':\n                if (parens) {\n                    parens--;\n                }\n                break;\n            case '\\t':\n            case ' ':\n                if (!parens) {\n                    // Add the new part if it's not an empty string\n                    if (i > partStart) {\n                        parts.push(value.substring(partStart, i));\n                    }\n                    partStart = i + 1;\n                }\n                break;\n        }\n    }\n    // Add the last part\n    if (partStart < value.length) {\n        parts.push(value.substring(partStart));\n    }\n    return parts;\n}\n//# sourceMappingURL=tokenizeWithParentheses.js.map","import $6nfFC$react, {useRef as $6nfFC$useRef, useContext as $6nfFC$useContext, useMemo as $6nfFC$useMemo, useEffect as $6nfFC$useEffect, useState as $6nfFC$useState, useCallback as $6nfFC$useCallback} from \"react\";\nimport {useLayoutEffect as $6nfFC$useLayoutEffect, runAfterTransition as $6nfFC$runAfterTransition, focusWithoutScrolling as $6nfFC$focusWithoutScrolling, mergeProps as $6nfFC$mergeProps, useSyncRef as $6nfFC$useSyncRef} from \"@react-aria/utils\";\nimport {getInteractionModality as $6nfFC$getInteractionModality, isFocusVisible as $6nfFC$isFocusVisible, useFocusVisibleListener as $6nfFC$useFocusVisibleListener, useFocus as $6nfFC$useFocus, useFocusWithin as $6nfFC$useFocusWithin, useKeyboard as $6nfFC$useKeyboard} from \"@react-aria/interactions\";\nimport $6nfFC$clsx from \"clsx\";\n\n\n\nfunction $6a99195332edec8b$export$80f3e147d781571c(element) {\n    // If the user is interacting with a virtual cursor, e.g. screen reader, then\n    // wait until after any animated transitions that are currently occurring on\n    // the page before shifting focus. This avoids issues with VoiceOver on iOS\n    // causing the page to scroll when moving focus if the element is transitioning\n    // from off the screen.\n    if ($6nfFC$getInteractionModality() === 'virtual') {\n        let lastFocusedElement = document.activeElement;\n        $6nfFC$runAfterTransition(()=>{\n            // If focus did not move and the element is still in the document, focus it.\n            if (document.activeElement === lastFocusedElement && document.contains(element)) $6nfFC$focusWithoutScrolling(element);\n        });\n    } else $6nfFC$focusWithoutScrolling(element);\n}\n\n\n/*\n * Copyright 2021 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ function $645f2e67b85a24c9$var$isStyleVisible(element) {\n    if (!(element instanceof HTMLElement) && !(element instanceof SVGElement)) return false;\n    let { display: display , visibility: visibility  } = element.style;\n    let isVisible = display !== 'none' && visibility !== 'hidden' && visibility !== 'collapse';\n    if (isVisible) {\n        const { getComputedStyle: getComputedStyle  } = element.ownerDocument.defaultView;\n        let { display: computedDisplay , visibility: computedVisibility  } = getComputedStyle(element);\n        isVisible = computedDisplay !== 'none' && computedVisibility !== 'hidden' && computedVisibility !== 'collapse';\n    }\n    return isVisible;\n}\nfunction $645f2e67b85a24c9$var$isAttributeVisible(element, childElement) {\n    return !element.hasAttribute('hidden') && (element.nodeName === 'DETAILS' && childElement && childElement.nodeName !== 'SUMMARY' ? element.hasAttribute('open') : true);\n}\nfunction $645f2e67b85a24c9$export$e989c0fffaa6b27a(element, childElement) {\n    return element.nodeName !== '#comment' && $645f2e67b85a24c9$var$isStyleVisible(element) && $645f2e67b85a24c9$var$isAttributeVisible(element, childElement) && (!element.parentElement || $645f2e67b85a24c9$export$e989c0fffaa6b27a(element.parentElement, element));\n}\n\n\n\n\nconst $9bf71ea28793e738$var$FocusContext = /*#__PURE__*/ $6nfFC$react.createContext(null);\nlet $9bf71ea28793e738$var$activeScope = null;\nfunction $9bf71ea28793e738$export$20e40289641fbbb6(props) {\n    let { children: children , contain: contain , restoreFocus: restoreFocus , autoFocus: autoFocus  } = props;\n    let startRef = $6nfFC$useRef();\n    let endRef = $6nfFC$useRef();\n    let scopeRef = $6nfFC$useRef([]);\n    let ctx = $6nfFC$useContext($9bf71ea28793e738$var$FocusContext);\n    var ref;\n    // The parent scope is based on the JSX tree, using context.\n    // However, if a new scope mounts outside the active scope (e.g. DialogContainer launched from a menu),\n    // we want the parent scope to be the active scope instead.\n    let ctxParent = (ref = ctx === null || ctx === void 0 ? void 0 : ctx.scopeRef) !== null && ref !== void 0 ? ref : null;\n    let parentScope1 = $6nfFC$useMemo(()=>$9bf71ea28793e738$var$activeScope && $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode($9bf71ea28793e738$var$activeScope) && !$9bf71ea28793e738$var$isAncestorScope($9bf71ea28793e738$var$activeScope, ctxParent) ? $9bf71ea28793e738$var$activeScope : ctxParent\n    , [\n        ctxParent\n    ]);\n    $6nfFC$useLayoutEffect(()=>{\n        // Find all rendered nodes between the sentinels and add them to the scope.\n        let node = startRef.current.nextSibling;\n        let nodes = [];\n        while(node && node !== endRef.current){\n            nodes.push(node);\n            node = node.nextSibling;\n        }\n        scopeRef.current = nodes;\n    }, [\n        children,\n        parentScope1\n    ]);\n    // add to the focus scope tree in render order because useEffects/useLayoutEffects run children first whereas render runs parent first\n    // which matters when constructing a tree\n    if ($9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode(parentScope1) && !$9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode(scopeRef)) $9bf71ea28793e738$export$d06fae2ee68b101e.addTreeNode(scopeRef, parentScope1);\n    let node1 = $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode(scopeRef);\n    node1.contain = contain;\n    $9bf71ea28793e738$var$useActiveScopeTracker(scopeRef, restoreFocus, contain);\n    $9bf71ea28793e738$var$useFocusContainment(scopeRef, contain);\n    $9bf71ea28793e738$var$useRestoreFocus(scopeRef, restoreFocus, contain);\n    $9bf71ea28793e738$var$useAutoFocus(scopeRef, autoFocus);\n    // this layout effect needs to run last so that focusScopeTree cleanup happens at the last moment possible\n    $6nfFC$useLayoutEffect(()=>{\n        if (scopeRef) return ()=>{\n            // Scope may have been re-parented.\n            let parentScope = $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode(scopeRef).parent.scopeRef;\n            // Restore the active scope on unmount if this scope or a descendant scope is active.\n            // Parent effect cleanups run before children, so we need to check if the\n            // parent scope actually still exists before restoring the active scope to it.\n            if ((scopeRef === $9bf71ea28793e738$var$activeScope || $9bf71ea28793e738$var$isAncestorScope(scopeRef, $9bf71ea28793e738$var$activeScope)) && (!parentScope || $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode(parentScope))) $9bf71ea28793e738$var$activeScope = parentScope;\n            $9bf71ea28793e738$export$d06fae2ee68b101e.removeTreeNode(scopeRef);\n        };\n    }, [\n        scopeRef,\n        parentScope1\n    ]);\n    let focusManager = $9bf71ea28793e738$var$createFocusManagerForScope(scopeRef);\n    return(/*#__PURE__*/ $6nfFC$react.createElement($9bf71ea28793e738$var$FocusContext.Provider, {\n        value: {\n            scopeRef: scopeRef,\n            focusManager: focusManager\n        }\n    }, /*#__PURE__*/ $6nfFC$react.createElement(\"span\", {\n        \"data-focus-scope-start\": true,\n        hidden: true,\n        ref: startRef\n    }), children, /*#__PURE__*/ $6nfFC$react.createElement(\"span\", {\n        \"data-focus-scope-end\": true,\n        hidden: true,\n        ref: endRef\n    })));\n}\nfunction $9bf71ea28793e738$export$10c5169755ce7bd7() {\n    var ref;\n    return (ref = $6nfFC$useContext($9bf71ea28793e738$var$FocusContext)) === null || ref === void 0 ? void 0 : ref.focusManager;\n}\nfunction $9bf71ea28793e738$var$createFocusManagerForScope(scopeRef) {\n    return {\n        focusNext (opts = {\n        }) {\n            let scope = scopeRef.current;\n            let { from: from , tabbable: tabbable , wrap: wrap , accept: accept  } = opts;\n            let node = from || document.activeElement;\n            let sentinel = scope[0].previousElementSibling;\n            let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa($9bf71ea28793e738$var$getScopeRoot(scope), {\n                tabbable: tabbable,\n                accept: accept\n            }, scope);\n            walker.currentNode = $9bf71ea28793e738$var$isElementInScope(node, scope) ? node : sentinel;\n            let nextNode = walker.nextNode();\n            if (!nextNode && wrap) {\n                walker.currentNode = sentinel;\n                nextNode = walker.nextNode();\n            }\n            if (nextNode) $9bf71ea28793e738$var$focusElement(nextNode, true);\n            return nextNode;\n        },\n        focusPrevious (opts = {\n        }) {\n            let scope = scopeRef.current;\n            let { from: from , tabbable: tabbable , wrap: wrap , accept: accept  } = opts;\n            let node = from || document.activeElement;\n            let sentinel = scope[scope.length - 1].nextElementSibling;\n            let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa($9bf71ea28793e738$var$getScopeRoot(scope), {\n                tabbable: tabbable,\n                accept: accept\n            }, scope);\n            walker.currentNode = $9bf71ea28793e738$var$isElementInScope(node, scope) ? node : sentinel;\n            let previousNode = walker.previousNode();\n            if (!previousNode && wrap) {\n                walker.currentNode = sentinel;\n                previousNode = walker.previousNode();\n            }\n            if (previousNode) $9bf71ea28793e738$var$focusElement(previousNode, true);\n            return previousNode;\n        },\n        focusFirst (opts = {\n        }) {\n            let scope = scopeRef.current;\n            let { tabbable: tabbable , accept: accept  } = opts;\n            let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa($9bf71ea28793e738$var$getScopeRoot(scope), {\n                tabbable: tabbable,\n                accept: accept\n            }, scope);\n            walker.currentNode = scope[0].previousElementSibling;\n            let nextNode = walker.nextNode();\n            if (nextNode) $9bf71ea28793e738$var$focusElement(nextNode, true);\n            return nextNode;\n        },\n        focusLast (opts = {\n        }) {\n            let scope = scopeRef.current;\n            let { tabbable: tabbable , accept: accept  } = opts;\n            let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa($9bf71ea28793e738$var$getScopeRoot(scope), {\n                tabbable: tabbable,\n                accept: accept\n            }, scope);\n            walker.currentNode = scope[scope.length - 1].nextElementSibling;\n            let previousNode = walker.previousNode();\n            if (previousNode) $9bf71ea28793e738$var$focusElement(previousNode, true);\n            return previousNode;\n        }\n    };\n}\nconst $9bf71ea28793e738$var$focusableElements = [\n    'input:not([disabled]):not([type=hidden])',\n    'select:not([disabled])',\n    'textarea:not([disabled])',\n    'button:not([disabled])',\n    'a[href]',\n    'area[href]',\n    'summary',\n    'iframe',\n    'object',\n    'embed',\n    'audio[controls]',\n    'video[controls]',\n    '[contenteditable]'\n];\nconst $9bf71ea28793e738$var$FOCUSABLE_ELEMENT_SELECTOR = $9bf71ea28793e738$var$focusableElements.join(':not([hidden]),') + ',[tabindex]:not([disabled]):not([hidden])';\n$9bf71ea28793e738$var$focusableElements.push('[tabindex]:not([tabindex=\"-1\"]):not([disabled])');\nconst $9bf71ea28793e738$var$TABBABLE_ELEMENT_SELECTOR = $9bf71ea28793e738$var$focusableElements.join(':not([hidden]):not([tabindex=\"-1\"]),');\nfunction $9bf71ea28793e738$var$getScopeRoot(scope) {\n    return scope[0].parentElement;\n}\nfunction $9bf71ea28793e738$var$shouldContainFocus(scopeRef) {\n    let scope = $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode($9bf71ea28793e738$var$activeScope);\n    while(scope && scope.scopeRef !== scopeRef){\n        if (scope.contain) return false;\n        scope = scope.parent;\n    }\n    return true;\n}\nfunction $9bf71ea28793e738$var$useFocusContainment(scopeRef, contain) {\n    let focusedNode = $6nfFC$useRef();\n    let raf = $6nfFC$useRef(null);\n    $6nfFC$useLayoutEffect(()=>{\n        let scope1 = scopeRef.current;\n        if (!contain) {\n            // if contain was changed, then we should cancel any ongoing waits to pull focus back into containment\n            if (raf.current) {\n                cancelAnimationFrame(raf.current);\n                raf.current = null;\n            }\n            return;\n        }\n        // Handle the Tab key to contain focus within the scope\n        let onKeyDown = (e)=>{\n            if (e.key !== 'Tab' || e.altKey || e.ctrlKey || e.metaKey || !$9bf71ea28793e738$var$shouldContainFocus(scopeRef)) return;\n            let focusedElement = document.activeElement;\n            let scope = scopeRef.current;\n            if (!$9bf71ea28793e738$var$isElementInScope(focusedElement, scope)) return;\n            let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa($9bf71ea28793e738$var$getScopeRoot(scope), {\n                tabbable: true\n            }, scope);\n            walker.currentNode = focusedElement;\n            let nextElement = e.shiftKey ? walker.previousNode() : walker.nextNode();\n            if (!nextElement) {\n                walker.currentNode = e.shiftKey ? scope[scope.length - 1].nextElementSibling : scope[0].previousElementSibling;\n                nextElement = e.shiftKey ? walker.previousNode() : walker.nextNode();\n            }\n            e.preventDefault();\n            if (nextElement) $9bf71ea28793e738$var$focusElement(nextElement, true);\n        };\n        let onFocus = (e)=>{\n            // If focusing an element in a child scope of the currently active scope, the child becomes active.\n            // Moving out of the active scope to an ancestor is not allowed.\n            if ((!$9bf71ea28793e738$var$activeScope || $9bf71ea28793e738$var$isAncestorScope($9bf71ea28793e738$var$activeScope, scopeRef)) && $9bf71ea28793e738$var$isElementInScope(e.target, scopeRef.current)) {\n                $9bf71ea28793e738$var$activeScope = scopeRef;\n                focusedNode.current = e.target;\n            } else if ($9bf71ea28793e738$var$shouldContainFocus(scopeRef) && !$9bf71ea28793e738$var$isElementInChildScope(e.target, scopeRef)) {\n                // If a focus event occurs outside the active scope (e.g. user tabs from browser location bar),\n                // restore focus to the previously focused node or the first tabbable element in the active scope.\n                if (focusedNode.current) focusedNode.current.focus();\n                else if ($9bf71ea28793e738$var$activeScope) $9bf71ea28793e738$var$focusFirstInScope($9bf71ea28793e738$var$activeScope.current);\n            } else if ($9bf71ea28793e738$var$shouldContainFocus(scopeRef)) focusedNode.current = e.target;\n        };\n        let onBlur = (e)=>{\n            // Firefox doesn't shift focus back to the Dialog properly without this\n            raf.current = requestAnimationFrame(()=>{\n                // Use document.activeElement instead of e.relatedTarget so we can tell if user clicked into iframe\n                if ($9bf71ea28793e738$var$shouldContainFocus(scopeRef) && !$9bf71ea28793e738$var$isElementInChildScope(document.activeElement, scopeRef)) {\n                    $9bf71ea28793e738$var$activeScope = scopeRef;\n                    if (document.body.contains(e.target)) {\n                        focusedNode.current = e.target;\n                        focusedNode.current.focus();\n                    } else if ($9bf71ea28793e738$var$activeScope) $9bf71ea28793e738$var$focusFirstInScope($9bf71ea28793e738$var$activeScope.current);\n                }\n            });\n        };\n        document.addEventListener('keydown', onKeyDown, false);\n        document.addEventListener('focusin', onFocus, false);\n        scope1.forEach((element)=>element.addEventListener('focusin', onFocus, false)\n        );\n        scope1.forEach((element)=>element.addEventListener('focusout', onBlur, false)\n        );\n        return ()=>{\n            document.removeEventListener('keydown', onKeyDown, false);\n            document.removeEventListener('focusin', onFocus, false);\n            scope1.forEach((element)=>element.removeEventListener('focusin', onFocus, false)\n            );\n            scope1.forEach((element)=>element.removeEventListener('focusout', onBlur, false)\n            );\n        };\n    }, [\n        scopeRef,\n        contain\n    ]);\n    // eslint-disable-next-line arrow-body-style\n    $6nfFC$useEffect(()=>{\n        return ()=>{\n            if (raf.current) cancelAnimationFrame(raf.current);\n        };\n    }, [\n        raf\n    ]);\n}\nfunction $9bf71ea28793e738$var$isElementInAnyScope(element) {\n    return $9bf71ea28793e738$var$isElementInChildScope(element);\n}\nfunction $9bf71ea28793e738$var$isElementInScope(element, scope) {\n    return scope.some((node)=>node.contains(element)\n    );\n}\nfunction $9bf71ea28793e738$var$isElementInChildScope(element, scope = null) {\n    // node.contains in isElementInScope covers child scopes that are also DOM children,\n    // but does not cover child scopes in portals.\n    for (let { scopeRef: s  } of $9bf71ea28793e738$export$d06fae2ee68b101e.traverse($9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode(scope))){\n        if ($9bf71ea28793e738$var$isElementInScope(element, s.current)) return true;\n    }\n    return false;\n}\nfunction $9bf71ea28793e738$var$isAncestorScope(ancestor, scope) {\n    var ref;\n    let parent = (ref = $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode(scope)) === null || ref === void 0 ? void 0 : ref.parent;\n    while(parent){\n        if (parent.scopeRef === ancestor) return true;\n        parent = parent.parent;\n    }\n    return false;\n}\nfunction $9bf71ea28793e738$var$focusElement(element, scroll = false) {\n    if (element != null && !scroll) try {\n        $6a99195332edec8b$export$80f3e147d781571c(element);\n    } catch (err) {\n    // ignore\n    }\n    else if (element != null) try {\n        element.focus();\n    } catch (err1) {\n    // ignore\n    }\n}\nfunction $9bf71ea28793e738$var$focusFirstInScope(scope, tabbable = true) {\n    let sentinel = scope[0].previousElementSibling;\n    let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa($9bf71ea28793e738$var$getScopeRoot(scope), {\n        tabbable: tabbable\n    }, scope);\n    walker.currentNode = sentinel;\n    let nextNode = walker.nextNode();\n    // If the scope does not contain a tabbable element, use the first focusable element.\n    if (tabbable && !nextNode) {\n        walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa($9bf71ea28793e738$var$getScopeRoot(scope), {\n            tabbable: false\n        }, scope);\n        walker.currentNode = sentinel;\n        nextNode = walker.nextNode();\n    }\n    $9bf71ea28793e738$var$focusElement(nextNode);\n}\nfunction $9bf71ea28793e738$var$useAutoFocus(scopeRef, autoFocus) {\n    const autoFocusRef = $6nfFC$react.useRef(autoFocus);\n    $6nfFC$useEffect(()=>{\n        if (autoFocusRef.current) {\n            $9bf71ea28793e738$var$activeScope = scopeRef;\n            if (!$9bf71ea28793e738$var$isElementInScope(document.activeElement, $9bf71ea28793e738$var$activeScope.current)) $9bf71ea28793e738$var$focusFirstInScope(scopeRef.current);\n        }\n        autoFocusRef.current = false;\n    }, [\n        scopeRef\n    ]);\n}\nfunction $9bf71ea28793e738$var$useActiveScopeTracker(scopeRef, restore, contain) {\n    // tracks the active scope, in case restore and contain are both false.\n    // if either are true, this is tracked in useRestoreFocus or useFocusContainment.\n    $6nfFC$useLayoutEffect(()=>{\n        if (restore || contain) return;\n        let scope = scopeRef.current;\n        let onFocus = (e)=>{\n            let target = e.target;\n            if ($9bf71ea28793e738$var$isElementInScope(target, scopeRef.current)) $9bf71ea28793e738$var$activeScope = scopeRef;\n            else if (!$9bf71ea28793e738$var$isElementInAnyScope(target)) $9bf71ea28793e738$var$activeScope = null;\n        };\n        document.addEventListener('focusin', onFocus, false);\n        scope.forEach((element)=>element.addEventListener('focusin', onFocus, false)\n        );\n        return ()=>{\n            document.removeEventListener('focusin', onFocus, false);\n            scope.forEach((element)=>element.removeEventListener('focusin', onFocus, false)\n            );\n        };\n    }, [\n        scopeRef,\n        restore,\n        contain\n    ]);\n}\nfunction $9bf71ea28793e738$var$shouldRestoreFocus(scopeRef) {\n    let scope = $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode($9bf71ea28793e738$var$activeScope);\n    while(scope && scope.scopeRef !== scopeRef){\n        if (scope.nodeToRestore) return false;\n        scope = scope.parent;\n    }\n    return true;\n}\nfunction $9bf71ea28793e738$var$useRestoreFocus(scopeRef, restoreFocus, contain) {\n    // create a ref during render instead of useLayoutEffect so the active element is saved before a child with autoFocus=true mounts.\n    const nodeToRestoreRef = $6nfFC$useRef(typeof document !== 'undefined' ? document.activeElement : null);\n    // restoring scopes should all track if they are active regardless of contain, but contain already tracks it plus logic to contain the focus\n    // restoring-non-containing scopes should only care if they become active so they can perform the restore\n    $6nfFC$useLayoutEffect(()=>{\n        let scope = scopeRef.current;\n        if (!restoreFocus || contain) return;\n        let onFocus = ()=>{\n            // If focusing an element in a child scope of the currently active scope, the child becomes active.\n            // Moving out of the active scope to an ancestor is not allowed.\n            if (!$9bf71ea28793e738$var$activeScope || $9bf71ea28793e738$var$isAncestorScope($9bf71ea28793e738$var$activeScope, scopeRef)) $9bf71ea28793e738$var$activeScope = scopeRef;\n        };\n        document.addEventListener('focusin', onFocus, false);\n        scope.forEach((element)=>element.addEventListener('focusin', onFocus, false)\n        );\n        return ()=>{\n            document.removeEventListener('focusin', onFocus, false);\n            scope.forEach((element)=>element.removeEventListener('focusin', onFocus, false)\n            );\n        };\n    }, [\n        scopeRef,\n        contain\n    ]);\n    // useLayoutEffect instead of useEffect so the active element is saved synchronously instead of asynchronously.\n    $6nfFC$useLayoutEffect(()=>{\n        if (!restoreFocus) return;\n        $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode(scopeRef).nodeToRestore = nodeToRestoreRef.current;\n        // Handle the Tab key so that tabbing out of the scope goes to the next element\n        // after the node that had focus when the scope mounted. This is important when\n        // using portals for overlays, so that focus goes to the expected element when\n        // tabbing out of the overlay.\n        let onKeyDown = (e)=>{\n            if (e.key !== 'Tab' || e.altKey || e.ctrlKey || e.metaKey) return;\n            let focusedElement = document.activeElement;\n            if (!$9bf71ea28793e738$var$isElementInScope(focusedElement, scopeRef.current)) return;\n            let nodeToRestore = $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode(scopeRef).nodeToRestore;\n            // Create a DOM tree walker that matches all tabbable elements\n            let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(document.body, {\n                tabbable: true\n            });\n            // Find the next tabbable element after the currently focused element\n            walker.currentNode = focusedElement;\n            let nextElement = e.shiftKey ? walker.previousNode() : walker.nextNode();\n            if (!document.body.contains(nodeToRestore) || nodeToRestore === document.body) {\n                nodeToRestore = null;\n                $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode(scopeRef).nodeToRestore = null;\n            }\n            // If there is no next element, or it is outside the current scope, move focus to the\n            // next element after the node to restore to instead.\n            if ((!nextElement || !$9bf71ea28793e738$var$isElementInScope(nextElement, scopeRef.current)) && nodeToRestore) {\n                walker.currentNode = nodeToRestore;\n                // Skip over elements within the scope, in case the scope immediately follows the node to restore.\n                do nextElement = e.shiftKey ? walker.previousNode() : walker.nextNode();\n                while ($9bf71ea28793e738$var$isElementInScope(nextElement, scopeRef.current))\n                e.preventDefault();\n                e.stopPropagation();\n                if (nextElement) $9bf71ea28793e738$var$focusElement(nextElement, true);\n                else // If there is no next element and the nodeToRestore isn't within a FocusScope (i.e. we are leaving the top level focus scope)\n                // then move focus to the body.\n                // Otherwise restore focus to the nodeToRestore (e.g menu within a popover -> tabbing to close the menu should move focus to menu trigger)\n                if (!$9bf71ea28793e738$var$isElementInAnyScope(nodeToRestore)) focusedElement.blur();\n                else $9bf71ea28793e738$var$focusElement(nodeToRestore, true);\n            }\n        };\n        if (!contain) document.addEventListener('keydown', onKeyDown, true);\n        return ()=>{\n            if (!contain) document.removeEventListener('keydown', onKeyDown, true);\n            let nodeToRestore = $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode(scopeRef).nodeToRestore;\n            // if we already lost focus to the body and this was the active scope, then we should attempt to restore\n            if (restoreFocus && nodeToRestore && ($9bf71ea28793e738$var$isElementInScope(document.activeElement, scopeRef.current) || document.activeElement === document.body && $9bf71ea28793e738$var$shouldRestoreFocus(scopeRef))) {\n                // freeze the focusScopeTree so it persists after the raf, otherwise during unmount nodes are removed from it\n                let clonedTree = $9bf71ea28793e738$export$d06fae2ee68b101e.clone();\n                requestAnimationFrame(()=>{\n                    // Only restore focus if we've lost focus to the body, the alternative is that focus has been purposefully moved elsewhere\n                    if (document.activeElement === document.body) {\n                        // look up the tree starting with our scope to find a nodeToRestore still in the DOM\n                        let treeNode = clonedTree.getTreeNode(scopeRef);\n                        while(treeNode){\n                            if (treeNode.nodeToRestore && document.body.contains(treeNode.nodeToRestore)) {\n                                $9bf71ea28793e738$var$focusElement(treeNode.nodeToRestore);\n                                return;\n                            }\n                            treeNode = treeNode.parent;\n                        }\n                        // If no nodeToRestore was found, focus the first element in the nearest\n                        // ancestor scope that is still in the tree.\n                        treeNode = clonedTree.getTreeNode(scopeRef);\n                        while(treeNode){\n                            if (treeNode.scopeRef && $9bf71ea28793e738$export$d06fae2ee68b101e.getTreeNode(treeNode.scopeRef)) {\n                                $9bf71ea28793e738$var$focusFirstInScope(treeNode.scopeRef.current, true);\n                                return;\n                            }\n                            treeNode = treeNode.parent;\n                        }\n                    }\n                });\n            }\n        };\n    }, [\n        scopeRef,\n        restoreFocus,\n        contain\n    ]);\n}\nfunction $9bf71ea28793e738$export$2d6ec8fc375ceafa(root, opts, scope) {\n    let selector = (opts === null || opts === void 0 ? void 0 : opts.tabbable) ? $9bf71ea28793e738$var$TABBABLE_ELEMENT_SELECTOR : $9bf71ea28793e738$var$FOCUSABLE_ELEMENT_SELECTOR;\n    let walker = document.createTreeWalker(root, NodeFilter.SHOW_ELEMENT, {\n        acceptNode (node) {\n            var ref;\n            // Skip nodes inside the starting node.\n            if (opts === null || opts === void 0 ? void 0 : (ref = opts.from) === null || ref === void 0 ? void 0 : ref.contains(node)) return NodeFilter.FILTER_REJECT;\n            if (node.matches(selector) && $645f2e67b85a24c9$export$e989c0fffaa6b27a(node) && (!scope || $9bf71ea28793e738$var$isElementInScope(node, scope)) && (!(opts === null || opts === void 0 ? void 0 : opts.accept) || opts.accept(node))) return NodeFilter.FILTER_ACCEPT;\n            return NodeFilter.FILTER_SKIP;\n        }\n    });\n    if (opts === null || opts === void 0 ? void 0 : opts.from) walker.currentNode = opts.from;\n    return walker;\n}\nfunction $9bf71ea28793e738$export$c5251b9e124bf29(ref, defaultOptions = {\n}) {\n    return {\n        focusNext (opts = {\n        }) {\n            let root = ref.current;\n            if (!root) return;\n            let { from: from , tabbable: tabbable = defaultOptions.tabbable , wrap: wrap = defaultOptions.wrap , accept: accept = defaultOptions.accept  } = opts;\n            let node = from || document.activeElement;\n            let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(root, {\n                tabbable: tabbable,\n                accept: accept\n            });\n            if (root.contains(node)) walker.currentNode = node;\n            let nextNode = walker.nextNode();\n            if (!nextNode && wrap) {\n                walker.currentNode = root;\n                nextNode = walker.nextNode();\n            }\n            if (nextNode) $9bf71ea28793e738$var$focusElement(nextNode, true);\n            return nextNode;\n        },\n        focusPrevious (opts = defaultOptions) {\n            let root = ref.current;\n            if (!root) return;\n            let { from: from , tabbable: tabbable = defaultOptions.tabbable , wrap: wrap = defaultOptions.wrap , accept: accept = defaultOptions.accept  } = opts;\n            let node = from || document.activeElement;\n            let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(root, {\n                tabbable: tabbable,\n                accept: accept\n            });\n            if (root.contains(node)) walker.currentNode = node;\n            else {\n                let next = $9bf71ea28793e738$var$last(walker);\n                if (next) $9bf71ea28793e738$var$focusElement(next, true);\n                return next;\n            }\n            let previousNode = walker.previousNode();\n            if (!previousNode && wrap) {\n                walker.currentNode = root;\n                previousNode = $9bf71ea28793e738$var$last(walker);\n            }\n            if (previousNode) $9bf71ea28793e738$var$focusElement(previousNode, true);\n            return previousNode;\n        },\n        focusFirst (opts = defaultOptions) {\n            let root = ref.current;\n            if (!root) return;\n            let { tabbable: tabbable = defaultOptions.tabbable , accept: accept = defaultOptions.accept  } = opts;\n            let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(root, {\n                tabbable: tabbable,\n                accept: accept\n            });\n            let nextNode = walker.nextNode();\n            if (nextNode) $9bf71ea28793e738$var$focusElement(nextNode, true);\n            return nextNode;\n        },\n        focusLast (opts = defaultOptions) {\n            let root = ref.current;\n            if (!root) return;\n            let { tabbable: tabbable = defaultOptions.tabbable , accept: accept = defaultOptions.accept  } = opts;\n            let walker = $9bf71ea28793e738$export$2d6ec8fc375ceafa(root, {\n                tabbable: tabbable,\n                accept: accept\n            });\n            let next = $9bf71ea28793e738$var$last(walker);\n            if (next) $9bf71ea28793e738$var$focusElement(next, true);\n            return next;\n        }\n    };\n}\nfunction $9bf71ea28793e738$var$last(walker) {\n    let next;\n    let last;\n    do {\n        last = walker.lastChild();\n        if (last) next = last;\n    }while (last)\n    return next;\n}\nclass $9bf71ea28793e738$var$Tree {\n    get size() {\n        return this.fastMap.size;\n    }\n    getTreeNode(data) {\n        return this.fastMap.get(data);\n    }\n    addTreeNode(scopeRef, parent, nodeToRestore) {\n        let parentNode = this.fastMap.get(parent !== null && parent !== void 0 ? parent : null);\n        let node = new $9bf71ea28793e738$var$TreeNode({\n            scopeRef: scopeRef\n        });\n        parentNode.addChild(node);\n        node.parent = parentNode;\n        this.fastMap.set(scopeRef, node);\n        if (nodeToRestore) node.nodeToRestore = nodeToRestore;\n    }\n    removeTreeNode(scopeRef) {\n        // never remove the root\n        if (scopeRef === null) return;\n        let node = this.fastMap.get(scopeRef);\n        let parentNode = node.parent;\n        // when we remove a scope, check if any sibling scopes are trying to restore focus to something inside the scope we're removing\n        // if we are, then replace the siblings restore with the restore from the scope we're removing\n        for (let current of this.traverse())if (current !== node && node.nodeToRestore && current.nodeToRestore && node.scopeRef.current && $9bf71ea28793e738$var$isElementInScope(current.nodeToRestore, node.scopeRef.current)) current.nodeToRestore = node.nodeToRestore;\n        let children = node.children;\n        parentNode.removeChild(node);\n        if (children.length > 0) children.forEach((child)=>parentNode.addChild(child)\n        );\n        this.fastMap.delete(node.scopeRef);\n    }\n    // Pre Order Depth First\n    *traverse(node = this.root) {\n        if (node.scopeRef != null) yield node;\n        if (node.children.length > 0) for (let child of node.children)yield* this.traverse(child);\n    }\n    clone() {\n        let newTree = new $9bf71ea28793e738$var$Tree();\n        for (let node of this.traverse())newTree.addTreeNode(node.scopeRef, node.parent.scopeRef, node.nodeToRestore);\n        return newTree;\n    }\n    constructor(){\n        this.fastMap = new Map();\n        this.root = new $9bf71ea28793e738$var$TreeNode({\n            scopeRef: null\n        });\n        this.fastMap.set(null, this.root);\n    }\n}\nclass $9bf71ea28793e738$var$TreeNode {\n    addChild(node) {\n        this.children.push(node);\n        node.parent = this;\n    }\n    removeChild(node) {\n        this.children.splice(this.children.indexOf(node), 1);\n        node.parent = undefined;\n    }\n    constructor(props){\n        this.children = [];\n        this.contain = false;\n        this.scopeRef = props.scopeRef;\n    }\n}\nlet $9bf71ea28793e738$export$d06fae2ee68b101e = new $9bf71ea28793e738$var$Tree();\n\n\n\n\n\n\n\n\nfunction $f7dceffc5ad7768b$export$4e328f61c538687f(props = {\n}) {\n    let { autoFocus: autoFocus = false , isTextInput: isTextInput , within: within  } = props;\n    let state = $6nfFC$useRef({\n        isFocused: false,\n        isFocusVisible: autoFocus || $6nfFC$isFocusVisible()\n    });\n    let [isFocused1, setFocused] = $6nfFC$useState(false);\n    let [isFocusVisibleState, setFocusVisible] = $6nfFC$useState(()=>state.current.isFocused && state.current.isFocusVisible\n    );\n    let updateState = $6nfFC$useCallback(()=>setFocusVisible(state.current.isFocused && state.current.isFocusVisible)\n    , []);\n    let onFocusChange = $6nfFC$useCallback((isFocused)=>{\n        state.current.isFocused = isFocused;\n        setFocused(isFocused);\n        updateState();\n    }, [\n        updateState\n    ]);\n    $6nfFC$useFocusVisibleListener((isFocusVisible)=>{\n        state.current.isFocusVisible = isFocusVisible;\n        updateState();\n    }, [], {\n        isTextInput: isTextInput\n    });\n    let { focusProps: focusProps  } = $6nfFC$useFocus({\n        isDisabled: within,\n        onFocusChange: onFocusChange\n    });\n    let { focusWithinProps: focusWithinProps  } = $6nfFC$useFocusWithin({\n        isDisabled: !within,\n        onFocusWithinChange: onFocusChange\n    });\n    return {\n        isFocused: isFocused1,\n        isFocusVisible: state.current.isFocused && isFocusVisibleState,\n        focusProps: within ? focusWithinProps : focusProps\n    };\n}\n\n\nfunction $907718708eab68af$export$1a38b4ad7f578e1d(props) {\n    let { children: children , focusClass: focusClass , focusRingClass: focusRingClass  } = props;\n    let { isFocused: isFocused , isFocusVisible: isFocusVisible , focusProps: focusProps  } = $f7dceffc5ad7768b$export$4e328f61c538687f(props);\n    let child = $6nfFC$react.Children.only(children);\n    return(/*#__PURE__*/ $6nfFC$react.cloneElement(child, $6nfFC$mergeProps(child.props, {\n        ...focusProps,\n        className: $6nfFC$clsx({\n            [focusClass || '']: isFocused,\n            [focusRingClass || '']: isFocusVisible\n        })\n    })));\n}\n\n\n\n\n\n\nlet $e6afbd83fe6ebbd2$var$FocusableContext = /*#__PURE__*/ $6nfFC$react.createContext(null);\nfunction $e6afbd83fe6ebbd2$var$useFocusableContext(ref) {\n    let context = $6nfFC$useContext($e6afbd83fe6ebbd2$var$FocusableContext) || {\n    };\n    $6nfFC$useSyncRef(context, ref);\n    // eslint-disable-next-line\n    let { ref: _ , ...otherProps } = context;\n    return otherProps;\n}\n/**\n * Provides DOM props to the nearest focusable child.\n */ function $e6afbd83fe6ebbd2$var$FocusableProvider(props, ref) {\n    let { children: children , ...otherProps } = props;\n    let context = {\n        ...otherProps,\n        ref: ref\n    };\n    return(/*#__PURE__*/ $6nfFC$react.createElement($e6afbd83fe6ebbd2$var$FocusableContext.Provider, {\n        value: context\n    }, children));\n}\nlet $e6afbd83fe6ebbd2$export$13f3202a3e5ddd5 = /*#__PURE__*/ $6nfFC$react.forwardRef($e6afbd83fe6ebbd2$var$FocusableProvider);\nfunction $e6afbd83fe6ebbd2$export$4c014de7c8940b4c(props, domRef) {\n    let { focusProps: focusProps  } = $6nfFC$useFocus(props);\n    let { keyboardProps: keyboardProps  } = $6nfFC$useKeyboard(props);\n    let interactions = $6nfFC$mergeProps(focusProps, keyboardProps);\n    let domProps = $e6afbd83fe6ebbd2$var$useFocusableContext(domRef);\n    let interactionProps = props.isDisabled ? {\n    } : domProps;\n    let autoFocusRef = $6nfFC$useRef(props.autoFocus);\n    $6nfFC$useEffect(()=>{\n        if (autoFocusRef.current && domRef.current) $6a99195332edec8b$export$80f3e147d781571c(domRef.current);\n        autoFocusRef.current = false;\n    }, [\n        domRef\n    ]);\n    return {\n        focusableProps: $6nfFC$mergeProps({\n            ...interactions,\n            tabIndex: props.excludeFromTabOrder && !props.isDisabled ? -1 : undefined\n        }, interactionProps)\n    };\n}\n\n\n\n\n\n\nexport {$9bf71ea28793e738$export$20e40289641fbbb6 as FocusScope, $9bf71ea28793e738$export$10c5169755ce7bd7 as useFocusManager, $9bf71ea28793e738$export$2d6ec8fc375ceafa as getFocusableTreeWalker, $9bf71ea28793e738$export$c5251b9e124bf29 as createFocusManager, $907718708eab68af$export$1a38b4ad7f578e1d as FocusRing, $e6afbd83fe6ebbd2$export$13f3202a3e5ddd5 as FocusableProvider, $e6afbd83fe6ebbd2$export$4c014de7c8940b4c as useFocusable, $f7dceffc5ad7768b$export$4e328f61c538687f as useFocusRing, $6a99195332edec8b$export$80f3e147d781571c as focusSafely};\n//# sourceMappingURL=module.js.map\n","import { concatStyleSets } from './concatStyleSets';\n/**\n * Concatenates style sets into one, but resolves functional sets using the given props.\n * @param styleProps - Props used to resolve functional sets.\n * @param allStyles - Style sets, which can be functions or objects.\n */\nexport function concatStyleSetsWithProps(styleProps) {\n    var allStyles = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        allStyles[_i - 1] = arguments[_i];\n    }\n    var result = [];\n    for (var _a = 0, allStyles_1 = allStyles; _a < allStyles_1.length; _a++) {\n        var styles = allStyles_1[_a];\n        if (styles) {\n            result.push(typeof styles === 'function' ? styles(styleProps) : styles);\n        }\n    }\n    if (result.length === 1) {\n        return result[0];\n    }\n    else if (result.length) {\n        // cliffkoh: I cannot figure out how to avoid the cast to any here.\n        // It is something to do with the use of Omit in IStyleSet.\n        // It might not be necessary once  Omit becomes part of lib.d.ts (when we remove our own Omit and rely on\n        // the official version).\n        return concatStyleSets.apply(void 0, result);\n    }\n    return {};\n}\n//# sourceMappingURL=concatStyleSetsWithProps.js.map","var reverseEasing = function (easing) { return function (p) { return 1 - easing(1 - p); }; };\nvar mirrorEasing = function (easing) { return function (p) {\n    return p <= 0.5 ? easing(2 * p) / 2 : (2 - easing(2 * (1 - p))) / 2;\n}; };\nvar createExpoIn = function (power) { return function (p) { return Math.pow(p, power); }; };\nvar createBackIn = function (power) { return function (p) {\n    return p * p * ((power + 1) * p - power);\n}; };\nvar createAnticipate = function (power) {\n    var backEasing = createBackIn(power);\n    return function (p) {\n        return (p *= 2) < 1\n            ? 0.5 * backEasing(p)\n            : 0.5 * (2 - Math.pow(2, -10 * (p - 1)));\n    };\n};\n\nexport { createAnticipate, createBackIn, createExpoIn, mirrorEasing, reverseEasing };\n","import getWindowScroll from \"./getWindowScroll.js\";\nimport getWindow from \"./getWindow.js\";\nimport { isHTMLElement } from \"./instanceOf.js\";\nimport getHTMLElementScroll from \"./getHTMLElementScroll.js\";\nexport default function getNodeScroll(node) {\n  if (node === getWindow(node) || !isHTMLElement(node)) {\n    return getWindowScroll(node);\n  } else {\n    return getHTMLElementScroll(node);\n  }\n}","import getBoundingClientRect from \"./getBoundingClientRect.js\";\nimport getDocumentElement from \"./getDocumentElement.js\";\nimport getWindowScroll from \"./getWindowScroll.js\";\nexport default function getWindowScrollBarX(element) {\n  // If <html> has a CSS width greater than the viewport, then this will be\n  // incorrect for RTL.\n  // Popper 1 is broken in this case and never had a bug report so let's assume\n  // it's not an issue. I don't think anyone ever specifies width on <html>\n  // anyway.\n  // Browsers where the left scrollbar doesn't cause an issue report `0` for\n  // this (e.g. Edge 2019, IE11, Safari)\n  return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;\n}","var _vendorSettings;\nexport function getVendorSettings() {\n    var _a;\n    if (!_vendorSettings) {\n        // eslint-disable-next-line no-restricted-globals\n        var doc = typeof document !== 'undefined' ? document : undefined;\n        var nav = typeof navigator !== 'undefined' ? navigator : undefined;\n        var userAgent = (_a = nav === null || nav === void 0 ? void 0 : nav.userAgent) === null || _a === void 0 ? void 0 : _a.toLowerCase();\n        if (!doc) {\n            _vendorSettings = {\n                isWebkit: true,\n                isMoz: true,\n                isOpera: true,\n                isMs: true,\n            };\n        }\n        else {\n            _vendorSettings = {\n                isWebkit: !!(doc && 'WebkitAppearance' in doc.documentElement.style),\n                isMoz: !!(userAgent && userAgent.indexOf('firefox') > -1),\n                isOpera: !!(userAgent && userAgent.indexOf('opera') > -1),\n                isMs: !!(nav && (/rv:11.0/i.test(nav.userAgent) || /Edge\\/\\d./i.test(navigator.userAgent))),\n            };\n        }\n    }\n    return _vendorSettings;\n}\n/**\n * Sets the vendor settings for prefixing and vendor specific operations.\n */\nexport function setVendorSettings(vendorSettings) {\n    _vendorSettings = vendorSettings;\n}\n//# sourceMappingURL=getVendorSettings.js.map","import { getVendorSettings } from '../getVendorSettings';\nvar autoPrefixNames = {\n    'user-select': 1,\n};\nexport function prefixRules(rulePairs, index) {\n    var vendorSettings = getVendorSettings();\n    var name = rulePairs[index];\n    if (autoPrefixNames[name]) {\n        var value = rulePairs[index + 1];\n        if (autoPrefixNames[name]) {\n            if (vendorSettings.isWebkit) {\n                rulePairs.push('-webkit-' + name, value);\n            }\n            if (vendorSettings.isMoz) {\n                rulePairs.push('-moz-' + name, value);\n            }\n            if (vendorSettings.isMs) {\n                rulePairs.push('-ms-' + name, value);\n            }\n            if (vendorSettings.isOpera) {\n                rulePairs.push('-o-' + name, value);\n            }\n        }\n    }\n}\n//# sourceMappingURL=prefixRules.js.map","import { onNextFrame, defaultTimestep } from './on-next-frame.js';\nimport { createRenderStep } from './create-render-step.js';\n\nvar maxElapsed = 40;\nvar useDefaultElapsed = true;\nvar runNextFrame = false;\nvar isProcessing = false;\nvar frame = {\n    delta: 0,\n    timestamp: 0\n};\nvar stepsOrder = [\"read\", \"update\", \"preRender\", \"render\", \"postRender\"];\nvar steps = /*#__PURE__*/stepsOrder.reduce(function (acc, key) {\n    acc[key] = createRenderStep(function () {\n        return runNextFrame = true;\n    });\n    return acc;\n}, {});\nvar sync = /*#__PURE__*/stepsOrder.reduce(function (acc, key) {\n    var step = steps[key];\n    acc[key] = function (process, keepAlive, immediate) {\n        if (keepAlive === void 0) {\n            keepAlive = false;\n        }\n        if (immediate === void 0) {\n            immediate = false;\n        }\n        if (!runNextFrame) startLoop();\n        return step.schedule(process, keepAlive, immediate);\n    };\n    return acc;\n}, {});\nvar cancelSync = /*#__PURE__*/stepsOrder.reduce(function (acc, key) {\n    acc[key] = steps[key].cancel;\n    return acc;\n}, {});\nvar flushSync = /*#__PURE__*/stepsOrder.reduce(function (acc, key) {\n    acc[key] = function () {\n        return steps[key].process(frame);\n    };\n    return acc;\n}, {});\nvar processStep = function (stepId) {\n    return steps[stepId].process(frame);\n};\nvar processFrame = function (timestamp) {\n    runNextFrame = false;\n    frame.delta = useDefaultElapsed ? defaultTimestep : Math.max(Math.min(timestamp - frame.timestamp, maxElapsed), 1);\n    frame.timestamp = timestamp;\n    isProcessing = true;\n    stepsOrder.forEach(processStep);\n    isProcessing = false;\n    if (runNextFrame) {\n        useDefaultElapsed = false;\n        onNextFrame(processFrame);\n    }\n};\nvar startLoop = function () {\n    runNextFrame = true;\n    useDefaultElapsed = true;\n    if (!isProcessing) onNextFrame(processFrame);\n};\nvar getFrameData = function () {\n    return frame;\n};\n\nexport default sync;\nexport { cancelSync, flushSync, getFrameData };\n","import { DEFINITION_LOOKUP_TABLE } from '../constants.esm.js';\nimport { debugData } from './store.esm.js';\nimport { getDebugClassNames } from './utils.esm.js';\n\nfunction getDebugTree(debugSequenceHash, parentNode) {\n  const lookupItem = DEFINITION_LOOKUP_TABLE[debugSequenceHash];\n  if (lookupItem === undefined) {\n    return undefined;\n  }\n  const parentLookupItem = parentNode ? DEFINITION_LOOKUP_TABLE[parentNode.sequenceHash] : undefined;\n  const debugClassNames = getDebugClassNames(lookupItem, parentLookupItem, parentNode === null || parentNode === void 0 ? void 0 : parentNode.debugClassNames, parentNode === null || parentNode === void 0 ? void 0 : parentNode.children);\n  const node = {\n    sequenceHash: debugSequenceHash,\n    direction: lookupItem[1],\n    children: [],\n    debugClassNames\n  };\n  const childrenSequences = debugData.getChildrenSequences(node.sequenceHash);\n  childrenSequences.reverse() // first process the overriding children that are merged last\n  .forEach(sequence => {\n    const child = getDebugTree(sequence, node);\n    if (child) {\n      node.children.push(child);\n    }\n  });\n  // if it's leaf (makeStyle node), get css rules\n  if (!node.children.length) {\n    node.rules = {};\n    node.debugClassNames.forEach(({\n      className\n    }) => {\n      const mapData = debugData.getSequenceDetails(debugSequenceHash);\n      if (mapData) {\n        node.slot = mapData.slotName;\n        node.sourceURL = mapData.sourceURL;\n      }\n      const cssRule = debugData.getCSSRules().find(cssRule => {\n        return cssRule.includes(className);\n      });\n      node.rules[className] = cssRule;\n    });\n  }\n  return node;\n}\n\nexport { getDebugTree };\n//# sourceMappingURL=getDebugTree.esm.js.map\n","import getScrollParent from \"./getScrollParent.js\";\nimport getParentNode from \"./getParentNode.js\";\nimport getWindow from \"./getWindow.js\";\nimport isScrollParent from \"./isScrollParent.js\";\n/*\ngiven a DOM element, return the list of all scroll parents, up the list of ancesors\nuntil we get to the top window object. This list is what we attach scroll listeners\nto, because if any of these parent elements scroll, we'll need to re-calculate the\nreference element's position.\n*/\n\nexport default function listScrollParents(element, list) {\n  var _element$ownerDocumen;\n\n  if (list === void 0) {\n    list = [];\n  }\n\n  var scrollParent = getScrollParent(element);\n  var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);\n  var win = getWindow(scrollParent);\n  var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;\n  var updatedList = list.concat(target);\n  return isBody ? updatedList : // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here\n  updatedList.concat(listScrollParents(getParentNode(target)));\n}","import { Mark, mergeAttributes, markInputRule, markPasteRule } from '@tiptap/core';\n\n/**\n * Matches an italic to a *italic* on input.\n */\nconst starInputRegex = /(?:^|\\s)(\\*(?!\\s+\\*)((?:[^*]+))\\*(?!\\s+\\*))$/;\n/**\n * Matches an italic to a *italic* on paste.\n */\nconst starPasteRegex = /(?:^|\\s)(\\*(?!\\s+\\*)((?:[^*]+))\\*(?!\\s+\\*))/g;\n/**\n * Matches an italic to a _italic_ on input.\n */\nconst underscoreInputRegex = /(?:^|\\s)(_(?!\\s+_)((?:[^_]+))_(?!\\s+_))$/;\n/**\n * Matches an italic to a _italic_ on paste.\n */\nconst underscorePasteRegex = /(?:^|\\s)(_(?!\\s+_)((?:[^_]+))_(?!\\s+_))/g;\n/**\n * This extension allows you to create italic text.\n * @see https://www.tiptap.dev/api/marks/italic\n */\nconst Italic = Mark.create({\n    name: 'italic',\n    addOptions() {\n        return {\n            HTMLAttributes: {},\n        };\n    },\n    parseHTML() {\n        return [\n            {\n                tag: 'em',\n            },\n            {\n                tag: 'i',\n                getAttrs: node => node.style.fontStyle !== 'normal' && null,\n            },\n            {\n                style: 'font-style=italic',\n            },\n        ];\n    },\n    renderHTML({ HTMLAttributes }) {\n        return ['em', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];\n    },\n    addCommands() {\n        return {\n            setItalic: () => ({ commands }) => {\n                return commands.setMark(this.name);\n            },\n            toggleItalic: () => ({ commands }) => {\n                return commands.toggleMark(this.name);\n            },\n            unsetItalic: () => ({ commands }) => {\n                return commands.unsetMark(this.name);\n            },\n        };\n    },\n    addKeyboardShortcuts() {\n        return {\n            'Mod-i': () => this.editor.commands.toggleItalic(),\n            'Mod-I': () => this.editor.commands.toggleItalic(),\n        };\n    },\n    addInputRules() {\n        return [\n            markInputRule({\n                find: starInputRegex,\n                type: this.type,\n            }),\n            markInputRule({\n                find: underscoreInputRegex,\n                type: this.type,\n            }),\n        ];\n    },\n    addPasteRules() {\n        return [\n            markPasteRule({\n                find: starPasteRegex,\n                type: this.type,\n            }),\n            markPasteRule({\n                find: underscorePasteRegex,\n                type: this.type,\n            }),\n        ];\n    },\n});\n\nexport { Italic, Italic as default, starInputRegex, starPasteRegex, underscoreInputRegex, underscorePasteRegex };\n//# sourceMappingURL=index.js.map\n","var zeroPoint = {\n    x: 0,\n    y: 0,\n    z: 0\n};\nvar isNum = function (v) { return typeof v === 'number'; };\n\nexport { isNum, zeroPoint };\n","import validate from './validate.js';\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nconst byteToHex = [];\n\nfor (let i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).slice(1));\n}\n\nexport function unsafeStringify(arr, offset = 0) {\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];\n}\n\nfunction stringify(arr, offset = 0) {\n  const uuid = unsafeStringify(arr, offset); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!validate(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\nexport default stringify;","var clamp = function (min, max, v) {\n    return Math.min(Math.max(v, min), max);\n};\n\nexport { clamp };\n","import { isTextSelection, isNodeSelection, posToDOMRect, Extension } from '@tiptap/core';\nimport { Plugin, PluginKey } from '@tiptap/pm/state';\nimport tippy from 'tippy.js';\n\nclass BubbleMenuView {\n    constructor({ editor, element, view, tippyOptions = {}, updateDelay = 250, shouldShow, }) {\n        this.preventHide = false;\n        this.shouldShow = ({ view, state, from, to, }) => {\n            const { doc, selection } = state;\n            const { empty } = selection;\n            // Sometime check for `empty` is not enough.\n            // Doubleclick an empty paragraph returns a node size of 2.\n            // So we check also for an empty text size.\n            const isEmptyTextBlock = !doc.textBetween(from, to).length && isTextSelection(state.selection);\n            // When clicking on a element inside the bubble menu the editor \"blur\" event\n            // is called and the bubble menu item is focussed. In this case we should\n            // consider the menu as part of the editor and keep showing the menu\n            const isChildOfMenu = this.element.contains(document.activeElement);\n            const hasEditorFocus = view.hasFocus() || isChildOfMenu;\n            if (!hasEditorFocus || empty || isEmptyTextBlock || !this.editor.isEditable) {\n                return false;\n            }\n            return true;\n        };\n        this.mousedownHandler = () => {\n            this.preventHide = true;\n        };\n        this.dragstartHandler = () => {\n            this.hide();\n        };\n        this.focusHandler = () => {\n            // we use `setTimeout` to make sure `selection` is already updated\n            setTimeout(() => this.update(this.editor.view));\n        };\n        this.blurHandler = ({ event }) => {\n            var _a;\n            if (this.preventHide) {\n                this.preventHide = false;\n                return;\n            }\n            if ((event === null || event === void 0 ? void 0 : event.relatedTarget) && ((_a = this.element.parentNode) === null || _a === void 0 ? void 0 : _a.contains(event.relatedTarget))) {\n                return;\n            }\n            this.hide();\n        };\n        this.tippyBlurHandler = (event) => {\n            this.blurHandler({ event });\n        };\n        this.handleDebouncedUpdate = (view, oldState) => {\n            const selectionChanged = !(oldState === null || oldState === void 0 ? void 0 : oldState.selection.eq(view.state.selection));\n            const docChanged = !(oldState === null || oldState === void 0 ? void 0 : oldState.doc.eq(view.state.doc));\n            if (!selectionChanged && !docChanged) {\n                return;\n            }\n            if (this.updateDebounceTimer) {\n                clearTimeout(this.updateDebounceTimer);\n            }\n            this.updateDebounceTimer = window.setTimeout(() => {\n                this.updateHandler(view, selectionChanged, docChanged, oldState);\n            }, this.updateDelay);\n        };\n        this.updateHandler = (view, selectionChanged, docChanged, oldState) => {\n            var _a, _b, _c;\n            const { state, composing } = view;\n            const { selection } = state;\n            const isSame = !selectionChanged && !docChanged;\n            if (composing || isSame) {\n                return;\n            }\n            this.createTooltip();\n            // support for CellSelections\n            const { ranges } = selection;\n            const from = Math.min(...ranges.map(range => range.$from.pos));\n            const to = Math.max(...ranges.map(range => range.$to.pos));\n            const shouldShow = (_a = this.shouldShow) === null || _a === void 0 ? void 0 : _a.call(this, {\n                editor: this.editor,\n                view,\n                state,\n                oldState,\n                from,\n                to,\n            });\n            if (!shouldShow) {\n                this.hide();\n                return;\n            }\n            (_b = this.tippy) === null || _b === void 0 ? void 0 : _b.setProps({\n                getReferenceClientRect: ((_c = this.tippyOptions) === null || _c === void 0 ? void 0 : _c.getReferenceClientRect)\n                    || (() => {\n                        if (isNodeSelection(state.selection)) {\n                            let node = view.nodeDOM(from);\n                            const nodeViewWrapper = node.dataset.nodeViewWrapper ? node : node.querySelector('[data-node-view-wrapper]');\n                            if (nodeViewWrapper) {\n                                node = nodeViewWrapper.firstChild;\n                            }\n                            if (node) {\n                                return node.getBoundingClientRect();\n                            }\n                        }\n                        return posToDOMRect(view, from, to);\n                    }),\n            });\n            this.show();\n        };\n        this.editor = editor;\n        this.element = element;\n        this.view = view;\n        this.updateDelay = updateDelay;\n        if (shouldShow) {\n            this.shouldShow = shouldShow;\n        }\n        this.element.addEventListener('mousedown', this.mousedownHandler, { capture: true });\n        this.view.dom.addEventListener('dragstart', this.dragstartHandler);\n        this.editor.on('focus', this.focusHandler);\n        this.editor.on('blur', this.blurHandler);\n        this.tippyOptions = tippyOptions;\n        // Detaches menu content from its current parent\n        this.element.remove();\n        this.element.style.visibility = 'visible';\n    }\n    createTooltip() {\n        const { element: editorElement } = this.editor.options;\n        const editorIsAttached = !!editorElement.parentElement;\n        if (this.tippy || !editorIsAttached) {\n            return;\n        }\n        this.tippy = tippy(editorElement, {\n            duration: 0,\n            getReferenceClientRect: null,\n            content: this.element,\n            interactive: true,\n            trigger: 'manual',\n            placement: 'top',\n            hideOnClick: 'toggle',\n            ...this.tippyOptions,\n        });\n        // maybe we have to hide tippy on its own blur event as well\n        if (this.tippy.popper.firstChild) {\n            this.tippy.popper.firstChild.addEventListener('blur', this.tippyBlurHandler);\n        }\n    }\n    update(view, oldState) {\n        const { state } = view;\n        const hasValidSelection = state.selection.from !== state.selection.to;\n        if (this.updateDelay > 0 && hasValidSelection) {\n            this.handleDebouncedUpdate(view, oldState);\n            return;\n        }\n        const selectionChanged = !(oldState === null || oldState === void 0 ? void 0 : oldState.selection.eq(view.state.selection));\n        const docChanged = !(oldState === null || oldState === void 0 ? void 0 : oldState.doc.eq(view.state.doc));\n        this.updateHandler(view, selectionChanged, docChanged, oldState);\n    }\n    show() {\n        var _a;\n        (_a = this.tippy) === null || _a === void 0 ? void 0 : _a.show();\n    }\n    hide() {\n        var _a;\n        (_a = this.tippy) === null || _a === void 0 ? void 0 : _a.hide();\n    }\n    destroy() {\n        var _a, _b;\n        if ((_a = this.tippy) === null || _a === void 0 ? void 0 : _a.popper.firstChild) {\n            this.tippy.popper.firstChild.removeEventListener('blur', this.tippyBlurHandler);\n        }\n        (_b = this.tippy) === null || _b === void 0 ? void 0 : _b.destroy();\n        this.element.removeEventListener('mousedown', this.mousedownHandler, { capture: true });\n        this.view.dom.removeEventListener('dragstart', this.dragstartHandler);\n        this.editor.off('focus', this.focusHandler);\n        this.editor.off('blur', this.blurHandler);\n    }\n}\nconst BubbleMenuPlugin = (options) => {\n    return new Plugin({\n        key: typeof options.pluginKey === 'string' ? new PluginKey(options.pluginKey) : options.pluginKey,\n        view: view => new BubbleMenuView({ view, ...options }),\n    });\n};\n\n/**\n * This extension allows you to create a bubble menu.\n * @see https://tiptap.dev/api/extensions/bubble-menu\n */\nconst BubbleMenu = Extension.create({\n    name: 'bubbleMenu',\n    addOptions() {\n        return {\n            element: null,\n            tippyOptions: {},\n            pluginKey: 'bubbleMenu',\n            updateDelay: undefined,\n            shouldShow: null,\n        };\n    },\n    addProseMirrorPlugins() {\n        if (!this.options.element) {\n            return [];\n        }\n        return [\n            BubbleMenuPlugin({\n                pluginKey: this.options.pluginKey,\n                editor: this.editor,\n                element: this.options.element,\n                tippyOptions: this.options.tippyOptions,\n                updateDelay: this.options.updateDelay,\n                shouldShow: this.options.shouldShow,\n            }),\n        ];\n    },\n});\n\nexport { BubbleMenu, BubbleMenuPlugin, BubbleMenuView, BubbleMenu as default };\n//# sourceMappingURL=index.js.map\n","import * as React from 'react';\nimport { useConst } from './useConst';\n/**\n * Hook to force update a function component by updating a dummy state.\n */\nexport function useForceUpdate() {\n    var _a = React.useState(0), setValue = _a[1];\n    var forceUpdate = useConst(function () { return function () { return setValue(function (value) { return ++value; }); }; });\n    return forceUpdate;\n}\n//# sourceMappingURL=useForceUpdate.js.map","import { Node, mergeAttributes, Mark, getMarkAttributes, wrappingInputRule } from '@tiptap/core';\n\n/**\n * This extension allows you to create list items.\n * @see https://www.tiptap.dev/api/nodes/list-item\n */\nconst ListItem = Node.create({\n    name: 'listItem',\n    addOptions() {\n        return {\n            HTMLAttributes: {},\n            bulletListTypeName: 'bulletList',\n            orderedListTypeName: 'orderedList',\n        };\n    },\n    content: 'paragraph block*',\n    defining: true,\n    parseHTML() {\n        return [\n            {\n                tag: 'li',\n            },\n        ];\n    },\n    renderHTML({ HTMLAttributes }) {\n        return ['li', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];\n    },\n    addKeyboardShortcuts() {\n        return {\n            Enter: () => this.editor.commands.splitListItem(this.name),\n            Tab: () => this.editor.commands.sinkListItem(this.name),\n            'Shift-Tab': () => this.editor.commands.liftListItem(this.name),\n        };\n    },\n});\n\n/**\n * This extension allows you to create text styles. It is required by default\n * for the `textColor` and `backgroundColor` extensions.\n * @see https://www.tiptap.dev/api/marks/text-style\n */\nconst TextStyle = Mark.create({\n    name: 'textStyle',\n    addOptions() {\n        return {\n            HTMLAttributes: {},\n        };\n    },\n    parseHTML() {\n        return [\n            {\n                tag: 'span',\n                getAttrs: element => {\n                    const hasStyles = element.hasAttribute('style');\n                    if (!hasStyles) {\n                        return false;\n                    }\n                    return {};\n                },\n            },\n        ];\n    },\n    renderHTML({ HTMLAttributes }) {\n        return ['span', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];\n    },\n    addCommands() {\n        return {\n            removeEmptyTextStyle: () => ({ state, commands }) => {\n                const attributes = getMarkAttributes(state, this.type);\n                const hasStyles = Object.entries(attributes).some(([, value]) => !!value);\n                if (hasStyles) {\n                    return true;\n                }\n                return commands.unsetMark(this.name);\n            },\n        };\n    },\n});\n\n/**\n * Matches an ordered list to a 1. on input (or any number followed by a dot).\n */\nconst inputRegex = /^(\\d+)\\.\\s$/;\n/**\n * This extension allows you to create ordered lists.\n * This requires the ListItem extension\n * @see https://www.tiptap.dev/api/nodes/ordered-list\n * @see https://www.tiptap.dev/api/nodes/list-item\n */\nconst OrderedList = Node.create({\n    name: 'orderedList',\n    addOptions() {\n        return {\n            itemTypeName: 'listItem',\n            HTMLAttributes: {},\n            keepMarks: false,\n            keepAttributes: false,\n        };\n    },\n    group: 'block list',\n    content() {\n        return `${this.options.itemTypeName}+`;\n    },\n    addAttributes() {\n        return {\n            start: {\n                default: 1,\n                parseHTML: element => {\n                    return element.hasAttribute('start')\n                        ? parseInt(element.getAttribute('start') || '', 10)\n                        : 1;\n                },\n            },\n        };\n    },\n    parseHTML() {\n        return [\n            {\n                tag: 'ol',\n            },\n        ];\n    },\n    renderHTML({ HTMLAttributes }) {\n        const { start, ...attributesWithoutStart } = HTMLAttributes;\n        return start === 1\n            ? ['ol', mergeAttributes(this.options.HTMLAttributes, attributesWithoutStart), 0]\n            : ['ol', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];\n    },\n    addCommands() {\n        return {\n            toggleOrderedList: () => ({ commands, chain }) => {\n                if (this.options.keepAttributes) {\n                    return chain().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(ListItem.name, this.editor.getAttributes(TextStyle.name)).run();\n                }\n                return commands.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks);\n            },\n        };\n    },\n    addKeyboardShortcuts() {\n        return {\n            'Mod-Shift-7': () => this.editor.commands.toggleOrderedList(),\n        };\n    },\n    addInputRules() {\n        let inputRule = wrappingInputRule({\n            find: inputRegex,\n            type: this.type,\n            getAttributes: match => ({ start: +match[1] }),\n            joinPredicate: (match, node) => node.childCount + node.attrs.start === +match[1],\n        });\n        if (this.options.keepMarks || this.options.keepAttributes) {\n            inputRule = wrappingInputRule({\n                find: inputRegex,\n                type: this.type,\n                keepMarks: this.options.keepMarks,\n                keepAttributes: this.options.keepAttributes,\n                getAttributes: match => ({ start: +match[1], ...this.editor.getAttributes(TextStyle.name) }),\n                joinPredicate: (match, node) => node.childCount + node.attrs.start === +match[1],\n                editor: this.editor,\n            });\n        }\n        return [\n            inputRule,\n        ];\n    },\n});\n\nexport { OrderedList, OrderedList as default, inputRegex };\n//# sourceMappingURL=index.js.map\n","import { __assign } from 'tslib';\nimport { number, alpha } from '../numbers/index.js';\nimport { sanitize, clamp } from '../utils.js';\nimport { isColorString, splitColor } from './utils.js';\n\nvar clampRgbUnit = clamp(0, 255);\nvar rgbUnit = __assign(__assign({}, number), { transform: function (v) { return Math.round(clampRgbUnit(v)); } });\nvar rgba = {\n    test: isColorString('rgb', 'red'),\n    parse: splitColor('red', 'green', 'blue'),\n    transform: function (_a) {\n        var red = _a.red, green = _a.green, blue = _a.blue, _b = _a.alpha, alpha$1 = _b === void 0 ? 1 : _b;\n        return 'rgba(' +\n            rgbUnit.transform(red) +\n            ', ' +\n            rgbUnit.transform(green) +\n            ', ' +\n            rgbUnit.transform(blue) +\n            ', ' +\n            sanitize(alpha.transform(alpha$1)) +\n            ')';\n    },\n};\n\nexport { rgbUnit, rgba };\n","var warning = function () { };\r\nvar invariant = function () { };\r\nif (process.env.NODE_ENV !== 'production') {\r\n    warning = function (check, message) {\r\n        if (!check && typeof console !== 'undefined') {\r\n            console.warn(message);\r\n        }\r\n    };\r\n    invariant = function (check, message) {\r\n        if (!check) {\r\n            throw new Error(message);\r\n        }\r\n    };\r\n}\n\nexport { invariant, warning };\n","export var ZIndexes;\n(function (ZIndexes) {\n    ZIndexes.Nav = 1;\n    /**\n     * @deprecated Do not use\n     */\n    ZIndexes.ScrollablePane = 1;\n    ZIndexes.FocusStyle = 1;\n    ZIndexes.Coachmark = 1000;\n    ZIndexes.Layer = 1000000;\n    ZIndexes.KeytipLayer = 1000001;\n})(ZIndexes || (ZIndexes = {}));\n//# sourceMappingURL=zIndexes.js.map","export var getEventTarget = function (event) {\n    var target = event.target;\n    if (target && target.shadowRoot) {\n        target = event.composedPath()[0];\n    }\n    return target;\n};\n//# sourceMappingURL=getEventTarget.js.map","import { injectDevTools } from '../devtools/injectDevTools.esm.js';\nimport { isDevToolsEnabled } from '../devtools/isDevToolsEnabled.esm.js';\nimport { debugData } from '../devtools/store.esm.js';\nimport { normalizeCSSBucketEntry } from '../runtime/utils/normalizeCSSBucketEntry.esm.js';\nimport { getStyleSheetForBucket } from './getStyleSheetForBucket.esm.js';\nimport { safeInsertRule } from './safeInsertRule.esm.js';\n\nlet lastIndex = 0;\n/** @internal */\nconst defaultCompareMediaQueries = (a, b) => a < b ? -1 : a > b ? 1 : 0;\n/**\n * Creates a new instances of a renderer.\n *\n * @public\n */\nfunction createDOMRenderer(targetDocument = typeof document === 'undefined' ? undefined : document, options = {}) {\n  const {\n    classNameHashSalt,\n    unstable_filterCSSRule,\n    insertionPoint,\n    styleElementAttributes,\n    compareMediaQueries = defaultCompareMediaQueries\n  } = options;\n  const renderer = {\n    classNameHashSalt,\n    insertionCache: {},\n    stylesheets: {},\n    styleElementAttributes: Object.freeze(styleElementAttributes),\n    compareMediaQueries,\n    id: `d${lastIndex++}`,\n    insertCSSRules(cssRules) {\n      // eslint-disable-next-line guard-for-in\n      for (const styleBucketName in cssRules) {\n        const cssRulesForBucket = cssRules[styleBucketName];\n        // This is a hot path in rendering styles: \".length\" is cached in \"l\" var to avoid accesses the property\n        for (let i = 0, l = cssRulesForBucket.length; i < l; i++) {\n          const [ruleCSS, metadata] = normalizeCSSBucketEntry(cssRulesForBucket[i]);\n          const sheet = getStyleSheetForBucket(styleBucketName, targetDocument, insertionPoint || null, renderer, metadata);\n          if (renderer.insertionCache[ruleCSS]) {\n            continue;\n          }\n          renderer.insertionCache[ruleCSS] = styleBucketName;\n          if (process.env.NODE_ENV !== 'production' && isDevToolsEnabled) {\n            debugData.addCSSRule(ruleCSS);\n          }\n          if (unstable_filterCSSRule) {\n            if (unstable_filterCSSRule(ruleCSS)) {\n              safeInsertRule(sheet, ruleCSS);\n            }\n          } else {\n            safeInsertRule(sheet, ruleCSS);\n          }\n        }\n      }\n    }\n  };\n  if (targetDocument && process.env.NODE_ENV !== 'production' && isDevToolsEnabled) {\n    injectDevTools(targetDocument);\n  }\n  return renderer;\n}\n\nexport { createDOMRenderer, defaultCompareMediaQueries };\n//# sourceMappingURL=createDOMRenderer.esm.js.map\n","// When adding or removing a color, make sure you keep this consistent with IColorClassNames\n// by adding the color variants.\nexport var DefaultPalette = {\n    themeDarker: '#004578',\n    themeDark: '#005a9e',\n    themeDarkAlt: '#106ebe',\n    themePrimary: '#0078d4',\n    themeSecondary: '#2b88d8',\n    themeTertiary: '#71afe5',\n    themeLight: '#c7e0f4',\n    themeLighter: '#deecf9',\n    themeLighterAlt: '#eff6fc',\n    black: '#000000',\n    blackTranslucent40: 'rgba(0,0,0,.4)',\n    neutralDark: '#201f1e',\n    neutralPrimary: '#323130',\n    neutralPrimaryAlt: '#3b3a39',\n    neutralSecondary: '#605e5c',\n    neutralSecondaryAlt: '#8a8886',\n    neutralTertiary: '#a19f9d',\n    neutralTertiaryAlt: '#c8c6c4',\n    neutralQuaternary: '#d2d0ce',\n    neutralQuaternaryAlt: '#e1dfdd',\n    neutralLight: '#edebe9',\n    neutralLighter: '#f3f2f1',\n    neutralLighterAlt: '#faf9f8',\n    accent: '#0078d4',\n    white: '#ffffff',\n    whiteTranslucent40: 'rgba(255,255,255,.4)',\n    yellowDark: '#d29200',\n    yellow: '#ffb900',\n    yellowLight: '#fff100',\n    orange: '#d83b01',\n    orangeLight: '#ea4300',\n    orangeLighter: '#ff8c00',\n    redDark: '#a4262c',\n    red: '#e81123',\n    magentaDark: '#5c005c',\n    magenta: '#b4009e',\n    magentaLight: '#e3008c',\n    purpleDark: '#32145a',\n    purple: '#5c2d91',\n    purpleLight: '#b4a0ff',\n    blueDark: '#002050',\n    blueMid: '#00188f',\n    blue: '#0078d4',\n    blueLight: '#00bcf2',\n    tealDark: '#004b50',\n    teal: '#008272',\n    tealLight: '#00b294',\n    greenDark: '#004b1c',\n    green: '#107c10',\n    greenLight: '#bad80a',\n};\n//# sourceMappingURL=DefaultPalette.js.map","export default function _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}","module.exports = function(originalModule) {\n\tif (!originalModule.webpackPolyfill) {\n\t\tvar module = Object.create(originalModule);\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"exports\", {\n\t\t\tenumerable: true\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n","/** @license React v17.0.2\n * react.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\nif (process.env.NODE_ENV !== \"production\") {\n  (function() {\n'use strict';\n\nvar _assign = require('object-assign');\n\n// TODO: this is special because it gets imported during build.\nvar ReactVersion = '17.0.2';\n\n// ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n// The Symbol used to tag the ReactElement-like types. If there is no native Symbol\n// nor polyfill, then a plain number is used for performance.\nvar REACT_ELEMENT_TYPE = 0xeac7;\nvar REACT_PORTAL_TYPE = 0xeaca;\nexports.Fragment = 0xeacb;\nexports.StrictMode = 0xeacc;\nexports.Profiler = 0xead2;\nvar REACT_PROVIDER_TYPE = 0xeacd;\nvar REACT_CONTEXT_TYPE = 0xeace;\nvar REACT_FORWARD_REF_TYPE = 0xead0;\nexports.Suspense = 0xead1;\nvar REACT_SUSPENSE_LIST_TYPE = 0xead8;\nvar REACT_MEMO_TYPE = 0xead3;\nvar REACT_LAZY_TYPE = 0xead4;\nvar REACT_BLOCK_TYPE = 0xead9;\nvar REACT_SERVER_BLOCK_TYPE = 0xeada;\nvar REACT_FUNDAMENTAL_TYPE = 0xead5;\nvar REACT_SCOPE_TYPE = 0xead7;\nvar REACT_OPAQUE_ID_TYPE = 0xeae0;\nvar REACT_DEBUG_TRACING_MODE_TYPE = 0xeae1;\nvar REACT_OFFSCREEN_TYPE = 0xeae2;\nvar REACT_LEGACY_HIDDEN_TYPE = 0xeae3;\n\nif (typeof Symbol === 'function' && Symbol.for) {\n  var symbolFor = Symbol.for;\n  REACT_ELEMENT_TYPE = symbolFor('react.element');\n  REACT_PORTAL_TYPE = symbolFor('react.portal');\n  exports.Fragment = symbolFor('react.fragment');\n  exports.StrictMode = symbolFor('react.strict_mode');\n  exports.Profiler = symbolFor('react.profiler');\n  REACT_PROVIDER_TYPE = symbolFor('react.provider');\n  REACT_CONTEXT_TYPE = symbolFor('react.context');\n  REACT_FORWARD_REF_TYPE = symbolFor('react.forward_ref');\n  exports.Suspense = symbolFor('react.suspense');\n  REACT_SUSPENSE_LIST_TYPE = symbolFor('react.suspense_list');\n  REACT_MEMO_TYPE = symbolFor('react.memo');\n  REACT_LAZY_TYPE = symbolFor('react.lazy');\n  REACT_BLOCK_TYPE = symbolFor('react.block');\n  REACT_SERVER_BLOCK_TYPE = symbolFor('react.server.block');\n  REACT_FUNDAMENTAL_TYPE = symbolFor('react.fundamental');\n  REACT_SCOPE_TYPE = symbolFor('react.scope');\n  REACT_OPAQUE_ID_TYPE = symbolFor('react.opaque.id');\n  REACT_DEBUG_TRACING_MODE_TYPE = symbolFor('react.debug_trace_mode');\n  REACT_OFFSCREEN_TYPE = symbolFor('react.offscreen');\n  REACT_LEGACY_HIDDEN_TYPE = symbolFor('react.legacy_hidden');\n}\n\nvar MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\n    return null;\n  }\n\n  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n\n  return null;\n}\n\n/**\n * Keeps track of the current dispatcher.\n */\nvar ReactCurrentDispatcher = {\n  /**\n   * @internal\n   * @type {ReactComponent}\n   */\n  current: null\n};\n\n/**\n * Keeps track of the current batch's configuration such as how long an update\n * should suspend for if it needs to.\n */\nvar ReactCurrentBatchConfig = {\n  transition: 0\n};\n\n/**\n * Keeps track of the current owner.\n *\n * The current owner is the component who should own any components that are\n * currently being constructed.\n */\nvar ReactCurrentOwner = {\n  /**\n   * @internal\n   * @type {ReactComponent}\n   */\n  current: null\n};\n\nvar ReactDebugCurrentFrame = {};\nvar currentExtraStackFrame = null;\nfunction setExtraStackFrame(stack) {\n  {\n    currentExtraStackFrame = stack;\n  }\n}\n\n{\n  ReactDebugCurrentFrame.setExtraStackFrame = function (stack) {\n    {\n      currentExtraStackFrame = stack;\n    }\n  }; // Stack implementation injected by the current renderer.\n\n\n  ReactDebugCurrentFrame.getCurrentStack = null;\n\n  ReactDebugCurrentFrame.getStackAddendum = function () {\n    var stack = ''; // Add an extra top frame while an element is being validated\n\n    if (currentExtraStackFrame) {\n      stack += currentExtraStackFrame;\n    } // Delegate to the injected renderer-specific implementation\n\n\n    var impl = ReactDebugCurrentFrame.getCurrentStack;\n\n    if (impl) {\n      stack += impl() || '';\n    }\n\n    return stack;\n  };\n}\n\n/**\n * Used by act() to track whether you're inside an act() scope.\n */\nvar IsSomeRendererActing = {\n  current: false\n};\n\nvar ReactSharedInternals = {\n  ReactCurrentDispatcher: ReactCurrentDispatcher,\n  ReactCurrentBatchConfig: ReactCurrentBatchConfig,\n  ReactCurrentOwner: ReactCurrentOwner,\n  IsSomeRendererActing: IsSomeRendererActing,\n  // Used by renderers to avoid bundling object-assign twice in UMD bundles:\n  assign: _assign\n};\n\n{\n  ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame;\n}\n\n// by calls to these methods by a Babel plugin.\n//\n// In PROD (or in packages without access to React internals),\n// they are left as they are instead.\n\nfunction warn(format) {\n  {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    printWarning('warn', format, args);\n  }\n}\nfunction error(format) {\n  {\n    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      args[_key2 - 1] = arguments[_key2];\n    }\n\n    printWarning('error', format, args);\n  }\n}\n\nfunction printWarning(level, format, args) {\n  // When changing this logic, you might want to also\n  // update consoleWithStackDev.www.js as well.\n  {\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n    var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n    if (stack !== '') {\n      format += '%s';\n      args = args.concat([stack]);\n    }\n\n    var argsWithFormat = args.map(function (item) {\n      return '' + item;\n    }); // Careful: RN currently depends on this prefix\n\n    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n    // breaks IE9: https://github.com/facebook/react/issues/13610\n    // eslint-disable-next-line react-internal/no-production-logging\n\n    Function.prototype.apply.call(console[level], console, argsWithFormat);\n  }\n}\n\nvar didWarnStateUpdateForUnmountedComponent = {};\n\nfunction warnNoop(publicInstance, callerName) {\n  {\n    var _constructor = publicInstance.constructor;\n    var componentName = _constructor && (_constructor.displayName || _constructor.name) || 'ReactClass';\n    var warningKey = componentName + \".\" + callerName;\n\n    if (didWarnStateUpdateForUnmountedComponent[warningKey]) {\n      return;\n    }\n\n    error(\"Can't call %s on a component that is not yet mounted. \" + 'This is a no-op, but it might indicate a bug in your application. ' + 'Instead, assign to `this.state` directly or define a `state = {};` ' + 'class property with the desired state in the %s component.', callerName, componentName);\n\n    didWarnStateUpdateForUnmountedComponent[warningKey] = true;\n  }\n}\n/**\n * This is the abstract API for an update queue.\n */\n\n\nvar ReactNoopUpdateQueue = {\n  /**\n   * Checks whether or not this composite component is mounted.\n   * @param {ReactClass} publicInstance The instance we want to test.\n   * @return {boolean} True if mounted, false otherwise.\n   * @protected\n   * @final\n   */\n  isMounted: function (publicInstance) {\n    return false;\n  },\n\n  /**\n   * Forces an update. This should only be invoked when it is known with\n   * certainty that we are **not** in a DOM transaction.\n   *\n   * You may want to call this when you know that some deeper aspect of the\n   * component's state has changed but `setState` was not called.\n   *\n   * This will not invoke `shouldComponentUpdate`, but it will invoke\n   * `componentWillUpdate` and `componentDidUpdate`.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {?function} callback Called after component is updated.\n   * @param {?string} callerName name of the calling function in the public API.\n   * @internal\n   */\n  enqueueForceUpdate: function (publicInstance, callback, callerName) {\n    warnNoop(publicInstance, 'forceUpdate');\n  },\n\n  /**\n   * Replaces all of the state. Always use this or `setState` to mutate state.\n   * You should treat `this.state` as immutable.\n   *\n   * There is no guarantee that `this.state` will be immediately updated, so\n   * accessing `this.state` after calling this method may return the old value.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} completeState Next state.\n   * @param {?function} callback Called after component is updated.\n   * @param {?string} callerName name of the calling function in the public API.\n   * @internal\n   */\n  enqueueReplaceState: function (publicInstance, completeState, callback, callerName) {\n    warnNoop(publicInstance, 'replaceState');\n  },\n\n  /**\n   * Sets a subset of the state. This only exists because _pendingState is\n   * internal. This provides a merging strategy that is not available to deep\n   * properties which is confusing. TODO: Expose pendingState or don't use it\n   * during the merge.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} partialState Next partial state to be merged with state.\n   * @param {?function} callback Called after component is updated.\n   * @param {?string} Name of the calling function in the public API.\n   * @internal\n   */\n  enqueueSetState: function (publicInstance, partialState, callback, callerName) {\n    warnNoop(publicInstance, 'setState');\n  }\n};\n\nvar emptyObject = {};\n\n{\n  Object.freeze(emptyObject);\n}\n/**\n * Base class helpers for the updating state of a component.\n */\n\n\nfunction Component(props, context, updater) {\n  this.props = props;\n  this.context = context; // If a component has string refs, we will assign a different object later.\n\n  this.refs = emptyObject; // We initialize the default updater but the real one gets injected by the\n  // renderer.\n\n  this.updater = updater || ReactNoopUpdateQueue;\n}\n\nComponent.prototype.isReactComponent = {};\n/**\n * Sets a subset of the state. Always use this to mutate\n * state. You should treat `this.state` as immutable.\n *\n * There is no guarantee that `this.state` will be immediately updated, so\n * accessing `this.state` after calling this method may return the old value.\n *\n * There is no guarantee that calls to `setState` will run synchronously,\n * as they may eventually be batched together.  You can provide an optional\n * callback that will be executed when the call to setState is actually\n * completed.\n *\n * When a function is provided to setState, it will be called at some point in\n * the future (not synchronously). It will be called with the up to date\n * component arguments (state, props, context). These values can be different\n * from this.* because your function may be called after receiveProps but before\n * shouldComponentUpdate, and this new state, props, and context will not yet be\n * assigned to this.\n *\n * @param {object|function} partialState Next partial state or function to\n *        produce next partial state to be merged with current state.\n * @param {?function} callback Called after state is updated.\n * @final\n * @protected\n */\n\nComponent.prototype.setState = function (partialState, callback) {\n  if (!(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null)) {\n    {\n      throw Error( \"setState(...): takes an object of state variables to update or a function which returns an object of state variables.\" );\n    }\n  }\n\n  this.updater.enqueueSetState(this, partialState, callback, 'setState');\n};\n/**\n * Forces an update. This should only be invoked when it is known with\n * certainty that we are **not** in a DOM transaction.\n *\n * You may want to call this when you know that some deeper aspect of the\n * component's state has changed but `setState` was not called.\n *\n * This will not invoke `shouldComponentUpdate`, but it will invoke\n * `componentWillUpdate` and `componentDidUpdate`.\n *\n * @param {?function} callback Called after update is complete.\n * @final\n * @protected\n */\n\n\nComponent.prototype.forceUpdate = function (callback) {\n  this.updater.enqueueForceUpdate(this, callback, 'forceUpdate');\n};\n/**\n * Deprecated APIs. These APIs used to exist on classic React classes but since\n * we would like to deprecate them, we're not going to move them over to this\n * modern base class. Instead, we define a getter that warns if it's accessed.\n */\n\n\n{\n  var deprecatedAPIs = {\n    isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],\n    replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).']\n  };\n\n  var defineDeprecationWarning = function (methodName, info) {\n    Object.defineProperty(Component.prototype, methodName, {\n      get: function () {\n        warn('%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]);\n\n        return undefined;\n      }\n    });\n  };\n\n  for (var fnName in deprecatedAPIs) {\n    if (deprecatedAPIs.hasOwnProperty(fnName)) {\n      defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);\n    }\n  }\n}\n\nfunction ComponentDummy() {}\n\nComponentDummy.prototype = Component.prototype;\n/**\n * Convenience component with default shallow equality check for sCU.\n */\n\nfunction PureComponent(props, context, updater) {\n  this.props = props;\n  this.context = context; // If a component has string refs, we will assign a different object later.\n\n  this.refs = emptyObject;\n  this.updater = updater || ReactNoopUpdateQueue;\n}\n\nvar pureComponentPrototype = PureComponent.prototype = new ComponentDummy();\npureComponentPrototype.constructor = PureComponent; // Avoid an extra prototype jump for these methods.\n\n_assign(pureComponentPrototype, Component.prototype);\n\npureComponentPrototype.isPureReactComponent = true;\n\n// an immutable object with a single mutable value\nfunction createRef() {\n  var refObject = {\n    current: null\n  };\n\n  {\n    Object.seal(refObject);\n  }\n\n  return refObject;\n}\n\nfunction getWrappedName(outerType, innerType, wrapperName) {\n  var functionName = innerType.displayName || innerType.name || '';\n  return outerType.displayName || (functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName);\n}\n\nfunction getContextName(type) {\n  return type.displayName || 'Context';\n}\n\nfunction getComponentName(type) {\n  if (type == null) {\n    // Host root, text node or just invalid type.\n    return null;\n  }\n\n  {\n    if (typeof type.tag === 'number') {\n      error('Received an unexpected object in getComponentName(). ' + 'This is likely a bug in React. Please file an issue.');\n    }\n  }\n\n  if (typeof type === 'function') {\n    return type.displayName || type.name || null;\n  }\n\n  if (typeof type === 'string') {\n    return type;\n  }\n\n  switch (type) {\n    case exports.Fragment:\n      return 'Fragment';\n\n    case REACT_PORTAL_TYPE:\n      return 'Portal';\n\n    case exports.Profiler:\n      return 'Profiler';\n\n    case exports.StrictMode:\n      return 'StrictMode';\n\n    case exports.Suspense:\n      return 'Suspense';\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return 'SuspenseList';\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_CONTEXT_TYPE:\n        var context = type;\n        return getContextName(context) + '.Consumer';\n\n      case REACT_PROVIDER_TYPE:\n        var provider = type;\n        return getContextName(provider._context) + '.Provider';\n\n      case REACT_FORWARD_REF_TYPE:\n        return getWrappedName(type, type.render, 'ForwardRef');\n\n      case REACT_MEMO_TYPE:\n        return getComponentName(type.type);\n\n      case REACT_BLOCK_TYPE:\n        return getComponentName(type._render);\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            return getComponentName(init(payload));\n          } catch (x) {\n            return null;\n          }\n        }\n    }\n  }\n\n  return null;\n}\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar RESERVED_PROPS = {\n  key: true,\n  ref: true,\n  __self: true,\n  __source: true\n};\nvar specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;\n\n{\n  didWarnAboutStringRefs = {};\n}\n\nfunction hasValidRef(config) {\n  {\n    if (hasOwnProperty.call(config, 'ref')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.ref !== undefined;\n}\n\nfunction hasValidKey(config) {\n  {\n    if (hasOwnProperty.call(config, 'key')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.key !== undefined;\n}\n\nfunction defineKeyPropWarningGetter(props, displayName) {\n  var warnAboutAccessingKey = function () {\n    {\n      if (!specialPropKeyWarningShown) {\n        specialPropKeyWarningShown = true;\n\n        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    }\n  };\n\n  warnAboutAccessingKey.isReactWarning = true;\n  Object.defineProperty(props, 'key', {\n    get: warnAboutAccessingKey,\n    configurable: true\n  });\n}\n\nfunction defineRefPropWarningGetter(props, displayName) {\n  var warnAboutAccessingRef = function () {\n    {\n      if (!specialPropRefWarningShown) {\n        specialPropRefWarningShown = true;\n\n        error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    }\n  };\n\n  warnAboutAccessingRef.isReactWarning = true;\n  Object.defineProperty(props, 'ref', {\n    get: warnAboutAccessingRef,\n    configurable: true\n  });\n}\n\nfunction warnIfStringRefCannotBeAutoConverted(config) {\n  {\n    if (typeof config.ref === 'string' && ReactCurrentOwner.current && config.__self && ReactCurrentOwner.current.stateNode !== config.__self) {\n      var componentName = getComponentName(ReactCurrentOwner.current.type);\n\n      if (!didWarnAboutStringRefs[componentName]) {\n        error('Component \"%s\" contains the string ref \"%s\". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', componentName, config.ref);\n\n        didWarnAboutStringRefs[componentName] = true;\n      }\n    }\n  }\n}\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */\n\n\nvar ReactElement = function (type, key, ref, self, source, owner, props) {\n  var element = {\n    // This tag allows us to uniquely identify this as a React Element\n    $$typeof: REACT_ELEMENT_TYPE,\n    // Built-in properties that belong on the element\n    type: type,\n    key: key,\n    ref: ref,\n    props: props,\n    // Record the component responsible for creating this element.\n    _owner: owner\n  };\n\n  {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: false\n    }); // self and source are DEV only properties.\n\n    Object.defineProperty(element, '_self', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: self\n    }); // Two elements created in two different places should be considered\n    // equal for testing purposes and therefore we hide it from enumeration.\n\n    Object.defineProperty(element, '_source', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: source\n    });\n\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n};\n/**\n * Create and return a new ReactElement of the given type.\n * See https://reactjs.org/docs/react-api.html#createelement\n */\n\nfunction createElement(type, config, children) {\n  var propName; // Reserved names are extracted\n\n  var props = {};\n  var key = null;\n  var ref = null;\n  var self = null;\n  var source = null;\n\n  if (config != null) {\n    if (hasValidRef(config)) {\n      ref = config.ref;\n\n      {\n        warnIfStringRefCannotBeAutoConverted(config);\n      }\n    }\n\n    if (hasValidKey(config)) {\n      key = '' + config.key;\n    }\n\n    self = config.__self === undefined ? null : config.__self;\n    source = config.__source === undefined ? null : config.__source; // Remaining properties are added to a new props object\n\n    for (propName in config) {\n      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n        props[propName] = config[propName];\n      }\n    }\n  } // Children can be more than one argument, and those are transferred onto\n  // the newly allocated props object.\n\n\n  var childrenLength = arguments.length - 2;\n\n  if (childrenLength === 1) {\n    props.children = children;\n  } else if (childrenLength > 1) {\n    var childArray = Array(childrenLength);\n\n    for (var i = 0; i < childrenLength; i++) {\n      childArray[i] = arguments[i + 2];\n    }\n\n    {\n      if (Object.freeze) {\n        Object.freeze(childArray);\n      }\n    }\n\n    props.children = childArray;\n  } // Resolve default props\n\n\n  if (type && type.defaultProps) {\n    var defaultProps = type.defaultProps;\n\n    for (propName in defaultProps) {\n      if (props[propName] === undefined) {\n        props[propName] = defaultProps[propName];\n      }\n    }\n  }\n\n  {\n    if (key || ref) {\n      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n\n      if (key) {\n        defineKeyPropWarningGetter(props, displayName);\n      }\n\n      if (ref) {\n        defineRefPropWarningGetter(props, displayName);\n      }\n    }\n  }\n\n  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n}\nfunction cloneAndReplaceKey(oldElement, newKey) {\n  var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);\n  return newElement;\n}\n/**\n * Clone and return a new ReactElement using element as the starting point.\n * See https://reactjs.org/docs/react-api.html#cloneelement\n */\n\nfunction cloneElement(element, config, children) {\n  if (!!(element === null || element === undefined)) {\n    {\n      throw Error( \"React.cloneElement(...): The argument must be a React element, but you passed \" + element + \".\" );\n    }\n  }\n\n  var propName; // Original props are copied\n\n  var props = _assign({}, element.props); // Reserved names are extracted\n\n\n  var key = element.key;\n  var ref = element.ref; // Self is preserved since the owner is preserved.\n\n  var self = element._self; // Source is preserved since cloneElement is unlikely to be targeted by a\n  // transpiler, and the original source is probably a better indicator of the\n  // true owner.\n\n  var source = element._source; // Owner will be preserved, unless ref is overridden\n\n  var owner = element._owner;\n\n  if (config != null) {\n    if (hasValidRef(config)) {\n      // Silently steal the ref from the parent.\n      ref = config.ref;\n      owner = ReactCurrentOwner.current;\n    }\n\n    if (hasValidKey(config)) {\n      key = '' + config.key;\n    } // Remaining properties override existing props\n\n\n    var defaultProps;\n\n    if (element.type && element.type.defaultProps) {\n      defaultProps = element.type.defaultProps;\n    }\n\n    for (propName in config) {\n      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n        if (config[propName] === undefined && defaultProps !== undefined) {\n          // Resolve default props\n          props[propName] = defaultProps[propName];\n        } else {\n          props[propName] = config[propName];\n        }\n      }\n    }\n  } // Children can be more than one argument, and those are transferred onto\n  // the newly allocated props object.\n\n\n  var childrenLength = arguments.length - 2;\n\n  if (childrenLength === 1) {\n    props.children = children;\n  } else if (childrenLength > 1) {\n    var childArray = Array(childrenLength);\n\n    for (var i = 0; i < childrenLength; i++) {\n      childArray[i] = arguments[i + 2];\n    }\n\n    props.children = childArray;\n  }\n\n  return ReactElement(element.type, key, ref, self, source, owner, props);\n}\n/**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */\n\nfunction isValidElement(object) {\n  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n}\n\nvar SEPARATOR = '.';\nvar SUBSEPARATOR = ':';\n/**\n * Escape and wrap key so it is safe to use as a reactid\n *\n * @param {string} key to be escaped.\n * @return {string} the escaped key.\n */\n\nfunction escape(key) {\n  var escapeRegex = /[=:]/g;\n  var escaperLookup = {\n    '=': '=0',\n    ':': '=2'\n  };\n  var escapedString = key.replace(escapeRegex, function (match) {\n    return escaperLookup[match];\n  });\n  return '$' + escapedString;\n}\n/**\n * TODO: Test that a single child and an array with one item have the same key\n * pattern.\n */\n\n\nvar didWarnAboutMaps = false;\nvar userProvidedKeyEscapeRegex = /\\/+/g;\n\nfunction escapeUserProvidedKey(text) {\n  return text.replace(userProvidedKeyEscapeRegex, '$&/');\n}\n/**\n * Generate a key string that identifies a element within a set.\n *\n * @param {*} element A element that could contain a manual key.\n * @param {number} index Index that is used if a manual key is not provided.\n * @return {string}\n */\n\n\nfunction getElementKey(element, index) {\n  // Do some typechecking here since we call this blindly. We want to ensure\n  // that we don't block potential future ES APIs.\n  if (typeof element === 'object' && element !== null && element.key != null) {\n    // Explicit key\n    return escape('' + element.key);\n  } // Implicit key determined by the index in the set\n\n\n  return index.toString(36);\n}\n\nfunction mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {\n  var type = typeof children;\n\n  if (type === 'undefined' || type === 'boolean') {\n    // All of the above are perceived as null.\n    children = null;\n  }\n\n  var invokeCallback = false;\n\n  if (children === null) {\n    invokeCallback = true;\n  } else {\n    switch (type) {\n      case 'string':\n      case 'number':\n        invokeCallback = true;\n        break;\n\n      case 'object':\n        switch (children.$$typeof) {\n          case REACT_ELEMENT_TYPE:\n          case REACT_PORTAL_TYPE:\n            invokeCallback = true;\n        }\n\n    }\n  }\n\n  if (invokeCallback) {\n    var _child = children;\n    var mappedChild = callback(_child); // If it's the only child, treat the name as if it was wrapped in an array\n    // so that it's consistent if the number of children grows:\n\n    var childKey = nameSoFar === '' ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;\n\n    if (Array.isArray(mappedChild)) {\n      var escapedChildKey = '';\n\n      if (childKey != null) {\n        escapedChildKey = escapeUserProvidedKey(childKey) + '/';\n      }\n\n      mapIntoArray(mappedChild, array, escapedChildKey, '', function (c) {\n        return c;\n      });\n    } else if (mappedChild != null) {\n      if (isValidElement(mappedChild)) {\n        mappedChild = cloneAndReplaceKey(mappedChild, // Keep both the (mapped) and old keys if they differ, just as\n        // traverseAllChildren used to do for objects as children\n        escapedPrefix + ( // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key\n        mappedChild.key && (!_child || _child.key !== mappedChild.key) ? // $FlowFixMe Flow incorrectly thinks existing element's key can be a number\n        escapeUserProvidedKey('' + mappedChild.key) + '/' : '') + childKey);\n      }\n\n      array.push(mappedChild);\n    }\n\n    return 1;\n  }\n\n  var child;\n  var nextName;\n  var subtreeCount = 0; // Count of children found in the current subtree.\n\n  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;\n\n  if (Array.isArray(children)) {\n    for (var i = 0; i < children.length; i++) {\n      child = children[i];\n      nextName = nextNamePrefix + getElementKey(child, i);\n      subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);\n    }\n  } else {\n    var iteratorFn = getIteratorFn(children);\n\n    if (typeof iteratorFn === 'function') {\n      var iterableChildren = children;\n\n      {\n        // Warn about using Maps as children\n        if (iteratorFn === iterableChildren.entries) {\n          if (!didWarnAboutMaps) {\n            warn('Using Maps as children is not supported. ' + 'Use an array of keyed ReactElements instead.');\n          }\n\n          didWarnAboutMaps = true;\n        }\n      }\n\n      var iterator = iteratorFn.call(iterableChildren);\n      var step;\n      var ii = 0;\n\n      while (!(step = iterator.next()).done) {\n        child = step.value;\n        nextName = nextNamePrefix + getElementKey(child, ii++);\n        subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);\n      }\n    } else if (type === 'object') {\n      var childrenString = '' + children;\n\n      {\n        {\n          throw Error( \"Objects are not valid as a React child (found: \" + (childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString) + \"). If you meant to render a collection of children, use an array instead.\" );\n        }\n      }\n    }\n  }\n\n  return subtreeCount;\n}\n\n/**\n * Maps children that are typically specified as `props.children`.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrenmap\n *\n * The provided mapFunction(child, index) will be called for each\n * leaf child.\n *\n * @param {?*} children Children tree container.\n * @param {function(*, int)} func The map function.\n * @param {*} context Context for mapFunction.\n * @return {object} Object containing the ordered map of results.\n */\nfunction mapChildren(children, func, context) {\n  if (children == null) {\n    return children;\n  }\n\n  var result = [];\n  var count = 0;\n  mapIntoArray(children, result, '', '', function (child) {\n    return func.call(context, child, count++);\n  });\n  return result;\n}\n/**\n * Count the number of children that are typically specified as\n * `props.children`.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrencount\n *\n * @param {?*} children Children tree container.\n * @return {number} The number of children.\n */\n\n\nfunction countChildren(children) {\n  var n = 0;\n  mapChildren(children, function () {\n    n++; // Don't return anything\n  });\n  return n;\n}\n\n/**\n * Iterates through children that are typically specified as `props.children`.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrenforeach\n *\n * The provided forEachFunc(child, index) will be called for each\n * leaf child.\n *\n * @param {?*} children Children tree container.\n * @param {function(*, int)} forEachFunc\n * @param {*} forEachContext Context for forEachContext.\n */\nfunction forEachChildren(children, forEachFunc, forEachContext) {\n  mapChildren(children, function () {\n    forEachFunc.apply(this, arguments); // Don't return anything.\n  }, forEachContext);\n}\n/**\n * Flatten a children object (typically specified as `props.children`) and\n * return an array with appropriately re-keyed children.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrentoarray\n */\n\n\nfunction toArray(children) {\n  return mapChildren(children, function (child) {\n    return child;\n  }) || [];\n}\n/**\n * Returns the first child in a collection of children and verifies that there\n * is only one child in the collection.\n *\n * See https://reactjs.org/docs/react-api.html#reactchildrenonly\n *\n * The current implementation of this function assumes that a single child gets\n * passed without a wrapper, but the purpose of this helper function is to\n * abstract away the particular structure of children.\n *\n * @param {?object} children Child collection structure.\n * @return {ReactElement} The first and only `ReactElement` contained in the\n * structure.\n */\n\n\nfunction onlyChild(children) {\n  if (!isValidElement(children)) {\n    {\n      throw Error( \"React.Children.only expected to receive a single React element child.\" );\n    }\n  }\n\n  return children;\n}\n\nfunction createContext(defaultValue, calculateChangedBits) {\n  if (calculateChangedBits === undefined) {\n    calculateChangedBits = null;\n  } else {\n    {\n      if (calculateChangedBits !== null && typeof calculateChangedBits !== 'function') {\n        error('createContext: Expected the optional second argument to be a ' + 'function. Instead received: %s', calculateChangedBits);\n      }\n    }\n  }\n\n  var context = {\n    $$typeof: REACT_CONTEXT_TYPE,\n    _calculateChangedBits: calculateChangedBits,\n    // As a workaround to support multiple concurrent renderers, we categorize\n    // some renderers as primary and others as secondary. We only expect\n    // there to be two concurrent renderers at most: React Native (primary) and\n    // Fabric (secondary); React DOM (primary) and React ART (secondary).\n    // Secondary renderers store their context values on separate fields.\n    _currentValue: defaultValue,\n    _currentValue2: defaultValue,\n    // Used to track how many concurrent renderers this context currently\n    // supports within in a single renderer. Such as parallel server rendering.\n    _threadCount: 0,\n    // These are circular\n    Provider: null,\n    Consumer: null\n  };\n  context.Provider = {\n    $$typeof: REACT_PROVIDER_TYPE,\n    _context: context\n  };\n  var hasWarnedAboutUsingNestedContextConsumers = false;\n  var hasWarnedAboutUsingConsumerProvider = false;\n  var hasWarnedAboutDisplayNameOnConsumer = false;\n\n  {\n    // A separate object, but proxies back to the original context object for\n    // backwards compatibility. It has a different $$typeof, so we can properly\n    // warn for the incorrect usage of Context as a Consumer.\n    var Consumer = {\n      $$typeof: REACT_CONTEXT_TYPE,\n      _context: context,\n      _calculateChangedBits: context._calculateChangedBits\n    }; // $FlowFixMe: Flow complains about not setting a value, which is intentional here\n\n    Object.defineProperties(Consumer, {\n      Provider: {\n        get: function () {\n          if (!hasWarnedAboutUsingConsumerProvider) {\n            hasWarnedAboutUsingConsumerProvider = true;\n\n            error('Rendering <Context.Consumer.Provider> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Provider> instead?');\n          }\n\n          return context.Provider;\n        },\n        set: function (_Provider) {\n          context.Provider = _Provider;\n        }\n      },\n      _currentValue: {\n        get: function () {\n          return context._currentValue;\n        },\n        set: function (_currentValue) {\n          context._currentValue = _currentValue;\n        }\n      },\n      _currentValue2: {\n        get: function () {\n          return context._currentValue2;\n        },\n        set: function (_currentValue2) {\n          context._currentValue2 = _currentValue2;\n        }\n      },\n      _threadCount: {\n        get: function () {\n          return context._threadCount;\n        },\n        set: function (_threadCount) {\n          context._threadCount = _threadCount;\n        }\n      },\n      Consumer: {\n        get: function () {\n          if (!hasWarnedAboutUsingNestedContextConsumers) {\n            hasWarnedAboutUsingNestedContextConsumers = true;\n\n            error('Rendering <Context.Consumer.Consumer> is not supported and will be removed in ' + 'a future major release. Did you mean to render <Context.Consumer> instead?');\n          }\n\n          return context.Consumer;\n        }\n      },\n      displayName: {\n        get: function () {\n          return context.displayName;\n        },\n        set: function (displayName) {\n          if (!hasWarnedAboutDisplayNameOnConsumer) {\n            warn('Setting `displayName` on Context.Consumer has no effect. ' + \"You should set it directly on the context with Context.displayName = '%s'.\", displayName);\n\n            hasWarnedAboutDisplayNameOnConsumer = true;\n          }\n        }\n      }\n    }); // $FlowFixMe: Flow complains about missing properties because it doesn't understand defineProperty\n\n    context.Consumer = Consumer;\n  }\n\n  {\n    context._currentRenderer = null;\n    context._currentRenderer2 = null;\n  }\n\n  return context;\n}\n\nvar Uninitialized = -1;\nvar Pending = 0;\nvar Resolved = 1;\nvar Rejected = 2;\n\nfunction lazyInitializer(payload) {\n  if (payload._status === Uninitialized) {\n    var ctor = payload._result;\n    var thenable = ctor(); // Transition to the next state.\n\n    var pending = payload;\n    pending._status = Pending;\n    pending._result = thenable;\n    thenable.then(function (moduleObject) {\n      if (payload._status === Pending) {\n        var defaultExport = moduleObject.default;\n\n        {\n          if (defaultExport === undefined) {\n            error('lazy: Expected the result of a dynamic import() call. ' + 'Instead received: %s\\n\\nYour code should look like: \\n  ' + // Break up imports to avoid accidentally parsing them as dependencies.\n            'const MyComponent = lazy(() => imp' + \"ort('./MyComponent'))\", moduleObject);\n          }\n        } // Transition to the next state.\n\n\n        var resolved = payload;\n        resolved._status = Resolved;\n        resolved._result = defaultExport;\n      }\n    }, function (error) {\n      if (payload._status === Pending) {\n        // Transition to the next state.\n        var rejected = payload;\n        rejected._status = Rejected;\n        rejected._result = error;\n      }\n    });\n  }\n\n  if (payload._status === Resolved) {\n    return payload._result;\n  } else {\n    throw payload._result;\n  }\n}\n\nfunction lazy(ctor) {\n  var payload = {\n    // We use these fields to store the result.\n    _status: -1,\n    _result: ctor\n  };\n  var lazyType = {\n    $$typeof: REACT_LAZY_TYPE,\n    _payload: payload,\n    _init: lazyInitializer\n  };\n\n  {\n    // In production, this would just set it on the object.\n    var defaultProps;\n    var propTypes; // $FlowFixMe\n\n    Object.defineProperties(lazyType, {\n      defaultProps: {\n        configurable: true,\n        get: function () {\n          return defaultProps;\n        },\n        set: function (newDefaultProps) {\n          error('React.lazy(...): It is not supported to assign `defaultProps` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');\n\n          defaultProps = newDefaultProps; // Match production behavior more closely:\n          // $FlowFixMe\n\n          Object.defineProperty(lazyType, 'defaultProps', {\n            enumerable: true\n          });\n        }\n      },\n      propTypes: {\n        configurable: true,\n        get: function () {\n          return propTypes;\n        },\n        set: function (newPropTypes) {\n          error('React.lazy(...): It is not supported to assign `propTypes` to ' + 'a lazy component import. Either specify them where the component ' + 'is defined, or create a wrapping component around it.');\n\n          propTypes = newPropTypes; // Match production behavior more closely:\n          // $FlowFixMe\n\n          Object.defineProperty(lazyType, 'propTypes', {\n            enumerable: true\n          });\n        }\n      }\n    });\n  }\n\n  return lazyType;\n}\n\nfunction forwardRef(render) {\n  {\n    if (render != null && render.$$typeof === REACT_MEMO_TYPE) {\n      error('forwardRef requires a render function but received a `memo` ' + 'component. Instead of forwardRef(memo(...)), use ' + 'memo(forwardRef(...)).');\n    } else if (typeof render !== 'function') {\n      error('forwardRef requires a render function but was given %s.', render === null ? 'null' : typeof render);\n    } else {\n      if (render.length !== 0 && render.length !== 2) {\n        error('forwardRef render functions accept exactly two parameters: props and ref. %s', render.length === 1 ? 'Did you forget to use the ref parameter?' : 'Any additional parameter will be undefined.');\n      }\n    }\n\n    if (render != null) {\n      if (render.defaultProps != null || render.propTypes != null) {\n        error('forwardRef render functions do not support propTypes or defaultProps. ' + 'Did you accidentally pass a React component?');\n      }\n    }\n  }\n\n  var elementType = {\n    $$typeof: REACT_FORWARD_REF_TYPE,\n    render: render\n  };\n\n  {\n    var ownName;\n    Object.defineProperty(elementType, 'displayName', {\n      enumerable: false,\n      configurable: true,\n      get: function () {\n        return ownName;\n      },\n      set: function (name) {\n        ownName = name;\n\n        if (render.displayName == null) {\n          render.displayName = name;\n        }\n      }\n    });\n  }\n\n  return elementType;\n}\n\n// Filter certain DOM attributes (e.g. src, href) if their values are empty strings.\n\nvar enableScopeAPI = false; // Experimental Create Event Handle API.\n\nfunction isValidElementType(type) {\n  if (typeof type === 'string' || typeof type === 'function') {\n    return true;\n  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n\n\n  if (type === exports.Fragment || type === exports.Profiler || type === REACT_DEBUG_TRACING_MODE_TYPE || type === exports.StrictMode || type === exports.Suspense || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_LEGACY_HIDDEN_TYPE || enableScopeAPI ) {\n    return true;\n  }\n\n  if (typeof type === 'object' && type !== null) {\n    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_BLOCK_TYPE || type[0] === REACT_SERVER_BLOCK_TYPE) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction memo(type, compare) {\n  {\n    if (!isValidElementType(type)) {\n      error('memo: The first argument must be a component. Instead ' + 'received: %s', type === null ? 'null' : typeof type);\n    }\n  }\n\n  var elementType = {\n    $$typeof: REACT_MEMO_TYPE,\n    type: type,\n    compare: compare === undefined ? null : compare\n  };\n\n  {\n    var ownName;\n    Object.defineProperty(elementType, 'displayName', {\n      enumerable: false,\n      configurable: true,\n      get: function () {\n        return ownName;\n      },\n      set: function (name) {\n        ownName = name;\n\n        if (type.displayName == null) {\n          type.displayName = name;\n        }\n      }\n    });\n  }\n\n  return elementType;\n}\n\nfunction resolveDispatcher() {\n  var dispatcher = ReactCurrentDispatcher.current;\n\n  if (!(dispatcher !== null)) {\n    {\n      throw Error( \"Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\\n1. You might have mismatching versions of React and the renderer (such as React DOM)\\n2. You might be breaking the Rules of Hooks\\n3. You might have more than one copy of React in the same app\\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.\" );\n    }\n  }\n\n  return dispatcher;\n}\n\nfunction useContext(Context, unstable_observedBits) {\n  var dispatcher = resolveDispatcher();\n\n  {\n    if (unstable_observedBits !== undefined) {\n      error('useContext() second argument is reserved for future ' + 'use in React. Passing it is not supported. ' + 'You passed: %s.%s', unstable_observedBits, typeof unstable_observedBits === 'number' && Array.isArray(arguments[2]) ? '\\n\\nDid you call array.map(useContext)? ' + 'Calling Hooks inside a loop is not supported. ' + 'Learn more at https://reactjs.org/link/rules-of-hooks' : '');\n    } // TODO: add a more generic warning for invalid values.\n\n\n    if (Context._context !== undefined) {\n      var realContext = Context._context; // Don't deduplicate because this legitimately causes bugs\n      // and nobody should be using this in existing code.\n\n      if (realContext.Consumer === Context) {\n        error('Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be ' + 'removed in a future major release. Did you mean to call useContext(Context) instead?');\n      } else if (realContext.Provider === Context) {\n        error('Calling useContext(Context.Provider) is not supported. ' + 'Did you mean to call useContext(Context) instead?');\n      }\n    }\n  }\n\n  return dispatcher.useContext(Context, unstable_observedBits);\n}\nfunction useState(initialState) {\n  var dispatcher = resolveDispatcher();\n  return dispatcher.useState(initialState);\n}\nfunction useReducer(reducer, initialArg, init) {\n  var dispatcher = resolveDispatcher();\n  return dispatcher.useReducer(reducer, initialArg, init);\n}\nfunction useRef(initialValue) {\n  var dispatcher = resolveDispatcher();\n  return dispatcher.useRef(initialValue);\n}\nfunction useEffect(create, deps) {\n  var dispatcher = resolveDispatcher();\n  return dispatcher.useEffect(create, deps);\n}\nfunction useLayoutEffect(create, deps) {\n  var dispatcher = resolveDispatcher();\n  return dispatcher.useLayoutEffect(create, deps);\n}\nfunction useCallback(callback, deps) {\n  var dispatcher = resolveDispatcher();\n  return dispatcher.useCallback(callback, deps);\n}\nfunction useMemo(create, deps) {\n  var dispatcher = resolveDispatcher();\n  return dispatcher.useMemo(create, deps);\n}\nfunction useImperativeHandle(ref, create, deps) {\n  var dispatcher = resolveDispatcher();\n  return dispatcher.useImperativeHandle(ref, create, deps);\n}\nfunction useDebugValue(value, formatterFn) {\n  {\n    var dispatcher = resolveDispatcher();\n    return dispatcher.useDebugValue(value, formatterFn);\n  }\n}\n\n// Helpers to patch console.logs to avoid logging during side-effect free\n// replaying on render function. This currently only patches the object\n// lazily which won't cover if the log function was extracted eagerly.\n// We could also eagerly patch the method.\nvar disabledDepth = 0;\nvar prevLog;\nvar prevInfo;\nvar prevWarn;\nvar prevError;\nvar prevGroup;\nvar prevGroupCollapsed;\nvar prevGroupEnd;\n\nfunction disabledLog() {}\n\ndisabledLog.__reactDisabledLog = true;\nfunction disableLogs() {\n  {\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      prevLog = console.log;\n      prevInfo = console.info;\n      prevWarn = console.warn;\n      prevError = console.error;\n      prevGroup = console.group;\n      prevGroupCollapsed = console.groupCollapsed;\n      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n\n      var props = {\n        configurable: true,\n        enumerable: true,\n        value: disabledLog,\n        writable: true\n      }; // $FlowFixMe Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        info: props,\n        log: props,\n        warn: props,\n        error: props,\n        group: props,\n        groupCollapsed: props,\n        groupEnd: props\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    disabledDepth++;\n  }\n}\nfunction reenableLogs() {\n  {\n    disabledDepth--;\n\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      var props = {\n        configurable: true,\n        enumerable: true,\n        writable: true\n      }; // $FlowFixMe Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        log: _assign({}, props, {\n          value: prevLog\n        }),\n        info: _assign({}, props, {\n          value: prevInfo\n        }),\n        warn: _assign({}, props, {\n          value: prevWarn\n        }),\n        error: _assign({}, props, {\n          value: prevError\n        }),\n        group: _assign({}, props, {\n          value: prevGroup\n        }),\n        groupCollapsed: _assign({}, props, {\n          value: prevGroupCollapsed\n        }),\n        groupEnd: _assign({}, props, {\n          value: prevGroupEnd\n        })\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    if (disabledDepth < 0) {\n      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\n    }\n  }\n}\n\nvar ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;\nvar prefix;\nfunction describeBuiltInComponentFrame(name, source, ownerFn) {\n  {\n    if (prefix === undefined) {\n      // Extract the VM specific prefix used by each line.\n      try {\n        throw Error();\n      } catch (x) {\n        var match = x.stack.trim().match(/\\n( *(at )?)/);\n        prefix = match && match[1] || '';\n      }\n    } // We use the prefix to ensure our stacks line up with native stack frames.\n\n\n    return '\\n' + prefix + name;\n  }\n}\nvar reentry = false;\nvar componentFrameCache;\n\n{\n  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n  componentFrameCache = new PossiblyWeakMap();\n}\n\nfunction describeNativeComponentFrame(fn, construct) {\n  // If something asked for a stack inside a fake render, it should get ignored.\n  if (!fn || reentry) {\n    return '';\n  }\n\n  {\n    var frame = componentFrameCache.get(fn);\n\n    if (frame !== undefined) {\n      return frame;\n    }\n  }\n\n  var control;\n  reentry = true;\n  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.\n\n  Error.prepareStackTrace = undefined;\n  var previousDispatcher;\n\n  {\n    previousDispatcher = ReactCurrentDispatcher$1.current; // Set the dispatcher in DEV because this might be call in the render function\n    // for warnings.\n\n    ReactCurrentDispatcher$1.current = null;\n    disableLogs();\n  }\n\n  try {\n    // This should throw.\n    if (construct) {\n      // Something should be setting the props in the constructor.\n      var Fake = function () {\n        throw Error();\n      }; // $FlowFixMe\n\n\n      Object.defineProperty(Fake.prototype, 'props', {\n        set: function () {\n          // We use a throwing setter instead of frozen or non-writable props\n          // because that won't throw in a non-strict mode function.\n          throw Error();\n        }\n      });\n\n      if (typeof Reflect === 'object' && Reflect.construct) {\n        // We construct a different control for this case to include any extra\n        // frames added by the construct call.\n        try {\n          Reflect.construct(Fake, []);\n        } catch (x) {\n          control = x;\n        }\n\n        Reflect.construct(fn, [], Fake);\n      } else {\n        try {\n          Fake.call();\n        } catch (x) {\n          control = x;\n        }\n\n        fn.call(Fake.prototype);\n      }\n    } else {\n      try {\n        throw Error();\n      } catch (x) {\n        control = x;\n      }\n\n      fn();\n    }\n  } catch (sample) {\n    // This is inlined manually because closure doesn't do it for us.\n    if (sample && control && typeof sample.stack === 'string') {\n      // This extracts the first frame from the sample that isn't also in the control.\n      // Skipping one frame that we assume is the frame that calls the two.\n      var sampleLines = sample.stack.split('\\n');\n      var controlLines = control.stack.split('\\n');\n      var s = sampleLines.length - 1;\n      var c = controlLines.length - 1;\n\n      while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n        // We expect at least one stack frame to be shared.\n        // Typically this will be the root most one. However, stack frames may be\n        // cut off due to maximum stack limits. In this case, one maybe cut off\n        // earlier than the other. We assume that the sample is longer or the same\n        // and there for cut off earlier. So we should find the root most frame in\n        // the sample somewhere in the control.\n        c--;\n      }\n\n      for (; s >= 1 && c >= 0; s--, c--) {\n        // Next we find the first one that isn't the same which should be the\n        // frame that called our sample function and the control.\n        if (sampleLines[s] !== controlLines[c]) {\n          // In V8, the first line is describing the message but other VMs don't.\n          // If we're about to return the first line, and the control is also on the same\n          // line, that's a pretty good indicator that our sample threw at same line as\n          // the control. I.e. before we entered the sample frame. So we ignore this result.\n          // This can happen if you passed a class to function component, or non-function.\n          if (s !== 1 || c !== 1) {\n            do {\n              s--;\n              c--; // We may still have similar intermediate frames from the construct call.\n              // The next one that isn't the same should be our match though.\n\n              if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at ');\n\n                {\n                  if (typeof fn === 'function') {\n                    componentFrameCache.set(fn, _frame);\n                  }\n                } // Return the line we found.\n\n\n                return _frame;\n              }\n            } while (s >= 1 && c >= 0);\n          }\n\n          break;\n        }\n      }\n    }\n  } finally {\n    reentry = false;\n\n    {\n      ReactCurrentDispatcher$1.current = previousDispatcher;\n      reenableLogs();\n    }\n\n    Error.prepareStackTrace = previousPrepareStackTrace;\n  } // Fallback to just using the name if we couldn't make it throw.\n\n\n  var name = fn ? fn.displayName || fn.name : '';\n  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n\n  {\n    if (typeof fn === 'function') {\n      componentFrameCache.set(fn, syntheticFrame);\n    }\n  }\n\n  return syntheticFrame;\n}\nfunction describeFunctionComponentFrame(fn, source, ownerFn) {\n  {\n    return describeNativeComponentFrame(fn, false);\n  }\n}\n\nfunction shouldConstruct(Component) {\n  var prototype = Component.prototype;\n  return !!(prototype && prototype.isReactComponent);\n}\n\nfunction describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n\n  if (type == null) {\n    return '';\n  }\n\n  if (typeof type === 'function') {\n    {\n      return describeNativeComponentFrame(type, shouldConstruct(type));\n    }\n  }\n\n  if (typeof type === 'string') {\n    return describeBuiltInComponentFrame(type);\n  }\n\n  switch (type) {\n    case exports.Suspense:\n      return describeBuiltInComponentFrame('Suspense');\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return describeBuiltInComponentFrame('SuspenseList');\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_FORWARD_REF_TYPE:\n        return describeFunctionComponentFrame(type.render);\n\n      case REACT_MEMO_TYPE:\n        // Memo may contain any component type so we recursively resolve it.\n        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n\n      case REACT_BLOCK_TYPE:\n        return describeFunctionComponentFrame(type._render);\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            // Lazy may contain any component type so we recursively resolve it.\n            return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n          } catch (x) {}\n        }\n    }\n  }\n\n  return '';\n}\n\nvar loggedTypeFailures = {};\nvar ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n\nfunction setCurrentlyValidatingElement(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n      ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n    }\n  }\n}\n\nfunction checkPropTypes(typeSpecs, values, location, componentName, element) {\n  {\n    // $FlowFixMe This is okay but Flow doesn't know it.\n    var has = Function.call.bind(Object.prototype.hasOwnProperty);\n\n    for (var typeSpecName in typeSpecs) {\n      if (has(typeSpecs, typeSpecName)) {\n        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n        // fail the render phase where it didn't fail before. So we log it.\n        // After these have been cleaned up, we'll let them throw.\n\n        try {\n          // This is intentionally an invariant that gets caught. It's the same\n          // behavior as without this statement except with a better message.\n          if (typeof typeSpecs[typeSpecName] !== 'function') {\n            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');\n            err.name = 'Invariant Violation';\n            throw err;\n          }\n\n          error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');\n        } catch (ex) {\n          error$1 = ex;\n        }\n\n        if (error$1 && !(error$1 instanceof Error)) {\n          setCurrentlyValidatingElement(element);\n\n          error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);\n\n          setCurrentlyValidatingElement(null);\n        }\n\n        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n          // Only monitor this failure once because there tends to be a lot of the\n          // same error.\n          loggedTypeFailures[error$1.message] = true;\n          setCurrentlyValidatingElement(element);\n\n          error('Failed %s type: %s', location, error$1.message);\n\n          setCurrentlyValidatingElement(null);\n        }\n      }\n    }\n  }\n}\n\nfunction setCurrentlyValidatingElement$1(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n      setExtraStackFrame(stack);\n    } else {\n      setExtraStackFrame(null);\n    }\n  }\n}\n\nvar propTypesMisspellWarningShown;\n\n{\n  propTypesMisspellWarningShown = false;\n}\n\nfunction getDeclarationErrorAddendum() {\n  if (ReactCurrentOwner.current) {\n    var name = getComponentName(ReactCurrentOwner.current.type);\n\n    if (name) {\n      return '\\n\\nCheck the render method of `' + name + '`.';\n    }\n  }\n\n  return '';\n}\n\nfunction getSourceInfoErrorAddendum(source) {\n  if (source !== undefined) {\n    var fileName = source.fileName.replace(/^.*[\\\\\\/]/, '');\n    var lineNumber = source.lineNumber;\n    return '\\n\\nCheck your code at ' + fileName + ':' + lineNumber + '.';\n  }\n\n  return '';\n}\n\nfunction getSourceInfoErrorAddendumForProps(elementProps) {\n  if (elementProps !== null && elementProps !== undefined) {\n    return getSourceInfoErrorAddendum(elementProps.__source);\n  }\n\n  return '';\n}\n/**\n * Warn if there's no key explicitly set on dynamic arrays of children or\n * object keys are not valid. This allows us to keep track of children between\n * updates.\n */\n\n\nvar ownerHasKeyUseWarning = {};\n\nfunction getCurrentComponentErrorInfo(parentType) {\n  var info = getDeclarationErrorAddendum();\n\n  if (!info) {\n    var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;\n\n    if (parentName) {\n      info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n    }\n  }\n\n  return info;\n}\n/**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */\n\n\nfunction validateExplicitKey(element, parentType) {\n  if (!element._store || element._store.validated || element.key != null) {\n    return;\n  }\n\n  element._store.validated = true;\n  var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n\n  if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n    return;\n  }\n\n  ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n  // property, it may be the creator of the child that's responsible for\n  // assigning it a key.\n\n  var childOwner = '';\n\n  if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n    // Give the component that originally created this child.\n    childOwner = \" It was passed a child from \" + getComponentName(element._owner.type) + \".\";\n  }\n\n  {\n    setCurrentlyValidatingElement$1(element);\n\n    error('Each child in a list should have a unique \"key\" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);\n\n    setCurrentlyValidatingElement$1(null);\n  }\n}\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\n\n\nfunction validateChildKeys(node, parentType) {\n  if (typeof node !== 'object') {\n    return;\n  }\n\n  if (Array.isArray(node)) {\n    for (var i = 0; i < node.length; i++) {\n      var child = node[i];\n\n      if (isValidElement(child)) {\n        validateExplicitKey(child, parentType);\n      }\n    }\n  } else if (isValidElement(node)) {\n    // This element was passed in a valid location.\n    if (node._store) {\n      node._store.validated = true;\n    }\n  } else if (node) {\n    var iteratorFn = getIteratorFn(node);\n\n    if (typeof iteratorFn === 'function') {\n      // Entry iterators used to provide implicit keys,\n      // but now we print a separate warning for them later.\n      if (iteratorFn !== node.entries) {\n        var iterator = iteratorFn.call(node);\n        var step;\n\n        while (!(step = iterator.next()).done) {\n          if (isValidElement(step.value)) {\n            validateExplicitKey(step.value, parentType);\n          }\n        }\n      }\n    }\n  }\n}\n/**\n * Given an element, validate that its props follow the propTypes definition,\n * provided by the type.\n *\n * @param {ReactElement} element\n */\n\n\nfunction validatePropTypes(element) {\n  {\n    var type = element.type;\n\n    if (type === null || type === undefined || typeof type === 'string') {\n      return;\n    }\n\n    var propTypes;\n\n    if (typeof type === 'function') {\n      propTypes = type.propTypes;\n    } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.\n    // Inner props are checked in the reconciler.\n    type.$$typeof === REACT_MEMO_TYPE)) {\n      propTypes = type.propTypes;\n    } else {\n      return;\n    }\n\n    if (propTypes) {\n      // Intentionally inside to avoid triggering lazy initializers:\n      var name = getComponentName(type);\n      checkPropTypes(propTypes, element.props, 'prop', name, element);\n    } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n      propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:\n\n      var _name = getComponentName(type);\n\n      error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');\n    }\n\n    if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {\n      error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');\n    }\n  }\n}\n/**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */\n\n\nfunction validateFragmentProps(fragment) {\n  {\n    var keys = Object.keys(fragment.props);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n\n      if (key !== 'children' && key !== 'key') {\n        setCurrentlyValidatingElement$1(fragment);\n\n        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\n\n        setCurrentlyValidatingElement$1(null);\n        break;\n      }\n    }\n\n    if (fragment.ref !== null) {\n      setCurrentlyValidatingElement$1(fragment);\n\n      error('Invalid attribute `ref` supplied to `React.Fragment`.');\n\n      setCurrentlyValidatingElement$1(null);\n    }\n  }\n}\nfunction createElementWithValidation(type, props, children) {\n  var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\n  // succeed and there will likely be errors in render.\n\n  if (!validType) {\n    var info = '';\n\n    if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n      info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n    }\n\n    var sourceInfo = getSourceInfoErrorAddendumForProps(props);\n\n    if (sourceInfo) {\n      info += sourceInfo;\n    } else {\n      info += getDeclarationErrorAddendum();\n    }\n\n    var typeString;\n\n    if (type === null) {\n      typeString = 'null';\n    } else if (Array.isArray(type)) {\n      typeString = 'array';\n    } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n      typeString = \"<\" + (getComponentName(type.type) || 'Unknown') + \" />\";\n      info = ' Did you accidentally export a JSX literal instead of a component?';\n    } else {\n      typeString = typeof type;\n    }\n\n    {\n      error('React.createElement: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n    }\n  }\n\n  var element = createElement.apply(this, arguments); // The result can be nullish if a mock or a custom function is used.\n  // TODO: Drop this when these are no longer allowed as the type argument.\n\n  if (element == null) {\n    return element;\n  } // Skip key warning if the type isn't valid since our key validation logic\n  // doesn't expect a non-string/function type and can throw confusing errors.\n  // We don't want exception behavior to differ between dev and prod.\n  // (Rendering will throw with a helpful message and as soon as the type is\n  // fixed, the key warnings will appear.)\n\n\n  if (validType) {\n    for (var i = 2; i < arguments.length; i++) {\n      validateChildKeys(arguments[i], type);\n    }\n  }\n\n  if (type === exports.Fragment) {\n    validateFragmentProps(element);\n  } else {\n    validatePropTypes(element);\n  }\n\n  return element;\n}\nvar didWarnAboutDeprecatedCreateFactory = false;\nfunction createFactoryWithValidation(type) {\n  var validatedFactory = createElementWithValidation.bind(null, type);\n  validatedFactory.type = type;\n\n  {\n    if (!didWarnAboutDeprecatedCreateFactory) {\n      didWarnAboutDeprecatedCreateFactory = true;\n\n      warn('React.createFactory() is deprecated and will be removed in ' + 'a future major release. Consider using JSX ' + 'or use React.createElement() directly instead.');\n    } // Legacy hook: remove it\n\n\n    Object.defineProperty(validatedFactory, 'type', {\n      enumerable: false,\n      get: function () {\n        warn('Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.');\n\n        Object.defineProperty(this, 'type', {\n          value: type\n        });\n        return type;\n      }\n    });\n  }\n\n  return validatedFactory;\n}\nfunction cloneElementWithValidation(element, props, children) {\n  var newElement = cloneElement.apply(this, arguments);\n\n  for (var i = 2; i < arguments.length; i++) {\n    validateChildKeys(arguments[i], newElement.type);\n  }\n\n  validatePropTypes(newElement);\n  return newElement;\n}\n\n{\n\n  try {\n    var frozenObject = Object.freeze({});\n    /* eslint-disable no-new */\n\n    new Map([[frozenObject, null]]);\n    new Set([frozenObject]);\n    /* eslint-enable no-new */\n  } catch (e) {\n  }\n}\n\nvar createElement$1 =  createElementWithValidation ;\nvar cloneElement$1 =  cloneElementWithValidation ;\nvar createFactory =  createFactoryWithValidation ;\nvar Children = {\n  map: mapChildren,\n  forEach: forEachChildren,\n  count: countChildren,\n  toArray: toArray,\n  only: onlyChild\n};\n\nexports.Children = Children;\nexports.Component = Component;\nexports.PureComponent = PureComponent;\nexports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;\nexports.cloneElement = cloneElement$1;\nexports.createContext = createContext;\nexports.createElement = createElement$1;\nexports.createFactory = createFactory;\nexports.createRef = createRef;\nexports.forwardRef = forwardRef;\nexports.isValidElement = isValidElement;\nexports.lazy = lazy;\nexports.memo = memo;\nexports.useCallback = useCallback;\nexports.useContext = useContext;\nexports.useDebugValue = useDebugValue;\nexports.useEffect = useEffect;\nexports.useImperativeHandle = useImperativeHandle;\nexports.useLayoutEffect = useLayoutEffect;\nexports.useMemo = useMemo;\nexports.useReducer = useReducer;\nexports.useRef = useRef;\nexports.useState = useState;\nexports.version = ReactVersion;\n  })();\n}\n","'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n","import { Stylesheet } from '@fluentui/merge-styles';\nimport { memoizeFunction } from '@fluentui/utilities';\n/**\n * Internal memoized function which simply takes in the class map and the\n * disable boolean. These immutable values can be memoized.\n */\nvar _getGlobalClassNames = memoizeFunction(function (classNames, disableGlobalClassNames) {\n    var styleSheet = Stylesheet.getInstance();\n    if (disableGlobalClassNames) {\n        // disable global classnames\n        return Object.keys(classNames).reduce(function (acc, className) {\n            acc[className] = styleSheet.getClassName(classNames[className]);\n            return acc;\n        }, {});\n    }\n    // use global classnames\n    return classNames;\n});\n/**\n * Checks for the `disableGlobalClassNames` property on the `theme` to determine if it should return `classNames`\n * Note that calls to this function are memoized.\n *\n * @param classNames - The collection of global class names that apply when the flag is false. Make sure to pass in\n * the same instance on each call to benefit from memoization.\n * @param theme - The theme to check the flag on\n * @param disableGlobalClassNames - Optional. Explicitly opt in/out of disabling global classnames. Defaults to false.\n */\nexport function getGlobalClassNames(classNames, theme, disableGlobalClassNames) {\n    return _getGlobalClassNames(classNames, disableGlobalClassNames !== undefined ? disableGlobalClassNames : theme.disableGlobalClassNames);\n}\n//# sourceMappingURL=getGlobalClassNames.js.map","var arrayWithHoles = require(\"./arrayWithHoles.js\");\nvar iterableToArrayLimit = require(\"./iterableToArrayLimit.js\");\nvar unsupportedIterableToArray = require(\"./unsupportedIterableToArray.js\");\nvar nonIterableRest = require(\"./nonIterableRest.js\");\nfunction _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();\n}\nmodule.exports = _slicedToArray, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","// dropcursor/index.ts\nexport * from \"prosemirror-dropcursor\";\n","import getBoundingClientRect from \"./getBoundingClientRect.js\"; // Returns the layout rect of an element relative to its offsetParent. Layout\n// means it doesn't take into account transforms.\n\nexport default function getLayoutRect(element) {\n  var clientRect = getBoundingClientRect(element); // Use the clientRect sizes if it's not been transformed.\n  // Fixes https://github.com/popperjs/popper-core/issues/1223\n\n  var width = element.offsetWidth;\n  var height = element.offsetHeight;\n\n  if (Math.abs(clientRect.width - width) <= 1) {\n    width = clientRect.width;\n  }\n\n  if (Math.abs(clientRect.height - height) <= 1) {\n    height = clientRect.height;\n  }\n\n  return {\n    x: element.offsetLeft,\n    y: element.offsetTop,\n    width: width,\n    height: height\n  };\n}","function velocityPerSecond(velocity, frameDuration) {\n    return frameDuration ? velocity * (1000 / frameDuration) : 0;\n}\n\nexport { velocityPerSecond };\n","import { isPoint } from './is-point.js';\nimport { isPoint3D } from './is-point-3d.js';\nimport { isNum } from './inc.js';\n\nvar distance1D = function (a, b) { return Math.abs(a - b); };\nfunction distance(a, b) {\n    if (isNum(a) && isNum(b)) {\n        return distance1D(a, b);\n    }\n    else if (isPoint(a) && isPoint(b)) {\n        var xDelta = distance1D(a.x, b.x);\n        var yDelta = distance1D(a.y, b.y);\n        var zDelta = isPoint3D(a) && isPoint3D(b) ? distance1D(a.z, b.z) : 0;\n        return Math.sqrt(Math.pow(xDelta, 2) + Math.pow(yDelta, 2) + Math.pow(zDelta, 2));\n    }\n}\n\nexport { distance };\n","import getComputedStyle from \"./getComputedStyle.js\";\nexport default function isScrollParent(element) {\n  // Firefox wants us to check `-x` and `-y` variations as well\n  var _getComputedStyle = getComputedStyle(element),\n      overflow = _getComputedStyle.overflow,\n      overflowX = _getComputedStyle.overflowX,\n      overflowY = _getComputedStyle.overflowY;\n\n  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);\n}","export var DATA_PORTAL_ATTRIBUTE = 'data-portal-element';\n/**\n * Identify element as a portal by setting an attribute.\n * @param element - Element to mark as a portal.\n */\nexport function setPortalAttribute(element) {\n    element.setAttribute(DATA_PORTAL_ATTRIBUTE, 'true');\n}\n//# sourceMappingURL=setPortalAttribute.js.map","// Font face names to be registered.\nexport var LocalizedFontNames;\n(function (LocalizedFontNames) {\n    LocalizedFontNames.Arabic = 'Segoe UI Web (Arabic)';\n    LocalizedFontNames.Cyrillic = 'Segoe UI Web (Cyrillic)';\n    LocalizedFontNames.EastEuropean = 'Segoe UI Web (East European)';\n    LocalizedFontNames.Greek = 'Segoe UI Web (Greek)';\n    LocalizedFontNames.Hebrew = 'Segoe UI Web (Hebrew)';\n    LocalizedFontNames.Thai = 'Leelawadee UI Web';\n    LocalizedFontNames.Vietnamese = 'Segoe UI Web (Vietnamese)';\n    LocalizedFontNames.WestEuropean = 'Segoe UI Web (West European)';\n    LocalizedFontNames.Selawik = 'Selawik Web';\n    LocalizedFontNames.Armenian = 'Segoe UI Web (Armenian)';\n    LocalizedFontNames.Georgian = 'Segoe UI Web (Georgian)';\n})(LocalizedFontNames || (LocalizedFontNames = {}));\n// Font families with fallbacks, for the general regions.\nexport var LocalizedFontFamilies;\n(function (LocalizedFontFamilies) {\n    LocalizedFontFamilies.Arabic = \"'\".concat(LocalizedFontNames.Arabic, \"'\");\n    LocalizedFontFamilies.ChineseSimplified = \"'Microsoft Yahei UI', Verdana, Simsun\";\n    LocalizedFontFamilies.ChineseTraditional = \"'Microsoft Jhenghei UI', Pmingliu\";\n    LocalizedFontFamilies.Cyrillic = \"'\".concat(LocalizedFontNames.Cyrillic, \"'\");\n    LocalizedFontFamilies.EastEuropean = \"'\".concat(LocalizedFontNames.EastEuropean, \"'\");\n    LocalizedFontFamilies.Greek = \"'\".concat(LocalizedFontNames.Greek, \"'\");\n    LocalizedFontFamilies.Hebrew = \"'\".concat(LocalizedFontNames.Hebrew, \"'\");\n    LocalizedFontFamilies.Hindi = \"'Nirmala UI'\";\n    LocalizedFontFamilies.Japanese = \"'Yu Gothic UI', 'Meiryo UI', Meiryo, 'MS Pgothic', Osaka\";\n    LocalizedFontFamilies.Korean = \"'Malgun Gothic', Gulim\";\n    LocalizedFontFamilies.Selawik = \"'\".concat(LocalizedFontNames.Selawik, \"'\");\n    LocalizedFontFamilies.Thai = \"'Leelawadee UI Web', 'Kmer UI'\";\n    LocalizedFontFamilies.Vietnamese = \"'\".concat(LocalizedFontNames.Vietnamese, \"'\");\n    LocalizedFontFamilies.WestEuropean = \"'\".concat(LocalizedFontNames.WestEuropean, \"'\");\n    LocalizedFontFamilies.Armenian = \"'\".concat(LocalizedFontNames.Armenian, \"'\");\n    LocalizedFontFamilies.Georgian = \"'\".concat(LocalizedFontNames.Georgian, \"'\");\n})(LocalizedFontFamilies || (LocalizedFontFamilies = {}));\n// Standard font sizes.\nexport var FontSizes;\n(function (FontSizes) {\n    FontSizes.size10 = '10px';\n    FontSizes.size12 = '12px';\n    FontSizes.size14 = '14px';\n    FontSizes.size16 = '16px';\n    FontSizes.size18 = '18px';\n    FontSizes.size20 = '20px';\n    FontSizes.size24 = '24px';\n    FontSizes.size28 = '28px';\n    FontSizes.size32 = '32px';\n    FontSizes.size42 = '42px';\n    FontSizes.size68 = '68px';\n    FontSizes.mini = '10px';\n    FontSizes.xSmall = '10px';\n    FontSizes.small = '12px';\n    FontSizes.smallPlus = '12px';\n    FontSizes.medium = '14px';\n    FontSizes.mediumPlus = '16px';\n    FontSizes.icon = '16px';\n    FontSizes.large = '18px';\n    FontSizes.xLarge = '20px';\n    FontSizes.xLargePlus = '24px';\n    FontSizes.xxLarge = '28px';\n    FontSizes.xxLargePlus = '32px';\n    FontSizes.superLarge = '42px';\n    FontSizes.mega = '68px';\n})(FontSizes || (FontSizes = {}));\n// Standard font weights.\nexport var FontWeights;\n(function (FontWeights) {\n    FontWeights.light = 100;\n    FontWeights.semilight = 300;\n    FontWeights.regular = 400;\n    FontWeights.semibold = 600;\n    FontWeights.bold = 700;\n})(FontWeights || (FontWeights = {}));\n// Standard Icon Sizes.\nexport var IconFontSizes;\n(function (IconFontSizes) {\n    IconFontSizes.xSmall = '10px';\n    IconFontSizes.small = '12px';\n    IconFontSizes.medium = '16px';\n    IconFontSizes.large = '20px';\n})(IconFontSizes || (IconFontSizes = {}));\n//# sourceMappingURL=FluentFonts.js.map","import React, { useRef, useImperativeHandle, useEffect, useContext, useLayoutEffect, useState, useCallback, useMemo } from 'react';\n\n/**\n * Rounds number to given decimal\n * eg. roundNumber(2.34343, 1) => 2.3\n */\nvar roundNumber = function (num, decimal) {\n    return Number(num.toFixed(decimal));\n};\n/**\n * Checks if value is number, if not it returns default value\n * 1# eg. checkIsNumber(2, 30) => 2\n * 2# eg. checkIsNumber(null, 30) => 30\n */\nvar checkIsNumber = function (num, defaultValue) {\n    return typeof num === \"number\" ? num : defaultValue;\n};\n\nvar handleCallback = function (context, event, callback) {\n    if (callback && typeof callback === \"function\") {\n        callback(context, event);\n    }\n};\n\n/* eslint-disable no-plusplus */\n/* eslint-disable no-param-reassign */\n/**\n * Functions should return denominator of the target value, which is the next animation step.\n * t is a value from 0 to 1, reflecting the percentage of animation status.\n */\nvar easeOut = function (t) {\n    return -Math.cos(t * Math.PI) / 2 + 0.5;\n};\n// linear\nvar linear = function (t) {\n    return t;\n};\n// accelerating from zero velocity\nvar easeInQuad = function (t) {\n    return t * t;\n};\n// decelerating to zero velocity\nvar easeOutQuad = function (t) {\n    return t * (2 - t);\n};\n// acceleration until halfway, then deceleration\nvar easeInOutQuad = function (t) {\n    return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;\n};\n// accelerating from zero velocity\nvar easeInCubic = function (t) {\n    return t * t * t;\n};\n// decelerating to zero velocity\nvar easeOutCubic = function (t) {\n    return --t * t * t + 1;\n};\n// acceleration until halfway, then deceleration\nvar easeInOutCubic = function (t) {\n    return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;\n};\n// accelerating from zero velocity\nvar easeInQuart = function (t) {\n    return t * t * t * t;\n};\n// decelerating to zero velocity\nvar easeOutQuart = function (t) {\n    return 1 - --t * t * t * t;\n};\n// acceleration until halfway, then deceleration\nvar easeInOutQuart = function (t) {\n    return t < 0.5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t;\n};\n// accelerating from zero velocity\nvar easeInQuint = function (t) {\n    return t * t * t * t * t;\n};\n// decelerating to zero velocity\nvar easeOutQuint = function (t) {\n    return 1 + --t * t * t * t * t;\n};\n// acceleration until halfway, then deceleration\nvar easeInOutQuint = function (t) {\n    return t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t;\n};\nvar animations = {\n    easeOut: easeOut,\n    linear: linear,\n    easeInQuad: easeInQuad,\n    easeOutQuad: easeOutQuad,\n    easeInOutQuad: easeInOutQuad,\n    easeInCubic: easeInCubic,\n    easeOutCubic: easeOutCubic,\n    easeInOutCubic: easeInOutCubic,\n    easeInQuart: easeInQuart,\n    easeOutQuart: easeOutQuart,\n    easeInOutQuart: easeInOutQuart,\n    easeInQuint: easeInQuint,\n    easeOutQuint: easeOutQuint,\n    easeInOutQuint: easeInOutQuint,\n};\n\n/* eslint-disable no-param-reassign */\nvar handleCancelAnimationFrame = function (animation) {\n    if (typeof animation === \"number\") {\n        cancelAnimationFrame(animation);\n    }\n};\nvar handleCancelAnimation = function (contextInstance) {\n    if (!contextInstance.mounted)\n        return;\n    handleCancelAnimationFrame(contextInstance.animation);\n    // Clear animation state\n    contextInstance.animate = false;\n    contextInstance.animation = null;\n    contextInstance.velocity = null;\n};\nfunction handleSetupAnimation(contextInstance, animationName, animationTime, callback) {\n    if (!contextInstance.mounted)\n        return;\n    var startTime = new Date().getTime();\n    var lastStep = 1;\n    // if another animation is active\n    handleCancelAnimation(contextInstance);\n    // new animation\n    contextInstance.animation = function () {\n        if (!contextInstance.mounted) {\n            return handleCancelAnimationFrame(contextInstance.animation);\n        }\n        var frameTime = new Date().getTime() - startTime;\n        var animationProgress = frameTime / animationTime;\n        var animationType = animations[animationName];\n        var step = animationType(animationProgress);\n        if (frameTime >= animationTime) {\n            callback(lastStep);\n            contextInstance.animation = null;\n        }\n        else if (contextInstance.animation) {\n            callback(step);\n            requestAnimationFrame(contextInstance.animation);\n        }\n    };\n    requestAnimationFrame(contextInstance.animation);\n}\nfunction isValidTargetState(targetState) {\n    var scale = targetState.scale, positionX = targetState.positionX, positionY = targetState.positionY;\n    if (Number.isNaN(scale) ||\n        Number.isNaN(positionX) ||\n        Number.isNaN(positionY)) {\n        return false;\n    }\n    return true;\n}\nfunction animate(contextInstance, targetState, animationTime, animationName) {\n    var isValid = isValidTargetState(targetState);\n    if (!contextInstance.mounted || !isValid)\n        return;\n    var setTransformState = contextInstance.setTransformState;\n    var _a = contextInstance.transformState, scale = _a.scale, positionX = _a.positionX, positionY = _a.positionY;\n    var scaleDiff = targetState.scale - scale;\n    var positionXDiff = targetState.positionX - positionX;\n    var positionYDiff = targetState.positionY - positionY;\n    if (animationTime === 0) {\n        setTransformState(targetState.scale, targetState.positionX, targetState.positionY);\n    }\n    else {\n        // animation start timestamp\n        handleSetupAnimation(contextInstance, animationName, animationTime, function (step) {\n            var newScale = scale + scaleDiff * step;\n            var newPositionX = positionX + positionXDiff * step;\n            var newPositionY = positionY + positionYDiff * step;\n            setTransformState(newScale, newPositionX, newPositionY);\n        });\n    }\n}\n\n/* eslint-disable no-param-reassign */\nfunction getComponentsSizes(wrapperComponent, contentComponent, newScale) {\n    var wrapperWidth = wrapperComponent.offsetWidth;\n    var wrapperHeight = wrapperComponent.offsetHeight;\n    var contentWidth = contentComponent.offsetWidth;\n    var contentHeight = contentComponent.offsetHeight;\n    var newContentWidth = contentWidth * newScale;\n    var newContentHeight = contentHeight * newScale;\n    var newDiffWidth = wrapperWidth - newContentWidth;\n    var newDiffHeight = wrapperHeight - newContentHeight;\n    return {\n        wrapperWidth: wrapperWidth,\n        wrapperHeight: wrapperHeight,\n        newContentWidth: newContentWidth,\n        newDiffWidth: newDiffWidth,\n        newContentHeight: newContentHeight,\n        newDiffHeight: newDiffHeight,\n    };\n}\nvar getBounds = function (wrapperWidth, newContentWidth, diffWidth, wrapperHeight, newContentHeight, diffHeight, centerZoomedOut) {\n    var scaleWidthFactor = wrapperWidth > newContentWidth\n        ? diffWidth * (centerZoomedOut ? 1 : 0.5)\n        : 0;\n    var scaleHeightFactor = wrapperHeight > newContentHeight\n        ? diffHeight * (centerZoomedOut ? 1 : 0.5)\n        : 0;\n    var minPositionX = wrapperWidth - newContentWidth - scaleWidthFactor;\n    var maxPositionX = scaleWidthFactor;\n    var minPositionY = wrapperHeight - newContentHeight - scaleHeightFactor;\n    var maxPositionY = scaleHeightFactor;\n    return { minPositionX: minPositionX, maxPositionX: maxPositionX, minPositionY: minPositionY, maxPositionY: maxPositionY };\n};\nvar calculateBounds = function (contextInstance, newScale) {\n    var wrapperComponent = contextInstance.wrapperComponent, contentComponent = contextInstance.contentComponent;\n    var centerZoomedOut = contextInstance.setup.centerZoomedOut;\n    if (!wrapperComponent || !contentComponent) {\n        throw new Error(\"Components are not mounted\");\n    }\n    var _a = getComponentsSizes(wrapperComponent, contentComponent, newScale), wrapperWidth = _a.wrapperWidth, wrapperHeight = _a.wrapperHeight, newContentWidth = _a.newContentWidth, newDiffWidth = _a.newDiffWidth, newContentHeight = _a.newContentHeight, newDiffHeight = _a.newDiffHeight;\n    var bounds = getBounds(wrapperWidth, newContentWidth, newDiffWidth, wrapperHeight, newContentHeight, newDiffHeight, Boolean(centerZoomedOut));\n    return bounds;\n};\n/**\n * Keeps value between given bounds, used for limiting view to given boundaries\n * 1# eg. boundLimiter(2, 0, 3, true) => 2\n * 2# eg. boundLimiter(4, 0, 3, true) => 3\n * 3# eg. boundLimiter(-2, 0, 3, true) => 0\n * 4# eg. boundLimiter(10, 0, 3, false) => 10\n */\nvar boundLimiter = function (value, minBound, maxBound, isActive) {\n    if (!isActive)\n        return roundNumber(value, 2);\n    if (value < minBound)\n        return roundNumber(minBound, 2);\n    if (value > maxBound)\n        return roundNumber(maxBound, 2);\n    return roundNumber(value, 2);\n};\nvar handleCalculateBounds = function (contextInstance, newScale) {\n    var bounds = calculateBounds(contextInstance, newScale);\n    // Save bounds\n    contextInstance.bounds = bounds;\n    return bounds;\n};\nfunction getMouseBoundedPosition(positionX, positionY, bounds, limitToBounds, paddingValueX, paddingValueY, wrapperComponent) {\n    var minPositionX = bounds.minPositionX, minPositionY = bounds.minPositionY, maxPositionX = bounds.maxPositionX, maxPositionY = bounds.maxPositionY;\n    var paddingX = 0;\n    var paddingY = 0;\n    if (wrapperComponent) {\n        paddingX = paddingValueX;\n        paddingY = paddingValueY;\n    }\n    var x = boundLimiter(positionX, minPositionX - paddingX, maxPositionX + paddingX, limitToBounds);\n    var y = boundLimiter(positionY, minPositionY - paddingY, maxPositionY + paddingY, limitToBounds);\n    return { x: x, y: y };\n}\n\nfunction handleCalculateZoomPositions(contextInstance, mouseX, mouseY, newScale, bounds, limitToBounds) {\n    var _a = contextInstance.transformState, scale = _a.scale, positionX = _a.positionX, positionY = _a.positionY;\n    var scaleDifference = newScale - scale;\n    if (typeof mouseX !== \"number\" || typeof mouseY !== \"number\") {\n        console.error(\"Mouse X and Y position were not provided!\");\n        return { x: positionX, y: positionY };\n    }\n    var calculatedPositionX = positionX - mouseX * scaleDifference;\n    var calculatedPositionY = positionY - mouseY * scaleDifference;\n    // do not limit to bounds when there is padding animation,\n    // it causes animation strange behaviour\n    var newPositions = getMouseBoundedPosition(calculatedPositionX, calculatedPositionY, bounds, limitToBounds, 0, 0, null);\n    return newPositions;\n}\nfunction checkZoomBounds(zoom, minScale, maxScale, zoomPadding, enablePadding) {\n    var scalePadding = enablePadding ? zoomPadding : 0;\n    var minScaleWithPadding = minScale - scalePadding;\n    if (!Number.isNaN(maxScale) && zoom >= maxScale)\n        return maxScale;\n    if (!Number.isNaN(minScale) && zoom <= minScaleWithPadding)\n        return minScaleWithPadding;\n    return zoom;\n}\n\nvar isPanningStartAllowed = function (contextInstance, event) {\n    var excluded = contextInstance.setup.panning.excluded;\n    var isInitialized = contextInstance.isInitialized, wrapperComponent = contextInstance.wrapperComponent;\n    var target = event.target;\n    var targetIsShadowDom = \"shadowRoot\" in target && \"composedPath\" in event;\n    var isWrapperChild = targetIsShadowDom\n        ? event.composedPath().some(function (el) {\n            if (!(el instanceof Element)) {\n                return false;\n            }\n            return wrapperComponent === null || wrapperComponent === void 0 ? void 0 : wrapperComponent.contains(el);\n        })\n        : wrapperComponent === null || wrapperComponent === void 0 ? void 0 : wrapperComponent.contains(target);\n    var isAllowed = isInitialized && target && isWrapperChild;\n    if (!isAllowed)\n        return false;\n    var isExcluded = isExcludedNode(target, excluded);\n    if (isExcluded)\n        return false;\n    return true;\n};\nvar isPanningAllowed = function (contextInstance) {\n    var isInitialized = contextInstance.isInitialized, isPanning = contextInstance.isPanning, setup = contextInstance.setup;\n    var disabled = setup.panning.disabled;\n    var isAllowed = isInitialized && isPanning && !disabled;\n    if (!isAllowed)\n        return false;\n    return true;\n};\nvar handlePanningSetup = function (contextInstance, event) {\n    var _a = contextInstance.transformState, positionX = _a.positionX, positionY = _a.positionY;\n    contextInstance.isPanning = true;\n    // Panning with mouse\n    var x = event.clientX;\n    var y = event.clientY;\n    contextInstance.startCoords = { x: x - positionX, y: y - positionY };\n};\nvar handleTouchPanningSetup = function (contextInstance, event) {\n    var touches = event.touches;\n    var _a = contextInstance.transformState, positionX = _a.positionX, positionY = _a.positionY;\n    contextInstance.isPanning = true;\n    // Panning with touch\n    var oneFingerTouch = touches.length === 1;\n    if (oneFingerTouch) {\n        var x = touches[0].clientX;\n        var y = touches[0].clientY;\n        contextInstance.startCoords = { x: x - positionX, y: y - positionY };\n    }\n};\nfunction handlePanToBounds(contextInstance) {\n    var _a = contextInstance.transformState, positionX = _a.positionX, positionY = _a.positionY, scale = _a.scale;\n    var _b = contextInstance.setup, disabled = _b.disabled, limitToBounds = _b.limitToBounds, centerZoomedOut = _b.centerZoomedOut;\n    var wrapperComponent = contextInstance.wrapperComponent;\n    if (disabled || !wrapperComponent || !contextInstance.bounds)\n        return;\n    var _c = contextInstance.bounds, maxPositionX = _c.maxPositionX, minPositionX = _c.minPositionX, maxPositionY = _c.maxPositionY, minPositionY = _c.minPositionY;\n    var xChanged = positionX > maxPositionX || positionX < minPositionX;\n    var yChanged = positionY > maxPositionY || positionY < minPositionY;\n    var mousePosX = positionX > maxPositionX\n        ? wrapperComponent.offsetWidth\n        : contextInstance.setup.minPositionX || 0;\n    var mousePosY = positionY > maxPositionY\n        ? wrapperComponent.offsetHeight\n        : contextInstance.setup.minPositionY || 0;\n    var _d = handleCalculateZoomPositions(contextInstance, mousePosX, mousePosY, scale, contextInstance.bounds, limitToBounds || centerZoomedOut), x = _d.x, y = _d.y;\n    return {\n        scale: scale,\n        positionX: xChanged ? x : positionX,\n        positionY: yChanged ? y : positionY,\n    };\n}\nfunction handleNewPosition(contextInstance, newPositionX, newPositionY, paddingValueX, paddingValueY) {\n    var limitToBounds = contextInstance.setup.limitToBounds;\n    var wrapperComponent = contextInstance.wrapperComponent, bounds = contextInstance.bounds;\n    var _a = contextInstance.transformState, scale = _a.scale, positionX = _a.positionX, positionY = _a.positionY;\n    if (wrapperComponent === null ||\n        bounds === null ||\n        (newPositionX === positionX && newPositionY === positionY)) {\n        return;\n    }\n    var _b = getMouseBoundedPosition(newPositionX, newPositionY, bounds, limitToBounds, paddingValueX, paddingValueY, wrapperComponent), x = _b.x, y = _b.y;\n    contextInstance.setTransformState(scale, x, y);\n}\nvar getPanningClientPosition = function (contextInstance, clientX, clientY) {\n    var startCoords = contextInstance.startCoords, transformState = contextInstance.transformState;\n    var panning = contextInstance.setup.panning;\n    var lockAxisX = panning.lockAxisX, lockAxisY = panning.lockAxisY;\n    var positionX = transformState.positionX, positionY = transformState.positionY;\n    if (!startCoords) {\n        return { x: positionX, y: positionY };\n    }\n    var mouseX = clientX - startCoords.x;\n    var mouseY = clientY - startCoords.y;\n    var newPositionX = lockAxisX ? positionX : mouseX;\n    var newPositionY = lockAxisY ? positionY : mouseY;\n    return { x: newPositionX, y: newPositionY };\n};\nvar getPaddingValue = function (contextInstance, size) {\n    var setup = contextInstance.setup, transformState = contextInstance.transformState;\n    var scale = transformState.scale;\n    var minScale = setup.minScale, disablePadding = setup.disablePadding;\n    if (size > 0 && scale >= minScale && !disablePadding) {\n        return size;\n    }\n    return 0;\n};\n\nvar isVelocityCalculationAllowed = function (contextInstance) {\n    var mounted = contextInstance.mounted;\n    var _a = contextInstance.setup, disabled = _a.disabled, velocityAnimation = _a.velocityAnimation;\n    var scale = contextInstance.transformState.scale;\n    var disabledVelocity = velocityAnimation.disabled;\n    var isAllowed = !disabledVelocity || scale > 1 || !disabled || mounted;\n    if (!isAllowed)\n        return false;\n    return true;\n};\nvar isVelocityAllowed = function (contextInstance) {\n    var mounted = contextInstance.mounted, velocity = contextInstance.velocity, bounds = contextInstance.bounds;\n    var _a = contextInstance.setup, disabled = _a.disabled, velocityAnimation = _a.velocityAnimation;\n    var scale = contextInstance.transformState.scale;\n    var disabledVelocity = velocityAnimation.disabled;\n    var isAllowed = !disabledVelocity || scale > 1 || !disabled || mounted;\n    if (!isAllowed)\n        return false;\n    if (!velocity || !bounds)\n        return false;\n    return true;\n};\nfunction getVelocityMoveTime(contextInstance, velocity) {\n    var velocityAnimation = contextInstance.setup.velocityAnimation;\n    var equalToMove = velocityAnimation.equalToMove, animationTime = velocityAnimation.animationTime, sensitivity = velocityAnimation.sensitivity;\n    if (equalToMove) {\n        return animationTime * velocity * sensitivity;\n    }\n    return animationTime;\n}\nfunction getVelocityPosition(newPosition, startPosition, currentPosition, isLocked, limitToBounds, minPosition, maxPosition, minTarget, maxTarget, step) {\n    if (limitToBounds) {\n        if (startPosition > maxPosition && currentPosition > maxPosition) {\n            var calculatedPosition = maxPosition + (newPosition - maxPosition) * step;\n            if (calculatedPosition > maxTarget)\n                return maxTarget;\n            if (calculatedPosition < maxPosition)\n                return maxPosition;\n            return calculatedPosition;\n        }\n        if (startPosition < minPosition && currentPosition < minPosition) {\n            var calculatedPosition = minPosition + (newPosition - minPosition) * step;\n            if (calculatedPosition < minTarget)\n                return minTarget;\n            if (calculatedPosition > minPosition)\n                return minPosition;\n            return calculatedPosition;\n        }\n    }\n    if (isLocked)\n        return startPosition;\n    return boundLimiter(newPosition, minPosition, maxPosition, limitToBounds);\n}\n\nfunction getSizeMultiplier(wrapperComponent, equalToMove) {\n    var defaultMultiplier = 1;\n    if (equalToMove) {\n        return Math.min(defaultMultiplier, wrapperComponent.offsetWidth / window.innerWidth);\n    }\n    return defaultMultiplier;\n}\nfunction handleCalculateVelocity(contextInstance, position) {\n    var isAllowed = isVelocityCalculationAllowed(contextInstance);\n    if (!isAllowed) {\n        return;\n    }\n    var lastMousePosition = contextInstance.lastMousePosition, velocityTime = contextInstance.velocityTime, setup = contextInstance.setup;\n    var wrapperComponent = contextInstance.wrapperComponent;\n    var equalToMove = setup.velocityAnimation.equalToMove;\n    var now = Date.now();\n    if (lastMousePosition && velocityTime && wrapperComponent) {\n        var sizeMultiplier = getSizeMultiplier(wrapperComponent, equalToMove);\n        var distanceX = position.x - lastMousePosition.x;\n        var distanceY = position.y - lastMousePosition.y;\n        var velocityX = distanceX / sizeMultiplier;\n        var velocityY = distanceY / sizeMultiplier;\n        var interval = now - velocityTime;\n        var speed = distanceX * distanceX + distanceY * distanceY;\n        var velocity = Math.sqrt(speed) / interval;\n        contextInstance.velocity = { velocityX: velocityX, velocityY: velocityY, total: velocity };\n    }\n    contextInstance.lastMousePosition = position;\n    contextInstance.velocityTime = now;\n}\nfunction handleVelocityPanning(contextInstance) {\n    var velocity = contextInstance.velocity, bounds = contextInstance.bounds, setup = contextInstance.setup, wrapperComponent = contextInstance.wrapperComponent;\n    var isAllowed = isVelocityAllowed(contextInstance);\n    if (!isAllowed || !velocity || !bounds || !wrapperComponent) {\n        return;\n    }\n    var velocityX = velocity.velocityX, velocityY = velocity.velocityY, total = velocity.total;\n    var maxPositionX = bounds.maxPositionX, minPositionX = bounds.minPositionX, maxPositionY = bounds.maxPositionY, minPositionY = bounds.minPositionY;\n    var limitToBounds = setup.limitToBounds, alignmentAnimation = setup.alignmentAnimation;\n    var zoomAnimation = setup.zoomAnimation, panning = setup.panning;\n    var lockAxisY = panning.lockAxisY, lockAxisX = panning.lockAxisX;\n    var animationType = zoomAnimation.animationType;\n    var sizeX = alignmentAnimation.sizeX, sizeY = alignmentAnimation.sizeY, velocityAlignmentTime = alignmentAnimation.velocityAlignmentTime;\n    var alignAnimationTime = velocityAlignmentTime;\n    var moveAnimationTime = getVelocityMoveTime(contextInstance, total);\n    var finalAnimationTime = Math.max(moveAnimationTime, alignAnimationTime);\n    var paddingValueX = getPaddingValue(contextInstance, sizeX);\n    var paddingValueY = getPaddingValue(contextInstance, sizeY);\n    var paddingX = (paddingValueX * wrapperComponent.offsetWidth) / 100;\n    var paddingY = (paddingValueY * wrapperComponent.offsetHeight) / 100;\n    var maxTargetX = maxPositionX + paddingX;\n    var minTargetX = minPositionX - paddingX;\n    var maxTargetY = maxPositionY + paddingY;\n    var minTargetY = minPositionY - paddingY;\n    var startState = contextInstance.transformState;\n    var startTime = new Date().getTime();\n    handleSetupAnimation(contextInstance, animationType, finalAnimationTime, function (step) {\n        var _a = contextInstance.transformState, scale = _a.scale, positionX = _a.positionX, positionY = _a.positionY;\n        var frameTime = new Date().getTime() - startTime;\n        var animationProgress = frameTime / alignAnimationTime;\n        var alignAnimation = animations[alignmentAnimation.animationType];\n        var alignStep = 1 - alignAnimation(Math.min(1, animationProgress));\n        var customStep = 1 - step;\n        var newPositionX = positionX + velocityX * customStep;\n        var newPositionY = positionY + velocityY * customStep;\n        var currentPositionX = getVelocityPosition(newPositionX, startState.positionX, positionX, lockAxisX, limitToBounds, minPositionX, maxPositionX, minTargetX, maxTargetX, alignStep);\n        var currentPositionY = getVelocityPosition(newPositionY, startState.positionY, positionY, lockAxisY, limitToBounds, minPositionY, maxPositionY, minTargetY, maxTargetY, alignStep);\n        if (positionX !== newPositionX || positionY !== newPositionY) {\n            contextInstance.setTransformState(scale, currentPositionX, currentPositionY);\n        }\n    });\n}\n\nfunction handlePanningStart(contextInstance, event) {\n    var scale = contextInstance.transformState.scale;\n    handleCancelAnimation(contextInstance);\n    handleCalculateBounds(contextInstance, scale);\n    if (window.TouchEvent !== undefined && event instanceof TouchEvent) {\n        handleTouchPanningSetup(contextInstance, event);\n    }\n    else {\n        handlePanningSetup(contextInstance, event);\n    }\n}\nfunction handleAlignToBounds(contextInstance) {\n    var scale = contextInstance.transformState.scale;\n    var _a = contextInstance.setup, minScale = _a.minScale, alignmentAnimation = _a.alignmentAnimation;\n    var disabled = alignmentAnimation.disabled, sizeX = alignmentAnimation.sizeX, sizeY = alignmentAnimation.sizeY, animationTime = alignmentAnimation.animationTime, animationType = alignmentAnimation.animationType;\n    var isDisabled = disabled || scale < minScale || (!sizeX && !sizeY);\n    if (isDisabled)\n        return;\n    var targetState = handlePanToBounds(contextInstance);\n    if (targetState) {\n        animate(contextInstance, targetState, animationTime, animationType);\n    }\n}\nfunction handlePanning(contextInstance, clientX, clientY) {\n    var startCoords = contextInstance.startCoords, setup = contextInstance.setup;\n    var _a = setup.alignmentAnimation, sizeX = _a.sizeX, sizeY = _a.sizeY;\n    if (!startCoords)\n        return;\n    var _b = getPanningClientPosition(contextInstance, clientX, clientY), x = _b.x, y = _b.y;\n    var paddingValueX = getPaddingValue(contextInstance, sizeX);\n    var paddingValueY = getPaddingValue(contextInstance, sizeY);\n    handleCalculateVelocity(contextInstance, { x: x, y: y });\n    handleNewPosition(contextInstance, x, y, paddingValueX, paddingValueY);\n}\nfunction handlePanningEnd(contextInstance) {\n    if (contextInstance.isPanning) {\n        var velocityDisabled = contextInstance.setup.panning.velocityDisabled;\n        var velocity = contextInstance.velocity, wrapperComponent = contextInstance.wrapperComponent, contentComponent = contextInstance.contentComponent;\n        contextInstance.isPanning = false;\n        contextInstance.animate = false;\n        contextInstance.animation = null;\n        var wrapperRect = wrapperComponent === null || wrapperComponent === void 0 ? void 0 : wrapperComponent.getBoundingClientRect();\n        var contentRect = contentComponent === null || contentComponent === void 0 ? void 0 : contentComponent.getBoundingClientRect();\n        var wrapperWidth = (wrapperRect === null || wrapperRect === void 0 ? void 0 : wrapperRect.width) || 0;\n        var wrapperHeight = (wrapperRect === null || wrapperRect === void 0 ? void 0 : wrapperRect.height) || 0;\n        var contentWidth = (contentRect === null || contentRect === void 0 ? void 0 : contentRect.width) || 0;\n        var contentHeight = (contentRect === null || contentRect === void 0 ? void 0 : contentRect.height) || 0;\n        var isZoomed = wrapperWidth < contentWidth || wrapperHeight < contentHeight;\n        var shouldAnimate = !velocityDisabled && velocity && (velocity === null || velocity === void 0 ? void 0 : velocity.total) > 0.1 && isZoomed;\n        if (shouldAnimate) {\n            handleVelocityPanning(contextInstance);\n        }\n        else {\n            handleAlignToBounds(contextInstance);\n        }\n    }\n}\n\nfunction handleZoomToPoint(contextInstance, scale, mouseX, mouseY) {\n    var _a = contextInstance.setup, minScale = _a.minScale, maxScale = _a.maxScale, limitToBounds = _a.limitToBounds;\n    var newScale = checkZoomBounds(roundNumber(scale, 2), minScale, maxScale, 0, false);\n    var bounds = handleCalculateBounds(contextInstance, newScale);\n    var _b = handleCalculateZoomPositions(contextInstance, mouseX, mouseY, newScale, bounds, limitToBounds), x = _b.x, y = _b.y;\n    return { scale: newScale, positionX: x, positionY: y };\n}\nfunction handleAlignToScaleBounds(contextInstance, mousePositionX, mousePositionY) {\n    var scale = contextInstance.transformState.scale;\n    var wrapperComponent = contextInstance.wrapperComponent;\n    var _a = contextInstance.setup, minScale = _a.minScale, limitToBounds = _a.limitToBounds, zoomAnimation = _a.zoomAnimation;\n    var disabled = zoomAnimation.disabled, animationTime = zoomAnimation.animationTime, animationType = zoomAnimation.animationType;\n    var isDisabled = disabled || scale >= minScale;\n    if (scale >= 1 || limitToBounds) {\n        // fire fit to bounds animation\n        handleAlignToBounds(contextInstance);\n    }\n    if (isDisabled || !wrapperComponent || !contextInstance.mounted)\n        return;\n    var mouseX = mousePositionX || wrapperComponent.offsetWidth / 2;\n    var mouseY = mousePositionY || wrapperComponent.offsetHeight / 2;\n    var targetState = handleZoomToPoint(contextInstance, minScale, mouseX, mouseY);\n    if (targetState) {\n        animate(contextInstance, targetState, animationTime, animationType);\n    }\n}\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nfunction __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\n\nvar initialState = {\n    previousScale: 1,\n    scale: 1,\n    positionX: 0,\n    positionY: 0,\n};\nvar initialSetup = {\n    disabled: false,\n    minPositionX: null,\n    maxPositionX: null,\n    minPositionY: null,\n    maxPositionY: null,\n    minScale: 1,\n    maxScale: 8,\n    limitToBounds: true,\n    centerZoomedOut: false,\n    centerOnInit: false,\n    disablePadding: false,\n    smooth: true,\n    wheel: {\n        step: 0.2,\n        disabled: false,\n        smoothStep: 0.001,\n        wheelDisabled: false,\n        touchPadDisabled: false,\n        activationKeys: [],\n        excluded: [],\n    },\n    panning: {\n        disabled: false,\n        velocityDisabled: false,\n        lockAxisX: false,\n        lockAxisY: false,\n        allowLeftClickPan: true,\n        allowMiddleClickPan: true,\n        allowRightClickPan: true,\n        wheelPanning: false,\n        activationKeys: [],\n        excluded: [],\n    },\n    pinch: {\n        step: 5,\n        disabled: false,\n        excluded: [],\n    },\n    doubleClick: {\n        disabled: false,\n        step: 0.7,\n        mode: \"zoomIn\",\n        animationType: \"easeOut\",\n        animationTime: 200,\n        excluded: [],\n    },\n    zoomAnimation: {\n        disabled: false,\n        size: 0.4,\n        animationTime: 200,\n        animationType: \"easeOut\",\n    },\n    alignmentAnimation: {\n        disabled: false,\n        sizeX: 100,\n        sizeY: 100,\n        animationTime: 200,\n        velocityAlignmentTime: 400,\n        animationType: \"easeOut\",\n    },\n    velocityAnimation: {\n        disabled: false,\n        sensitivity: 1,\n        animationTime: 400,\n        animationType: \"easeOut\",\n        equalToMove: true,\n    },\n};\n\nvar createState = function (props) {\n    var _a, _b, _c, _d;\n    return {\n        previousScale: (_a = props.initialScale) !== null && _a !== void 0 ? _a : initialState.scale,\n        scale: (_b = props.initialScale) !== null && _b !== void 0 ? _b : initialState.scale,\n        positionX: (_c = props.initialPositionX) !== null && _c !== void 0 ? _c : initialState.positionX,\n        positionY: (_d = props.initialPositionY) !== null && _d !== void 0 ? _d : initialState.positionY,\n    };\n};\nvar createSetup = function (props) {\n    var newSetup = __assign({}, initialSetup);\n    Object.keys(props).forEach(function (key) {\n        var validValue = typeof props[key] !== \"undefined\";\n        var validParameter = typeof initialSetup[key] !== \"undefined\";\n        if (validParameter && validValue) {\n            var dataType = Object.prototype.toString.call(initialSetup[key]);\n            var isObject = dataType === \"[object Object]\";\n            var isArray = dataType === \"[object Array]\";\n            if (isObject) {\n                newSetup[key] = __assign(__assign({}, initialSetup[key]), props[key]);\n            }\n            else if (isArray) {\n                newSetup[key] = __spreadArray(__spreadArray([], initialSetup[key], true), props[key], true);\n            }\n            else {\n                newSetup[key] = props[key];\n            }\n        }\n    });\n    return newSetup;\n};\n\nvar handleCalculateButtonZoom = function (contextInstance, delta, step) {\n    var scale = contextInstance.transformState.scale;\n    var wrapperComponent = contextInstance.wrapperComponent, setup = contextInstance.setup;\n    var maxScale = setup.maxScale, minScale = setup.minScale, zoomAnimation = setup.zoomAnimation, smooth = setup.smooth;\n    var size = zoomAnimation.size;\n    if (!wrapperComponent) {\n        throw new Error(\"Wrapper is not mounted\");\n    }\n    var targetScale = smooth\n        ? scale * Math.exp(delta * step)\n        : scale + delta * step;\n    var newScale = checkZoomBounds(roundNumber(targetScale, 3), minScale, maxScale, size, false);\n    return newScale;\n};\nfunction handleZoomToViewCenter(contextInstance, delta, step, animationTime, animationType) {\n    var wrapperComponent = contextInstance.wrapperComponent;\n    var _a = contextInstance.transformState, scale = _a.scale, positionX = _a.positionX, positionY = _a.positionY;\n    if (!wrapperComponent)\n        return console.error(\"No WrapperComponent found\");\n    var wrapperWidth = wrapperComponent.offsetWidth;\n    var wrapperHeight = wrapperComponent.offsetHeight;\n    var mouseX = (wrapperWidth / 2 - positionX) / scale;\n    var mouseY = (wrapperHeight / 2 - positionY) / scale;\n    var newScale = handleCalculateButtonZoom(contextInstance, delta, step);\n    var targetState = handleZoomToPoint(contextInstance, newScale, mouseX, mouseY);\n    if (!targetState) {\n        return console.error(\"Error during zoom event. New transformation state was not calculated.\");\n    }\n    animate(contextInstance, targetState, animationTime, animationType);\n}\nfunction resetTransformations(contextInstance, animationTime, animationType, onResetTransformation) {\n    var setup = contextInstance.setup, wrapperComponent = contextInstance.wrapperComponent;\n    var limitToBounds = setup.limitToBounds;\n    var initialTransformation = createState(contextInstance.props);\n    var _a = contextInstance.transformState, scale = _a.scale, positionX = _a.positionX, positionY = _a.positionY;\n    if (!wrapperComponent)\n        return;\n    var newBounds = calculateBounds(contextInstance, initialTransformation.scale);\n    var boundedPositions = getMouseBoundedPosition(initialTransformation.positionX, initialTransformation.positionY, newBounds, limitToBounds, 0, 0, wrapperComponent);\n    var newState = {\n        scale: initialTransformation.scale,\n        positionX: boundedPositions.x,\n        positionY: boundedPositions.y,\n    };\n    if (scale === initialTransformation.scale &&\n        positionX === initialTransformation.positionX &&\n        positionY === initialTransformation.positionY) {\n        return;\n    }\n    onResetTransformation === null || onResetTransformation === void 0 ? void 0 : onResetTransformation();\n    animate(contextInstance, newState, animationTime, animationType);\n}\nfunction getOffset(element, wrapper, content, state) {\n    var offset = element.getBoundingClientRect();\n    var wrapperOffset = wrapper.getBoundingClientRect();\n    var contentOffset = content.getBoundingClientRect();\n    var xOff = wrapperOffset.x * state.scale;\n    var yOff = wrapperOffset.y * state.scale;\n    return {\n        x: (offset.x - contentOffset.x + xOff) / state.scale,\n        y: (offset.y - contentOffset.y + yOff) / state.scale,\n    };\n}\nfunction calculateZoomToNode(contextInstance, node, customZoom) {\n    var wrapperComponent = contextInstance.wrapperComponent, contentComponent = contextInstance.contentComponent, transformState = contextInstance.transformState;\n    var _a = contextInstance.setup, limitToBounds = _a.limitToBounds, minScale = _a.minScale, maxScale = _a.maxScale;\n    if (!wrapperComponent || !contentComponent)\n        return transformState;\n    var wrapperRect = wrapperComponent.getBoundingClientRect();\n    var nodeRect = node.getBoundingClientRect();\n    var nodeOffset = getOffset(node, wrapperComponent, contentComponent, transformState);\n    var nodeLeft = nodeOffset.x;\n    var nodeTop = nodeOffset.y;\n    var nodeWidth = nodeRect.width / transformState.scale;\n    var nodeHeight = nodeRect.height / transformState.scale;\n    var scaleX = wrapperComponent.offsetWidth / nodeWidth;\n    var scaleY = wrapperComponent.offsetHeight / nodeHeight;\n    var newScale = checkZoomBounds(customZoom || Math.min(scaleX, scaleY), minScale, maxScale, 0, false);\n    var offsetX = (wrapperRect.width - nodeWidth * newScale) / 2;\n    var offsetY = (wrapperRect.height - nodeHeight * newScale) / 2;\n    var newPositionX = (wrapperRect.left - nodeLeft) * newScale + offsetX;\n    var newPositionY = (wrapperRect.top - nodeTop) * newScale + offsetY;\n    var bounds = calculateBounds(contextInstance, newScale);\n    var _b = getMouseBoundedPosition(newPositionX, newPositionY, bounds, limitToBounds, 0, 0, wrapperComponent), x = _b.x, y = _b.y;\n    return { positionX: x, positionY: y, scale: newScale };\n}\n\nvar zoomIn = function (contextInstance) {\n    return function (step, animationTime, animationType) {\n        if (step === void 0) { step = 0.5; }\n        if (animationTime === void 0) { animationTime = 300; }\n        if (animationType === void 0) { animationType = \"easeOut\"; }\n        handleZoomToViewCenter(contextInstance, 1, step, animationTime, animationType);\n    };\n};\nvar zoomOut = function (contextInstance) {\n    return function (step, animationTime, animationType) {\n        if (step === void 0) { step = 0.5; }\n        if (animationTime === void 0) { animationTime = 300; }\n        if (animationType === void 0) { animationType = \"easeOut\"; }\n        handleZoomToViewCenter(contextInstance, -1, step, animationTime, animationType);\n    };\n};\nvar setTransform = function (contextInstance) {\n    return function (newPositionX, newPositionY, newScale, animationTime, animationType) {\n        if (animationTime === void 0) { animationTime = 300; }\n        if (animationType === void 0) { animationType = \"easeOut\"; }\n        var _a = contextInstance.transformState, positionX = _a.positionX, positionY = _a.positionY, scale = _a.scale;\n        var wrapperComponent = contextInstance.wrapperComponent, contentComponent = contextInstance.contentComponent;\n        var disabled = contextInstance.setup.disabled;\n        if (disabled || !wrapperComponent || !contentComponent)\n            return;\n        var targetState = {\n            positionX: Number.isNaN(newPositionX) ? positionX : newPositionX,\n            positionY: Number.isNaN(newPositionY) ? positionY : newPositionY,\n            scale: Number.isNaN(newScale) ? scale : newScale,\n        };\n        animate(contextInstance, targetState, animationTime, animationType);\n    };\n};\nvar resetTransform = function (contextInstance) {\n    return function (animationTime, animationType) {\n        if (animationTime === void 0) { animationTime = 200; }\n        if (animationType === void 0) { animationType = \"easeOut\"; }\n        resetTransformations(contextInstance, animationTime, animationType);\n    };\n};\nvar centerView = function (contextInstance) {\n    return function (scale, animationTime, animationType) {\n        if (animationTime === void 0) { animationTime = 200; }\n        if (animationType === void 0) { animationType = \"easeOut\"; }\n        var transformState = contextInstance.transformState, wrapperComponent = contextInstance.wrapperComponent, contentComponent = contextInstance.contentComponent;\n        if (wrapperComponent && contentComponent) {\n            var targetState = getCenterPosition(scale || transformState.scale, wrapperComponent, contentComponent);\n            animate(contextInstance, targetState, animationTime, animationType);\n        }\n    };\n};\nvar zoomToElement = function (contextInstance) {\n    return function (node, scale, animationTime, animationType) {\n        if (animationTime === void 0) { animationTime = 600; }\n        if (animationType === void 0) { animationType = \"easeOut\"; }\n        handleCancelAnimation(contextInstance);\n        var wrapperComponent = contextInstance.wrapperComponent;\n        var target = typeof node === \"string\" ? document.getElementById(node) : node;\n        if (wrapperComponent && target && wrapperComponent.contains(target)) {\n            var targetState = calculateZoomToNode(contextInstance, target, scale);\n            animate(contextInstance, targetState, animationTime, animationType);\n        }\n    };\n};\n\nvar getControls = function (contextInstance) {\n    return {\n        instance: contextInstance,\n        zoomIn: zoomIn(contextInstance),\n        zoomOut: zoomOut(contextInstance),\n        setTransform: setTransform(contextInstance),\n        resetTransform: resetTransform(contextInstance),\n        centerView: centerView(contextInstance),\n        zoomToElement: zoomToElement(contextInstance),\n    };\n};\nvar getState = function (contextInstance) {\n    return {\n        instance: contextInstance,\n        state: contextInstance.transformState,\n    };\n};\nvar getContext = function (contextInstance) {\n    var ref = {};\n    Object.assign(ref, getState(contextInstance));\n    Object.assign(ref, getControls(contextInstance));\n    return ref;\n};\n\n// We want to make event listeners non-passive, and to do so have to check\n// that browsers support EventListenerOptions in the first place.\n// https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener#Safely_detecting_option_support\nvar passiveSupported = false;\nfunction makePassiveEventOption() {\n    try {\n        var options = {\n            get passive() {\n                // This function will be called when the browser\n                //   attempts to access the passive property.\n                passiveSupported = true;\n                return false;\n            },\n        };\n        return options;\n    }\n    catch (err) {\n        passiveSupported = false;\n        return passiveSupported;\n    }\n}\n\nvar isExcludedNode = function (node, excluded) {\n    return excluded.some(function (exclude) {\n        return node.matches(\"\".concat(exclude, \", .\").concat(exclude, \", \").concat(exclude, \" *, .\").concat(exclude, \" *\"));\n    });\n};\nvar cancelTimeout = function (timeout) {\n    if (timeout) {\n        clearTimeout(timeout);\n    }\n};\n\nvar getTransformStyles = function (x, y, scale) {\n    // Standard translate prevents blurry svg on the safari\n    return \"translate(\".concat(x, \"px, \").concat(y, \"px) scale(\").concat(scale, \")\");\n};\nvar getMatrixTransformStyles = function (x, y, scale) {\n    // The shorthand for matrix does not work for Safari hence the need to explicitly use matrix3d\n    // Refer to https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/matrix\n    var a = scale;\n    var b = 0;\n    var c = 0;\n    var d = scale;\n    var tx = x;\n    var ty = y;\n    return \"matrix3d(\".concat(a, \", \").concat(b, \", 0, 0, \").concat(c, \", \").concat(d, \", 0, 0, 0, 0, 1, 0, \").concat(tx, \", \").concat(ty, \", 0, 1)\");\n};\nvar getCenterPosition = function (scale, wrapperComponent, contentComponent) {\n    var contentWidth = contentComponent.offsetWidth * scale;\n    var contentHeight = contentComponent.offsetHeight * scale;\n    var centerPositionX = (wrapperComponent.offsetWidth - contentWidth) / 2;\n    var centerPositionY = (wrapperComponent.offsetHeight - contentHeight) / 2;\n    return {\n        scale: scale,\n        positionX: centerPositionX,\n        positionY: centerPositionY,\n    };\n};\n\nfunction mergeRefs(refs) {\n    return function (value) {\n        refs.forEach(function (ref) {\n            if (typeof ref === \"function\") {\n                ref(value);\n            }\n            else if (ref != null) {\n                ref.current = value;\n            }\n        });\n    };\n}\n\nvar isWheelAllowed = function (contextInstance, event) {\n    var _a = contextInstance.setup.wheel, disabled = _a.disabled, wheelDisabled = _a.wheelDisabled, touchPadDisabled = _a.touchPadDisabled, excluded = _a.excluded;\n    var isInitialized = contextInstance.isInitialized, isPanning = contextInstance.isPanning;\n    var target = event.target;\n    var isAllowed = isInitialized && !isPanning && !disabled && target;\n    if (!isAllowed)\n        return false;\n    // Event ctrlKey detects if touchpad action is executing wheel or pinch gesture\n    if (wheelDisabled && !event.ctrlKey)\n        return false;\n    if (touchPadDisabled && event.ctrlKey)\n        return false;\n    var isExcluded = isExcludedNode(target, excluded);\n    if (isExcluded)\n        return false;\n    return true;\n};\nvar getDeltaY = function (event) {\n    if (event) {\n        return event.deltaY < 0 ? 1 : -1;\n    }\n    return 0;\n};\nfunction getDelta(event, customDelta) {\n    var deltaY = getDeltaY(event);\n    var delta = checkIsNumber(customDelta, deltaY);\n    return delta;\n}\nfunction getMousePosition(event, contentComponent, scale) {\n    var contentRect = contentComponent.getBoundingClientRect();\n    var mouseX = 0;\n    var mouseY = 0;\n    if (\"clientX\" in event) {\n        // mouse position x, y over wrapper component\n        mouseX = (event.clientX - contentRect.left) / scale;\n        mouseY = (event.clientY - contentRect.top) / scale;\n    }\n    else {\n        var touch = event.touches[0];\n        mouseX = (touch.clientX - contentRect.left) / scale;\n        mouseY = (touch.clientY - contentRect.top) / scale;\n    }\n    if (Number.isNaN(mouseX) || Number.isNaN(mouseY))\n        console.error(\"No mouse or touch offset found\");\n    return {\n        x: mouseX,\n        y: mouseY,\n    };\n}\nvar handleCalculateWheelZoom = function (contextInstance, delta, step, disable, getTarget) {\n    var scale = contextInstance.transformState.scale;\n    var wrapperComponent = contextInstance.wrapperComponent, setup = contextInstance.setup;\n    var maxScale = setup.maxScale, minScale = setup.minScale, zoomAnimation = setup.zoomAnimation, disablePadding = setup.disablePadding;\n    var size = zoomAnimation.size, disabled = zoomAnimation.disabled;\n    if (!wrapperComponent) {\n        throw new Error(\"Wrapper is not mounted\");\n    }\n    var targetScale = scale + delta * step;\n    if (getTarget)\n        return targetScale;\n    var paddingEnabled = disable ? false : !disabled;\n    var newScale = checkZoomBounds(roundNumber(targetScale, 3), minScale, maxScale, size, paddingEnabled && !disablePadding);\n    return newScale;\n};\nvar handleWheelZoomStop = function (contextInstance, event) {\n    var previousWheelEvent = contextInstance.previousWheelEvent;\n    var scale = contextInstance.transformState.scale;\n    var _a = contextInstance.setup, maxScale = _a.maxScale, minScale = _a.minScale;\n    if (!previousWheelEvent)\n        return false;\n    if (scale < maxScale || scale > minScale)\n        return true;\n    if (Math.sign(previousWheelEvent.deltaY) !== Math.sign(event.deltaY))\n        return true;\n    if (previousWheelEvent.deltaY > 0 && previousWheelEvent.deltaY < event.deltaY)\n        return true;\n    if (previousWheelEvent.deltaY < 0 && previousWheelEvent.deltaY > event.deltaY)\n        return true;\n    if (Math.sign(previousWheelEvent.deltaY) !== Math.sign(event.deltaY))\n        return true;\n    return false;\n};\n\nvar isPinchStartAllowed = function (contextInstance, event) {\n    var _a = contextInstance.setup.pinch, disabled = _a.disabled, excluded = _a.excluded;\n    var isInitialized = contextInstance.isInitialized;\n    var target = event.target;\n    var isAllowed = isInitialized && !disabled && target;\n    if (!isAllowed)\n        return false;\n    var isExcluded = isExcludedNode(target, excluded);\n    if (isExcluded)\n        return false;\n    return true;\n};\nvar isPinchAllowed = function (contextInstance) {\n    var disabled = contextInstance.setup.pinch.disabled;\n    var isInitialized = contextInstance.isInitialized, pinchStartDistance = contextInstance.pinchStartDistance;\n    var isAllowed = isInitialized && !disabled && pinchStartDistance;\n    if (!isAllowed)\n        return false;\n    return true;\n};\nvar calculateTouchMidPoint = function (event, scale, contentComponent) {\n    var contentRect = contentComponent.getBoundingClientRect();\n    var touches = event.touches;\n    var firstPointX = roundNumber(touches[0].clientX - contentRect.left, 5);\n    var firstPointY = roundNumber(touches[0].clientY - contentRect.top, 5);\n    var secondPointX = roundNumber(touches[1].clientX - contentRect.left, 5);\n    var secondPointY = roundNumber(touches[1].clientY - contentRect.top, 5);\n    return {\n        x: (firstPointX + secondPointX) / 2 / scale,\n        y: (firstPointY + secondPointY) / 2 / scale,\n    };\n};\nvar getTouchDistance = function (event) {\n    return Math.sqrt(Math.pow((event.touches[0].pageX - event.touches[1].pageX), 2) +\n        Math.pow((event.touches[0].pageY - event.touches[1].pageY), 2));\n};\nvar calculatePinchZoom = function (contextInstance, currentDistance) {\n    var pinchStartScale = contextInstance.pinchStartScale, pinchStartDistance = contextInstance.pinchStartDistance, setup = contextInstance.setup;\n    var maxScale = setup.maxScale, minScale = setup.minScale, zoomAnimation = setup.zoomAnimation, disablePadding = setup.disablePadding;\n    var size = zoomAnimation.size, disabled = zoomAnimation.disabled;\n    if (!pinchStartScale || pinchStartDistance === null || !currentDistance) {\n        throw new Error(\"Pinch touches distance was not provided\");\n    }\n    if (currentDistance < 0) {\n        return contextInstance.transformState.scale;\n    }\n    var touchProportion = currentDistance / pinchStartDistance;\n    var scaleDifference = touchProportion * pinchStartScale;\n    return checkZoomBounds(roundNumber(scaleDifference, 2), minScale, maxScale, size, !disabled && !disablePadding);\n};\n\nvar wheelStopEventTime = 160;\nvar wheelAnimationTime = 100;\nvar handleWheelStart = function (contextInstance, event) {\n    var _a = contextInstance.props, onWheelStart = _a.onWheelStart, onZoomStart = _a.onZoomStart;\n    if (!contextInstance.wheelStopEventTimer) {\n        handleCancelAnimation(contextInstance);\n        handleCallback(getContext(contextInstance), event, onWheelStart);\n        handleCallback(getContext(contextInstance), event, onZoomStart);\n    }\n};\nvar handleWheelZoom = function (contextInstance, event) {\n    var _a = contextInstance.props, onWheel = _a.onWheel, onZoom = _a.onZoom;\n    var contentComponent = contextInstance.contentComponent, setup = contextInstance.setup, transformState = contextInstance.transformState;\n    var scale = transformState.scale;\n    var limitToBounds = setup.limitToBounds, centerZoomedOut = setup.centerZoomedOut, zoomAnimation = setup.zoomAnimation, wheel = setup.wheel, disablePadding = setup.disablePadding, smooth = setup.smooth;\n    var size = zoomAnimation.size, disabled = zoomAnimation.disabled;\n    var step = wheel.step, smoothStep = wheel.smoothStep;\n    if (!contentComponent) {\n        throw new Error(\"Component not mounted\");\n    }\n    event.preventDefault();\n    event.stopPropagation();\n    var delta = getDelta(event, null);\n    var zoomStep = smooth ? smoothStep * Math.abs(event.deltaY) : step;\n    var newScale = handleCalculateWheelZoom(contextInstance, delta, zoomStep, !event.ctrlKey);\n    // if scale not change\n    if (scale === newScale)\n        return;\n    var bounds = handleCalculateBounds(contextInstance, newScale);\n    var mousePosition = getMousePosition(event, contentComponent, scale);\n    var isPaddingDisabled = disabled || size === 0 || centerZoomedOut || disablePadding;\n    var isLimitedToBounds = limitToBounds && isPaddingDisabled;\n    var _b = handleCalculateZoomPositions(contextInstance, mousePosition.x, mousePosition.y, newScale, bounds, isLimitedToBounds), x = _b.x, y = _b.y;\n    contextInstance.previousWheelEvent = event;\n    contextInstance.setTransformState(newScale, x, y);\n    handleCallback(getContext(contextInstance), event, onWheel);\n    handleCallback(getContext(contextInstance), event, onZoom);\n};\nvar handleWheelStop = function (contextInstance, event) {\n    var _a = contextInstance.props, onWheelStop = _a.onWheelStop, onZoomStop = _a.onZoomStop;\n    // fire animation\n    cancelTimeout(contextInstance.wheelAnimationTimer);\n    contextInstance.wheelAnimationTimer = setTimeout(function () {\n        if (!contextInstance.mounted)\n            return;\n        handleAlignToScaleBounds(contextInstance, event.x, event.y);\n        contextInstance.wheelAnimationTimer = null;\n    }, wheelAnimationTime);\n    // Wheel stop event\n    var hasStoppedZooming = handleWheelZoomStop(contextInstance, event);\n    if (hasStoppedZooming) {\n        cancelTimeout(contextInstance.wheelStopEventTimer);\n        contextInstance.wheelStopEventTimer = setTimeout(function () {\n            if (!contextInstance.mounted)\n                return;\n            contextInstance.wheelStopEventTimer = null;\n            handleCallback(getContext(contextInstance), event, onWheelStop);\n            handleCallback(getContext(contextInstance), event, onZoomStop);\n        }, wheelStopEventTime);\n    }\n};\n\nvar handlePinchStart = function (contextInstance, event) {\n    var distance = getTouchDistance(event);\n    contextInstance.pinchStartDistance = distance;\n    contextInstance.lastDistance = distance;\n    contextInstance.pinchStartScale = contextInstance.transformState.scale;\n    contextInstance.isPanning = false;\n    handleCancelAnimation(contextInstance);\n};\nvar handlePinchZoom = function (contextInstance, event) {\n    var contentComponent = contextInstance.contentComponent, pinchStartDistance = contextInstance.pinchStartDistance;\n    var scale = contextInstance.transformState.scale;\n    var _a = contextInstance.setup, limitToBounds = _a.limitToBounds, centerZoomedOut = _a.centerZoomedOut, zoomAnimation = _a.zoomAnimation;\n    var disabled = zoomAnimation.disabled, size = zoomAnimation.size;\n    // if one finger starts from outside of wrapper\n    if (pinchStartDistance === null || !contentComponent)\n        return;\n    var midPoint = calculateTouchMidPoint(event, scale, contentComponent);\n    // if touches goes off of the wrapper element\n    if (!Number.isFinite(midPoint.x) || !Number.isFinite(midPoint.y))\n        return;\n    var currentDistance = getTouchDistance(event);\n    var newScale = calculatePinchZoom(contextInstance, currentDistance);\n    if (newScale === scale)\n        return;\n    var bounds = handleCalculateBounds(contextInstance, newScale);\n    var isPaddingDisabled = disabled || size === 0 || centerZoomedOut;\n    var isLimitedToBounds = limitToBounds && isPaddingDisabled;\n    var _b = handleCalculateZoomPositions(contextInstance, midPoint.x, midPoint.y, newScale, bounds, isLimitedToBounds), x = _b.x, y = _b.y;\n    contextInstance.pinchMidpoint = midPoint;\n    contextInstance.lastDistance = currentDistance;\n    contextInstance.setTransformState(newScale, x, y);\n};\nvar handlePinchStop = function (contextInstance) {\n    var pinchMidpoint = contextInstance.pinchMidpoint;\n    contextInstance.velocity = null;\n    contextInstance.lastDistance = null;\n    contextInstance.pinchMidpoint = null;\n    contextInstance.pinchStartScale = null;\n    contextInstance.pinchStartDistance = null;\n    handleAlignToScaleBounds(contextInstance, pinchMidpoint === null || pinchMidpoint === void 0 ? void 0 : pinchMidpoint.x, pinchMidpoint === null || pinchMidpoint === void 0 ? void 0 : pinchMidpoint.y);\n};\n\nvar handleDoubleClickStop = function (contextInstance, event) {\n    var onZoomStop = contextInstance.props.onZoomStop;\n    var animationTime = contextInstance.setup.doubleClick.animationTime;\n    cancelTimeout(contextInstance.doubleClickStopEventTimer);\n    contextInstance.doubleClickStopEventTimer = setTimeout(function () {\n        contextInstance.doubleClickStopEventTimer = null;\n        handleCallback(getContext(contextInstance), event, onZoomStop);\n    }, animationTime);\n};\nvar handleDoubleClickResetMode = function (contextInstance, event) {\n    var _a = contextInstance.props, onZoomStart = _a.onZoomStart, onZoom = _a.onZoom;\n    var _b = contextInstance.setup.doubleClick, animationTime = _b.animationTime, animationType = _b.animationType;\n    handleCallback(getContext(contextInstance), event, onZoomStart);\n    resetTransformations(contextInstance, animationTime, animationType, function () {\n        return handleCallback(getContext(contextInstance), event, onZoom);\n    });\n    handleDoubleClickStop(contextInstance, event);\n};\nfunction getDoubleClickScale(mode, scale) {\n    if (mode === \"toggle\") {\n        return scale === 1 ? 1 : -1;\n    }\n    return mode === \"zoomOut\" ? -1 : 1;\n}\nfunction handleDoubleClick(contextInstance, event) {\n    var setup = contextInstance.setup, doubleClickStopEventTimer = contextInstance.doubleClickStopEventTimer, transformState = contextInstance.transformState, contentComponent = contextInstance.contentComponent;\n    var scale = transformState.scale;\n    var _a = contextInstance.props, onZoomStart = _a.onZoomStart, onZoom = _a.onZoom;\n    var _b = setup.doubleClick, disabled = _b.disabled, mode = _b.mode, step = _b.step, animationTime = _b.animationTime, animationType = _b.animationType;\n    if (disabled)\n        return;\n    if (doubleClickStopEventTimer)\n        return;\n    if (mode === \"reset\") {\n        return handleDoubleClickResetMode(contextInstance, event);\n    }\n    if (!contentComponent)\n        return console.error(\"No ContentComponent found\");\n    var delta = getDoubleClickScale(mode, contextInstance.transformState.scale);\n    var newScale = handleCalculateButtonZoom(contextInstance, delta, step);\n    // stop execution when scale didn't change\n    if (scale === newScale)\n        return;\n    handleCallback(getContext(contextInstance), event, onZoomStart);\n    var mousePosition = getMousePosition(event, contentComponent, scale);\n    var targetState = handleZoomToPoint(contextInstance, newScale, mousePosition.x, mousePosition.y);\n    if (!targetState) {\n        return console.error(\"Error during zoom event. New transformation state was not calculated.\");\n    }\n    handleCallback(getContext(contextInstance), event, onZoom);\n    animate(contextInstance, targetState, animationTime, animationType);\n    handleDoubleClickStop(contextInstance, event);\n}\nvar isDoubleClickAllowed = function (contextInstance, event) {\n    var isInitialized = contextInstance.isInitialized, setup = contextInstance.setup, wrapperComponent = contextInstance.wrapperComponent;\n    var _a = setup.doubleClick, disabled = _a.disabled, excluded = _a.excluded;\n    var target = event.target;\n    var isWrapperChild = wrapperComponent === null || wrapperComponent === void 0 ? void 0 : wrapperComponent.contains(target);\n    var isAllowed = isInitialized && target && isWrapperChild && !disabled;\n    if (!isAllowed)\n        return false;\n    var isExcluded = isExcludedNode(target, excluded);\n    if (isExcluded)\n        return false;\n    return true;\n};\n\nvar ZoomPanPinch = /** @class */ (function () {\n    function ZoomPanPinch(props) {\n        var _this = this;\n        this.mounted = true;\n        this.onChangeCallbacks = new Set();\n        this.onInitCallbacks = new Set();\n        // Components\n        this.wrapperComponent = null;\n        this.contentComponent = null;\n        // Initialization\n        this.isInitialized = false;\n        this.bounds = null;\n        // wheel helpers\n        this.previousWheelEvent = null;\n        this.wheelStopEventTimer = null;\n        this.wheelAnimationTimer = null;\n        // panning helpers\n        this.isPanning = false;\n        this.isWheelPanning = false;\n        this.startCoords = null;\n        this.lastTouch = null;\n        // pinch helpers\n        this.distance = null;\n        this.lastDistance = null;\n        this.pinchStartDistance = null;\n        this.pinchStartScale = null;\n        this.pinchMidpoint = null;\n        // double click helpers\n        this.doubleClickStopEventTimer = null;\n        // velocity helpers\n        this.velocity = null;\n        this.velocityTime = null;\n        this.lastMousePosition = null;\n        // animations helpers\n        this.animate = false;\n        this.animation = null;\n        this.maxBounds = null;\n        // key press\n        this.pressedKeys = {};\n        this.mount = function () {\n            _this.initializeWindowEvents();\n        };\n        this.unmount = function () {\n            _this.cleanupWindowEvents();\n        };\n        this.update = function (newProps) {\n            _this.props = newProps;\n            handleCalculateBounds(_this, _this.transformState.scale);\n            _this.setup = createSetup(newProps);\n        };\n        this.initializeWindowEvents = function () {\n            var _a, _b;\n            var passive = makePassiveEventOption();\n            var currentDocument = (_a = _this.wrapperComponent) === null || _a === void 0 ? void 0 : _a.ownerDocument;\n            var currentWindow = currentDocument === null || currentDocument === void 0 ? void 0 : currentDocument.defaultView;\n            (_b = _this.wrapperComponent) === null || _b === void 0 ? void 0 : _b.addEventListener(\"wheel\", _this.onWheelPanning, passive);\n            // Panning on window to allow panning when mouse is out of component wrapper\n            currentWindow === null || currentWindow === void 0 ? void 0 : currentWindow.addEventListener(\"mousedown\", _this.onPanningStart, passive);\n            currentWindow === null || currentWindow === void 0 ? void 0 : currentWindow.addEventListener(\"mousemove\", _this.onPanning, passive);\n            currentWindow === null || currentWindow === void 0 ? void 0 : currentWindow.addEventListener(\"mouseup\", _this.onPanningStop, passive);\n            currentDocument === null || currentDocument === void 0 ? void 0 : currentDocument.addEventListener(\"mouseleave\", _this.clearPanning, passive);\n            currentWindow === null || currentWindow === void 0 ? void 0 : currentWindow.addEventListener(\"keyup\", _this.setKeyUnPressed, passive);\n            currentWindow === null || currentWindow === void 0 ? void 0 : currentWindow.addEventListener(\"keydown\", _this.setKeyPressed, passive);\n        };\n        this.cleanupWindowEvents = function () {\n            var _a, _b;\n            var passive = makePassiveEventOption();\n            var currentDocument = (_a = _this.wrapperComponent) === null || _a === void 0 ? void 0 : _a.ownerDocument;\n            var currentWindow = currentDocument === null || currentDocument === void 0 ? void 0 : currentDocument.defaultView;\n            currentWindow === null || currentWindow === void 0 ? void 0 : currentWindow.removeEventListener(\"mousedown\", _this.onPanningStart, passive);\n            currentWindow === null || currentWindow === void 0 ? void 0 : currentWindow.removeEventListener(\"mousemove\", _this.onPanning, passive);\n            currentWindow === null || currentWindow === void 0 ? void 0 : currentWindow.removeEventListener(\"mouseup\", _this.onPanningStop, passive);\n            currentDocument === null || currentDocument === void 0 ? void 0 : currentDocument.removeEventListener(\"mouseleave\", _this.clearPanning, passive);\n            currentWindow === null || currentWindow === void 0 ? void 0 : currentWindow.removeEventListener(\"keyup\", _this.setKeyUnPressed, passive);\n            currentWindow === null || currentWindow === void 0 ? void 0 : currentWindow.removeEventListener(\"keydown\", _this.setKeyPressed, passive);\n            document.removeEventListener(\"mouseleave\", _this.clearPanning, passive);\n            handleCancelAnimation(_this);\n            (_b = _this.observer) === null || _b === void 0 ? void 0 : _b.disconnect();\n        };\n        this.handleInitializeWrapperEvents = function (wrapper) {\n            // Zooming events on wrapper\n            var passive = makePassiveEventOption();\n            wrapper.addEventListener(\"wheel\", _this.onWheelZoom, passive);\n            wrapper.addEventListener(\"dblclick\", _this.onDoubleClick, passive);\n            wrapper.addEventListener(\"touchstart\", _this.onTouchPanningStart, passive);\n            wrapper.addEventListener(\"touchmove\", _this.onTouchPanning, passive);\n            wrapper.addEventListener(\"touchend\", _this.onTouchPanningStop, passive);\n        };\n        this.handleInitialize = function (contentComponent) {\n            var centerOnInit = _this.setup.centerOnInit;\n            _this.applyTransformation();\n            _this.onInitCallbacks.forEach(function (callback) { return callback(getContext(_this)); });\n            if (centerOnInit) {\n                _this.setCenter();\n                _this.observer = new ResizeObserver(function () {\n                    var _a;\n                    _this.onInitCallbacks.forEach(function (callback) { return callback(getContext(_this)); });\n                    _this.setCenter();\n                    (_a = _this.observer) === null || _a === void 0 ? void 0 : _a.disconnect();\n                });\n                // Start observing the target node for configured mutations\n                _this.observer.observe(contentComponent);\n            }\n        };\n        /// ///////\n        // Zoom\n        /// ///////\n        this.onWheelZoom = function (event) {\n            var disabled = _this.setup.disabled;\n            if (disabled)\n                return;\n            var isAllowed = isWheelAllowed(_this, event);\n            if (!isAllowed)\n                return;\n            var keysPressed = _this.isPressingKeys(_this.setup.wheel.activationKeys);\n            if (!keysPressed)\n                return;\n            handleWheelStart(_this, event);\n            handleWheelZoom(_this, event);\n            handleWheelStop(_this, event);\n        };\n        /// ///////\n        // Pan\n        /// ///////\n        this.onWheelPanning = function (event) {\n            var _a = _this.setup, disabled = _a.disabled, wheel = _a.wheel, panning = _a.panning;\n            if (!_this.wrapperComponent ||\n                !_this.contentComponent ||\n                disabled ||\n                !wheel.wheelDisabled ||\n                panning.disabled ||\n                !panning.wheelPanning ||\n                event.ctrlKey) {\n                return;\n            }\n            event.preventDefault();\n            event.stopPropagation();\n            var _b = _this.transformState, positionX = _b.positionX, positionY = _b.positionY;\n            var mouseX = positionX - event.deltaX;\n            var mouseY = positionY - event.deltaY;\n            var newPositionX = panning.lockAxisX ? positionX : mouseX;\n            var newPositionY = panning.lockAxisY ? positionY : mouseY;\n            var _c = _this.setup.alignmentAnimation, sizeX = _c.sizeX, sizeY = _c.sizeY;\n            var paddingValueX = getPaddingValue(_this, sizeX);\n            var paddingValueY = getPaddingValue(_this, sizeY);\n            if (newPositionX === positionX && newPositionY === positionY)\n                return;\n            handleNewPosition(_this, newPositionX, newPositionY, paddingValueX, paddingValueY);\n        };\n        this.onPanningStart = function (event) {\n            var disabled = _this.setup.disabled;\n            var onPanningStart = _this.props.onPanningStart;\n            if (disabled)\n                return;\n            var isAllowed = isPanningStartAllowed(_this, event);\n            if (!isAllowed)\n                return;\n            var keysPressed = _this.isPressingKeys(_this.setup.panning.activationKeys);\n            if (!keysPressed)\n                return;\n            if (event.button === 0 && !_this.setup.panning.allowLeftClickPan)\n                return;\n            if (event.button === 1 && !_this.setup.panning.allowMiddleClickPan)\n                return;\n            if (event.button === 2 && !_this.setup.panning.allowRightClickPan)\n                return;\n            event.preventDefault();\n            event.stopPropagation();\n            handleCancelAnimation(_this);\n            handlePanningStart(_this, event);\n            handleCallback(getContext(_this), event, onPanningStart);\n        };\n        this.onPanning = function (event) {\n            var disabled = _this.setup.disabled;\n            var onPanning = _this.props.onPanning;\n            if (disabled)\n                return;\n            var isAllowed = isPanningAllowed(_this);\n            if (!isAllowed)\n                return;\n            var keysPressed = _this.isPressingKeys(_this.setup.panning.activationKeys);\n            if (!keysPressed)\n                return;\n            event.preventDefault();\n            event.stopPropagation();\n            handlePanning(_this, event.clientX, event.clientY);\n            handleCallback(getContext(_this), event, onPanning);\n        };\n        this.onPanningStop = function (event) {\n            var onPanningStop = _this.props.onPanningStop;\n            if (_this.isPanning) {\n                handlePanningEnd(_this);\n                handleCallback(getContext(_this), event, onPanningStop);\n            }\n        };\n        /// ///////\n        // Pinch\n        /// ///////\n        this.onPinchStart = function (event) {\n            var disabled = _this.setup.disabled;\n            var _a = _this.props, onPinchingStart = _a.onPinchingStart, onZoomStart = _a.onZoomStart;\n            if (disabled)\n                return;\n            var isAllowed = isPinchStartAllowed(_this, event);\n            if (!isAllowed)\n                return;\n            handlePinchStart(_this, event);\n            handleCancelAnimation(_this);\n            handleCallback(getContext(_this), event, onPinchingStart);\n            handleCallback(getContext(_this), event, onZoomStart);\n        };\n        this.onPinch = function (event) {\n            var disabled = _this.setup.disabled;\n            var _a = _this.props, onPinching = _a.onPinching, onZoom = _a.onZoom;\n            if (disabled)\n                return;\n            var isAllowed = isPinchAllowed(_this);\n            if (!isAllowed)\n                return;\n            event.preventDefault();\n            event.stopPropagation();\n            handlePinchZoom(_this, event);\n            handleCallback(getContext(_this), event, onPinching);\n            handleCallback(getContext(_this), event, onZoom);\n        };\n        this.onPinchStop = function (event) {\n            var _a = _this.props, onPinchingStop = _a.onPinchingStop, onZoomStop = _a.onZoomStop;\n            if (_this.pinchStartScale) {\n                handlePinchStop(_this);\n                handleCallback(getContext(_this), event, onPinchingStop);\n                handleCallback(getContext(_this), event, onZoomStop);\n            }\n        };\n        /// ///////\n        // Touch\n        /// ///////\n        this.onTouchPanningStart = function (event) {\n            var disabled = _this.setup.disabled;\n            var onPanningStart = _this.props.onPanningStart;\n            if (disabled)\n                return;\n            var isAllowed = isPanningStartAllowed(_this, event);\n            if (!isAllowed)\n                return;\n            var isDoubleTap = _this.lastTouch && +new Date() - _this.lastTouch < 200;\n            if (isDoubleTap && event.touches.length === 1) {\n                _this.onDoubleClick(event);\n            }\n            else {\n                _this.lastTouch = +new Date();\n                handleCancelAnimation(_this);\n                var touches = event.touches;\n                var isPanningAction = touches.length === 1;\n                var isPinchAction = touches.length === 2;\n                if (isPanningAction) {\n                    handleCancelAnimation(_this);\n                    handlePanningStart(_this, event);\n                    handleCallback(getContext(_this), event, onPanningStart);\n                }\n                if (isPinchAction) {\n                    _this.onPinchStart(event);\n                }\n            }\n        };\n        this.onTouchPanning = function (event) {\n            var disabled = _this.setup.disabled;\n            var onPanning = _this.props.onPanning;\n            if (_this.isPanning && event.touches.length === 1) {\n                if (disabled)\n                    return;\n                var isAllowed = isPanningAllowed(_this);\n                if (!isAllowed)\n                    return;\n                event.preventDefault();\n                event.stopPropagation();\n                var touch = event.touches[0];\n                handlePanning(_this, touch.clientX, touch.clientY);\n                handleCallback(getContext(_this), event, onPanning);\n            }\n            else if (event.touches.length > 1) {\n                _this.onPinch(event);\n            }\n        };\n        this.onTouchPanningStop = function (event) {\n            _this.onPanningStop(event);\n            _this.onPinchStop(event);\n        };\n        /// ///////\n        // Double Click\n        /// ///////\n        this.onDoubleClick = function (event) {\n            var disabled = _this.setup.disabled;\n            if (disabled)\n                return;\n            var isAllowed = isDoubleClickAllowed(_this, event);\n            if (!isAllowed)\n                return;\n            handleDoubleClick(_this, event);\n        };\n        /// ///////\n        // Helpers\n        /// ///////\n        this.clearPanning = function (event) {\n            if (_this.isPanning) {\n                _this.onPanningStop(event);\n            }\n        };\n        this.setKeyPressed = function (e) {\n            _this.pressedKeys[e.key] = true;\n        };\n        this.setKeyUnPressed = function (e) {\n            _this.pressedKeys[e.key] = false;\n        };\n        this.isPressingKeys = function (keys) {\n            if (!keys.length) {\n                return true;\n            }\n            return Boolean(keys.find(function (key) { return _this.pressedKeys[key]; }));\n        };\n        this.setTransformState = function (scale, positionX, positionY) {\n            var onTransformed = _this.props.onTransformed;\n            if (!Number.isNaN(scale) &&\n                !Number.isNaN(positionX) &&\n                !Number.isNaN(positionY)) {\n                if (scale !== _this.transformState.scale) {\n                    _this.transformState.previousScale = _this.transformState.scale;\n                    _this.transformState.scale = scale;\n                }\n                _this.transformState.positionX = positionX;\n                _this.transformState.positionY = positionY;\n                _this.applyTransformation();\n                var ctx_1 = getContext(_this);\n                _this.onChangeCallbacks.forEach(function (callback) { return callback(ctx_1); });\n                handleCallback(ctx_1, { scale: scale, positionX: positionX, positionY: positionY }, onTransformed);\n            }\n            else {\n                console.error(\"Detected NaN set state values\");\n            }\n        };\n        this.setCenter = function () {\n            if (_this.wrapperComponent && _this.contentComponent) {\n                var targetState = getCenterPosition(_this.transformState.scale, _this.wrapperComponent, _this.contentComponent);\n                _this.setTransformState(targetState.scale, targetState.positionX, targetState.positionY);\n            }\n        };\n        this.handleTransformStyles = function (x, y, scale) {\n            if (_this.props.customTransform) {\n                return _this.props.customTransform(x, y, scale);\n            }\n            return getTransformStyles(x, y, scale);\n        };\n        this.applyTransformation = function () {\n            if (!_this.mounted || !_this.contentComponent)\n                return;\n            var _a = _this.transformState, scale = _a.scale, positionX = _a.positionX, positionY = _a.positionY;\n            var transform = _this.handleTransformStyles(positionX, positionY, scale);\n            _this.contentComponent.style.transform = transform;\n        };\n        this.getContext = function () {\n            return getContext(_this);\n        };\n        /**\n         * Hooks\n         */\n        this.onChange = function (callback) {\n            if (!_this.onChangeCallbacks.has(callback)) {\n                _this.onChangeCallbacks.add(callback);\n            }\n            return function () {\n                _this.onChangeCallbacks.delete(callback);\n            };\n        };\n        this.onInit = function (callback) {\n            if (!_this.onInitCallbacks.has(callback)) {\n                _this.onInitCallbacks.add(callback);\n            }\n            return function () {\n                _this.onInitCallbacks.delete(callback);\n            };\n        };\n        /**\n         * Initialization\n         */\n        this.init = function (wrapperComponent, contentComponent) {\n            _this.cleanupWindowEvents();\n            _this.wrapperComponent = wrapperComponent;\n            _this.contentComponent = contentComponent;\n            handleCalculateBounds(_this, _this.transformState.scale);\n            _this.handleInitializeWrapperEvents(wrapperComponent);\n            _this.handleInitialize(contentComponent);\n            _this.initializeWindowEvents();\n            _this.isInitialized = true;\n            var ctx = getContext(_this);\n            handleCallback(ctx, undefined, _this.props.onInit);\n        };\n        this.props = props;\n        this.setup = createSetup(this.props);\n        this.transformState = createState(this.props);\n    }\n    return ZoomPanPinch;\n}());\n\nvar Context = React.createContext(null);\nvar getContent = function (children, ctx) {\n    if (typeof children === \"function\") {\n        return children(ctx);\n    }\n    return children;\n};\nvar TransformWrapper = React.forwardRef(function (props, ref) {\n    var instance = useRef(new ZoomPanPinch(props)).current;\n    var content = getContent(props.children, getControls(instance));\n    useImperativeHandle(ref, function () { return getControls(instance); }, [instance]);\n    useEffect(function () {\n        instance.update(props);\n    }, [instance, props]);\n    return React.createElement(Context.Provider, { value: instance }, content);\n});\n\nvar KeepScale = React.forwardRef(function (props, ref) {\n    var localRef = useRef(null);\n    var instance = useContext(Context);\n    useEffect(function () {\n        return instance.onChange(function (ctx) {\n            if (localRef.current) {\n                var positionX = 0;\n                var positionY = 0;\n                localRef.current.style.transform = instance.handleTransformStyles(positionX, positionY, 1 / ctx.instance.transformState.scale);\n            }\n        });\n    }, [instance]);\n    return React.createElement(\"div\", __assign({}, props, { ref: mergeRefs([localRef, ref]) }));\n});\n\nvar initialElementRect = {\n    width: 0,\n    height: 0,\n    y: 0,\n    x: 0,\n    top: 0,\n    bottom: 0,\n    left: 0,\n    right: 0,\n};\nvar useResize = function (ref, onResize, dependencies) {\n    var resizeObserverRef = useRef();\n    var rectRef = useRef(initialElementRect);\n    var didUnmount = useRef(false);\n    useLayoutEffect(function () {\n        var _a;\n        didUnmount.current = false;\n        if (!(\"ResizeObserver\" in window)) {\n            return;\n        }\n        if (ref) {\n            resizeObserverRef.current = new ResizeObserver(function (entries) {\n                var newSize = ref.getBoundingClientRect();\n                if (!Array.isArray(entries) ||\n                    !entries.length ||\n                    didUnmount.current ||\n                    (newSize.width === rectRef.current.width &&\n                        newSize.height === rectRef.current.height))\n                    return;\n                onResize(newSize, ref);\n                rectRef.current = newSize;\n            });\n            (_a = resizeObserverRef.current) === null || _a === void 0 ? void 0 : _a.observe(ref);\n        }\n        return function () {\n            var _a;\n            didUnmount.current = true;\n            if (ref) {\n                (_a = resizeObserverRef.current) === null || _a === void 0 ? void 0 : _a.unobserve(ref);\n            }\n        };\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, __spreadArray([onResize, ref], dependencies, true));\n};\n\nvar previewStyles = {\n    position: \"absolute\",\n    zIndex: 2,\n    top: \"0px\",\n    left: \"0px\",\n    boxSizing: \"border-box\",\n    border: \"3px solid red\",\n    transformOrigin: \"0% 0%\",\n    boxShadow: \"rgba(0,0,0,0.2) 0 0 0 10000000px\",\n};\nvar MiniMap = function (_a) {\n    var _b = _a.width, width = _b === void 0 ? 200 : _b, _c = _a.height, height = _c === void 0 ? 200 : _c, _d = _a.borderColor, borderColor = _d === void 0 ? \"red\" : _d, children = _a.children, rest = __rest(_a, [\"width\", \"height\", \"borderColor\", \"children\"]);\n    var _e = useState(false), initialized = _e[0], setInitialized = _e[1];\n    var instance = useTransformContext();\n    var miniMapInstance = useRef(null);\n    var mainRef = useRef(null);\n    var wrapperRef = useRef(null);\n    var previewRef = useRef(null);\n    var getContentSize = useCallback(function () {\n        if (instance.contentComponent) {\n            var rect = instance.contentComponent.getBoundingClientRect();\n            return {\n                width: rect.width / instance.transformState.scale,\n                height: rect.height / instance.transformState.scale,\n            };\n        }\n        return {\n            width: 0,\n            height: 0,\n        };\n    }, [instance.contentComponent, instance.transformState.scale]);\n    var computeMiniMapScale = useCallback(function () {\n        var contentSize = getContentSize();\n        var scaleX = width / contentSize.width;\n        var scaleY = height / contentSize.height;\n        var scale = scaleY > scaleX ? scaleX : scaleY;\n        return scale;\n    }, [getContentSize, height, width]);\n    var computeMiniMapSize = function () {\n        var contentSize = getContentSize();\n        var scaleX = width / contentSize.width;\n        var scaleY = height / contentSize.height;\n        if (scaleY > scaleX) {\n            return { width: width, height: contentSize.height * scaleX };\n        }\n        return { width: contentSize.width * scaleY, height: height };\n    };\n    var computeMiniMapStyle = function () {\n        var scale = computeMiniMapScale();\n        var style = {\n            transform: \"scale(\".concat(scale || 1, \")\"),\n            transformOrigin: \"0% 0%\",\n            position: \"absolute\",\n            boxSizing: \"border-box\",\n            zIndex: 1,\n            overflow: \"hidden\",\n        };\n        Object.keys(style).forEach(function (key) {\n            if (wrapperRef.current) {\n                wrapperRef.current.style[key] = style[key];\n            }\n        });\n    };\n    var transformMiniMap = function () {\n        computeMiniMapStyle();\n        var miniSize = computeMiniMapSize();\n        var wrapSize = getContentSize();\n        if (wrapperRef.current) {\n            wrapperRef.current.style.width = \"\".concat(wrapSize.width, \"px\");\n            wrapperRef.current.style.height = \"\".concat(wrapSize.height, \"px\");\n        }\n        if (mainRef.current) {\n            mainRef.current.style.width = \"\".concat(miniSize.width, \"px\");\n            mainRef.current.style.height = \"\".concat(miniSize.height, \"px\");\n        }\n        if (previewRef.current) {\n            var size = getContentSize();\n            var scale = computeMiniMapScale();\n            var previewScale = scale * (1 / instance.transformState.scale);\n            var transform = instance.handleTransformStyles(-instance.transformState.positionX * previewScale, -instance.transformState.positionY * previewScale, 1);\n            previewRef.current.style.transform = transform;\n            previewRef.current.style.width = \"\".concat(size.width * previewScale, \"px\");\n            previewRef.current.style.height = \"\".concat(size.height * previewScale, \"px\");\n        }\n    };\n    var initialize = function () {\n        transformMiniMap();\n    };\n    useTransformEffect(function () {\n        transformMiniMap();\n    });\n    useTransformInit(function () {\n        initialize();\n        setInitialized(true);\n    });\n    useResize(instance.contentComponent, initialize, [initialized]);\n    useEffect(function () {\n        return instance.onChange(function (zpp) {\n            var scale = computeMiniMapScale();\n            if (miniMapInstance.current) {\n                miniMapInstance.current.instance.transformState.scale =\n                    zpp.instance.transformState.scale;\n                miniMapInstance.current.instance.transformState.positionX =\n                    zpp.instance.transformState.positionX * scale;\n                miniMapInstance.current.instance.transformState.positionY =\n                    zpp.instance.transformState.positionY * scale;\n            }\n        });\n    }, [computeMiniMapScale, instance, miniMapInstance]);\n    var wrapperStyle = useMemo(function () {\n        return {\n            position: \"relative\",\n            zIndex: 2,\n            overflow: \"hidden\",\n        };\n    }, []);\n    return (React.createElement(\"div\", __assign({}, rest, { ref: mainRef, style: wrapperStyle, className: \"rzpp-mini-map \".concat(rest.className || \"\") }),\n        React.createElement(\"div\", __assign({}, rest, { ref: wrapperRef, className: \"rzpp-wrapper\" }), children),\n        React.createElement(\"div\", { className: \"rzpp-preview\", ref: previewRef, style: __assign(__assign({}, previewStyles), { borderColor: borderColor }) })));\n};\n\nfunction styleInject(css, ref) {\n  if ( ref === void 0 ) ref = {};\n  var insertAt = ref.insertAt;\n\n  if (!css || typeof document === 'undefined') { return; }\n\n  var head = document.head || document.getElementsByTagName('head')[0];\n  var style = document.createElement('style');\n  style.type = 'text/css';\n\n  if (insertAt === 'top') {\n    if (head.firstChild) {\n      head.insertBefore(style, head.firstChild);\n    } else {\n      head.appendChild(style);\n    }\n  } else {\n    head.appendChild(style);\n  }\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nvar css_248z = \".transform-component-module_wrapper__SPB86 {\\n  position: relative;\\n  width: -moz-fit-content;\\n  width: fit-content;\\n  height: -moz-fit-content;\\n  height: fit-content;\\n  overflow: hidden;\\n  -webkit-touch-callout: none; /* iOS Safari */\\n  -webkit-user-select: none; /* Safari */\\n  -khtml-user-select: none; /* Konqueror HTML */\\n  -moz-user-select: none; /* Firefox */\\n  -ms-user-select: none; /* Internet Explorer/Edge */\\n  user-select: none;\\n  margin: 0;\\n  padding: 0;\\n}\\n.transform-component-module_content__FBWxo {\\n  display: flex;\\n  flex-wrap: wrap;\\n  width: -moz-fit-content;\\n  width: fit-content;\\n  height: -moz-fit-content;\\n  height: fit-content;\\n  margin: 0;\\n  padding: 0;\\n  transform-origin: 0% 0%;\\n}\\n.transform-component-module_content__FBWxo img {\\n  pointer-events: none;\\n}\\n\";\nvar styles = {\"wrapper\":\"transform-component-module_wrapper__SPB86\",\"content\":\"transform-component-module_content__FBWxo\"};\nstyleInject(css_248z);\n\nvar TransformComponent = function (_a) {\n    var children = _a.children, _b = _a.wrapperClass, wrapperClass = _b === void 0 ? \"\" : _b, _c = _a.contentClass, contentClass = _c === void 0 ? \"\" : _c, wrapperStyle = _a.wrapperStyle, contentStyle = _a.contentStyle, _d = _a.wrapperProps, wrapperProps = _d === void 0 ? {} : _d, _e = _a.contentProps, contentProps = _e === void 0 ? {} : _e;\n    var _f = useContext(Context), init = _f.init, cleanupWindowEvents = _f.cleanupWindowEvents;\n    var wrapperRef = useRef(null);\n    var contentRef = useRef(null);\n    useEffect(function () {\n        var wrapper = wrapperRef.current;\n        var content = contentRef.current;\n        if (wrapper !== null && content !== null && init) {\n            init === null || init === void 0 ? void 0 : init(wrapper, content);\n        }\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n        return function () {\n            cleanupWindowEvents === null || cleanupWindowEvents === void 0 ? void 0 : cleanupWindowEvents();\n        };\n    }, []);\n    return (React.createElement(\"div\", __assign({}, wrapperProps, { ref: wrapperRef, className: \"react-transform-wrapper \".concat(styles.wrapper, \" \").concat(wrapperClass), style: wrapperStyle }),\n        React.createElement(\"div\", __assign({}, contentProps, { ref: contentRef, className: \"react-transform-component \".concat(styles.content, \" \").concat(contentClass), style: contentStyle }), children)));\n};\n\nvar useTransformContext = function () {\n    var libraryContext = useContext(Context);\n    if (!libraryContext) {\n        throw new Error(\"Transform context must be placed inside TransformWrapper\");\n    }\n    return libraryContext;\n};\n\nvar useControls = function () {\n    var libraryContext = useTransformContext();\n    return getControls(libraryContext);\n};\n\nvar useTransformInit = function (callback) {\n    var libraryContext = useTransformContext();\n    useEffect(function () {\n        var unmountCallback;\n        var unmount;\n        if (libraryContext.contentComponent && libraryContext.wrapperComponent) {\n            unmountCallback = callback(getState(libraryContext));\n        }\n        else {\n            unmount = libraryContext.onInit(function (ref) {\n                unmountCallback = callback(getState(ref.instance));\n            });\n        }\n        return function () {\n            unmount === null || unmount === void 0 ? void 0 : unmount();\n            unmountCallback === null || unmountCallback === void 0 ? void 0 : unmountCallback();\n        };\n    }, []);\n};\n\nvar useTransformEffect = function (callback) {\n    var libraryContext = useTransformContext();\n    useEffect(function () {\n        var unmountCallback;\n        var unmount = libraryContext.onChange(function (ref) {\n            unmountCallback = callback(getState(ref.instance));\n        });\n        return function () {\n            unmount();\n            unmountCallback === null || unmountCallback === void 0 ? void 0 : unmountCallback();\n        };\n    }, [callback, libraryContext]);\n};\n\nexport { Context, KeepScale, MiniMap, TransformComponent, TransformWrapper, getCenterPosition, getMatrixTransformStyles, getTransformStyles, useControls, useTransformContext, useTransformEffect, useTransformInit };\n//# sourceMappingURL=index.esm.js.map\n","import getWindow from \"../dom-utils/getWindow.js\"; // eslint-disable-next-line import/no-unused-modules\n\nvar passive = {\n  passive: true\n};\n\nfunction effect(_ref) {\n  var state = _ref.state,\n      instance = _ref.instance,\n      options = _ref.options;\n  var _options$scroll = options.scroll,\n      scroll = _options$scroll === void 0 ? true : _options$scroll,\n      _options$resize = options.resize,\n      resize = _options$resize === void 0 ? true : _options$resize;\n  var window = getWindow(state.elements.popper);\n  var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);\n\n  if (scroll) {\n    scrollParents.forEach(function (scrollParent) {\n      scrollParent.addEventListener('scroll', instance.update, passive);\n    });\n  }\n\n  if (resize) {\n    window.addEventListener('resize', instance.update, passive);\n  }\n\n  return function () {\n    if (scroll) {\n      scrollParents.forEach(function (scrollParent) {\n        scrollParent.removeEventListener('scroll', instance.update, passive);\n      });\n    }\n\n    if (resize) {\n      window.removeEventListener('resize', instance.update, passive);\n    }\n  };\n} // eslint-disable-next-line import/no-unused-modules\n\n\nexport default {\n  name: 'eventListeners',\n  enabled: true,\n  phase: 'write',\n  fn: function fn() {},\n  effect: effect,\n  data: {}\n};","import { DEFAULT_SHADOW_CONFIG } from './shadowConfig';\n/**\n * Sets the current RTL value.\n */\nexport function setRTL(isRTL) {\n    if (_rtl !== isRTL) {\n        _rtl = isRTL;\n    }\n}\n/**\n * Gets the current RTL value.\n */\nexport function getRTL() {\n    if (_rtl === undefined) {\n        _rtl =\n            // eslint-disable-next-line no-restricted-globals\n            typeof document !== 'undefined' &&\n                // eslint-disable-next-line no-restricted-globals\n                !!document.documentElement &&\n                // eslint-disable-next-line no-restricted-globals\n                document.documentElement.getAttribute('dir') === 'rtl';\n    }\n    return _rtl;\n}\n// This has been split into 2 lines because it was working in Fabric due to the code being transpiled to es5, so this\n// was converted to var while not working in Fluent that uses babel to transpile the code to be es6-like. Splitting the\n// logic into two lines, however, allows it to work in both scenarios.\nvar _rtl;\n_rtl = getRTL();\nexport function getStyleOptions() {\n    return {\n        rtl: getRTL(),\n        shadowConfig: DEFAULT_SHADOW_CONFIG,\n    };\n}\n//# sourceMappingURL=StyleOptionsState.js.map","function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nmodule.exports = _nonIterableRest, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","import { createExpoIn, reverseEasing, mirrorEasing, createBackIn, createAnticipate } from './utils.js';\n\nvar DEFAULT_OVERSHOOT_STRENGTH = 1.525;\nvar BOUNCE_FIRST_THRESHOLD = 4.0 / 11.0;\nvar BOUNCE_SECOND_THRESHOLD = 8.0 / 11.0;\nvar BOUNCE_THIRD_THRESHOLD = 9.0 / 10.0;\nvar linear = function (p) { return p; };\nvar easeIn = createExpoIn(2);\nvar easeOut = reverseEasing(easeIn);\nvar easeInOut = mirrorEasing(easeIn);\nvar circIn = function (p) { return 1 - Math.sin(Math.acos(p)); };\nvar circOut = reverseEasing(circIn);\nvar circInOut = mirrorEasing(circOut);\nvar backIn = createBackIn(DEFAULT_OVERSHOOT_STRENGTH);\nvar backOut = reverseEasing(backIn);\nvar backInOut = mirrorEasing(backIn);\nvar anticipate = createAnticipate(DEFAULT_OVERSHOOT_STRENGTH);\nvar ca = 4356.0 / 361.0;\nvar cb = 35442.0 / 1805.0;\nvar cc = 16061.0 / 1805.0;\nvar bounceOut = function (p) {\n    if (p === 1 || p === 0)\n        return p;\n    var p2 = p * p;\n    return p < BOUNCE_FIRST_THRESHOLD\n        ? 7.5625 * p2\n        : p < BOUNCE_SECOND_THRESHOLD\n            ? 9.075 * p2 - 9.9 * p + 3.4\n            : p < BOUNCE_THIRD_THRESHOLD\n                ? ca * p2 - cb * p + cc\n                : 10.8 * p * p - 20.52 * p + 10.72;\n};\nvar bounceIn = reverseEasing(bounceOut);\nvar bounceInOut = function (p) {\n    return p < 0.5\n        ? 0.5 * (1.0 - bounceOut(1.0 - p * 2.0))\n        : 0.5 * bounceOut(p * 2.0 - 1.0) + 0.5;\n};\n\nexport { anticipate, backIn, backInOut, backOut, bounceIn, bounceInOut, bounceOut, circIn, circInOut, circOut, easeIn, easeInOut, easeOut, linear };\n","import getWindow from \"./getWindow.js\";\n\nfunction isElement(node) {\n  var OwnElement = getWindow(node).Element;\n  return node instanceof OwnElement || node instanceof Element;\n}\n\nfunction isHTMLElement(node) {\n  var OwnElement = getWindow(node).HTMLElement;\n  return node instanceof OwnElement || node instanceof HTMLElement;\n}\n\nfunction isShadowRoot(node) {\n  // IE 11 has no ShadowRoot\n  if (typeof ShadowRoot === 'undefined') {\n    return false;\n  }\n\n  var OwnElement = getWindow(node).ShadowRoot;\n  return node instanceof OwnElement || node instanceof ShadowRoot;\n}\n\nexport { isElement, isHTMLElement, isShadowRoot };","/** PURE_IMPORTS_START tslib,_Observable,_Subscriber,_Subscription,_util_ObjectUnsubscribedError,_SubjectSubscription,_internal_symbol_rxSubscriber PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Observable } from './Observable';\nimport { Subscriber } from './Subscriber';\nimport { Subscription } from './Subscription';\nimport { ObjectUnsubscribedError } from './util/ObjectUnsubscribedError';\nimport { SubjectSubscription } from './SubjectSubscription';\nimport { rxSubscriber as rxSubscriberSymbol } from '../internal/symbol/rxSubscriber';\nvar SubjectSubscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(SubjectSubscriber, _super);\n    function SubjectSubscriber(destination) {\n        var _this = _super.call(this, destination) || this;\n        _this.destination = destination;\n        return _this;\n    }\n    return SubjectSubscriber;\n}(Subscriber));\nexport { SubjectSubscriber };\nvar Subject = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(Subject, _super);\n    function Subject() {\n        var _this = _super.call(this) || this;\n        _this.observers = [];\n        _this.closed = false;\n        _this.isStopped = false;\n        _this.hasError = false;\n        _this.thrownError = null;\n        return _this;\n    }\n    Subject.prototype[rxSubscriberSymbol] = function () {\n        return new SubjectSubscriber(this);\n    };\n    Subject.prototype.lift = function (operator) {\n        var subject = new AnonymousSubject(this, this);\n        subject.operator = operator;\n        return subject;\n    };\n    Subject.prototype.next = function (value) {\n        if (this.closed) {\n            throw new ObjectUnsubscribedError();\n        }\n        if (!this.isStopped) {\n            var observers = this.observers;\n            var len = observers.length;\n            var copy = observers.slice();\n            for (var i = 0; i < len; i++) {\n                copy[i].next(value);\n            }\n        }\n    };\n    Subject.prototype.error = function (err) {\n        if (this.closed) {\n            throw new ObjectUnsubscribedError();\n        }\n        this.hasError = true;\n        this.thrownError = err;\n        this.isStopped = true;\n        var observers = this.observers;\n        var len = observers.length;\n        var copy = observers.slice();\n        for (var i = 0; i < len; i++) {\n            copy[i].error(err);\n        }\n        this.observers.length = 0;\n    };\n    Subject.prototype.complete = function () {\n        if (this.closed) {\n            throw new ObjectUnsubscribedError();\n        }\n        this.isStopped = true;\n        var observers = this.observers;\n        var len = observers.length;\n        var copy = observers.slice();\n        for (var i = 0; i < len; i++) {\n            copy[i].complete();\n        }\n        this.observers.length = 0;\n    };\n    Subject.prototype.unsubscribe = function () {\n        this.isStopped = true;\n        this.closed = true;\n        this.observers = null;\n    };\n    Subject.prototype._trySubscribe = function (subscriber) {\n        if (this.closed) {\n            throw new ObjectUnsubscribedError();\n        }\n        else {\n            return _super.prototype._trySubscribe.call(this, subscriber);\n        }\n    };\n    Subject.prototype._subscribe = function (subscriber) {\n        if (this.closed) {\n            throw new ObjectUnsubscribedError();\n        }\n        else if (this.hasError) {\n            subscriber.error(this.thrownError);\n            return Subscription.EMPTY;\n        }\n        else if (this.isStopped) {\n            subscriber.complete();\n            return Subscription.EMPTY;\n        }\n        else {\n            this.observers.push(subscriber);\n            return new SubjectSubscription(this, subscriber);\n        }\n    };\n    Subject.prototype.asObservable = function () {\n        var observable = new Observable();\n        observable.source = this;\n        return observable;\n    };\n    Subject.create = function (destination, source) {\n        return new AnonymousSubject(destination, source);\n    };\n    return Subject;\n}(Observable));\nexport { Subject };\nvar AnonymousSubject = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(AnonymousSubject, _super);\n    function AnonymousSubject(destination, source) {\n        var _this = _super.call(this) || this;\n        _this.destination = destination;\n        _this.source = source;\n        return _this;\n    }\n    AnonymousSubject.prototype.next = function (value) {\n        var destination = this.destination;\n        if (destination && destination.next) {\n            destination.next(value);\n        }\n    };\n    AnonymousSubject.prototype.error = function (err) {\n        var destination = this.destination;\n        if (destination && destination.error) {\n            this.destination.error(err);\n        }\n    };\n    AnonymousSubject.prototype.complete = function () {\n        var destination = this.destination;\n        if (destination && destination.complete) {\n            this.destination.complete();\n        }\n    };\n    AnonymousSubject.prototype._subscribe = function (subscriber) {\n        var source = this.source;\n        if (source) {\n            return this.source.subscribe(subscriber);\n        }\n        else {\n            return Subscription.EMPTY;\n        }\n    };\n    return AnonymousSubject;\n}(Subject));\nexport { AnonymousSubject };\n//# sourceMappingURL=Subject.js.map\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","import { keyframes } from '@fluentui/merge-styles';\n/* Register the keyframes */\nvar EASING_FUNCTION_1 = 'cubic-bezier(.1,.9,.2,1)';\nvar EASING_FUNCTION_2 = 'cubic-bezier(.1,.25,.75,.9)';\nvar DURATION_1 = '0.167s';\nvar DURATION_2 = '0.267s';\nvar DURATION_3 = '0.367s';\nvar DURATION_4 = '0.467s';\nvar FADE_IN = keyframes({\n    from: { opacity: 0 },\n    to: { opacity: 1 },\n});\nvar FADE_OUT = keyframes({\n    from: { opacity: 1 },\n    to: { opacity: 0, visibility: 'hidden' },\n});\nvar SLIDE_RIGHT_IN10 = _createSlideInX(-10);\nvar SLIDE_RIGHT_IN20 = _createSlideInX(-20);\nvar SLIDE_RIGHT_IN40 = _createSlideInX(-40);\nvar SLIDE_RIGHT_IN400 = _createSlideInX(-400);\nvar SLIDE_LEFT_IN10 = _createSlideInX(10);\nvar SLIDE_LEFT_IN20 = _createSlideInX(20);\nvar SLIDE_LEFT_IN40 = _createSlideInX(40);\nvar SLIDE_LEFT_IN400 = _createSlideInX(400);\nvar SLIDE_UP_IN10 = _createSlideInY(10);\nvar SLIDE_UP_IN20 = _createSlideInY(20);\nvar SLIDE_DOWN_IN10 = _createSlideInY(-10);\nvar SLIDE_DOWN_IN20 = _createSlideInY(-20);\nvar SLIDE_RIGHT_OUT10 = _createSlideOutX(10);\nvar SLIDE_RIGHT_OUT20 = _createSlideOutX(20);\nvar SLIDE_RIGHT_OUT40 = _createSlideOutX(40);\nvar SLIDE_RIGHT_OUT400 = _createSlideOutX(400);\nvar SLIDE_LEFT_OUT10 = _createSlideOutX(-10);\nvar SLIDE_LEFT_OUT20 = _createSlideOutX(-20);\nvar SLIDE_LEFT_OUT40 = _createSlideOutX(-40);\nvar SLIDE_LEFT_OUT400 = _createSlideOutX(-400);\nvar SLIDE_UP_OUT10 = _createSlideOutY(-10);\nvar SLIDE_UP_OUT20 = _createSlideOutY(-20);\nvar SLIDE_DOWN_OUT10 = _createSlideOutY(10);\nvar SLIDE_DOWN_OUT20 = _createSlideOutY(20);\nvar SCALE_UP100 = keyframes({\n    from: { transform: 'scale3d(.98,.98,1)' },\n    to: { transform: 'scale3d(1,1,1)' },\n});\nvar SCALE_DOWN98 = keyframes({\n    from: { transform: 'scale3d(1,1,1)' },\n    to: { transform: 'scale3d(.98,.98,1)' },\n});\nvar SCALE_DOWN100 = keyframes({\n    from: { transform: 'scale3d(1.03,1.03,1)' },\n    to: { transform: 'scale3d(1,1,1)' },\n});\nvar SCALE_UP103 = keyframes({\n    from: { transform: 'scale3d(1,1,1)' },\n    to: { transform: 'scale3d(1.03,1.03,1)' },\n});\nvar ROTATE90 = keyframes({\n    from: { transform: 'rotateZ(0deg)' },\n    to: { transform: 'rotateZ(90deg)' },\n});\nvar ROTATE_N90 = keyframes({\n    from: { transform: 'rotateZ(0deg)' },\n    to: { transform: 'rotateZ(-90deg)' },\n});\n/**\n * Exporting raw duraction values and easing functions to be used in custom animations\n */\nexport var AnimationVariables = {\n    easeFunction1: EASING_FUNCTION_1,\n    easeFunction2: EASING_FUNCTION_2,\n    durationValue1: DURATION_1,\n    durationValue2: DURATION_2,\n    durationValue3: DURATION_3,\n    durationValue4: DURATION_4,\n};\n/**\n * All Fabric standard animations, exposed as json objects referencing predefined\n * keyframes. These objects can be mixed in with other class definitions.\n */\nexport var AnimationStyles = {\n    slideRightIn10: _createAnimation(\"\".concat(FADE_IN, \",\").concat(SLIDE_RIGHT_IN10), DURATION_3, EASING_FUNCTION_1),\n    slideRightIn20: _createAnimation(\"\".concat(FADE_IN, \",\").concat(SLIDE_RIGHT_IN20), DURATION_3, EASING_FUNCTION_1),\n    slideRightIn40: _createAnimation(\"\".concat(FADE_IN, \",\").concat(SLIDE_RIGHT_IN40), DURATION_3, EASING_FUNCTION_1),\n    slideRightIn400: _createAnimation(\"\".concat(FADE_IN, \",\").concat(SLIDE_RIGHT_IN400), DURATION_3, EASING_FUNCTION_1),\n    slideLeftIn10: _createAnimation(\"\".concat(FADE_IN, \",\").concat(SLIDE_LEFT_IN10), DURATION_3, EASING_FUNCTION_1),\n    slideLeftIn20: _createAnimation(\"\".concat(FADE_IN, \",\").concat(SLIDE_LEFT_IN20), DURATION_3, EASING_FUNCTION_1),\n    slideLeftIn40: _createAnimation(\"\".concat(FADE_IN, \",\").concat(SLIDE_LEFT_IN40), DURATION_3, EASING_FUNCTION_1),\n    slideLeftIn400: _createAnimation(\"\".concat(FADE_IN, \",\").concat(SLIDE_LEFT_IN400), DURATION_3, EASING_FUNCTION_1),\n    slideUpIn10: _createAnimation(\"\".concat(FADE_IN, \",\").concat(SLIDE_UP_IN10), DURATION_3, EASING_FUNCTION_1),\n    slideUpIn20: _createAnimation(\"\".concat(FADE_IN, \",\").concat(SLIDE_UP_IN20), DURATION_3, EASING_FUNCTION_1),\n    slideDownIn10: _createAnimation(\"\".concat(FADE_IN, \",\").concat(SLIDE_DOWN_IN10), DURATION_3, EASING_FUNCTION_1),\n    slideDownIn20: _createAnimation(\"\".concat(FADE_IN, \",\").concat(SLIDE_DOWN_IN20), DURATION_3, EASING_FUNCTION_1),\n    slideRightOut10: _createAnimation(\"\".concat(FADE_OUT, \",\").concat(SLIDE_RIGHT_OUT10), DURATION_3, EASING_FUNCTION_1),\n    slideRightOut20: _createAnimation(\"\".concat(FADE_OUT, \",\").concat(SLIDE_RIGHT_OUT20), DURATION_3, EASING_FUNCTION_1),\n    slideRightOut40: _createAnimation(\"\".concat(FADE_OUT, \",\").concat(SLIDE_RIGHT_OUT40), DURATION_3, EASING_FUNCTION_1),\n    slideRightOut400: _createAnimation(\"\".concat(FADE_OUT, \",\").concat(SLIDE_RIGHT_OUT400), DURATION_3, EASING_FUNCTION_1),\n    slideLeftOut10: _createAnimation(\"\".concat(FADE_OUT, \",\").concat(SLIDE_LEFT_OUT10), DURATION_3, EASING_FUNCTION_1),\n    slideLeftOut20: _createAnimation(\"\".concat(FADE_OUT, \",\").concat(SLIDE_LEFT_OUT20), DURATION_3, EASING_FUNCTION_1),\n    slideLeftOut40: _createAnimation(\"\".concat(FADE_OUT, \",\").concat(SLIDE_LEFT_OUT40), DURATION_3, EASING_FUNCTION_1),\n    slideLeftOut400: _createAnimation(\"\".concat(FADE_OUT, \",\").concat(SLIDE_LEFT_OUT400), DURATION_3, EASING_FUNCTION_1),\n    slideUpOut10: _createAnimation(\"\".concat(FADE_OUT, \",\").concat(SLIDE_UP_OUT10), DURATION_3, EASING_FUNCTION_1),\n    slideUpOut20: _createAnimation(\"\".concat(FADE_OUT, \",\").concat(SLIDE_UP_OUT20), DURATION_3, EASING_FUNCTION_1),\n    slideDownOut10: _createAnimation(\"\".concat(FADE_OUT, \",\").concat(SLIDE_DOWN_OUT10), DURATION_3, EASING_FUNCTION_1),\n    slideDownOut20: _createAnimation(\"\".concat(FADE_OUT, \",\").concat(SLIDE_DOWN_OUT20), DURATION_3, EASING_FUNCTION_1),\n    scaleUpIn100: _createAnimation(\"\".concat(FADE_IN, \",\").concat(SCALE_UP100), DURATION_3, EASING_FUNCTION_1),\n    scaleDownIn100: _createAnimation(\"\".concat(FADE_IN, \",\").concat(SCALE_DOWN100), DURATION_3, EASING_FUNCTION_1),\n    scaleUpOut103: _createAnimation(\"\".concat(FADE_OUT, \",\").concat(SCALE_UP103), DURATION_1, EASING_FUNCTION_2),\n    scaleDownOut98: _createAnimation(\"\".concat(FADE_OUT, \",\").concat(SCALE_DOWN98), DURATION_1, EASING_FUNCTION_2),\n    fadeIn100: _createAnimation(FADE_IN, DURATION_1, EASING_FUNCTION_2),\n    fadeIn200: _createAnimation(FADE_IN, DURATION_2, EASING_FUNCTION_2),\n    fadeIn400: _createAnimation(FADE_IN, DURATION_3, EASING_FUNCTION_2),\n    fadeIn500: _createAnimation(FADE_IN, DURATION_4, EASING_FUNCTION_2),\n    fadeOut100: _createAnimation(FADE_OUT, DURATION_1, EASING_FUNCTION_2),\n    fadeOut200: _createAnimation(FADE_OUT, DURATION_2, EASING_FUNCTION_2),\n    fadeOut400: _createAnimation(FADE_OUT, DURATION_3, EASING_FUNCTION_2),\n    fadeOut500: _createAnimation(FADE_OUT, DURATION_4, EASING_FUNCTION_2),\n    rotate90deg: _createAnimation(ROTATE90, '0.1s', EASING_FUNCTION_2),\n    rotateN90deg: _createAnimation(ROTATE_N90, '0.1s', EASING_FUNCTION_2),\n    // expandCollapse 100/200/400, delay 100/200\n};\nfunction _createAnimation(animationName, animationDuration, animationTimingFunction) {\n    return {\n        animationName: animationName,\n        animationDuration: animationDuration,\n        animationTimingFunction: animationTimingFunction,\n        animationFillMode: 'both',\n    };\n}\nfunction _createSlideInX(fromX) {\n    return keyframes({\n        from: { transform: \"translate3d(\".concat(fromX, \"px,0,0)\"), pointerEvents: 'none' },\n        to: { transform: \"translate3d(0,0,0)\", pointerEvents: 'auto' },\n    });\n}\nfunction _createSlideInY(fromY) {\n    return keyframes({\n        from: { transform: \"translate3d(0,\".concat(fromY, \"px,0)\"), pointerEvents: 'none' },\n        to: { transform: \"translate3d(0,0,0)\", pointerEvents: 'auto' },\n    });\n}\nfunction _createSlideOutX(toX) {\n    return keyframes({\n        from: { transform: \"translate3d(0,0,0)\" },\n        to: { transform: \"translate3d(\".concat(toX, \"px,0,0)\") },\n    });\n}\nfunction _createSlideOutY(toY) {\n    return keyframes({\n        from: { transform: \"translate3d(0,0,0)\" },\n        to: { transform: \"translate3d(0,\".concat(toY, \"px,0)\") },\n    });\n}\n//# sourceMappingURL=AnimationStyles.js.map","const randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);\nexport default {\n  randomUUID\n};","import { linear } from './index.js';\n\nvar a = function (a1, a2) { return 1.0 - 3.0 * a2 + 3.0 * a1; };\nvar b = function (a1, a2) { return 3.0 * a2 - 6.0 * a1; };\nvar c = function (a1) { return 3.0 * a1; };\nvar calcBezier = function (t, a1, a2) {\n    return ((a(a1, a2) * t + b(a1, a2)) * t + c(a1)) * t;\n};\nvar getSlope = function (t, a1, a2) {\n    return 3.0 * a(a1, a2) * t * t + 2.0 * b(a1, a2) * t + c(a1);\n};\nvar subdivisionPrecision = 0.0000001;\nvar subdivisionMaxIterations = 10;\nfunction binarySubdivide(aX, aA, aB, mX1, mX2) {\n    var currentX;\n    var currentT;\n    var i = 0;\n    do {\n        currentT = aA + (aB - aA) / 2.0;\n        currentX = calcBezier(currentT, mX1, mX2) - aX;\n        if (currentX > 0.0) {\n            aB = currentT;\n        }\n        else {\n            aA = currentT;\n        }\n    } while (Math.abs(currentX) > subdivisionPrecision &&\n        ++i < subdivisionMaxIterations);\n    return currentT;\n}\nvar newtonIterations = 8;\nvar newtonMinSlope = 0.001;\nfunction newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {\n    for (var i = 0; i < newtonIterations; ++i) {\n        var currentSlope = getSlope(aGuessT, mX1, mX2);\n        if (currentSlope === 0.0) {\n            return aGuessT;\n        }\n        var currentX = calcBezier(aGuessT, mX1, mX2) - aX;\n        aGuessT -= currentX / currentSlope;\n    }\n    return aGuessT;\n}\nvar kSplineTableSize = 11;\nvar kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);\nfunction cubicBezier(mX1, mY1, mX2, mY2) {\n    if (mX1 === mY1 && mX2 === mY2)\n        return linear;\n    var sampleValues = new Float32Array(kSplineTableSize);\n    for (var i = 0; i < kSplineTableSize; ++i) {\n        sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);\n    }\n    function getTForX(aX) {\n        var intervalStart = 0.0;\n        var currentSample = 1;\n        var lastSample = kSplineTableSize - 1;\n        for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {\n            intervalStart += kSampleStepSize;\n        }\n        --currentSample;\n        var dist = (aX - sampleValues[currentSample]) /\n            (sampleValues[currentSample + 1] - sampleValues[currentSample]);\n        var guessForT = intervalStart + dist * kSampleStepSize;\n        var initialSlope = getSlope(guessForT, mX1, mX2);\n        if (initialSlope >= newtonMinSlope) {\n            return newtonRaphsonIterate(aX, guessForT, mX1, mX2);\n        }\n        else if (initialSlope === 0.0) {\n            return guessForT;\n        }\n        else {\n            return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);\n        }\n    }\n    return function (t) {\n        return t === 0 || t === 1 ? t : calcBezier(getTForX(t), mY1, mY2);\n    };\n}\n\nexport { cubicBezier };\n","import { posToDOMRect, Extension } from '@tiptap/core';\nimport { Plugin, PluginKey } from '@tiptap/pm/state';\nimport tippy from 'tippy.js';\n\nclass FloatingMenuView {\n    constructor({ editor, element, view, tippyOptions = {}, shouldShow, }) {\n        this.preventHide = false;\n        this.shouldShow = ({ view, state }) => {\n            const { selection } = state;\n            const { $anchor, empty } = selection;\n            const isRootDepth = $anchor.depth === 1;\n            const isEmptyTextBlock = $anchor.parent.isTextblock && !$anchor.parent.type.spec.code && !$anchor.parent.textContent;\n            if (!view.hasFocus()\n                || !empty\n                || !isRootDepth\n                || !isEmptyTextBlock\n                || !this.editor.isEditable) {\n                return false;\n            }\n            return true;\n        };\n        this.mousedownHandler = () => {\n            this.preventHide = true;\n        };\n        this.focusHandler = () => {\n            // we use `setTimeout` to make sure `selection` is already updated\n            setTimeout(() => this.update(this.editor.view));\n        };\n        this.blurHandler = ({ event }) => {\n            var _a;\n            if (this.preventHide) {\n                this.preventHide = false;\n                return;\n            }\n            if ((event === null || event === void 0 ? void 0 : event.relatedTarget) && ((_a = this.element.parentNode) === null || _a === void 0 ? void 0 : _a.contains(event.relatedTarget))) {\n                return;\n            }\n            this.hide();\n        };\n        this.tippyBlurHandler = (event) => {\n            this.blurHandler({ event });\n        };\n        this.editor = editor;\n        this.element = element;\n        this.view = view;\n        if (shouldShow) {\n            this.shouldShow = shouldShow;\n        }\n        this.element.addEventListener('mousedown', this.mousedownHandler, { capture: true });\n        this.editor.on('focus', this.focusHandler);\n        this.editor.on('blur', this.blurHandler);\n        this.tippyOptions = tippyOptions;\n        // Detaches menu content from its current parent\n        this.element.remove();\n        this.element.style.visibility = 'visible';\n    }\n    createTooltip() {\n        const { element: editorElement } = this.editor.options;\n        const editorIsAttached = !!editorElement.parentElement;\n        if (this.tippy || !editorIsAttached) {\n            return;\n        }\n        this.tippy = tippy(editorElement, {\n            duration: 0,\n            getReferenceClientRect: null,\n            content: this.element,\n            interactive: true,\n            trigger: 'manual',\n            placement: 'right',\n            hideOnClick: 'toggle',\n            ...this.tippyOptions,\n        });\n        // maybe we have to hide tippy on its own blur event as well\n        if (this.tippy.popper.firstChild) {\n            this.tippy.popper.firstChild.addEventListener('blur', this.tippyBlurHandler);\n        }\n    }\n    update(view, oldState) {\n        var _a, _b, _c;\n        const { state } = view;\n        const { doc, selection } = state;\n        const { from, to } = selection;\n        const isSame = oldState && oldState.doc.eq(doc) && oldState.selection.eq(selection);\n        if (isSame) {\n            return;\n        }\n        this.createTooltip();\n        const shouldShow = (_a = this.shouldShow) === null || _a === void 0 ? void 0 : _a.call(this, {\n            editor: this.editor,\n            view,\n            state,\n            oldState,\n        });\n        if (!shouldShow) {\n            this.hide();\n            return;\n        }\n        (_b = this.tippy) === null || _b === void 0 ? void 0 : _b.setProps({\n            getReferenceClientRect: ((_c = this.tippyOptions) === null || _c === void 0 ? void 0 : _c.getReferenceClientRect) || (() => posToDOMRect(view, from, to)),\n        });\n        this.show();\n    }\n    show() {\n        var _a;\n        (_a = this.tippy) === null || _a === void 0 ? void 0 : _a.show();\n    }\n    hide() {\n        var _a;\n        (_a = this.tippy) === null || _a === void 0 ? void 0 : _a.hide();\n    }\n    destroy() {\n        var _a, _b;\n        if ((_a = this.tippy) === null || _a === void 0 ? void 0 : _a.popper.firstChild) {\n            this.tippy.popper.firstChild.removeEventListener('blur', this.tippyBlurHandler);\n        }\n        (_b = this.tippy) === null || _b === void 0 ? void 0 : _b.destroy();\n        this.element.removeEventListener('mousedown', this.mousedownHandler, { capture: true });\n        this.editor.off('focus', this.focusHandler);\n        this.editor.off('blur', this.blurHandler);\n    }\n}\nconst FloatingMenuPlugin = (options) => {\n    return new Plugin({\n        key: typeof options.pluginKey === 'string' ? new PluginKey(options.pluginKey) : options.pluginKey,\n        view: view => new FloatingMenuView({ view, ...options }),\n    });\n};\n\n/**\n * This extension allows you to create a floating menu.\n * @see https://tiptap.dev/api/extensions/floating-menu\n */\nconst FloatingMenu = Extension.create({\n    name: 'floatingMenu',\n    addOptions() {\n        return {\n            element: null,\n            tippyOptions: {},\n            pluginKey: 'floatingMenu',\n            shouldShow: null,\n        };\n    },\n    addProseMirrorPlugins() {\n        if (!this.options.element) {\n            return [];\n        }\n        return [\n            FloatingMenuPlugin({\n                pluginKey: this.options.pluginKey,\n                editor: this.editor,\n                element: this.options.element,\n                tippyOptions: this.options.tippyOptions,\n                shouldShow: this.options.shouldShow,\n            }),\n        ];\n    },\n});\n\nexport { FloatingMenu, FloatingMenuPlugin, FloatingMenuView, FloatingMenu as default };\n//# sourceMappingURL=index.js.map\n","(function (global, undefined) {\n    \"use strict\";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== \"function\") {\n        callback = new Function(\"\" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n        // So if we're currently running a task, we'll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // \"too much recursion\" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can't be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage(\"\", \"*\");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === \"string\" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener(\"message\", onGlobalMessage, false);\n        } else {\n            global.attachEvent(\"onmessage\", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, \"*\");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n            var script = doc.createElement(\"script\");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don't get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === \"[object process]\") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n        // For IE 68\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self));\n","import getFreshSideObject from \"./getFreshSideObject.js\";\nexport default function mergePaddingObject(paddingObject) {\n  return Object.assign({}, getFreshSideObject(), paddingObject);\n}","import { Node, mergeAttributes } from '@tiptap/core';\n\n/**\n * This extension allows you to insert hard breaks.\n * @see https://www.tiptap.dev/api/nodes/hard-break\n */\nconst HardBreak = Node.create({\n    name: 'hardBreak',\n    addOptions() {\n        return {\n            keepMarks: true,\n            HTMLAttributes: {},\n        };\n    },\n    inline: true,\n    group: 'inline',\n    selectable: false,\n    parseHTML() {\n        return [\n            { tag: 'br' },\n        ];\n    },\n    renderHTML({ HTMLAttributes }) {\n        return ['br', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes)];\n    },\n    renderText() {\n        return '\\n';\n    },\n    addCommands() {\n        return {\n            setHardBreak: () => ({ commands, chain, state, editor, }) => {\n                return commands.first([\n                    () => commands.exitCode(),\n                    () => commands.command(() => {\n                        const { selection, storedMarks } = state;\n                        if (selection.$from.parent.type.spec.isolating) {\n                            return false;\n                        }\n                        const { keepMarks } = this.options;\n                        const { splittableMarks } = editor.extensionManager;\n                        const marks = storedMarks\n                            || (selection.$to.parentOffset && selection.$from.marks());\n                        return chain()\n                            .insertContent({ type: this.name })\n                            .command(({ tr, dispatch }) => {\n                            if (dispatch && marks && keepMarks) {\n                                const filteredMarks = marks\n                                    .filter(mark => splittableMarks.includes(mark.type.name));\n                                tr.ensureMarks(filteredMarks);\n                            }\n                            return true;\n                        })\n                            .run();\n                    }),\n                ]);\n            },\n        };\n    },\n    addKeyboardShortcuts() {\n        return {\n            'Mod-Enter': () => this.editor.commands.setHardBreak(),\n            'Shift-Enter': () => this.editor.commands.setHardBreak(),\n        };\n    },\n});\n\nexport { HardBreak, HardBreak as default };\n//# sourceMappingURL=index.js.map\n","// model/index.ts\nexport * from \"prosemirror-model\";\n","import { Node } from '@tiptap/core';\n\n/**\n * This extension allows you to create text nodes.\n * @see https://www.tiptap.dev/api/nodes/text\n */\nconst Text = Node.create({\n    name: 'text',\n    group: 'inline',\n});\n\nexport { Text, Text as default };\n//# sourceMappingURL=index.js.map\n","/**\n * Suffixes to be ignored in case of error\n */\nconst ignoreSuffixes = /*#__PURE__*/['-moz-placeholder', '-moz-focus-inner', '-moz-focusring', '-ms-input-placeholder', '-moz-read-write', '-moz-read-only'].join('|');\nconst ignoreSuffixesRegex = /*#__PURE__*/new RegExp(`:(${ignoreSuffixes})`);\n/**\n * @internal\n *\n * Calls `sheet.insertRule` and catches errors related to browser prefixes.\n */\nfunction safeInsertRule(sheet, ruleCSS) {\n  try {\n    sheet.insertRule(ruleCSS);\n  } catch (e) {\n    // We've disabled these warnings due to false-positive errors with browser prefixes\n    if (process.env.NODE_ENV !== 'production' && !ignoreSuffixesRegex.test(ruleCSS)) {\n      // eslint-disable-next-line no-console\n      console.error(`There was a problem inserting the following rule: \"${ruleCSS}\"`, e);\n    }\n  }\n}\n\nexport { safeInsertRule };\n//# sourceMappingURL=safeInsertRule.esm.js.map\n","/** PURE_IMPORTS_START  PURE_IMPORTS_END */\nvar ObjectUnsubscribedErrorImpl = /*@__PURE__*/ (function () {\n    function ObjectUnsubscribedErrorImpl() {\n        Error.call(this);\n        this.message = 'object unsubscribed';\n        this.name = 'ObjectUnsubscribedError';\n        return this;\n    }\n    ObjectUnsubscribedErrorImpl.prototype = /*@__PURE__*/ Object.create(Error.prototype);\n    return ObjectUnsubscribedErrorImpl;\n})();\nexport var ObjectUnsubscribedError = ObjectUnsubscribedErrorImpl;\n//# sourceMappingURL=ObjectUnsubscribedError.js.map\n","import {mergeProps as $9BxnE$mergeProps} from \"@react-aria/utils\";\nimport $9BxnE$react, {useState as $9BxnE$useState, useMemo as $9BxnE$useMemo} from \"react\";\nimport {useFocusWithin as $9BxnE$useFocusWithin} from \"@react-aria/interactions\";\n\n\n\n\nconst $5c3e21d68f1c4674$var$styles = {\n    border: 0,\n    clip: 'rect(0 0 0 0)',\n    clipPath: 'inset(50%)',\n    height: 1,\n    margin: '0 -1px -1px 0',\n    overflow: 'hidden',\n    padding: 0,\n    position: 'absolute',\n    width: 1,\n    whiteSpace: 'nowrap'\n};\nfunction $5c3e21d68f1c4674$export$a966af930f325cab(props = {\n}) {\n    let { style: style , isFocusable: isFocusable  } = props;\n    let [isFocused, setFocused] = $9BxnE$useState(false);\n    let { focusWithinProps: focusWithinProps  } = $9BxnE$useFocusWithin({\n        isDisabled: !isFocusable,\n        onFocusWithinChange: (val)=>setFocused(val)\n    });\n    // If focused, don't hide the element.\n    let combinedStyles = $9BxnE$useMemo(()=>{\n        if (isFocused) return style;\n        else if (style) return {\n            ...$5c3e21d68f1c4674$var$styles,\n            ...style\n        };\n        else return $5c3e21d68f1c4674$var$styles;\n    }, [\n        isFocused\n    ]);\n    return {\n        visuallyHiddenProps: {\n            ...focusWithinProps,\n            style: combinedStyles\n        }\n    };\n}\nfunction $5c3e21d68f1c4674$export$439d29a4e110a164(props) {\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    let { children: children , elementType: Element = 'div' , isFocusable: isFocusable , style: style , ...otherProps } = props;\n    let { visuallyHiddenProps: visuallyHiddenProps  } = $5c3e21d68f1c4674$export$a966af930f325cab(props);\n    return(/*#__PURE__*/ $9BxnE$react.createElement(Element, $9BxnE$mergeProps(otherProps, visuallyHiddenProps), children));\n}\n\n\n\n\nexport {$5c3e21d68f1c4674$export$a966af930f325cab as useVisuallyHidden, $5c3e21d68f1c4674$export$439d29a4e110a164 as VisuallyHidden};\n//# sourceMappingURL=module.js.map\n","import { fontFace } from '@fluentui/merge-styles';\nimport { FontWeights, LocalizedFontFamilies, LocalizedFontNames } from './FluentFonts';\nimport { createFontStyles } from './createFontStyles';\nimport { getLanguage, getWindow } from '@fluentui/utilities';\n// Default urls.\nvar DefaultBaseUrl = 'https://res-1.cdn.office.net/files/fabric-cdn-prod_20230815.002/assets';\n// Standard font styling.\nexport var DefaultFontStyles = createFontStyles(getLanguage());\nfunction _registerFontFace(fontFamily, url, fontWeight, localFontName) {\n    fontFamily = \"'\".concat(fontFamily, \"'\");\n    var localFontSrc = localFontName !== undefined ? \"local('\".concat(localFontName, \"'),\") : '';\n    fontFace({\n        fontFamily: fontFamily,\n        src: localFontSrc + \"url('\".concat(url, \".woff2') format('woff2'),\") + \"url('\".concat(url, \".woff') format('woff')\"),\n        fontWeight: fontWeight,\n        fontStyle: 'normal',\n        fontDisplay: 'swap',\n    });\n}\nfunction _registerFontFaceSet(baseUrl, fontFamily, cdnFolder, cdnFontName, localFontName) {\n    if (cdnFontName === void 0) { cdnFontName = 'segoeui'; }\n    var urlBase = \"\".concat(baseUrl, \"/\").concat(cdnFolder, \"/\").concat(cdnFontName);\n    _registerFontFace(fontFamily, urlBase + '-light', FontWeights.light, localFontName && localFontName + ' Light');\n    _registerFontFace(fontFamily, urlBase + '-semilight', FontWeights.semilight, localFontName && localFontName + ' SemiLight');\n    _registerFontFace(fontFamily, urlBase + '-regular', FontWeights.regular, localFontName);\n    _registerFontFace(fontFamily, urlBase + '-semibold', FontWeights.semibold, localFontName && localFontName + ' SemiBold');\n    _registerFontFace(fontFamily, urlBase + '-bold', FontWeights.bold, localFontName && localFontName + ' Bold');\n}\nexport function registerDefaultFontFaces(baseUrl) {\n    if (baseUrl) {\n        var fontUrl = \"\".concat(baseUrl, \"/fonts\");\n        // Produce @font-face definitions for all supported web fonts.\n        _registerFontFaceSet(fontUrl, LocalizedFontNames.Thai, 'leelawadeeui-thai', 'leelawadeeui');\n        _registerFontFaceSet(fontUrl, LocalizedFontNames.Arabic, 'segoeui-arabic');\n        _registerFontFaceSet(fontUrl, LocalizedFontNames.Cyrillic, 'segoeui-cyrillic');\n        _registerFontFaceSet(fontUrl, LocalizedFontNames.EastEuropean, 'segoeui-easteuropean');\n        _registerFontFaceSet(fontUrl, LocalizedFontNames.Greek, 'segoeui-greek');\n        _registerFontFaceSet(fontUrl, LocalizedFontNames.Hebrew, 'segoeui-hebrew');\n        _registerFontFaceSet(fontUrl, LocalizedFontNames.Vietnamese, 'segoeui-vietnamese');\n        _registerFontFaceSet(fontUrl, LocalizedFontNames.WestEuropean, 'segoeui-westeuropean', 'segoeui', 'Segoe UI');\n        _registerFontFaceSet(fontUrl, LocalizedFontFamilies.Selawik, 'selawik', 'selawik');\n        _registerFontFaceSet(fontUrl, LocalizedFontNames.Armenian, 'segoeui-armenian');\n        _registerFontFaceSet(fontUrl, LocalizedFontNames.Georgian, 'segoeui-georgian');\n        // Leelawadee UI (Thai) does not have a 'light' weight, so we override\n        // the font-face generated above to use the 'semilight' weight instead.\n        _registerFontFace('Leelawadee UI Web', \"\".concat(fontUrl, \"/leelawadeeui-thai/leelawadeeui-semilight\"), FontWeights.light);\n        // Leelawadee UI (Thai) does not have a 'semibold' weight, so we override\n        // the font-face generated above to use the 'bold' weight instead.\n        _registerFontFace('Leelawadee UI Web', \"\".concat(fontUrl, \"/leelawadeeui-thai/leelawadeeui-bold\"), FontWeights.semibold);\n    }\n}\n/**\n * Reads the fontBaseUrl from window.FabricConfig.fontBaseUrl or falls back to a default.\n */\nfunction _getFontBaseUrl() {\n    var _a, _b;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    var fabricConfig = (_a = getWindow()) === null || _a === void 0 ? void 0 : _a.FabricConfig;\n    return (_b = fabricConfig === null || fabricConfig === void 0 ? void 0 : fabricConfig.fontBaseUrl) !== null && _b !== void 0 ? _b : DefaultBaseUrl;\n}\n/**\n * Register the font faces.\n */\nregisterDefaultFontFaces(_getFontBaseUrl());\n//# sourceMappingURL=DefaultFontStyles.js.map","// schema-list/index.ts\nexport * from \"prosemirror-schema-list\";\n","// ::- Persistent data structure representing an ordered mapping from\n// strings to values, with some convenient update methods.\nfunction OrderedMap(content) {\n  this.content = content;\n}\n\nOrderedMap.prototype = {\n  constructor: OrderedMap,\n\n  find: function(key) {\n    for (var i = 0; i < this.content.length; i += 2)\n      if (this.content[i] === key) return i\n    return -1\n  },\n\n  // :: (string)  ?any\n  // Retrieve the value stored under `key`, or return undefined when\n  // no such key exists.\n  get: function(key) {\n    var found = this.find(key);\n    return found == -1 ? undefined : this.content[found + 1]\n  },\n\n  // :: (string, any, ?string)  OrderedMap\n  // Create a new map by replacing the value of `key` with a new\n  // value, or adding a binding to the end of the map. If `newKey` is\n  // given, the key of the binding will be replaced with that key.\n  update: function(key, value, newKey) {\n    var self = newKey && newKey != key ? this.remove(newKey) : this;\n    var found = self.find(key), content = self.content.slice();\n    if (found == -1) {\n      content.push(newKey || key, value);\n    } else {\n      content[found + 1] = value;\n      if (newKey) content[found] = newKey;\n    }\n    return new OrderedMap(content)\n  },\n\n  // :: (string)  OrderedMap\n  // Return a map with the given key removed, if it existed.\n  remove: function(key) {\n    var found = this.find(key);\n    if (found == -1) return this\n    var content = this.content.slice();\n    content.splice(found, 2);\n    return new OrderedMap(content)\n  },\n\n  // :: (string, any)  OrderedMap\n  // Add a new key to the start of the map.\n  addToStart: function(key, value) {\n    return new OrderedMap([key, value].concat(this.remove(key).content))\n  },\n\n  // :: (string, any)  OrderedMap\n  // Add a new key to the end of the map.\n  addToEnd: function(key, value) {\n    var content = this.remove(key).content.slice();\n    content.push(key, value);\n    return new OrderedMap(content)\n  },\n\n  // :: (string, string, any)  OrderedMap\n  // Add a key after the given key. If `place` is not found, the new\n  // key is added to the end.\n  addBefore: function(place, key, value) {\n    var without = this.remove(key), content = without.content.slice();\n    var found = without.find(place);\n    content.splice(found == -1 ? content.length : found, 0, key, value);\n    return new OrderedMap(content)\n  },\n\n  // :: ((key: string, value: any))\n  // Call the given function for each key/value pair in the map, in\n  // order.\n  forEach: function(f) {\n    for (var i = 0; i < this.content.length; i += 2)\n      f(this.content[i], this.content[i + 1]);\n  },\n\n  // :: (union<Object, OrderedMap>)  OrderedMap\n  // Create a new map by prepending the keys in this map that don't\n  // appear in `map` before the keys in `map`.\n  prepend: function(map) {\n    map = OrderedMap.from(map);\n    if (!map.size) return this\n    return new OrderedMap(map.content.concat(this.subtract(map).content))\n  },\n\n  // :: (union<Object, OrderedMap>)  OrderedMap\n  // Create a new map by appending the keys in this map that don't\n  // appear in `map` after the keys in `map`.\n  append: function(map) {\n    map = OrderedMap.from(map);\n    if (!map.size) return this\n    return new OrderedMap(this.subtract(map).content.concat(map.content))\n  },\n\n  // :: (union<Object, OrderedMap>)  OrderedMap\n  // Create a map containing all the keys in this map that don't\n  // appear in `map`.\n  subtract: function(map) {\n    var result = this;\n    map = OrderedMap.from(map);\n    for (var i = 0; i < map.content.length; i += 2)\n      result = result.remove(map.content[i]);\n    return result\n  },\n\n  // :: ()  Object\n  // Turn ordered map into a plain object.\n  toObject: function() {\n    var result = {};\n    this.forEach(function(key, value) { result[key] = value; });\n    return result\n  },\n\n  // :: number\n  // The amount of keys in this map.\n  get size() {\n    return this.content.length >> 1\n  }\n};\n\n// :: (?union<Object, OrderedMap>)  OrderedMap\n// Return a map with the given content. If null, create an empty\n// map. If given an ordered map, return that map itself. If given an\n// object, create a map from the object's properties.\nOrderedMap.from = function(value) {\n  if (value instanceof OrderedMap) return value\n  var content = [];\n  if (value) for (var prop in value) content.push(prop, value[prop]);\n  return new OrderedMap(content)\n};\n\nexport default OrderedMap;\n","/** PURE_IMPORTS_START tslib,_Subscription PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Subscription } from './Subscription';\nvar SubjectSubscription = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(SubjectSubscription, _super);\n    function SubjectSubscription(subject, subscriber) {\n        var _this = _super.call(this) || this;\n        _this.subject = subject;\n        _this.subscriber = subscriber;\n        _this.closed = false;\n        return _this;\n    }\n    SubjectSubscription.prototype.unsubscribe = function () {\n        if (this.closed) {\n            return;\n        }\n        this.closed = true;\n        var subject = this.subject;\n        var observers = subject.observers;\n        this.subject = null;\n        if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {\n            return;\n        }\n        var subscriberIndex = observers.indexOf(this.subscriber);\n        if (subscriberIndex !== -1) {\n            observers.splice(subscriberIndex, 1);\n        }\n    };\n    return SubjectSubscription;\n}(Subscription));\nexport { SubjectSubscription };\n//# sourceMappingURL=SubjectSubscription.js.map\n","export default /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;","function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}\nmodule.exports = _arrayLikeToArray, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","import getWindow from \"./getWindow.js\";\nexport default function getWindowScroll(node) {\n  var win = getWindow(node);\n  var scrollLeft = win.pageXOffset;\n  var scrollTop = win.pageYOffset;\n  return {\n    scrollLeft: scrollLeft,\n    scrollTop: scrollTop\n  };\n}","import { DefaultPalette } from './colors/index';\nimport { DefaultEffects } from './effects/index';\nimport { DefaultFontStyles } from './fonts/index';\nimport { mergeThemes } from './mergeThemes';\nimport { DefaultSpacing } from './spacing/index';\nimport { makeSemanticColors } from './utilities/makeSemanticColors';\n/**\n * Creates a custom theme definition.\n * @param theme - Partial theme object.\n * @param depComments - Whether to include deprecated tags as comments for deprecated slots.\n */\nexport function createTheme(theme, depComments) {\n    if (theme === void 0) { theme = {}; }\n    if (depComments === void 0) { depComments = false; }\n    var isInverted = !!theme.isInverted;\n    var baseTheme = {\n        palette: DefaultPalette,\n        effects: DefaultEffects,\n        fonts: DefaultFontStyles,\n        spacing: DefaultSpacing,\n        isInverted: isInverted,\n        disableGlobalClassNames: false,\n        semanticColors: makeSemanticColors(DefaultPalette, DefaultEffects, undefined, isInverted, depComments),\n        rtl: undefined,\n    };\n    return mergeThemes(baseTheme, theme);\n}\n//# sourceMappingURL=createTheme.js.map","import { keyframes } from '@fluentui/merge-styles';\nvar fadeInAnimationName = keyframes({\n    from: { opacity: 0 },\n    to: { opacity: 1 },\n});\nvar fadeOutAnimationName = keyframes({\n    from: { opacity: 1 },\n    to: { opacity: 0 },\n});\nvar scaleDownInAnimationName = keyframes({\n    from: { transform: 'scale3d(1.15, 1.15, 1)' },\n    to: { transform: 'scale3d(1, 1, 1)' },\n});\nvar scaleDownOutAnimationName = keyframes({\n    from: { transform: 'scale3d(1, 1, 1)' },\n    to: { transform: 'scale3d(0.9, 0.9, 1)' },\n});\nvar slideLeftOutAnimationName = keyframes({\n    from: { transform: 'translate3d(0, 0, 0)' },\n    to: { transform: 'translate3d(-48px, 0, 0)' },\n});\nvar slideRightOutAnimationName = keyframes({\n    from: { transform: 'translate3d(0, 0, 0)' },\n    to: { transform: 'translate3d(48px, 0, 0)' },\n});\nvar slideLeftInAnimationName = keyframes({\n    from: { transform: 'translate3d(48px, 0, 0)' },\n    to: { transform: 'translate3d(0, 0, 0)' },\n});\nvar slideRightInAnimationName = keyframes({\n    from: { transform: 'translate3d(-48px, 0, 0)' },\n    to: { transform: 'translate3d(0, 0, 0)' },\n});\nvar slideUpOutAnimationName = keyframes({\n    from: { transform: 'translate3d(0, 0, 0)' },\n    to: { transform: 'translate3d(0, -48px, 0)' },\n});\nvar slideDownOutAnimationName = keyframes({\n    from: { transform: 'translate3d(0, 0, 0)' },\n    to: { transform: 'translate3d(0, 48px, 0)' },\n});\nvar slideUpInAnimationName = keyframes({\n    from: { transform: 'translate3d(0, 48px, 0)' },\n    to: { transform: 'translate3d(0, 0, 0)' },\n});\nvar slideDownInAnimationName = keyframes({\n    from: { transform: 'translate3d(0, -48px, 0)' },\n    to: { transform: 'translate3d(0, 0, 0)' },\n});\nexport var MotionDurations;\n(function (MotionDurations) {\n    MotionDurations.duration1 = '100ms';\n    MotionDurations.duration2 = '200ms';\n    MotionDurations.duration3 = '300ms';\n    MotionDurations.duration4 = '400ms';\n})(MotionDurations || (MotionDurations = {}));\nexport var MotionTimings;\n(function (MotionTimings) {\n    MotionTimings.accelerate = 'cubic-bezier(0.9, 0.1, 1, 0.2)';\n    MotionTimings.decelerate = 'cubic-bezier(0.1, 0.9, 0.2, 1)';\n    MotionTimings.linear = 'cubic-bezier(0, 0, 1, 1)';\n    MotionTimings.standard = 'cubic-bezier(0.8, 0, 0.2, 1)';\n})(MotionTimings || (MotionTimings = {}));\nfunction _createAnimation(animationName, animationDuration, animationTimingFunction) {\n    return \"\".concat(animationName, \" \").concat(animationDuration, \" \").concat(animationTimingFunction);\n}\nexport var MotionAnimations;\n(function (MotionAnimations) {\n    MotionAnimations.fadeIn = _createAnimation(fadeInAnimationName, MotionDurations.duration1, MotionTimings.linear);\n    MotionAnimations.fadeOut = _createAnimation(fadeOutAnimationName, MotionDurations.duration1, MotionTimings.linear);\n    MotionAnimations.scaleDownIn = _createAnimation(scaleDownInAnimationName, MotionDurations.duration3, MotionTimings.decelerate);\n    MotionAnimations.scaleDownOut = _createAnimation(scaleDownOutAnimationName, MotionDurations.duration3, MotionTimings.decelerate);\n    MotionAnimations.slideLeftOut = _createAnimation(slideLeftOutAnimationName, MotionDurations.duration1, MotionTimings.accelerate);\n    MotionAnimations.slideRightOut = _createAnimation(slideRightOutAnimationName, MotionDurations.duration1, MotionTimings.accelerate);\n    MotionAnimations.slideLeftIn = _createAnimation(slideLeftInAnimationName, MotionDurations.duration1, MotionTimings.decelerate);\n    MotionAnimations.slideRightIn = _createAnimation(slideRightInAnimationName, MotionDurations.duration1, MotionTimings.decelerate);\n    MotionAnimations.slideUpOut = _createAnimation(slideUpOutAnimationName, MotionDurations.duration1, MotionTimings.accelerate);\n    MotionAnimations.slideDownOut = _createAnimation(slideDownOutAnimationName, MotionDurations.duration1, MotionTimings.accelerate);\n    MotionAnimations.slideUpIn = _createAnimation(slideUpInAnimationName, MotionDurations.duration1, MotionTimings.decelerate);\n    MotionAnimations.slideDownIn = _createAnimation(slideDownInAnimationName, MotionDurations.duration1, MotionTimings.decelerate);\n})(MotionAnimations || (MotionAnimations = {}));\n//# sourceMappingURL=FluentMotion.js.map","var _a;\nvar LEFT = 'left';\nvar RIGHT = 'right';\nvar NO_FLIP = '@noflip';\nvar NAME_REPLACEMENTS = (_a = {},\n    _a[LEFT] = RIGHT,\n    _a[RIGHT] = LEFT,\n    _a);\nvar VALUE_REPLACEMENTS = {\n    'w-resize': 'e-resize',\n    'sw-resize': 'se-resize',\n    'nw-resize': 'ne-resize',\n};\n/**\n * RTLifies the rulePair in the array at the current index. This mutates the array for performance\n * reasons.\n */\nexport function rtlifyRules(options, rulePairs, index) {\n    if (options.rtl) {\n        var name_1 = rulePairs[index];\n        if (!name_1) {\n            return;\n        }\n        var value = rulePairs[index + 1];\n        if (typeof value === 'string' && value.indexOf(NO_FLIP) >= 0) {\n            rulePairs[index + 1] = value.replace(/\\s*(?:\\/\\*\\s*)?\\@noflip\\b(?:\\s*\\*\\/)?\\s*?/g, '');\n        }\n        else if (name_1.indexOf(LEFT) >= 0) {\n            rulePairs[index] = name_1.replace(LEFT, RIGHT);\n        }\n        else if (name_1.indexOf(RIGHT) >= 0) {\n            rulePairs[index] = name_1.replace(RIGHT, LEFT);\n        }\n        else if (String(value).indexOf(LEFT) >= 0) {\n            rulePairs[index + 1] = value.replace(LEFT, RIGHT);\n        }\n        else if (String(value).indexOf(RIGHT) >= 0) {\n            rulePairs[index + 1] = value.replace(RIGHT, LEFT);\n        }\n        else if (NAME_REPLACEMENTS[name_1]) {\n            rulePairs[index] = NAME_REPLACEMENTS[name_1];\n        }\n        else if (VALUE_REPLACEMENTS[value]) {\n            rulePairs[index + 1] = VALUE_REPLACEMENTS[value];\n        }\n        else {\n            switch (name_1) {\n                case 'margin':\n                case 'padding':\n                    rulePairs[index + 1] = flipQuad(value);\n                    break;\n                case 'box-shadow':\n                    rulePairs[index + 1] = negateNum(value, 0);\n                    break;\n            }\n        }\n    }\n}\n/**\n * Given a string value in a space delimited format (e.g. \"1 2 3 4\"), negates a particular value.\n */\nfunction negateNum(value, partIndex) {\n    var parts = value.split(' ');\n    var numberVal = parseInt(parts[partIndex], 10);\n    parts[0] = parts[0].replace(String(numberVal), String(numberVal * -1));\n    return parts.join(' ');\n}\n/**\n * Given a string quad, flips the left and right values.\n */\nfunction flipQuad(value) {\n    if (typeof value === 'string') {\n        var parts = value.split(' ');\n        if (parts.length === 4) {\n            return \"\".concat(parts[0], \" \").concat(parts[3], \" \").concat(parts[2], \" \").concat(parts[1]);\n        }\n    }\n    return value;\n}\n//# sourceMappingURL=rtlifyRules.js.map","import { keyName, base } from 'w3c-keyname';\nimport { Plugin } from 'prosemirror-state';\n\nconst mac = typeof navigator != \"undefined\" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : false;\nfunction normalizeKeyName(name) {\n    let parts = name.split(/-(?!$)/), result = parts[parts.length - 1];\n    if (result == \"Space\")\n        result = \" \";\n    let alt, ctrl, shift, meta;\n    for (let i = 0; i < parts.length - 1; i++) {\n        let mod = parts[i];\n        if (/^(cmd|meta|m)$/i.test(mod))\n            meta = true;\n        else if (/^a(lt)?$/i.test(mod))\n            alt = true;\n        else if (/^(c|ctrl|control)$/i.test(mod))\n            ctrl = true;\n        else if (/^s(hift)?$/i.test(mod))\n            shift = true;\n        else if (/^mod$/i.test(mod)) {\n            if (mac)\n                meta = true;\n            else\n                ctrl = true;\n        }\n        else\n            throw new Error(\"Unrecognized modifier name: \" + mod);\n    }\n    if (alt)\n        result = \"Alt-\" + result;\n    if (ctrl)\n        result = \"Ctrl-\" + result;\n    if (meta)\n        result = \"Meta-\" + result;\n    if (shift)\n        result = \"Shift-\" + result;\n    return result;\n}\nfunction normalize(map) {\n    let copy = Object.create(null);\n    for (let prop in map)\n        copy[normalizeKeyName(prop)] = map[prop];\n    return copy;\n}\nfunction modifiers(name, event, shift = true) {\n    if (event.altKey)\n        name = \"Alt-\" + name;\n    if (event.ctrlKey)\n        name = \"Ctrl-\" + name;\n    if (event.metaKey)\n        name = \"Meta-\" + name;\n    if (shift && event.shiftKey)\n        name = \"Shift-\" + name;\n    return name;\n}\n/**\nCreate a keymap plugin for the given set of bindings.\n\nBindings should map key names to [command](https://prosemirror.net/docs/ref/#commands)-style\nfunctions, which will be called with `(EditorState, dispatch,\nEditorView)` arguments, and should return true when they've handled\nthe key. Note that the view argument isn't part of the command\nprotocol, but can be used as an escape hatch if a binding needs to\ndirectly interact with the UI.\n\nKey names may be strings like `\"Shift-Ctrl-Enter\"`a key\nidentifier prefixed with zero or more modifiers. Key identifiers\nare based on the strings that can appear in\n[`KeyEvent.key`](https:developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key).\nUse lowercase letters to refer to letter keys (or uppercase letters\nif you want shift to be held). You may use `\"Space\"` as an alias\nfor the `\" \"` name.\n\nModifiers can be given in any order. `Shift-` (or `s-`), `Alt-` (or\n`a-`), `Ctrl-` (or `c-` or `Control-`) and `Cmd-` (or `m-` or\n`Meta-`) are recognized. For characters that are created by holding\nshift, the `Shift-` prefix is implied, and should not be added\nexplicitly.\n\nYou can use `Mod-` as a shorthand for `Cmd-` on Mac and `Ctrl-` on\nother platforms.\n\nYou can add multiple keymap plugins to an editor. The order in\nwhich they appear determines their precedence (the ones early in\nthe array get to dispatch first).\n*/\nfunction keymap(bindings) {\n    return new Plugin({ props: { handleKeyDown: keydownHandler(bindings) } });\n}\n/**\nGiven a set of bindings (using the same format as\n[`keymap`](https://prosemirror.net/docs/ref/#keymap.keymap)), return a [keydown\nhandler](https://prosemirror.net/docs/ref/#view.EditorProps.handleKeyDown) that handles them.\n*/\nfunction keydownHandler(bindings) {\n    let map = normalize(bindings);\n    return function (view, event) {\n        let name = keyName(event), baseName, direct = map[modifiers(name, event)];\n        if (direct && direct(view.state, view.dispatch, view))\n            return true;\n        // A character key\n        if (name.length == 1 && name != \" \") {\n            if (event.shiftKey) {\n                // In case the name was already modified by shift, try looking\n                // it up without its shift modifier\n                let noShift = map[modifiers(name, event, false)];\n                if (noShift && noShift(view.state, view.dispatch, view))\n                    return true;\n            }\n            if ((event.shiftKey || event.altKey || event.metaKey || name.charCodeAt(0) > 127) &&\n                (baseName = base[event.keyCode]) && baseName != name) {\n                // Try falling back to the keyCode when there's a modifier\n                // active or the character produced isn't ASCII, and our table\n                // produces a different name from the the keyCode. See #668,\n                // #1060\n                let fromCode = map[modifiers(baseName, event)];\n                if (fromCode && fromCode(view.state, view.dispatch, view))\n                    return true;\n            }\n        }\n        return false;\n    };\n}\n\nexport { keydownHandler, keymap };\n","var isPoint = function (point) {\n    return point.hasOwnProperty('x') && point.hasOwnProperty('y');\n};\n\nexport { isPoint };\n","/** PURE_IMPORTS_START  PURE_IMPORTS_END */\nexport function identity(x) {\n    return x;\n}\n//# sourceMappingURL=identity.js.map\n","import { progress } from './progress.js';\nimport { mix } from './mix.js';\nimport { mixColor } from './mix-color.js';\nimport { mixComplex, mixArray, mixObject } from './mix-complex.js';\nimport { color } from 'style-value-types';\nimport { clamp } from './clamp.js';\nimport { pipe } from './pipe.js';\nimport { invariant } from 'hey-listen';\n\nvar mixNumber = function (from, to) { return function (p) { return mix(from, to, p); }; };\nfunction detectMixerFactory(v) {\n    if (typeof v === 'number') {\n        return mixNumber;\n    }\n    else if (typeof v === 'string') {\n        if (color.test(v)) {\n            return mixColor;\n        }\n        else {\n            return mixComplex;\n        }\n    }\n    else if (Array.isArray(v)) {\n        return mixArray;\n    }\n    else if (typeof v === 'object') {\n        return mixObject;\n    }\n}\nfunction createMixers(output, ease, customMixer) {\n    var mixers = [];\n    var mixerFactory = customMixer || detectMixerFactory(output[0]);\n    var numMixers = output.length - 1;\n    for (var i = 0; i < numMixers; i++) {\n        var mixer = mixerFactory(output[i], output[i + 1]);\n        if (ease) {\n            var easingFunction = Array.isArray(ease) ? ease[i] : ease;\n            mixer = pipe(easingFunction, mixer);\n        }\n        mixers.push(mixer);\n    }\n    return mixers;\n}\nfunction fastInterpolate(_a, _b) {\n    var from = _a[0], to = _a[1];\n    var mixer = _b[0];\n    return function (v) { return mixer(progress(from, to, v)); };\n}\nfunction slowInterpolate(input, mixers) {\n    var inputLength = input.length;\n    var lastInputIndex = inputLength - 1;\n    return function (v) {\n        var mixerIndex = 0;\n        var foundMixerIndex = false;\n        if (v <= input[0]) {\n            foundMixerIndex = true;\n        }\n        else if (v >= input[lastInputIndex]) {\n            mixerIndex = lastInputIndex - 1;\n            foundMixerIndex = true;\n        }\n        if (!foundMixerIndex) {\n            var i = 1;\n            for (; i < inputLength; i++) {\n                if (input[i] > v || i === lastInputIndex) {\n                    break;\n                }\n            }\n            mixerIndex = i - 1;\n        }\n        var progressInRange = progress(input[mixerIndex], input[mixerIndex + 1], v);\n        return mixers[mixerIndex](progressInRange);\n    };\n}\nfunction interpolate(input, output, _a) {\n    var _b = _a === void 0 ? {} : _a, _c = _b.clamp, isClamp = _c === void 0 ? true : _c, ease = _b.ease, mixer = _b.mixer;\n    var inputLength = input.length;\n    invariant(inputLength === output.length, 'Both input and output ranges must be the same length');\n    invariant(!ease || !Array.isArray(ease) || ease.length === inputLength - 1, 'Array of easing functions must be of length `input.length - 1`, as it applies to the transitions **between** the defined values.');\n    if (input[0] > input[inputLength - 1]) {\n        input = [].concat(input);\n        output = [].concat(output);\n        input.reverse();\n        output.reverse();\n    }\n    var mixers = createMixers(output, ease, mixer);\n    var interpolator = inputLength === 2\n        ? fastInterpolate(input, mixers)\n        : slowInterpolate(input, mixers);\n    return isClamp\n        ? function (v) { return interpolator(clamp(input[0], input[inputLength - 1], v)); }\n        : interpolator;\n}\n\nexport { interpolate };\n","function e(e){this.message=e}e.prototype=new Error,e.prototype.name=\"InvalidCharacterError\";var r=\"undefined\"!=typeof window&&window.atob&&window.atob.bind(window)||function(r){var t=String(r).replace(/=+$/,\"\");if(t.length%4==1)throw new e(\"'atob' failed: The string to be decoded is not correctly encoded.\");for(var n,o,a=0,i=0,c=\"\";o=t.charAt(i++);~o&&(n=a%4?64*n+o:o,a++%4)?c+=String.fromCharCode(255&n>>(-2*a&6)):0)o=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\".indexOf(o);return c};function t(e){var t=e.replace(/-/g,\"+\").replace(/_/g,\"/\");switch(t.length%4){case 0:break;case 2:t+=\"==\";break;case 3:t+=\"=\";break;default:throw\"Illegal base64url string!\"}try{return function(e){return decodeURIComponent(r(e).replace(/(.)/g,(function(e,r){var t=r.charCodeAt(0).toString(16).toUpperCase();return t.length<2&&(t=\"0\"+t),\"%\"+t})))}(t)}catch(e){return r(t)}}function n(e){this.message=e}function o(e,r){if(\"string\"!=typeof e)throw new n(\"Invalid token specified\");var o=!0===(r=r||{}).header?0:1;try{return JSON.parse(t(e.split(\".\")[o]))}catch(e){throw new n(\"Invalid token specified: \"+e.message)}}n.prototype=new Error,n.prototype.name=\"InvalidTokenError\";export default o;export{n as InvalidTokenError};\n//# sourceMappingURL=jwt-decode.esm.js.map\n","import { __assign } from \"tslib\";\n/** Generates all the semantic slot colors based on the theme so far\n * We'll use these as fallbacks for semantic slots that the passed in theme did not define.\n * The caller must still mix in the customized semantic slots at the end.\n */\nexport function makeSemanticColors(p, e, s, isInverted, depComments) {\n    if (depComments === void 0) { depComments = false; }\n    var semanticColors = __assign({ primaryButtonBorder: 'transparent', errorText: !isInverted ? '#a4262c' : '#F1707B', messageText: !isInverted ? '#323130' : '#F3F2F1', messageLink: !isInverted ? '#005A9E' : '#6CB8F6', messageLinkHovered: !isInverted ? '#004578' : '#82C7FF', infoIcon: !isInverted ? '#605e5c' : '#C8C6C4', errorIcon: !isInverted ? '#A80000' : '#F1707B', blockingIcon: !isInverted ? '#FDE7E9' : '#442726', warningIcon: !isInverted ? '#797775' : '#C8C6C4', severeWarningIcon: !isInverted ? '#D83B01' : '#FCE100', successIcon: !isInverted ? '#107C10' : '#92C353', infoBackground: !isInverted ? '#f3f2f1' : '#323130', errorBackground: !isInverted ? '#FDE7E9' : '#442726', blockingBackground: !isInverted ? '#FDE7E9' : '#442726', warningBackground: !isInverted ? '#FFF4CE' : '#433519', severeWarningBackground: !isInverted ? '#FED9CC' : '#4F2A0F', successBackground: !isInverted ? '#DFF6DD' : '#393D1B', \n        // deprecated\n        warningHighlight: !isInverted ? '#ffb900' : '#fff100', successText: !isInverted ? '#107C10' : '#92c353' }, s);\n    var fullSemanticColors = getSemanticColors(p, e, semanticColors, isInverted);\n    return _fixDeprecatedSlots(fullSemanticColors, depComments);\n}\n/**\n * Map partial platte and effects to partial semantic colors.\n */\nexport function getSemanticColors(p, e, s, isInverted, depComments) {\n    if (depComments === void 0) { depComments = false; }\n    var result = {};\n    // map palette\n    var _a = p || {}, white = _a.white, black = _a.black, themePrimary = _a.themePrimary, themeDark = _a.themeDark, themeDarker = _a.themeDarker, themeDarkAlt = _a.themeDarkAlt, themeLighter = _a.themeLighter, neutralLight = _a.neutralLight, neutralLighter = _a.neutralLighter, neutralDark = _a.neutralDark, neutralQuaternary = _a.neutralQuaternary, neutralQuaternaryAlt = _a.neutralQuaternaryAlt, neutralPrimary = _a.neutralPrimary, neutralSecondary = _a.neutralSecondary, neutralSecondaryAlt = _a.neutralSecondaryAlt, neutralTertiary = _a.neutralTertiary, neutralTertiaryAlt = _a.neutralTertiaryAlt, neutralLighterAlt = _a.neutralLighterAlt, accent = _a.accent;\n    if (white) {\n        result.bodyBackground = white;\n        result.bodyFrameBackground = white;\n        result.accentButtonText = white;\n        result.buttonBackground = white;\n        result.primaryButtonText = white;\n        result.primaryButtonTextHovered = white;\n        result.primaryButtonTextPressed = white;\n        result.inputBackground = white;\n        result.inputForegroundChecked = white;\n        result.listBackground = white;\n        result.menuBackground = white;\n        result.cardStandoutBackground = white;\n    }\n    if (black) {\n        result.bodyTextChecked = black;\n        result.buttonTextCheckedHovered = black;\n    }\n    if (themePrimary) {\n        result.link = themePrimary;\n        result.primaryButtonBackground = themePrimary;\n        result.inputBackgroundChecked = themePrimary;\n        result.inputIcon = themePrimary;\n        result.inputFocusBorderAlt = themePrimary;\n        result.menuIcon = themePrimary;\n        result.menuHeader = themePrimary;\n        result.accentButtonBackground = themePrimary;\n    }\n    if (themeDark) {\n        result.primaryButtonBackgroundPressed = themeDark;\n        result.inputBackgroundCheckedHovered = themeDark;\n        result.inputIconHovered = themeDark;\n    }\n    if (themeDarker) {\n        result.linkHovered = themeDarker;\n    }\n    if (themeDarkAlt) {\n        result.primaryButtonBackgroundHovered = themeDarkAlt;\n    }\n    if (themeLighter) {\n        result.inputPlaceholderBackgroundChecked = themeLighter;\n    }\n    if (neutralLight) {\n        result.bodyBackgroundChecked = neutralLight;\n        result.bodyFrameDivider = neutralLight;\n        result.bodyDivider = neutralLight;\n        result.variantBorder = neutralLight;\n        result.buttonBackgroundCheckedHovered = neutralLight;\n        result.buttonBackgroundPressed = neutralLight;\n        result.listItemBackgroundChecked = neutralLight;\n        result.listHeaderBackgroundPressed = neutralLight;\n        result.menuItemBackgroundPressed = neutralLight;\n        // eslint-disable-next-line deprecation/deprecation\n        result.menuItemBackgroundChecked = neutralLight;\n    }\n    if (neutralLighter) {\n        result.bodyBackgroundHovered = neutralLighter;\n        result.buttonBackgroundHovered = neutralLighter;\n        result.buttonBackgroundDisabled = neutralLighter;\n        result.buttonBorderDisabled = neutralLighter;\n        result.primaryButtonBackgroundDisabled = neutralLighter;\n        result.disabledBackground = neutralLighter;\n        result.listItemBackgroundHovered = neutralLighter;\n        result.listHeaderBackgroundHovered = neutralLighter;\n        result.menuItemBackgroundHovered = neutralLighter;\n    }\n    if (neutralQuaternary) {\n        result.primaryButtonTextDisabled = neutralQuaternary;\n        result.disabledSubtext = neutralQuaternary;\n    }\n    if (neutralQuaternaryAlt) {\n        result.listItemBackgroundCheckedHovered = neutralQuaternaryAlt;\n    }\n    if (neutralTertiary) {\n        result.disabledBodyText = neutralTertiary;\n        result.variantBorderHovered = (s === null || s === void 0 ? void 0 : s.variantBorderHovered) || neutralTertiary;\n        result.buttonTextDisabled = neutralTertiary;\n        result.inputIconDisabled = neutralTertiary;\n        result.disabledText = neutralTertiary;\n    }\n    if (neutralPrimary) {\n        result.bodyText = neutralPrimary;\n        result.actionLink = neutralPrimary;\n        result.buttonText = neutralPrimary;\n        result.inputBorderHovered = neutralPrimary;\n        result.inputText = neutralPrimary;\n        result.listText = neutralPrimary;\n        result.menuItemText = neutralPrimary;\n    }\n    if (neutralLighterAlt) {\n        result.bodyStandoutBackground = neutralLighterAlt;\n        result.defaultStateBackground = neutralLighterAlt;\n    }\n    if (neutralDark) {\n        result.actionLinkHovered = neutralDark;\n        result.buttonTextHovered = neutralDark;\n        result.buttonTextChecked = neutralDark;\n        result.buttonTextPressed = neutralDark;\n        result.inputTextHovered = neutralDark;\n        result.menuItemTextHovered = neutralDark;\n    }\n    if (neutralSecondary) {\n        result.bodySubtext = neutralSecondary;\n        result.focusBorder = neutralSecondary;\n        result.inputBorder = neutralSecondary;\n        result.smallInputBorder = neutralSecondary;\n        result.inputPlaceholderText = neutralSecondary;\n    }\n    if (neutralSecondaryAlt) {\n        result.buttonBorder = neutralSecondaryAlt;\n    }\n    if (neutralTertiaryAlt) {\n        result.disabledBodySubtext = neutralTertiaryAlt;\n        result.disabledBorder = neutralTertiaryAlt;\n        result.buttonBackgroundChecked = neutralTertiaryAlt;\n        result.menuDivider = neutralTertiaryAlt;\n    }\n    if (accent) {\n        result.accentButtonBackground = accent;\n    }\n    // map effects\n    if (e === null || e === void 0 ? void 0 : e.elevation4) {\n        result.cardShadow = e.elevation4;\n    }\n    if (!isInverted && (e === null || e === void 0 ? void 0 : e.elevation8)) {\n        result.cardShadowHovered = e.elevation8;\n    }\n    else if (result.variantBorderHovered) {\n        result.cardShadowHovered = '0 0 1px ' + result.variantBorderHovered;\n    }\n    result = __assign(__assign({}, result), s);\n    return result;\n}\nfunction _fixDeprecatedSlots(s, depComments) {\n    // Add @deprecated tag as comment if enabled\n    var dep = '';\n    if (depComments === true) {\n        dep = ' /* @deprecated */';\n    }\n    /* eslint-disable deprecation/deprecation */\n    s.listTextColor = s.listText + dep;\n    s.menuItemBackgroundChecked += dep;\n    s.warningHighlight += dep;\n    s.warningText = s.messageText + dep;\n    s.successText += dep;\n    /* eslint-enable deprecation/deprecation */\n    return s;\n}\n//# sourceMappingURL=makeSemanticColors.js.map","import { __spreadArray, __assign } from 'tslib';\nimport { complex, color } from 'style-value-types';\nimport { mix } from './mix.js';\nimport { mixColor } from './mix-color.js';\nimport { isNum } from './inc.js';\nimport { pipe } from './pipe.js';\nimport { invariant } from 'hey-listen';\n\nfunction getMixer(origin, target) {\n    if (isNum(origin)) {\n        return function (v) { return mix(origin, target, v); };\n    }\n    else if (color.test(origin)) {\n        return mixColor(origin, target);\n    }\n    else {\n        return mixComplex(origin, target);\n    }\n}\nvar mixArray = function (from, to) {\n    var output = __spreadArray([], from);\n    var numValues = output.length;\n    var blendValue = from.map(function (fromThis, i) { return getMixer(fromThis, to[i]); });\n    return function (v) {\n        for (var i = 0; i < numValues; i++) {\n            output[i] = blendValue[i](v);\n        }\n        return output;\n    };\n};\nvar mixObject = function (origin, target) {\n    var output = __assign(__assign({}, origin), target);\n    var blendValue = {};\n    for (var key in output) {\n        if (origin[key] !== undefined && target[key] !== undefined) {\n            blendValue[key] = getMixer(origin[key], target[key]);\n        }\n    }\n    return function (v) {\n        for (var key in blendValue) {\n            output[key] = blendValue[key](v);\n        }\n        return output;\n    };\n};\nfunction analyse(value) {\n    var parsed = complex.parse(value);\n    var numValues = parsed.length;\n    var numNumbers = 0;\n    var numRGB = 0;\n    var numHSL = 0;\n    for (var i = 0; i < numValues; i++) {\n        if (numNumbers || typeof parsed[i] === \"number\") {\n            numNumbers++;\n        }\n        else {\n            if (parsed[i].hue !== undefined) {\n                numHSL++;\n            }\n            else {\n                numRGB++;\n            }\n        }\n    }\n    return { parsed: parsed, numNumbers: numNumbers, numRGB: numRGB, numHSL: numHSL };\n}\nvar mixComplex = function (origin, target) {\n    var template = complex.createTransformer(target);\n    var originStats = analyse(origin);\n    var targetStats = analyse(target);\n    invariant(originStats.numHSL === targetStats.numHSL &&\n        originStats.numRGB === targetStats.numRGB &&\n        originStats.numNumbers >= targetStats.numNumbers, \"Complex values '\" + origin + \"' and '\" + target + \"' too different to mix. Ensure all colors are of the same type.\");\n    return pipe(mixArray(originStats.parsed, targetStats.parsed), template);\n};\n\nexport { mixArray, mixComplex, mixObject };\n","export default function getNodeName(element) {\n  return element ? (element.nodeName || '').toLowerCase() : null;\n}","/** PURE_IMPORTS_START  PURE_IMPORTS_END */\nvar _enable_super_gross_mode_that_will_cause_bad_things = false;\nexport var config = {\n    Promise: undefined,\n    set useDeprecatedSynchronousErrorHandling(value) {\n        if (value) {\n            var error = /*@__PURE__*/ new Error();\n            /*@__PURE__*/ console.warn('DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \\n' + error.stack);\n        }\n        else if (_enable_super_gross_mode_that_will_cause_bad_things) {\n            /*@__PURE__*/ console.log('RxJS: Back to a better error behavior. Thank you. <3');\n        }\n        _enable_super_gross_mode_that_will_cause_bad_things = value;\n    },\n    get useDeprecatedSynchronousErrorHandling() {\n        return _enable_super_gross_mode_that_will_cause_bad_things;\n    },\n};\n//# sourceMappingURL=config.js.map\n","export default function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","import { useRef, useEffect } from 'react';\n/**\n * Hook keeping track of a given value from a previous execution of the component the Hook is used in.\n *\n * See [React Hooks FAQ](https://reactjs.org/docs/hooks-faq.html#how-to-get-the-previous-props-or-state)\n */\nexport function usePrevious(value) {\n    var ref = useRef();\n    useEffect(function () {\n        ref.current = value;\n    });\n    return ref.current;\n}\n//# sourceMappingURL=usePrevious.js.map","import { Node, mergeAttributes, wrappingInputRule } from '@tiptap/core';\n\n/**\n * Matches a blockquote to a `>` as input.\n */\nconst inputRegex = /^\\s*>\\s$/;\n/**\n * This extension allows you to create blockquotes.\n * @see https://tiptap.dev/api/nodes/blockquote\n */\nconst Blockquote = Node.create({\n    name: 'blockquote',\n    addOptions() {\n        return {\n            HTMLAttributes: {},\n        };\n    },\n    content: 'block+',\n    group: 'block',\n    defining: true,\n    parseHTML() {\n        return [\n            { tag: 'blockquote' },\n        ];\n    },\n    renderHTML({ HTMLAttributes }) {\n        return ['blockquote', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];\n    },\n    addCommands() {\n        return {\n            setBlockquote: () => ({ commands }) => {\n                return commands.wrapIn(this.name);\n            },\n            toggleBlockquote: () => ({ commands }) => {\n                return commands.toggleWrap(this.name);\n            },\n            unsetBlockquote: () => ({ commands }) => {\n                return commands.lift(this.name);\n            },\n        };\n    },\n    addKeyboardShortcuts() {\n        return {\n            'Mod-Shift-b': () => this.editor.commands.toggleBlockquote(),\n        };\n    },\n    addInputRules() {\n        return [\n            wrappingInputRule({\n                find: inputRegex,\n                type: this.type,\n            }),\n        ];\n    },\n});\n\nexport { Blockquote, Blockquote as default, inputRegex };\n//# sourceMappingURL=index.js.map\n","import * as React from 'react';\n/**\n * Creates a ref, and calls a callback whenever the ref changes to a non-null value. The callback can optionally return\n * a cleanup function that'll be called before the value changes, and when the ref is unmounted.\n *\n * This can be used to work around a limitation that useEffect cannot depend on `ref.current` (see\n * https://github.com/facebook/react/issues/14387#issuecomment-503616820).\n *\n * Usage example:\n * ```ts\n * const myRef = useRefEffect<HTMLElement>(element => {\n *  ...\n *  return () => { ... cleanup ... };\n * });\n * ```\n * ```jsx\n * <div ref={myRef} />\n * ```\n *\n * @param callback - Called whenever the ref's value changes to non-null. Can optionally return a cleanup function.\n * @param initial - (Optional) The initial value for the ref.\n *\n * @returns A function that should be called to set the ref's value. The object also has a `.current` member that can be\n * used to access the ref's value (like a normal RefObject). It can be hooked up to an element's `ref` property.\n */\nexport function useRefEffect(callback, initial) {\n    if (initial === void 0) { initial = null; }\n    var createRefCallback = function () {\n        var refCallback = function (value) {\n            if (data.ref.current !== value) {\n                if (data.cleanup) {\n                    data.cleanup();\n                    data.cleanup = undefined;\n                }\n                data.ref.current = value;\n                if (value !== null) {\n                    data.cleanup = data.callback(value);\n                }\n            }\n        };\n        refCallback.current = initial;\n        return refCallback;\n    };\n    var data = React.useRef({\n        ref: createRefCallback(),\n        callback: callback,\n    }).current;\n    data.callback = callback;\n    return data.ref;\n}\n//# sourceMappingURL=useRefEffect.js.map","class $5b160d28a433310d$export$c17fa47878dc55b6 {\n    /** Returns a localized string for the given key and locale. */ getStringForLocale(key, locale) {\n        let strings = this.strings[locale];\n        if (!strings) {\n            strings = $5b160d28a433310d$var$getStringsForLocale(locale, this.strings, this.defaultLocale);\n            this.strings[locale] = strings;\n        }\n        let string = strings[key];\n        if (!string) throw new Error(`Could not find intl message ${key} in ${locale} locale`);\n        return string;\n    }\n    constructor(messages, defaultLocale = 'en-US'){\n        // Clone messages so we don't modify the original object.\n        this.strings = {\n            ...messages\n        };\n        this.defaultLocale = defaultLocale;\n    }\n}\nfunction $5b160d28a433310d$var$getStringsForLocale(locale, strings, defaultLocale = 'en-US') {\n    // If there is an exact match, use it.\n    if (strings[locale]) return strings[locale];\n    // Attempt to find the closest match by language.\n    // For example, if the locale is fr-CA (French Canadian), but there is only\n    // an fr-FR (France) set of strings, use that.\n    // This could be replaced with Intl.LocaleMatcher once it is supported.\n    // https://github.com/tc39/proposal-intl-localematcher\n    let language = $5b160d28a433310d$var$getLanguage(locale);\n    if (strings[language]) return strings[language];\n    for(let key in strings){\n        if (key.startsWith(language + '-')) return strings[key];\n    }\n    // Nothing close, use english.\n    return strings[defaultLocale];\n}\nfunction $5b160d28a433310d$var$getLanguage(locale) {\n    // @ts-ignore\n    if (Intl.Locale) // @ts-ignore\n    return new Intl.Locale(locale).language;\n    return locale.split('-')[0];\n}\n\n\nconst $6db58dc88e78b024$var$pluralRulesCache = new Map();\nconst $6db58dc88e78b024$var$numberFormatCache = new Map();\nclass $6db58dc88e78b024$export$2f817fcdc4b89ae0 {\n    /** Formats a localized string for the given key with the provided variables. */ format(key, variables) {\n        let message = this.strings.getStringForLocale(key, this.locale);\n        return typeof message === 'function' ? message(variables, this) : message;\n    }\n    plural(count, options, type = 'cardinal') {\n        let opt = options['=' + count];\n        if (opt) return typeof opt === 'function' ? opt() : opt;\n        let key = this.locale + ':' + type;\n        let pluralRules = $6db58dc88e78b024$var$pluralRulesCache.get(key);\n        if (!pluralRules) {\n            pluralRules = new Intl.PluralRules(this.locale, {\n                type: type\n            });\n            $6db58dc88e78b024$var$pluralRulesCache.set(key, pluralRules);\n        }\n        let selected = pluralRules.select(count);\n        opt = options[selected] || options.other;\n        return typeof opt === 'function' ? opt() : opt;\n    }\n    number(value) {\n        let numberFormat = $6db58dc88e78b024$var$numberFormatCache.get(this.locale);\n        if (!numberFormat) {\n            numberFormat = new Intl.NumberFormat(this.locale);\n            $6db58dc88e78b024$var$numberFormatCache.set(this.locale, numberFormat);\n        }\n        return numberFormat.format(value);\n    }\n    select(options, value) {\n        let opt = options[value] || options.other;\n        return typeof opt === 'function' ? opt() : opt;\n    }\n    constructor(locale, strings){\n        this.locale = locale;\n        this.strings = strings;\n    }\n}\n\n\n\n\nexport {$5b160d28a433310d$export$c17fa47878dc55b6 as LocalizedStringDictionary, $6db58dc88e78b024$export$2f817fcdc4b89ae0 as LocalizedStringFormatter};\n//# sourceMappingURL=module.js.map\n","import { getVirtualParent } from './getVirtualParent';\n/**\n * Gets the element which is the parent of a given element.\n * If `allowVirtuaParents` is `true`, this method prefers the virtual parent over\n * real DOM parent when present.\n *\n * @public\n */\nexport function getParent(child, allowVirtualParents) {\n    var _a, _b;\n    if (allowVirtualParents === void 0) { allowVirtualParents = true; }\n    if (!child) {\n        return null;\n    }\n    var parent = allowVirtualParents && getVirtualParent(child);\n    if (parent) {\n        return parent;\n    }\n    // Support looking for parents in shadow DOM\n    if (typeof child.assignedElements !== 'function' && ((_a = child.assignedSlot) === null || _a === void 0 ? void 0 : _a.parentNode)) {\n        // Element is slotted\n        return child.assignedSlot;\n    }\n    else if (((_b = child.parentNode) === null || _b === void 0 ? void 0 : _b.nodeType) === 11) {\n        // nodeType 11 is DOCUMENT_FRAGMENT\n        // Element is in shadow root\n        return child.parentNode.host;\n    }\n    else {\n        return child.parentNode;\n    }\n}\n//# sourceMappingURL=getParent.js.map","/**\n * Default implementation of insertion factory. Inserts styles only once per renderer and performs\n * insertion immediately after styles computation.\n *\n * @internal\n */\nconst insertionFactory = () => {\n  const insertionCache = {};\n  return function insertStyles(renderer, cssRules) {\n    if (insertionCache[renderer.id] === undefined) {\n      renderer.insertCSSRules(cssRules);\n      insertionCache[renderer.id] = true;\n    }\n  };\n};\n\nexport { insertionFactory };\n//# sourceMappingURL=insertionFactory.esm.js.map\n","export default function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n  return arr2;\n}","import { __assign } from \"tslib\";\nimport { GLOBAL_STYLESHEET_KEY, SHADOW_DOM_STYLESHEET_SETTING } from './shadowConfig';\nexport var InjectionMode = {\n    /**\n     * Avoids style injection, use getRules() to read the styles.\n     */\n    none: 0,\n    /**\n     * Inserts rules using the insertRule api.\n     */\n    insertNode: 1,\n    /**\n     * Appends rules using appendChild.\n     */\n    appendChild: 2,\n};\nexport var STYLESHEET_SETTING = '__stylesheet__';\n/**\n * MSIE 11 doesn't cascade styles based on DOM ordering, but rather on the order that each style node\n * is created. As such, to maintain consistent priority, IE11 should reuse a single style node.\n */\nvar REUSE_STYLE_NODE = typeof navigator !== 'undefined' && /rv:11.0/.test(navigator.userAgent);\nvar _global = {};\n// Grab window.\ntry {\n    // Why the cast?\n    // if compiled/type checked in same program with `@fluentui/font-icons-mdl2` which extends `Window` on global\n    // ( check packages/font-icons-mdl2/src/index.ts ) the definitions don't match! Thus the need of this extra assertion\n    _global = (window || {});\n}\ncatch (_a) {\n    /* leave as blank object */\n}\nvar _stylesheet;\n/**\n * Represents the state of styles registered in the page. Abstracts\n * the surface for adding styles to the stylesheet, exposes helpers\n * for reading the styles registered in server rendered scenarios.\n *\n * @public\n */\nvar Stylesheet = /** @class */ (function () {\n    function Stylesheet(config, serializedStylesheet) {\n        var _a, _b, _c, _d, _e, _f;\n        this._rules = [];\n        this._preservedRules = [];\n        this._counter = 0;\n        this._keyToClassName = {};\n        this._onInsertRuleCallbacks = [];\n        this._onResetCallbacks = [];\n        this._classNameToArgs = {};\n        // If there is no document we won't have an element to inject into.\n        this._config = __assign({ injectionMode: typeof document === 'undefined' ? InjectionMode.none : InjectionMode.insertNode, defaultPrefix: 'css', namespace: undefined, cspSettings: undefined }, config);\n        this._classNameToArgs = (_a = serializedStylesheet === null || serializedStylesheet === void 0 ? void 0 : serializedStylesheet.classNameToArgs) !== null && _a !== void 0 ? _a : this._classNameToArgs;\n        this._counter = (_b = serializedStylesheet === null || serializedStylesheet === void 0 ? void 0 : serializedStylesheet.counter) !== null && _b !== void 0 ? _b : this._counter;\n        this._keyToClassName = (_d = (_c = this._config.classNameCache) !== null && _c !== void 0 ? _c : serializedStylesheet === null || serializedStylesheet === void 0 ? void 0 : serializedStylesheet.keyToClassName) !== null && _d !== void 0 ? _d : this._keyToClassName;\n        this._preservedRules = (_e = serializedStylesheet === null || serializedStylesheet === void 0 ? void 0 : serializedStylesheet.preservedRules) !== null && _e !== void 0 ? _e : this._preservedRules;\n        this._rules = (_f = serializedStylesheet === null || serializedStylesheet === void 0 ? void 0 : serializedStylesheet.rules) !== null && _f !== void 0 ? _f : this._rules;\n    }\n    /**\n     * Gets the singleton instance.\n     */\n    Stylesheet.getInstance = function (shadowConfig) {\n        _stylesheet = _global[STYLESHEET_SETTING];\n        if (_global[SHADOW_DOM_STYLESHEET_SETTING]) {\n            return _global[SHADOW_DOM_STYLESHEET_SETTING].getInstance(shadowConfig);\n        }\n        if (!_stylesheet || (_stylesheet._lastStyleElement && _stylesheet._lastStyleElement.ownerDocument !== document)) {\n            var fabricConfig = (_global === null || _global === void 0 ? void 0 : _global.FabricConfig) || {};\n            var stylesheet = new Stylesheet(fabricConfig.mergeStyles, fabricConfig.serializedStylesheet);\n            _stylesheet = stylesheet;\n            _global[STYLESHEET_SETTING] = stylesheet;\n        }\n        return _stylesheet;\n    };\n    /**\n     * Serializes the Stylesheet instance into a format which allows rehydration on creation.\n     * @returns string representation of `ISerializedStylesheet` interface.\n     */\n    Stylesheet.prototype.serialize = function () {\n        return JSON.stringify({\n            classNameToArgs: this._classNameToArgs,\n            counter: this._counter,\n            keyToClassName: this._keyToClassName,\n            preservedRules: this._preservedRules,\n            rules: this._rules,\n        });\n    };\n    /**\n     * Configures the stylesheet.\n     */\n    Stylesheet.prototype.setConfig = function (config) {\n        this._config = __assign(__assign({}, this._config), config);\n    };\n    /**\n     * Configures a reset callback.\n     *\n     * @param callback - A callback which will be called when the Stylesheet is reset.\n     * @returns function which when called un-registers provided callback.\n     */\n    Stylesheet.prototype.onReset = function (callback) {\n        var _this = this;\n        this._onResetCallbacks.push(callback);\n        return function () {\n            _this._onResetCallbacks = _this._onResetCallbacks.filter(function (cb) { return cb !== callback; });\n        };\n    };\n    /**\n     * Configures an insert rule callback.\n     *\n     * @param callback - A callback which will be called when a rule is inserted.\n     * @returns function which when called un-registers provided callback.\n     */\n    Stylesheet.prototype.onInsertRule = function (callback) {\n        var _this = this;\n        this._onInsertRuleCallbacks.push(callback);\n        return function () {\n            _this._onInsertRuleCallbacks = _this._onInsertRuleCallbacks.filter(function (cb) { return cb !== callback; });\n        };\n    };\n    /**\n     * Generates a unique classname.\n     *\n     * @param displayName - Optional value to use as a prefix.\n     */\n    Stylesheet.prototype.getClassName = function (displayName) {\n        var namespace = this._config.namespace;\n        var prefix = displayName || this._config.defaultPrefix;\n        return \"\".concat(namespace ? namespace + '-' : '').concat(prefix, \"-\").concat(this._counter++);\n    };\n    /**\n     * Used internally to cache information about a class which was\n     * registered with the stylesheet.\n     */\n    Stylesheet.prototype.cacheClassName = function (className, key, args, rules) {\n        this._keyToClassName[this._getCacheKey(key)] = className;\n        this._classNameToArgs[className] = {\n            args: args,\n            rules: rules,\n        };\n    };\n    /**\n     * Gets the appropriate classname given a key which was previously\n     * registered using cacheClassName.\n     */\n    Stylesheet.prototype.classNameFromKey = function (key) {\n        return this._keyToClassName[this._getCacheKey(key)];\n    };\n    /**\n     * Gets all classnames cache with the stylesheet.\n     */\n    Stylesheet.prototype.getClassNameCache = function () {\n        return this._keyToClassName;\n    };\n    /**\n     * Gets the arguments associated with a given classname which was\n     * previously registered using cacheClassName.\n     */\n    Stylesheet.prototype.argsFromClassName = function (className) {\n        var entry = this._classNameToArgs[className];\n        return entry && entry.args;\n    };\n    /**\n     * Gets the rules associated with a given classname which was\n     * previously registered using cacheClassName.\n     */\n    Stylesheet.prototype.insertedRulesFromClassName = function (className) {\n        var entry = this._classNameToArgs[className];\n        return entry && entry.rules;\n    };\n    /**\n     * Inserts a css rule into the stylesheet.\n     * @param preserve - Preserves the rule beyond a reset boundary.\n     */\n    Stylesheet.prototype.insertRule = function (rule, preserve, stylesheetKey) {\n        if (stylesheetKey === void 0) { stylesheetKey = GLOBAL_STYLESHEET_KEY; }\n        var injectionMode = this._config.injectionMode;\n        var element = injectionMode !== InjectionMode.none ? this._getStyleElement() : undefined;\n        if (preserve) {\n            this._preservedRules.push(rule);\n        }\n        if (element) {\n            switch (injectionMode) {\n                case InjectionMode.insertNode:\n                    this._insertRuleIntoSheet(element.sheet, rule);\n                    break;\n                case InjectionMode.appendChild:\n                    element.appendChild(document.createTextNode(rule));\n                    break;\n            }\n        }\n        else {\n            this._rules.push(rule);\n        }\n        // eslint-disable-next-line deprecation/deprecation\n        if (this._config.onInsertRule) {\n            // eslint-disable-next-line deprecation/deprecation\n            this._config.onInsertRule(rule);\n        }\n        this._onInsertRuleCallbacks.forEach(function (callback) {\n            return callback({ key: stylesheetKey, sheet: (element ? element.sheet : undefined), rule: rule });\n        });\n    };\n    /**\n     * Gets all rules registered with the stylesheet; only valid when\n     * using InsertionMode.none.\n     */\n    Stylesheet.prototype.getRules = function (includePreservedRules) {\n        return (includePreservedRules ? this._preservedRules.join('') : '') + this._rules.join('');\n    };\n    /**\n     * Resets the internal state of the stylesheet. Only used in server\n     * rendered scenarios where we're using InsertionMode.none.\n     */\n    Stylesheet.prototype.reset = function () {\n        this._rules = [];\n        this._counter = 0;\n        this._classNameToArgs = {};\n        this._keyToClassName = {};\n        this._onResetCallbacks.forEach(function (callback) { return callback(); });\n    };\n    // Forces the regeneration of incoming styles without totally resetting the stylesheet.\n    Stylesheet.prototype.resetKeys = function () {\n        this._keyToClassName = {};\n    };\n    Stylesheet.prototype._createStyleElement = function () {\n        var _a;\n        var doc = ((_a = this._config.window) === null || _a === void 0 ? void 0 : _a.document) || document;\n        var head = doc.head;\n        var styleElement = doc.createElement('style');\n        var nodeToInsertBefore = null;\n        styleElement.setAttribute('data-merge-styles', 'true');\n        var cspSettings = this._config.cspSettings;\n        if (cspSettings) {\n            if (cspSettings.nonce) {\n                styleElement.setAttribute('nonce', cspSettings.nonce);\n            }\n        }\n        if (this._lastStyleElement) {\n            // If the `nextElementSibling` is null, then the insertBefore will act as a regular append.\n            // https://developer.mozilla.org/en-US/docs/Web/API/Node/insertBefore#Syntax\n            nodeToInsertBefore = this._lastStyleElement.nextElementSibling;\n        }\n        else {\n            var placeholderStyleTag = this._findPlaceholderStyleTag();\n            if (placeholderStyleTag) {\n                nodeToInsertBefore = placeholderStyleTag.nextElementSibling;\n            }\n            else {\n                nodeToInsertBefore = head.childNodes[0];\n            }\n        }\n        head.insertBefore(styleElement, head.contains(nodeToInsertBefore) ? nodeToInsertBefore : null);\n        this._lastStyleElement = styleElement;\n        return styleElement;\n    };\n    Stylesheet.prototype._insertRuleIntoSheet = function (sheet, rule) {\n        if (!sheet) {\n            return false;\n        }\n        try {\n            sheet.insertRule(rule, sheet.cssRules.length);\n            return true;\n        }\n        catch (e) {\n            // The browser will throw exceptions on unsupported rules (such as a moz prefix in webkit.)\n            // We need to swallow the exceptions for this scenario, otherwise we'd need to filter\n            // which could be slower and bulkier.\n        }\n        return false;\n    };\n    Stylesheet.prototype._getCacheKey = function (key) {\n        return key;\n    };\n    Stylesheet.prototype._getStyleElement = function () {\n        var _this = this;\n        if (!this._styleElement) {\n            this._styleElement = this._createStyleElement();\n            if (!REUSE_STYLE_NODE) {\n                // Reset the style element on the next frame.\n                var win = this._config.window || window;\n                win.requestAnimationFrame(function () {\n                    _this._styleElement = undefined;\n                });\n            }\n        }\n        return this._styleElement;\n    };\n    Stylesheet.prototype._findPlaceholderStyleTag = function () {\n        var head = document.head;\n        if (head) {\n            return head.querySelector('style[data-merge-styles]');\n        }\n        return null;\n    };\n    return Stylesheet;\n}());\nexport { Stylesheet };\n//# sourceMappingURL=Stylesheet.js.map","/** PURE_IMPORTS_START _config,_util_hostReportError PURE_IMPORTS_END */\nimport { config } from './config';\nimport { hostReportError } from './util/hostReportError';\nexport var empty = {\n    closed: true,\n    next: function (value) { },\n    error: function (err) {\n        if (config.useDeprecatedSynchronousErrorHandling) {\n            throw err;\n        }\n        else {\n            hostReportError(err);\n        }\n    },\n    complete: function () { }\n};\n//# sourceMappingURL=Observer.js.map\n","import { parseStackTraceLine } from './react-render-tracker/stackTrace.esm.js';\n\nfunction getSourceURLfromError() {\n  const stacks = String(new Error().stack).split('\\n');\n  const userMakeStyleCallLine = findUserMakeStyleCallInStacks(stacks);\n  if (userMakeStyleCallLine === undefined) {\n    return undefined;\n  }\n  const result = parseStackTraceLine(userMakeStyleCallLine);\n  return result === null || result === void 0 ? void 0 : result.loc;\n}\nfunction findUserMakeStyleCallInStacks(stacks) {\n  for (let i = stacks.length - 1; i >= 0; --i) {\n    if (stacks[i].includes('at getSourceURLfromError')) {\n      // The error stacks look like:\n      //   getSourceURLfromError\n      //   makeStyles/__styles in griffel core\n      //   makeStyles/__styles in griffel react\n      //   user makeStyles call\n      return stacks[i + 3];\n    }\n  }\n  return undefined;\n}\n\nexport { getSourceURLfromError };\n//# sourceMappingURL=getSourceURLfromError.esm.js.map\n","/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Subscriber } from '../Subscriber';\nexport function distinctUntilChanged(compare, keySelector) {\n    return function (source) { return source.lift(new DistinctUntilChangedOperator(compare, keySelector)); };\n}\nvar DistinctUntilChangedOperator = /*@__PURE__*/ (function () {\n    function DistinctUntilChangedOperator(compare, keySelector) {\n        this.compare = compare;\n        this.keySelector = keySelector;\n    }\n    DistinctUntilChangedOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new DistinctUntilChangedSubscriber(subscriber, this.compare, this.keySelector));\n    };\n    return DistinctUntilChangedOperator;\n}());\nvar DistinctUntilChangedSubscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(DistinctUntilChangedSubscriber, _super);\n    function DistinctUntilChangedSubscriber(destination, compare, keySelector) {\n        var _this = _super.call(this, destination) || this;\n        _this.keySelector = keySelector;\n        _this.hasKey = false;\n        if (typeof compare === 'function') {\n            _this.compare = compare;\n        }\n        return _this;\n    }\n    DistinctUntilChangedSubscriber.prototype.compare = function (x, y) {\n        return x === y;\n    };\n    DistinctUntilChangedSubscriber.prototype._next = function (value) {\n        var key;\n        try {\n            var keySelector = this.keySelector;\n            key = keySelector ? keySelector(value) : value;\n        }\n        catch (err) {\n            return this.destination.error(err);\n        }\n        var result = false;\n        if (this.hasKey) {\n            try {\n                var compare = this.compare;\n                result = compare(this.key, key);\n            }\n            catch (err) {\n                return this.destination.error(err);\n            }\n        }\n        else {\n            this.hasKey = true;\n        }\n        if (!result) {\n            this.key = key;\n            this.destination.next(value);\n        }\n    };\n    return DistinctUntilChangedSubscriber;\n}(Subscriber));\n//# sourceMappingURL=distinctUntilChanged.js.map\n","import { Extension } from '@tiptap/core';\nimport { undo, redo, history } from '@tiptap/pm/history';\n\n/**\n * This extension allows you to undo and redo recent changes.\n * @see https://www.tiptap.dev/api/extensions/history\n *\n * **Important**: If the `@tiptap/extension-collaboration` package is used, make sure to remove\n * the `history` extension, as it is not compatible with the `collaboration` extension.\n *\n * `@tiptap/extension-collaboration` uses its own history implementation.\n */\nconst History = Extension.create({\n    name: 'history',\n    addOptions() {\n        return {\n            depth: 100,\n            newGroupDelay: 500,\n        };\n    },\n    addCommands() {\n        return {\n            undo: () => ({ state, dispatch }) => {\n                return undo(state, dispatch);\n            },\n            redo: () => ({ state, dispatch }) => {\n                return redo(state, dispatch);\n            },\n        };\n    },\n    addProseMirrorPlugins() {\n        return [\n            history(this.options),\n        ];\n    },\n    addKeyboardShortcuts() {\n        return {\n            'Mod-z': () => this.editor.commands.undo(),\n            'Shift-Mod-z': () => this.editor.commands.redo(),\n            'Mod-y': () => this.editor.commands.redo(),\n            // Russian keyboard layouts\n            'Mod-': () => this.editor.commands.undo(),\n            'Shift-Mod-': () => this.editor.commands.redo(),\n        };\n    },\n});\n\nexport { History, History as default };\n//# sourceMappingURL=index.js.map\n","import { Node, mergeAttributes } from '@tiptap/core';\n\n/**\n * This extension allows you to create table cells.\n * @see https://www.tiptap.dev/api/nodes/table-cell\n */\nconst TableCell = Node.create({\n    name: 'tableCell',\n    addOptions() {\n        return {\n            HTMLAttributes: {},\n        };\n    },\n    content: 'block+',\n    addAttributes() {\n        return {\n            colspan: {\n                default: 1,\n            },\n            rowspan: {\n                default: 1,\n            },\n            colwidth: {\n                default: null,\n                parseHTML: element => {\n                    const colwidth = element.getAttribute('colwidth');\n                    const value = colwidth\n                        ? [parseInt(colwidth, 10)]\n                        : null;\n                    return value;\n                },\n            },\n        };\n    },\n    tableRole: 'cell',\n    isolating: true,\n    parseHTML() {\n        return [\n            { tag: 'td' },\n        ];\n    },\n    renderHTML({ HTMLAttributes }) {\n        return ['td', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];\n    },\n});\n\nexport { TableCell, TableCell as default };\n//# sourceMappingURL=index.js.map\n","import * as React from 'react';\n/**\n * Hook to initialize and return a constant value. Unlike `React.useMemo`, this is guaranteed to\n * always return the same value (and if the initializer is a function, only call it once).\n * This is similar to setting a private member in a class constructor.\n *\n * If the value should ever change based on dependencies, use `React.useMemo` instead.\n *\n * @param initialValue - Initial value, or function to get the initial value. Similar to `useState`,\n * only the value/function passed in the first time this is called is respected.\n * @returns The value. The identity of this value will always be the same.\n */\nexport function useConst(initialValue) {\n    // Use useRef to store the value because it's the least expensive built-in hook that works here\n    // (we could also use `const [value] = React.useState(initialValue)` but that's more expensive\n    // internally due to reducer handling which we don't need)\n    var ref = React.useRef();\n    if (ref.current === undefined) {\n        // Box the value in an object so we can tell if it's initialized even if the initializer\n        // returns/is undefined\n        ref.current = {\n            value: typeof initialValue === 'function' ? initialValue() : initialValue,\n        };\n    }\n    return ref.current.value;\n}\n//# sourceMappingURL=useConst.js.map","import './constants.esm.js';\nimport { debugData } from './devtools/store.esm.js';\nimport { isDevToolsEnabled } from './devtools/isDevToolsEnabled.esm.js';\nimport { getSourceURLfromError } from './devtools/getSourceURLfromError.esm.js';\nimport { insertionFactory } from './insertionFactory.esm.js';\nimport { reduceToClassNameForSlots } from './runtime/reduceToClassNameForSlots.esm.js';\n\n/**\n * A version of makeStyles() that accepts build output as an input and skips all runtime transforms.\n *\n * @internal\n */\nfunction __styles(classesMapBySlot, cssRules, factory = insertionFactory) {\n  const insertStyles = factory();\n  let ltrClassNamesForSlots = null;\n  let rtlClassNamesForSlots = null;\n  let sourceURL;\n  if (process.env.NODE_ENV !== 'production' && isDevToolsEnabled) {\n    sourceURL = getSourceURLfromError();\n  }\n  function computeClasses(options) {\n    const {\n      dir,\n      renderer\n    } = options;\n    const isLTR = dir === 'ltr';\n    if (isLTR) {\n      if (ltrClassNamesForSlots === null) {\n        ltrClassNamesForSlots = reduceToClassNameForSlots(classesMapBySlot, dir);\n      }\n    } else {\n      if (rtlClassNamesForSlots === null) {\n        rtlClassNamesForSlots = reduceToClassNameForSlots(classesMapBySlot, dir);\n      }\n    }\n    insertStyles(renderer, cssRules);\n    const classNamesForSlots = isLTR ? ltrClassNamesForSlots : rtlClassNamesForSlots;\n    if (process.env.NODE_ENV !== 'production' && isDevToolsEnabled) {\n      debugData.addSequenceDetails(classNamesForSlots, sourceURL);\n    }\n    return classNamesForSlots;\n  }\n  return computeClasses;\n}\n\nexport { __styles };\n//# sourceMappingURL=__styles.esm.js.map\n","import { compareDatePart } from '../dateMath/dateMath';\n/**\n * Checks if `date` happens earlier than min date\n * @param date - date to check\n * @param options - object with min date to check against\n */\nexport var isBeforeMinDate = function (date, options) {\n    var minDate = options.minDate;\n    return minDate ? compareDatePart(minDate, date) >= 1 : false;\n};\n//# sourceMappingURL=isBeforeMinDate.js.map","/*\nobject-assign\n(c) Sindre Sorhus\n@license MIT\n*/\n\n'use strict';\n/* eslint-disable no-unused-vars */\nvar getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\n\nfunction toObject(val) {\n\tif (val === null || val === undefined) {\n\t\tthrow new TypeError('Object.assign cannot be called with null or undefined');\n\t}\n\n\treturn Object(val);\n}\n\nfunction shouldUseNative() {\n\ttry {\n\t\tif (!Object.assign) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Detect buggy property enumeration order in older V8 versions.\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=4118\n\t\tvar test1 = new String('abc');  // eslint-disable-line no-new-wrappers\n\t\ttest1[5] = 'de';\n\t\tif (Object.getOwnPropertyNames(test1)[0] === '5') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test2 = {};\n\t\tfor (var i = 0; i < 10; i++) {\n\t\t\ttest2['_' + String.fromCharCode(i)] = i;\n\t\t}\n\t\tvar order2 = Object.getOwnPropertyNames(test2).map(function (n) {\n\t\t\treturn test2[n];\n\t\t});\n\t\tif (order2.join('') !== '0123456789') {\n\t\t\treturn false;\n\t\t}\n\n\t\t// https://bugs.chromium.org/p/v8/issues/detail?id=3056\n\t\tvar test3 = {};\n\t\t'abcdefghijklmnopqrst'.split('').forEach(function (letter) {\n\t\t\ttest3[letter] = letter;\n\t\t});\n\t\tif (Object.keys(Object.assign({}, test3)).join('') !==\n\t\t\t\t'abcdefghijklmnopqrst') {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn true;\n\t} catch (err) {\n\t\t// We don't expect any of the above to throw, but better to be safe.\n\t\treturn false;\n\t}\n}\n\nmodule.exports = shouldUseNative() ? Object.assign : function (target, source) {\n\tvar from;\n\tvar to = toObject(target);\n\tvar symbols;\n\n\tfor (var s = 1; s < arguments.length; s++) {\n\t\tfrom = Object(arguments[s]);\n\n\t\tfor (var key in from) {\n\t\t\tif (hasOwnProperty.call(from, key)) {\n\t\t\t\tto[key] = from[key];\n\t\t\t}\n\t\t}\n\n\t\tif (getOwnPropertySymbols) {\n\t\t\tsymbols = getOwnPropertySymbols(from);\n\t\t\tfor (var i = 0; i < symbols.length; i++) {\n\t\t\t\tif (propIsEnumerable.call(from, symbols[i])) {\n\t\t\t\t\tto[symbols[i]] = from[symbols[i]];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn to;\n};\n","export default function getWindow(node) {\n  if (node == null) {\n    return window;\n  }\n\n  if (node.toString() !== '[object Window]') {\n    var ownerDocument = node.ownerDocument;\n    return ownerDocument ? ownerDocument.defaultView || window : window;\n  }\n\n  return node;\n}","import { DEFINITION_LOOKUP_TABLE } from '../constants.esm.js';\nimport { hashSequence } from './utils/hashSequence.esm.js';\n\n/**\n * Reduces a classname map for slot to a classname string. Uses classnames according to text directions.\n *\n * @private\n */\nfunction reduceToClassName(classMap, dir) {\n  // - `classString` is a string of classnames separated by a space, used to output classes\n  // - `hashString` is a string of classnames separated by a space, used to generate a hash\n  //\n  // `hashString` is needed to handle `null` values in a class map as they don't produce any classes.\n  let classString = '';\n  let hashString = '';\n  // eslint-disable-next-line guard-for-in\n  for (const propertyHash in classMap) {\n    const classNameMapping = classMap[propertyHash];\n    if (classNameMapping === 0) {\n      hashString += propertyHash + ' ';\n      continue;\n    }\n    const hasRTLClassName = Array.isArray(classNameMapping);\n    const className = dir === 'rtl' ? (hasRTLClassName ? classNameMapping[1] : classNameMapping) + ' ' : (hasRTLClassName ? classNameMapping[0] : classNameMapping) + ' ';\n    classString += className;\n    hashString += className;\n  }\n  return [classString.slice(0, -1), hashString.slice(0, -1)];\n}\n/**\n * Reduces classname maps for slots to classname strings. Registers them in a definition cache to be used by\n * `mergeClasses()`.\n *\n * @internal\n */\nfunction reduceToClassNameForSlots(classesMapBySlot, dir) {\n  const classNamesForSlots = {};\n  // eslint-disable-next-line guard-for-in\n  for (const slotName in classesMapBySlot) {\n    const [slotClasses, slotClassesHash] = reduceToClassName(classesMapBySlot[slotName], dir);\n    // Handles a case when there are no classes in a set i.e. \"makeStyles({ root: {} })\"\n    if (slotClassesHash === '') {\n      classNamesForSlots[slotName] = '';\n      continue;\n    }\n    const sequenceHash = hashSequence(slotClassesHash, dir);\n    const resultSlotClasses = sequenceHash + (slotClasses === '' ? '' : ' ' + slotClasses);\n    DEFINITION_LOOKUP_TABLE[sequenceHash] = [classesMapBySlot[slotName], dir];\n    classNamesForSlots[slotName] = resultSlotClasses;\n  }\n  return classNamesForSlots;\n}\n\nexport { reduceToClassName, reduceToClassNameForSlots };\n//# sourceMappingURL=reduceToClassNameForSlots.esm.js.map\n","import { Node, mergeAttributes } from '@tiptap/core';\n\n/**\n * This extension allows you to create table rows.\n * @see https://www.tiptap.dev/api/nodes/table-row\n */\nconst TableRow = Node.create({\n    name: 'tableRow',\n    addOptions() {\n        return {\n            HTMLAttributes: {},\n        };\n    },\n    content: '(tableCell | tableHeader)*',\n    tableRole: 'row',\n    parseHTML() {\n        return [\n            { tag: 'tr' },\n        ];\n    },\n    renderHTML({ HTMLAttributes }) {\n        return ['tr', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];\n    },\n});\n\nexport { TableRow, TableRow as default };\n//# sourceMappingURL=index.js.map\n","export var hiddenContentStyle = {\n    position: 'absolute',\n    width: 1,\n    height: 1,\n    margin: -1,\n    padding: 0,\n    border: 0,\n    overflow: 'hidden',\n    whiteSpace: 'nowrap',\n};\n//# sourceMappingURL=hiddenContentStyle.js.map","import { setVersion } from './setVersion';\nexport { setVersion };\nsetVersion('@fluentui/set-version', '6.0.0');\n//# sourceMappingURL=index.js.map","export var DefaultSpacing = {\n    s2: '4px',\n    s1: '8px',\n    m: '16px',\n    l1: '20px',\n    l2: '32px',\n};\n//# sourceMappingURL=DefaultSpacing.js.map","export default function rectToClientRect(rect) {\n  return Object.assign({}, rect, {\n    left: rect.x,\n    top: rect.y,\n    right: rect.x + rect.width,\n    bottom: rect.y + rect.height\n  });\n}","import { on } from '@fluentui/utilities';\nimport * as React from 'react';\n/**\n * Hook to attach an event handler on mount and handle cleanup.\n * @param element - Element (or ref to an element) to attach the event handler to\n * @param eventName - The event to attach a handler for\n * @param callback - The handler for the event\n * @param useCapture - Whether or not to attach the handler for the capture phase\n */\nexport function useOnEvent(element, eventName, callback, useCapture) {\n    // Use a ref for the callback to prevent repeatedly attaching/unattaching callbacks that are unstable across renders\n    var callbackRef = React.useRef(callback);\n    callbackRef.current = callback;\n    React.useEffect(function () {\n        var actualElement = element && 'current' in element ? element.current : element;\n        if (!actualElement || !actualElement.addEventListener) {\n            return;\n        }\n        var dispose = on(actualElement, eventName, function (ev) { return callbackRef.current(ev); }, useCapture);\n        return dispose;\n    }, [element, eventName, useCapture]);\n}\n//# sourceMappingURL=useOnEvent.js.map","var hash = {\n  left: 'right',\n  right: 'left',\n  bottom: 'top',\n  top: 'bottom'\n};\nexport default function getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, function (matched) {\n    return hash[matched];\n  });\n}","export { AnimationClassNames, FontClassNames, ColorClassNames } from './classNames/index';\nexport { AnimationStyles, AnimationVariables, DefaultPalette, DefaultEffects, DefaultFontStyles, registerDefaultFontFaces, FontSizes, FontWeights, IconFontSizes, createFontStyles, hiddenContentStyle, PulsingBeaconAnimationStyles, getGlobalClassNames, \n// eslint-disable-next-line deprecation/deprecation\ngetFocusStyle, getFocusOutlineStyle, getInputFocusStyle, getThemedContext, focusClear, ThemeSettingName, getTheme, loadTheme, createTheme, registerOnThemeChangeCallback, removeOnThemeChangeCallback, HighContrastSelector, HighContrastSelectorWhite, HighContrastSelectorBlack, \n// eslint-disable-next-line deprecation/deprecation\nEdgeChromiumHighContrastSelector, ScreenWidthMinSmall, ScreenWidthMinMedium, ScreenWidthMinLarge, ScreenWidthMinXLarge, ScreenWidthMinXXLarge, ScreenWidthMinXXXLarge, ScreenWidthMaxSmall, ScreenWidthMaxMedium, ScreenWidthMaxLarge, ScreenWidthMaxXLarge, ScreenWidthMaxXXLarge, ScreenWidthMinUhfMobile, getScreenSelector, getHighContrastNoAdjustStyle, \n// eslint-disable-next-line deprecation/deprecation\ngetEdgeChromiumNoHighContrastAdjustSelector, normalize, noWrap, getFadedOverflowStyle, getPlaceholderStyles, ZIndexes, } from './styles/index';\nexport { buildClassMap, getIcon, registerIcons, registerIconAlias, unregisterIcons, setIconOptions, getIconClassName, } from './utilities/index';\nexport { InjectionMode, Stylesheet, concatStyleSets, concatStyleSetsWithProps, fontFace, keyframes, mergeStyleSets, mergeStyles, } from './MergeStyles';\nexport { FLUENT_CDN_BASE_URL } from './cdn';\nimport './version';\n// Ensure theme is initialized when this package is referenced.\nimport { initializeThemeInCustomizations } from './styles/theme';\ninitializeThemeInCustomizations();\n//# sourceMappingURL=index.js.map","var defaultTimestep = (1 / 60) * 1000;\nvar getCurrentTime = typeof performance !== \"undefined\"\n    ? function () { return performance.now(); }\n    : function () { return Date.now(); };\nvar onNextFrame = typeof window !== \"undefined\"\n    ? function (callback) {\n        return window.requestAnimationFrame(callback);\n    }\n    : function (callback) {\n        return setTimeout(function () { return callback(getCurrentTime()); }, defaultTimestep);\n    };\n\nexport { defaultTimestep, onNextFrame };\n","import { __spreadArray } from \"tslib\";\nimport * as React from 'react';\n/**\n * React hook to merge multiple React refs (either MutableRefObjects or ref callbacks) into a single ref callback that\n * updates all provided refs\n * @param refs - Refs to collectively update with one ref value.\n * @returns A function with an attached \"current\" prop, so that it can be treated like a RefObject.\n */\nexport function useMergedRefs() {\n    var refs = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        refs[_i] = arguments[_i];\n    }\n    var mergedCallback = React.useCallback(function (value) {\n        // Update the \"current\" prop hanging on the function.\n        mergedCallback.current = value;\n        for (var _i = 0, refs_1 = refs; _i < refs_1.length; _i++) {\n            var ref = refs_1[_i];\n            if (typeof ref === 'function') {\n                ref(value);\n            }\n            else if (ref) {\n                // work around the immutability of the React.Ref type\n                ref.current = value;\n            }\n        }\n    }, __spreadArray([], refs, true));\n    return mergedCallback;\n}\n//# sourceMappingURL=useMergedRefs.js.map","import getParentNode from \"./getParentNode.js\";\nimport isScrollParent from \"./isScrollParent.js\";\nimport getNodeName from \"./getNodeName.js\";\nimport { isHTMLElement } from \"./instanceOf.js\";\nexport default function getScrollParent(node) {\n  if (['html', 'body', '#document'].indexOf(getNodeName(node)) >= 0) {\n    // $FlowFixMe[incompatible-return]: assume body is always available\n    return node.ownerDocument.body;\n  }\n\n  if (isHTMLElement(node) && isScrollParent(node)) {\n    return node;\n  }\n\n  return getScrollParent(getParentNode(node));\n}","import { Plugin } from 'prosemirror-state';\nimport { dropPoint } from 'prosemirror-transform';\n\n/**\nCreate a plugin that, when added to a ProseMirror instance,\ncauses a decoration to show up at the drop position when something\nis dragged over the editor.\n\nNodes may add a `disableDropCursor` property to their spec to\ncontrol the showing of a drop cursor inside them. This may be a\nboolean or a function, which will be called with a view and a\nposition, and should return a boolean.\n*/\nfunction dropCursor(options = {}) {\n    return new Plugin({\n        view(editorView) { return new DropCursorView(editorView, options); }\n    });\n}\nclass DropCursorView {\n    constructor(editorView, options) {\n        var _a;\n        this.editorView = editorView;\n        this.cursorPos = null;\n        this.element = null;\n        this.timeout = -1;\n        this.width = (_a = options.width) !== null && _a !== void 0 ? _a : 1;\n        this.color = options.color === false ? undefined : (options.color || \"black\");\n        this.class = options.class;\n        this.handlers = [\"dragover\", \"dragend\", \"drop\", \"dragleave\"].map(name => {\n            let handler = (e) => { this[name](e); };\n            editorView.dom.addEventListener(name, handler);\n            return { name, handler };\n        });\n    }\n    destroy() {\n        this.handlers.forEach(({ name, handler }) => this.editorView.dom.removeEventListener(name, handler));\n    }\n    update(editorView, prevState) {\n        if (this.cursorPos != null && prevState.doc != editorView.state.doc) {\n            if (this.cursorPos > editorView.state.doc.content.size)\n                this.setCursor(null);\n            else\n                this.updateOverlay();\n        }\n    }\n    setCursor(pos) {\n        if (pos == this.cursorPos)\n            return;\n        this.cursorPos = pos;\n        if (pos == null) {\n            this.element.parentNode.removeChild(this.element);\n            this.element = null;\n        }\n        else {\n            this.updateOverlay();\n        }\n    }\n    updateOverlay() {\n        let $pos = this.editorView.state.doc.resolve(this.cursorPos);\n        let isBlock = !$pos.parent.inlineContent, rect;\n        if (isBlock) {\n            let before = $pos.nodeBefore, after = $pos.nodeAfter;\n            if (before || after) {\n                let node = this.editorView.nodeDOM(this.cursorPos - (before ? before.nodeSize : 0));\n                if (node) {\n                    let nodeRect = node.getBoundingClientRect();\n                    let top = before ? nodeRect.bottom : nodeRect.top;\n                    if (before && after)\n                        top = (top + this.editorView.nodeDOM(this.cursorPos).getBoundingClientRect().top) / 2;\n                    rect = { left: nodeRect.left, right: nodeRect.right, top: top - this.width / 2, bottom: top + this.width / 2 };\n                }\n            }\n        }\n        if (!rect) {\n            let coords = this.editorView.coordsAtPos(this.cursorPos);\n            rect = { left: coords.left - this.width / 2, right: coords.left + this.width / 2, top: coords.top, bottom: coords.bottom };\n        }\n        let parent = this.editorView.dom.offsetParent;\n        if (!this.element) {\n            this.element = parent.appendChild(document.createElement(\"div\"));\n            if (this.class)\n                this.element.className = this.class;\n            this.element.style.cssText = \"position: absolute; z-index: 50; pointer-events: none;\";\n            if (this.color) {\n                this.element.style.backgroundColor = this.color;\n            }\n        }\n        this.element.classList.toggle(\"prosemirror-dropcursor-block\", isBlock);\n        this.element.classList.toggle(\"prosemirror-dropcursor-inline\", !isBlock);\n        let parentLeft, parentTop;\n        if (!parent || parent == document.body && getComputedStyle(parent).position == \"static\") {\n            parentLeft = -pageXOffset;\n            parentTop = -pageYOffset;\n        }\n        else {\n            let rect = parent.getBoundingClientRect();\n            parentLeft = rect.left - parent.scrollLeft;\n            parentTop = rect.top - parent.scrollTop;\n        }\n        this.element.style.left = (rect.left - parentLeft) + \"px\";\n        this.element.style.top = (rect.top - parentTop) + \"px\";\n        this.element.style.width = (rect.right - rect.left) + \"px\";\n        this.element.style.height = (rect.bottom - rect.top) + \"px\";\n    }\n    scheduleRemoval(timeout) {\n        clearTimeout(this.timeout);\n        this.timeout = setTimeout(() => this.setCursor(null), timeout);\n    }\n    dragover(event) {\n        if (!this.editorView.editable)\n            return;\n        let pos = this.editorView.posAtCoords({ left: event.clientX, top: event.clientY });\n        let node = pos && pos.inside >= 0 && this.editorView.state.doc.nodeAt(pos.inside);\n        let disableDropCursor = node && node.type.spec.disableDropCursor;\n        let disabled = typeof disableDropCursor == \"function\" ? disableDropCursor(this.editorView, pos, event) : disableDropCursor;\n        if (pos && !disabled) {\n            let target = pos.pos;\n            if (this.editorView.dragging && this.editorView.dragging.slice) {\n                let point = dropPoint(this.editorView.state.doc, target, this.editorView.dragging.slice);\n                if (point != null)\n                    target = point;\n            }\n            this.setCursor(target);\n            this.scheduleRemoval(5000);\n        }\n    }\n    dragend() {\n        this.scheduleRemoval(20);\n    }\n    drop() {\n        this.scheduleRemoval(20);\n    }\n    dragleave(event) {\n        if (event.target == this.editorView.dom || !this.editorView.dom.contains(event.relatedTarget))\n            this.setCursor(null);\n    }\n}\n\nexport { dropCursor };\n","export default function _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n  return self;\n}","var arrayLikeToArray = require(\"./arrayLikeToArray.js\");\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}\nmodule.exports = _unsupportedIterableToArray, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","var NON_PIXEL_NUMBER_PROPS = [\n    'column-count',\n    'font-weight',\n    'flex',\n    'flex-grow',\n    'flex-shrink',\n    'fill-opacity',\n    'opacity',\n    'order',\n    'z-index',\n    'zoom',\n];\nexport function provideUnits(rulePairs, index) {\n    var name = rulePairs[index];\n    var value = rulePairs[index + 1];\n    if (typeof value === 'number') {\n        var isNonPixelProp = NON_PIXEL_NUMBER_PROPS.indexOf(name) > -1;\n        var isVariableOrPrefixed = name.indexOf('--') > -1;\n        var unit = isNonPixelProp || isVariableOrPrefixed ? '' : 'px';\n        rulePairs[index + 1] = \"\".concat(value).concat(unit);\n    }\n}\n//# sourceMappingURL=provideUnits.js.map","import { top, bottom, left, right } from \"../enums.js\";\nimport detectOverflow from \"../utils/detectOverflow.js\";\n\nfunction getSideOffsets(overflow, rect, preventedOffsets) {\n  if (preventedOffsets === void 0) {\n    preventedOffsets = {\n      x: 0,\n      y: 0\n    };\n  }\n\n  return {\n    top: overflow.top - rect.height - preventedOffsets.y,\n    right: overflow.right - rect.width + preventedOffsets.x,\n    bottom: overflow.bottom - rect.height + preventedOffsets.y,\n    left: overflow.left - rect.width - preventedOffsets.x\n  };\n}\n\nfunction isAnySideFullyClipped(overflow) {\n  return [top, right, bottom, left].some(function (side) {\n    return overflow[side] >= 0;\n  });\n}\n\nfunction hide(_ref) {\n  var state = _ref.state,\n      name = _ref.name;\n  var referenceRect = state.rects.reference;\n  var popperRect = state.rects.popper;\n  var preventedOffsets = state.modifiersData.preventOverflow;\n  var referenceOverflow = detectOverflow(state, {\n    elementContext: 'reference'\n  });\n  var popperAltOverflow = detectOverflow(state, {\n    altBoundary: true\n  });\n  var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);\n  var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);\n  var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);\n  var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);\n  state.modifiersData[name] = {\n    referenceClippingOffsets: referenceClippingOffsets,\n    popperEscapeOffsets: popperEscapeOffsets,\n    isReferenceHidden: isReferenceHidden,\n    hasPopperEscaped: hasPopperEscaped\n  };\n  state.attributes.popper = Object.assign({}, state.attributes.popper, {\n    'data-popper-reference-hidden': isReferenceHidden,\n    'data-popper-escaped': hasPopperEscaped\n  });\n} // eslint-disable-next-line import/no-unused-modules\n\n\nexport default {\n  name: 'hide',\n  enabled: true,\n  phase: 'main',\n  requiresIfExists: ['preventOverflow'],\n  fn: hide\n};","function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\nmodule.exports = _arrayWithHoles, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","import getCompositeRect from \"./dom-utils/getCompositeRect.js\";\nimport getLayoutRect from \"./dom-utils/getLayoutRect.js\";\nimport listScrollParents from \"./dom-utils/listScrollParents.js\";\nimport getOffsetParent from \"./dom-utils/getOffsetParent.js\";\nimport orderModifiers from \"./utils/orderModifiers.js\";\nimport debounce from \"./utils/debounce.js\";\nimport mergeByName from \"./utils/mergeByName.js\";\nimport detectOverflow from \"./utils/detectOverflow.js\";\nimport { isElement } from \"./dom-utils/instanceOf.js\";\nvar DEFAULT_OPTIONS = {\n  placement: 'bottom',\n  modifiers: [],\n  strategy: 'absolute'\n};\n\nfunction areValidElements() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  return !args.some(function (element) {\n    return !(element && typeof element.getBoundingClientRect === 'function');\n  });\n}\n\nexport function popperGenerator(generatorOptions) {\n  if (generatorOptions === void 0) {\n    generatorOptions = {};\n  }\n\n  var _generatorOptions = generatorOptions,\n      _generatorOptions$def = _generatorOptions.defaultModifiers,\n      defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,\n      _generatorOptions$def2 = _generatorOptions.defaultOptions,\n      defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;\n  return function createPopper(reference, popper, options) {\n    if (options === void 0) {\n      options = defaultOptions;\n    }\n\n    var state = {\n      placement: 'bottom',\n      orderedModifiers: [],\n      options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),\n      modifiersData: {},\n      elements: {\n        reference: reference,\n        popper: popper\n      },\n      attributes: {},\n      styles: {}\n    };\n    var effectCleanupFns = [];\n    var isDestroyed = false;\n    var instance = {\n      state: state,\n      setOptions: function setOptions(setOptionsAction) {\n        var options = typeof setOptionsAction === 'function' ? setOptionsAction(state.options) : setOptionsAction;\n        cleanupModifierEffects();\n        state.options = Object.assign({}, defaultOptions, state.options, options);\n        state.scrollParents = {\n          reference: isElement(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],\n          popper: listScrollParents(popper)\n        }; // Orders the modifiers based on their dependencies and `phase`\n        // properties\n\n        var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers\n\n        state.orderedModifiers = orderedModifiers.filter(function (m) {\n          return m.enabled;\n        });\n        runModifierEffects();\n        return instance.update();\n      },\n      // Sync update  it will always be executed, even if not necessary. This\n      // is useful for low frequency updates where sync behavior simplifies the\n      // logic.\n      // For high frequency updates (e.g. `resize` and `scroll` events), always\n      // prefer the async Popper#update method\n      forceUpdate: function forceUpdate() {\n        if (isDestroyed) {\n          return;\n        }\n\n        var _state$elements = state.elements,\n            reference = _state$elements.reference,\n            popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements\n        // anymore\n\n        if (!areValidElements(reference, popper)) {\n          return;\n        } // Store the reference and popper rects to be read by modifiers\n\n\n        state.rects = {\n          reference: getCompositeRect(reference, getOffsetParent(popper), state.options.strategy === 'fixed'),\n          popper: getLayoutRect(popper)\n        }; // Modifiers have the ability to reset the current update cycle. The\n        // most common use case for this is the `flip` modifier changing the\n        // placement, which then needs to re-run all the modifiers, because the\n        // logic was previously ran for the previous placement and is therefore\n        // stale/incorrect\n\n        state.reset = false;\n        state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier\n        // is filled with the initial data specified by the modifier. This means\n        // it doesn't persist and is fresh on each update.\n        // To ensure persistent data, use `${name}#persistent`\n\n        state.orderedModifiers.forEach(function (modifier) {\n          return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);\n        });\n\n        for (var index = 0; index < state.orderedModifiers.length; index++) {\n          if (state.reset === true) {\n            state.reset = false;\n            index = -1;\n            continue;\n          }\n\n          var _state$orderedModifie = state.orderedModifiers[index],\n              fn = _state$orderedModifie.fn,\n              _state$orderedModifie2 = _state$orderedModifie.options,\n              _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,\n              name = _state$orderedModifie.name;\n\n          if (typeof fn === 'function') {\n            state = fn({\n              state: state,\n              options: _options,\n              name: name,\n              instance: instance\n            }) || state;\n          }\n        }\n      },\n      // Async and optimistically optimized update  it will not be executed if\n      // not necessary (debounced to run at most once-per-tick)\n      update: debounce(function () {\n        return new Promise(function (resolve) {\n          instance.forceUpdate();\n          resolve(state);\n        });\n      }),\n      destroy: function destroy() {\n        cleanupModifierEffects();\n        isDestroyed = true;\n      }\n    };\n\n    if (!areValidElements(reference, popper)) {\n      return instance;\n    }\n\n    instance.setOptions(options).then(function (state) {\n      if (!isDestroyed && options.onFirstUpdate) {\n        options.onFirstUpdate(state);\n      }\n    }); // Modifiers have the ability to execute arbitrary code before the first\n    // update cycle runs. They will be executed in the same order as the update\n    // cycle. This is useful when a modifier adds some persistent data that\n    // other modifiers need to use, but the modifier is run after the dependent\n    // one.\n\n    function runModifierEffects() {\n      state.orderedModifiers.forEach(function (_ref) {\n        var name = _ref.name,\n            _ref$options = _ref.options,\n            options = _ref$options === void 0 ? {} : _ref$options,\n            effect = _ref.effect;\n\n        if (typeof effect === 'function') {\n          var cleanupFn = effect({\n            state: state,\n            name: name,\n            instance: instance,\n            options: options\n          });\n\n          var noopFn = function noopFn() {};\n\n          effectCleanupFns.push(cleanupFn || noopFn);\n        }\n      });\n    }\n\n    function cleanupModifierEffects() {\n      effectCleanupFns.forEach(function (fn) {\n        return fn();\n      });\n      effectCleanupFns = [];\n    }\n\n    return instance;\n  };\n}\nexport var createPopper = /*#__PURE__*/popperGenerator(); // eslint-disable-next-line import/no-unused-modules\n\nexport { detectOverflow };","import { __assign, __extends } from \"tslib\";\n/* eslint no-restricted-globals: 0 */\nimport { InjectionMode, STYLESHEET_SETTING, Stylesheet } from './Stylesheet';\nimport { DEFAULT_SHADOW_CONFIG, GLOBAL_STYLESHEET_KEY, SHADOW_DOM_STYLESHEET_SETTING } from './shadowConfig';\nexport var SUPPORTS_CONSTRUCTABLE_STYLESHEETS = typeof document !== 'undefined' && Array.isArray(document.adoptedStyleSheets) && 'replace' in CSSStyleSheet.prototype;\nvar supportsModifyingAdoptedStyleSheets = false;\nif (SUPPORTS_CONSTRUCTABLE_STYLESHEETS) {\n    try {\n        document.adoptedStyleSheets.push();\n        supportsModifyingAdoptedStyleSheets = true;\n    }\n    catch (e) {\n        supportsModifyingAdoptedStyleSheets = false;\n    }\n}\nexport var SUPPORTS_MODIFYING_ADOPTED_STYLESHEETS = supportsModifyingAdoptedStyleSheets;\nvar _stylesheet;\nvar _global = {};\n// Grab window.\ntry {\n    // Why the cast?\n    // if compiled/type checked in same program with `@fluentui/font-icons-mdl2` which extends `Window` on global\n    // ( check packages/font-icons-mdl2/src/index.ts ) the definitions don't match! Thus the need of this extra assertion\n    _global = (window || {});\n}\ncatch (_a) {\n    /* leave as blank object */\n}\nvar copyOldGlobalRules = function (stylesheet, inShadow, win, doc) {\n    var _a;\n    if (inShadow === void 0) { inShadow = false; }\n    if (!doc) {\n        // SSR\n        return;\n    }\n    var oldGlobalRules = doc.querySelectorAll('[data-merge-styles]');\n    if (oldGlobalRules) {\n        stylesheet.setConfig({\n            window: win,\n            inShadow: inShadow,\n            stylesheetKey: GLOBAL_STYLESHEET_KEY,\n        });\n        for (var i = 0; i < oldGlobalRules.length; i++) {\n            var styleElem = oldGlobalRules[i];\n            styleElem.setAttribute('data-merge-styles-global', 'true');\n            var cssRules = ((_a = styleElem.sheet) === null || _a === void 0 ? void 0 : _a.cssRules) || [];\n            for (var j = 0; j < cssRules.length; j++) {\n                var rule = cssRules[j];\n                stylesheet.insertRule(rule.cssText);\n            }\n        }\n    }\n};\nvar ShadowDomStylesheet = /** @class */ (function (_super) {\n    __extends(ShadowDomStylesheet, _super);\n    function ShadowDomStylesheet(config, serializedStylesheet) {\n        var _this = _super.call(this, config, serializedStylesheet) || this;\n        _this._onAddSheetCallbacks = [];\n        _this._sheetCounter = 0;\n        _this._adoptableSheets = new Map();\n        _global[SHADOW_DOM_STYLESHEET_SETTING] = ShadowDomStylesheet;\n        return _this;\n    }\n    ShadowDomStylesheet.getInstance = function (shadowConfig) {\n        var sConfig = shadowConfig || DEFAULT_SHADOW_CONFIG;\n        var stylesheetKey = sConfig.stylesheetKey || GLOBAL_STYLESHEET_KEY;\n        var inShadow = sConfig.inShadow;\n        var win = sConfig.window || (typeof window !== 'undefined' ? window : undefined);\n        var global = (win || _global);\n        var doc = win ? win.document : typeof document !== 'undefined' ? document : undefined;\n        _stylesheet = global[STYLESHEET_SETTING];\n        // When an app has multiple versions of Fluent v8 it is possible\n        // that an older version of Stylesheet is initialized before\n        // the version that supports shadow DOM. We check for this case\n        // and re-initialize the stylesheet in that case.\n        var oldStylesheetInitializedFirst = _stylesheet && !_stylesheet.getAdoptedSheets;\n        if (!_stylesheet ||\n            oldStylesheetInitializedFirst ||\n            (_stylesheet._lastStyleElement && _stylesheet._lastStyleElement.ownerDocument !== doc)) {\n            var fabricConfig = (global === null || global === void 0 ? void 0 : global.FabricConfig) || {};\n            var defaultMergeStyles = {\n                window: win,\n                inShadow: inShadow,\n                stylesheetKey: stylesheetKey,\n            };\n            fabricConfig.mergeStyles = fabricConfig.mergeStyles || {};\n            fabricConfig.mergeStyles = __assign(__assign({}, defaultMergeStyles), fabricConfig.mergeStyles);\n            var stylesheet = void 0;\n            if (oldStylesheetInitializedFirst) {\n                stylesheet = new ShadowDomStylesheet(fabricConfig.mergeStyles, JSON.parse(_stylesheet.serialize()));\n                copyOldGlobalRules(stylesheet, inShadow, win, doc);\n            }\n            else {\n                stylesheet = new ShadowDomStylesheet(fabricConfig.mergeStyles, fabricConfig.serializedStylesheet);\n            }\n            _stylesheet = stylesheet;\n            global[STYLESHEET_SETTING] = _stylesheet;\n        }\n        else {\n            _stylesheet.setConfig({\n                window: win,\n                inShadow: inShadow,\n                stylesheetKey: stylesheetKey,\n            });\n        }\n        if (win) {\n            _stylesheet._getAdoptableStyleSheet(stylesheetKey);\n        }\n        return _stylesheet;\n    };\n    ShadowDomStylesheet.prototype.getAdoptedSheets = function () {\n        return this._adoptableSheets;\n    };\n    ShadowDomStylesheet.prototype.onAddSheet = function (callback) {\n        var _this = this;\n        this._onAddSheetCallbacks.push(callback);\n        return function () {\n            _this._onAddSheetCallbacks = _this._onAddSheetCallbacks.filter(function (cb) { return cb !== callback; });\n        };\n    };\n    ShadowDomStylesheet.prototype.insertRule = function (rule, preserve) {\n        var _a = this._config, injectionMode = _a.injectionMode, _b = _a.stylesheetKey, stylesheetKey = _b === void 0 ? GLOBAL_STYLESHEET_KEY : _b;\n        var injectStyles = injectionMode !== InjectionMode.none;\n        var addToConstructableStylesheet = stylesheetKey === GLOBAL_STYLESHEET_KEY || !!this._adoptableSheets.has(stylesheetKey);\n        var constructableSheet = undefined;\n        if (injectStyles && addToConstructableStylesheet) {\n            constructableSheet = this._getAdoptableStyleSheet(stylesheetKey);\n        }\n        if (constructableSheet) {\n            this._insertRuleIntoSheet(constructableSheet, rule);\n        }\n        _super.prototype.insertRule.call(this, rule, preserve, stylesheetKey);\n    };\n    ShadowDomStylesheet.prototype._getCacheKey = function (key) {\n        var _a = this._config, _b = _a.inShadow, inShadow = _b === void 0 ? false : _b, _c = _a.stylesheetKey, currentStylesheetKey = _c === void 0 ? GLOBAL_STYLESHEET_KEY : _c;\n        if (inShadow) {\n            return \"__\".concat(currentStylesheetKey, \"__\").concat(key);\n        }\n        return _super.prototype._getCacheKey.call(this, key);\n    };\n    ShadowDomStylesheet.prototype._createStyleElement = function () {\n        var styleElement = _super.prototype._createStyleElement.call(this);\n        if (this._config.stylesheetKey === GLOBAL_STYLESHEET_KEY) {\n            styleElement.setAttribute('data-merge-styles-global', 'true');\n        }\n        return styleElement;\n    };\n    ShadowDomStylesheet.prototype._makeCSSStyleSheet = function () {\n        var win = this._config.window || window;\n        var sheet = undefined;\n        if (!SUPPORTS_CONSTRUCTABLE_STYLESHEETS) {\n            var style = this._createStyleElement();\n            sheet = style.sheet;\n        }\n        else {\n            sheet = new win.CSSStyleSheet();\n        }\n        if (sheet) {\n            sheet.bucketName = 'merge-styles';\n            sheet.metadata = {\n                stylesheetKey: this._config.stylesheetKey || GLOBAL_STYLESHEET_KEY,\n                sortOrder: this._sheetCounter++,\n            };\n        }\n        return sheet;\n    };\n    ShadowDomStylesheet.prototype._addAdoptableStyleSheet = function (key, sheet, queue) {\n        var _this = this;\n        if (queue === void 0) { queue = true; }\n        if (!this._adoptableSheets.has(key)) {\n            this._adoptableSheets.set(key, sheet);\n            var win = this._config.window;\n            if (queue && win) {\n                win.queueMicrotask(function () {\n                    _this._onAddSheetCallbacks.forEach(function (callback) { return callback({ key: key, sheet: sheet }); });\n                });\n            }\n        }\n    };\n    ShadowDomStylesheet.prototype._getAdoptableStyleSheet = function (key) {\n        var sheet = this._adoptableSheets.get(key);\n        if (!sheet) {\n            sheet = this._makeCSSStyleSheet();\n            this._addAdoptableStyleSheet(key, sheet);\n        }\n        return sheet;\n    };\n    return ShadowDomStylesheet;\n}(Stylesheet));\nexport { ShadowDomStylesheet };\n//# sourceMappingURL=ShadowDomStylesheet.js.map","var clamp = function (min, max) { return function (v) {\n    return Math.max(Math.min(v, max), min);\n}; };\nvar sanitize = function (v) { return (v % 1 ? Number(v.toFixed(5)) : v); };\nvar floatRegex = /(-)?([\\d]*\\.?[\\d])+/g;\nvar colorRegex = /(#[0-9a-f]{6}|#[0-9a-f]{3}|#(?:[0-9a-f]{2}){2,4}|(rgb|hsl)a?\\((-?[\\d\\.]+%?[,\\s]+){2,3}\\s*\\/*\\s*[\\d\\.]+%?\\))/gi;\nvar singleColorRegex = /^(#[0-9a-f]{3}|#(?:[0-9a-f]{2}){2,4}|(rgb|hsl)a?\\((-?[\\d\\.]+%?[,\\s]+){2,3}\\s*\\/*\\s*[\\d\\.]+%?\\))$/i;\nfunction isString(v) {\n    return typeof v === 'string';\n}\n\nexport { clamp, colorRegex, floatRegex, isString, sanitize, singleColorRegex };\n","import { keydownHandler } from 'prosemirror-keymap';\nimport { Selection, NodeSelection, TextSelection, Plugin } from 'prosemirror-state';\nimport { Slice, Fragment } from 'prosemirror-model';\nimport { DecorationSet, Decoration } from 'prosemirror-view';\n\n/**\nGap cursor selections are represented using this class. Its\n`$anchor` and `$head` properties both point at the cursor position.\n*/\nclass GapCursor extends Selection {\n    /**\n    Create a gap cursor.\n    */\n    constructor($pos) {\n        super($pos, $pos);\n    }\n    map(doc, mapping) {\n        let $pos = doc.resolve(mapping.map(this.head));\n        return GapCursor.valid($pos) ? new GapCursor($pos) : Selection.near($pos);\n    }\n    content() { return Slice.empty; }\n    eq(other) {\n        return other instanceof GapCursor && other.head == this.head;\n    }\n    toJSON() {\n        return { type: \"gapcursor\", pos: this.head };\n    }\n    /**\n    @internal\n    */\n    static fromJSON(doc, json) {\n        if (typeof json.pos != \"number\")\n            throw new RangeError(\"Invalid input for GapCursor.fromJSON\");\n        return new GapCursor(doc.resolve(json.pos));\n    }\n    /**\n    @internal\n    */\n    getBookmark() { return new GapBookmark(this.anchor); }\n    /**\n    @internal\n    */\n    static valid($pos) {\n        let parent = $pos.parent;\n        if (parent.isTextblock || !closedBefore($pos) || !closedAfter($pos))\n            return false;\n        let override = parent.type.spec.allowGapCursor;\n        if (override != null)\n            return override;\n        let deflt = parent.contentMatchAt($pos.index()).defaultType;\n        return deflt && deflt.isTextblock;\n    }\n    /**\n    @internal\n    */\n    static findGapCursorFrom($pos, dir, mustMove = false) {\n        search: for (;;) {\n            if (!mustMove && GapCursor.valid($pos))\n                return $pos;\n            let pos = $pos.pos, next = null;\n            // Scan up from this position\n            for (let d = $pos.depth;; d--) {\n                let parent = $pos.node(d);\n                if (dir > 0 ? $pos.indexAfter(d) < parent.childCount : $pos.index(d) > 0) {\n                    next = parent.child(dir > 0 ? $pos.indexAfter(d) : $pos.index(d) - 1);\n                    break;\n                }\n                else if (d == 0) {\n                    return null;\n                }\n                pos += dir;\n                let $cur = $pos.doc.resolve(pos);\n                if (GapCursor.valid($cur))\n                    return $cur;\n            }\n            // And then down into the next node\n            for (;;) {\n                let inside = dir > 0 ? next.firstChild : next.lastChild;\n                if (!inside) {\n                    if (next.isAtom && !next.isText && !NodeSelection.isSelectable(next)) {\n                        $pos = $pos.doc.resolve(pos + next.nodeSize * dir);\n                        mustMove = false;\n                        continue search;\n                    }\n                    break;\n                }\n                next = inside;\n                pos += dir;\n                let $cur = $pos.doc.resolve(pos);\n                if (GapCursor.valid($cur))\n                    return $cur;\n            }\n            return null;\n        }\n    }\n}\nGapCursor.prototype.visible = false;\nGapCursor.findFrom = GapCursor.findGapCursorFrom;\nSelection.jsonID(\"gapcursor\", GapCursor);\nclass GapBookmark {\n    constructor(pos) {\n        this.pos = pos;\n    }\n    map(mapping) {\n        return new GapBookmark(mapping.map(this.pos));\n    }\n    resolve(doc) {\n        let $pos = doc.resolve(this.pos);\n        return GapCursor.valid($pos) ? new GapCursor($pos) : Selection.near($pos);\n    }\n}\nfunction closedBefore($pos) {\n    for (let d = $pos.depth; d >= 0; d--) {\n        let index = $pos.index(d), parent = $pos.node(d);\n        // At the start of this parent, look at next one\n        if (index == 0) {\n            if (parent.type.spec.isolating)\n                return true;\n            continue;\n        }\n        // See if the node before (or its first ancestor) is closed\n        for (let before = parent.child(index - 1);; before = before.lastChild) {\n            if ((before.childCount == 0 && !before.inlineContent) || before.isAtom || before.type.spec.isolating)\n                return true;\n            if (before.inlineContent)\n                return false;\n        }\n    }\n    // Hit start of document\n    return true;\n}\nfunction closedAfter($pos) {\n    for (let d = $pos.depth; d >= 0; d--) {\n        let index = $pos.indexAfter(d), parent = $pos.node(d);\n        if (index == parent.childCount) {\n            if (parent.type.spec.isolating)\n                return true;\n            continue;\n        }\n        for (let after = parent.child(index);; after = after.firstChild) {\n            if ((after.childCount == 0 && !after.inlineContent) || after.isAtom || after.type.spec.isolating)\n                return true;\n            if (after.inlineContent)\n                return false;\n        }\n    }\n    return true;\n}\n\n/**\nCreate a gap cursor plugin. When enabled, this will capture clicks\nnear and arrow-key-motion past places that don't have a normally\nselectable position nearby, and create a gap cursor selection for\nthem. The cursor is drawn as an element with class\n`ProseMirror-gapcursor`. You can either include\n`style/gapcursor.css` from the package's directory or add your own\nstyles to make it visible.\n*/\nfunction gapCursor() {\n    return new Plugin({\n        props: {\n            decorations: drawGapCursor,\n            createSelectionBetween(_view, $anchor, $head) {\n                return $anchor.pos == $head.pos && GapCursor.valid($head) ? new GapCursor($head) : null;\n            },\n            handleClick,\n            handleKeyDown,\n            handleDOMEvents: { beforeinput: beforeinput }\n        }\n    });\n}\nconst handleKeyDown = keydownHandler({\n    \"ArrowLeft\": arrow(\"horiz\", -1),\n    \"ArrowRight\": arrow(\"horiz\", 1),\n    \"ArrowUp\": arrow(\"vert\", -1),\n    \"ArrowDown\": arrow(\"vert\", 1)\n});\nfunction arrow(axis, dir) {\n    const dirStr = axis == \"vert\" ? (dir > 0 ? \"down\" : \"up\") : (dir > 0 ? \"right\" : \"left\");\n    return function (state, dispatch, view) {\n        let sel = state.selection;\n        let $start = dir > 0 ? sel.$to : sel.$from, mustMove = sel.empty;\n        if (sel instanceof TextSelection) {\n            if (!view.endOfTextblock(dirStr) || $start.depth == 0)\n                return false;\n            mustMove = false;\n            $start = state.doc.resolve(dir > 0 ? $start.after() : $start.before());\n        }\n        let $found = GapCursor.findGapCursorFrom($start, dir, mustMove);\n        if (!$found)\n            return false;\n        if (dispatch)\n            dispatch(state.tr.setSelection(new GapCursor($found)));\n        return true;\n    };\n}\nfunction handleClick(view, pos, event) {\n    if (!view || !view.editable)\n        return false;\n    let $pos = view.state.doc.resolve(pos);\n    if (!GapCursor.valid($pos))\n        return false;\n    let clickPos = view.posAtCoords({ left: event.clientX, top: event.clientY });\n    if (clickPos && clickPos.inside > -1 && NodeSelection.isSelectable(view.state.doc.nodeAt(clickPos.inside)))\n        return false;\n    view.dispatch(view.state.tr.setSelection(new GapCursor($pos)));\n    return true;\n}\n// This is a hack that, when a composition starts while a gap cursor\n// is active, quickly creates an inline context for the composition to\n// happen in, to avoid it being aborted by the DOM selection being\n// moved into a valid position.\nfunction beforeinput(view, event) {\n    if (event.inputType != \"insertCompositionText\" || !(view.state.selection instanceof GapCursor))\n        return false;\n    let { $from } = view.state.selection;\n    let insert = $from.parent.contentMatchAt($from.index()).findWrapping(view.state.schema.nodes.text);\n    if (!insert)\n        return false;\n    let frag = Fragment.empty;\n    for (let i = insert.length - 1; i >= 0; i--)\n        frag = Fragment.from(insert[i].createAndFill(null, frag));\n    let tr = view.state.tr.replace($from.pos, $from.pos, new Slice(frag, 0, 0));\n    tr.setSelection(TextSelection.near(tr.doc.resolve($from.pos + 1)));\n    view.dispatch(tr);\n    return false;\n}\nfunction drawGapCursor(state) {\n    if (!(state.selection instanceof GapCursor))\n        return null;\n    let node = document.createElement(\"div\");\n    node.className = \"ProseMirror-gapcursor\";\n    return DecorationSet.create(state.doc, [Decoration.widget(state.selection.head, node, { key: \"gapcursor\" })]);\n}\n\nexport { GapCursor, gapCursor };\n","export var FLUENT_CDN_BASE_URL = 'https://res.cdn.office.net/files/fabric-cdn-prod_20240805.001';\n//# sourceMappingURL=cdn.js.map","import $iFADg$react, {useContext as $iFADg$useContext, useState as $iFADg$useState, useEffect as $iFADg$useEffect, useMemo as $iFADg$useMemo, useRef as $iFADg$useRef} from \"react\";\nimport {useIsSSR as $iFADg$useIsSSR} from \"@react-aria/ssr\";\nimport {LocalizedStringDictionary as $iFADg$LocalizedStringDictionary, LocalizedStringFormatter as $iFADg$LocalizedStringFormatter} from \"@internationalized/string\";\nimport {DateFormatter as $iFADg$DateFormatter} from \"@internationalized/date\";\nimport {NumberFormatter as $iFADg$NumberFormatter} from \"@internationalized/number\";\n\n/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */ // https://en.wikipedia.org/wiki/Right-to-left\nconst $148a7a147e38ea7f$var$RTL_SCRIPTS = new Set([\n    'Arab',\n    'Syrc',\n    'Samr',\n    'Mand',\n    'Thaa',\n    'Mend',\n    'Nkoo',\n    'Adlm',\n    'Rohg',\n    'Hebr'\n]);\nconst $148a7a147e38ea7f$var$RTL_LANGS = new Set([\n    'ae',\n    'ar',\n    'arc',\n    'bcc',\n    'bqi',\n    'ckb',\n    'dv',\n    'fa',\n    'glk',\n    'he',\n    'ku',\n    'mzn',\n    'nqo',\n    'pnb',\n    'ps',\n    'sd',\n    'ug',\n    'ur',\n    'yi'\n]);\nfunction $148a7a147e38ea7f$export$702d680b21cbd764(locale) {\n    // If the Intl.Locale API is available, use it to get the script for the locale.\n    // This is more accurate than guessing by language, since languages can be written in multiple scripts.\n    // @ts-ignore\n    if (Intl.Locale) {\n        // @ts-ignore\n        let script = new Intl.Locale(locale).maximize().script;\n        return $148a7a147e38ea7f$var$RTL_SCRIPTS.has(script);\n    }\n    // If not, just guess by the language (first part of the locale)\n    let lang = locale.split('-')[0];\n    return $148a7a147e38ea7f$var$RTL_LANGS.has(lang);\n}\n\n\n\n\n\nfunction $1e5a04cdaf7d1af8$export$f09106e7c6677ec5() {\n    // @ts-ignore\n    let locale = typeof navigator !== 'undefined' && (navigator.language || navigator.userLanguage) || 'en-US';\n    try {\n        // @ts-ignore\n        Intl.DateTimeFormat.supportedLocalesOf([\n            locale\n        ]);\n    } catch (_err) {\n        locale = 'en-US';\n    }\n    return {\n        locale: locale,\n        direction: $148a7a147e38ea7f$export$702d680b21cbd764(locale) ? 'rtl' : 'ltr'\n    };\n}\nlet $1e5a04cdaf7d1af8$var$currentLocale = $1e5a04cdaf7d1af8$export$f09106e7c6677ec5();\nlet $1e5a04cdaf7d1af8$var$listeners = new Set();\nfunction $1e5a04cdaf7d1af8$var$updateLocale() {\n    $1e5a04cdaf7d1af8$var$currentLocale = $1e5a04cdaf7d1af8$export$f09106e7c6677ec5();\n    for (let listener of $1e5a04cdaf7d1af8$var$listeners)listener($1e5a04cdaf7d1af8$var$currentLocale);\n}\nfunction $1e5a04cdaf7d1af8$export$188ec29ebc2bdc3a() {\n    let isSSR = $iFADg$useIsSSR();\n    let [defaultLocale, setDefaultLocale] = $iFADg$useState($1e5a04cdaf7d1af8$var$currentLocale);\n    $iFADg$useEffect(()=>{\n        if ($1e5a04cdaf7d1af8$var$listeners.size === 0) window.addEventListener('languagechange', $1e5a04cdaf7d1af8$var$updateLocale);\n        $1e5a04cdaf7d1af8$var$listeners.add(setDefaultLocale);\n        return ()=>{\n            $1e5a04cdaf7d1af8$var$listeners.delete(setDefaultLocale);\n            if ($1e5a04cdaf7d1af8$var$listeners.size === 0) window.removeEventListener('languagechange', $1e5a04cdaf7d1af8$var$updateLocale);\n        };\n    }, []);\n    // We cannot determine the browser's language on the server, so default to\n    // en-US. This will be updated after hydration on the client to the correct value.\n    if (isSSR) return {\n        locale: 'en-US',\n        direction: 'ltr'\n    };\n    return defaultLocale;\n}\n\n\n\nconst $18f2051aff69b9bf$var$I18nContext = /*#__PURE__*/ $iFADg$react.createContext(null);\nfunction $18f2051aff69b9bf$export$a54013f0d02a8f82(props) {\n    let { locale: locale , children: children  } = props;\n    let defaultLocale = $1e5a04cdaf7d1af8$export$188ec29ebc2bdc3a();\n    let value = locale ? {\n        locale: locale,\n        direction: $148a7a147e38ea7f$export$702d680b21cbd764(locale) ? 'rtl' : 'ltr'\n    } : defaultLocale;\n    return(/*#__PURE__*/ $iFADg$react.createElement($18f2051aff69b9bf$var$I18nContext.Provider, {\n        value: value\n    }, children));\n}\nfunction $18f2051aff69b9bf$export$43bb16f9c6d9e3f7() {\n    let defaultLocale = $1e5a04cdaf7d1af8$export$188ec29ebc2bdc3a();\n    let context = $iFADg$useContext($18f2051aff69b9bf$var$I18nContext);\n    return context || defaultLocale;\n}\n\n\nvar $2aa2084a6c2b6b4f$exports = {};\n\"use strict\";\n\n\n\n\n\nconst $fca6afa0e843324b$var$cache = new WeakMap();\nfunction $fca6afa0e843324b$var$getCachedDictionary(strings) {\n    let dictionary = $fca6afa0e843324b$var$cache.get(strings);\n    if (!dictionary) {\n        dictionary = new $iFADg$LocalizedStringDictionary(strings);\n        $fca6afa0e843324b$var$cache.set(strings, dictionary);\n    }\n    return dictionary;\n}\nfunction $fca6afa0e843324b$export$f12b703ca79dfbb1(strings) {\n    let { locale: locale  } = $18f2051aff69b9bf$export$43bb16f9c6d9e3f7();\n    let dictionary = $iFADg$useMemo(()=>$fca6afa0e843324b$var$getCachedDictionary(strings)\n    , [\n        strings\n    ]);\n    return $iFADg$useMemo(()=>new $iFADg$LocalizedStringFormatter(locale, dictionary)\n    , [\n        locale,\n        dictionary\n    ]);\n}\n\n\n\n\nfunction $33bf17300c498528$export$a2f47a3d2973640(options = {\n}) {\n    let { locale: locale  } = $18f2051aff69b9bf$export$43bb16f9c6d9e3f7();\n    // @ts-ignore\n    return $iFADg$useMemo(()=>new Intl.ListFormat(locale, options)\n    , [\n        locale,\n        options\n    ]);\n}\n\n\n\n\n\nfunction $896ba0a80a8f4d36$export$85fd5fdf27bacc79(options) {\n    // Reuse last options object if it is shallowly equal, which allows the useMemo result to also be reused.\n    let lastOptions = $iFADg$useRef(null);\n    if (options && lastOptions.current && $896ba0a80a8f4d36$var$isEqual(options, lastOptions.current)) options = lastOptions.current;\n    lastOptions.current = options;\n    let { locale: locale  } = $18f2051aff69b9bf$export$43bb16f9c6d9e3f7();\n    return $iFADg$useMemo(()=>new $iFADg$DateFormatter(locale, options)\n    , [\n        locale,\n        options\n    ]);\n}\nfunction $896ba0a80a8f4d36$var$isEqual(a, b) {\n    if (a === b) return true;\n    let aKeys = Object.keys(a);\n    let bKeys = Object.keys(b);\n    if (aKeys.length !== bKeys.length) return false;\n    for (let key of aKeys){\n        if (b[key] !== a[key]) return false;\n    }\n    return true;\n}\n\n\n\n\n\nfunction $a916eb452884faea$export$b7a616150fdb9f44(options = {\n}) {\n    let { locale: locale  } = $18f2051aff69b9bf$export$43bb16f9c6d9e3f7();\n    return $iFADg$useMemo(()=>new $iFADg$NumberFormatter(locale, options)\n    , [\n        locale,\n        options\n    ]);\n}\n\n\n\nlet $325a3faab7a68acd$var$cache = new Map();\nfunction $325a3faab7a68acd$export$a16aca283550c30d(options) {\n    let { locale: locale  } = $18f2051aff69b9bf$export$43bb16f9c6d9e3f7();\n    let cacheKey = locale + (options ? Object.entries(options).sort((a, b)=>a[0] < b[0] ? -1 : 1\n    ).join() : '');\n    if ($325a3faab7a68acd$var$cache.has(cacheKey)) return $325a3faab7a68acd$var$cache.get(cacheKey);\n    let formatter = new Intl.Collator(locale, options);\n    $325a3faab7a68acd$var$cache.set(cacheKey, formatter);\n    return formatter;\n}\n\n\n\nfunction $bb77f239b46e8c72$export$3274cf84b703fff(options) {\n    let collator = $325a3faab7a68acd$export$a16aca283550c30d({\n        usage: 'search',\n        ...options\n    });\n    // TODO(later): these methods don't currently support the ignorePunctuation option.\n    return {\n        startsWith (string, substring) {\n            if (substring.length === 0) return true;\n            // Normalize both strings so we can slice safely\n            // TODO: take into account the ignorePunctuation option as well...\n            string = string.normalize('NFC');\n            substring = substring.normalize('NFC');\n            return collator.compare(string.slice(0, substring.length), substring) === 0;\n        },\n        endsWith (string, substring) {\n            if (substring.length === 0) return true;\n            string = string.normalize('NFC');\n            substring = substring.normalize('NFC');\n            return collator.compare(string.slice(-substring.length), substring) === 0;\n        },\n        contains (string, substring) {\n            if (substring.length === 0) return true;\n            string = string.normalize('NFC');\n            substring = substring.normalize('NFC');\n            let scan = 0;\n            let sliceLen = substring.length;\n            for(; scan + sliceLen <= string.length; scan++){\n                let slice = string.slice(scan, scan + sliceLen);\n                if (collator.compare(substring, slice) === 0) return true;\n            }\n            return false;\n        }\n    };\n}\n\n\n\n\nexport {$18f2051aff69b9bf$export$a54013f0d02a8f82 as I18nProvider, $18f2051aff69b9bf$export$43bb16f9c6d9e3f7 as useLocale, $fca6afa0e843324b$export$f12b703ca79dfbb1 as useLocalizedStringFormatter, $33bf17300c498528$export$a2f47a3d2973640 as useListFormatter, $896ba0a80a8f4d36$export$85fd5fdf27bacc79 as useDateFormatter, $a916eb452884faea$export$b7a616150fdb9f44 as useNumberFormatter, $325a3faab7a68acd$export$a16aca283550c30d as useCollator, $bb77f239b46e8c72$export$3274cf84b703fff as useFilter};\n//# sourceMappingURL=real-module.js.map\n","/** PURE_IMPORTS_START _identity PURE_IMPORTS_END */\nimport { identity } from './identity';\nexport function pipe() {\n    var fns = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        fns[_i] = arguments[_i];\n    }\n    return pipeFromArray(fns);\n}\nexport function pipeFromArray(fns) {\n    if (fns.length === 0) {\n        return identity;\n    }\n    if (fns.length === 1) {\n        return fns[0];\n    }\n    return function piped(input) {\n        return fns.reduce(function (prev, fn) { return fn(prev); }, input);\n    };\n}\n//# sourceMappingURL=pipe.js.map\n","var rules = {};\nexport function kebabRules(rulePairs, index) {\n    var rule = rulePairs[index];\n    if (rule.charAt(0) !== '-') {\n        rulePairs[index] = rules[rule] = rules[rule] || rule.replace(/([A-Z])/g, '-$1').toLowerCase();\n    }\n}\n//# sourceMappingURL=kebabRules.js.map","/**\n * Sets the virtual parent of an element.\n * Pass `undefined` as the `parent` to clear the virtual parent.\n *\n * @public\n */\nexport function setVirtualParent(child, parent) {\n    var virtualChild = child;\n    var virtualParent = parent;\n    if (!virtualChild._virtual) {\n        virtualChild._virtual = {\n            children: [],\n        };\n    }\n    var oldParent = virtualChild._virtual.parent;\n    if (oldParent && oldParent !== parent) {\n        // Remove the child from its old parent.\n        var index = oldParent._virtual.children.indexOf(virtualChild);\n        if (index > -1) {\n            oldParent._virtual.children.splice(index, 1);\n        }\n    }\n    virtualChild._virtual.parent = virtualParent || undefined;\n    if (virtualParent) {\n        if (!virtualParent._virtual) {\n            virtualParent._virtual = {\n                children: [],\n            };\n        }\n        virtualParent._virtual.children.push(virtualChild);\n    }\n}\n//# sourceMappingURL=setVirtualParent.js.map","import '../constants.esm.js';\nimport { debugData } from '../devtools/store.esm.js';\nimport { isDevToolsEnabled } from '../devtools/isDevToolsEnabled.esm.js';\nimport { createIsomorphicStyleSheetFromElement } from './createIsomorphicStyleSheet.esm.js';\nimport { getStyleSheetKeyFromElement } from './getStyleSheetForBucket.esm.js';\n\n// Regexps to extract names of classes and animations\n// https://github.com/styletron/styletron/blob/e0fcae826744eb00ce679ac613a1b10d44256660/packages/styletron-engine-atomic/src/client/client.js#L8\nconst KEYFRAMES_HYDRATOR = /@(-webkit-)?keyframes ([^{]+){((?:(?:from|to|(?:\\d+\\.?\\d*%))\\{(?:[^}])*})*)}/g;\nconst AT_RULES_HYDRATOR = /@(media|supports|layer)[^{]+\\{([\\s\\S]+?})\\s*}/g;\nconst STYLES_HYDRATOR = /\\.([^{:]+)(:[^{]+)?{(?:[^}]*;)?([^}]*?)}/g;\nconst regexps = {\n  k: KEYFRAMES_HYDRATOR,\n  t: AT_RULES_HYDRATOR,\n  m: AT_RULES_HYDRATOR\n};\n/**\n * Should be called in a case of Server-Side rendering. Rehydrates cache from for a renderer to avoid double insertion\n * of classes to DOM.\n *\n * @public\n */\nfunction rehydrateRendererCache(renderer, target = typeof document === 'undefined' ? undefined : document) {\n  if (target) {\n    const styleElements = target.querySelectorAll('[data-make-styles-bucket]');\n    styleElements.forEach(styleElement => {\n      const bucketName = styleElement.dataset['makeStylesBucket'];\n      const stylesheetKey = getStyleSheetKeyFromElement(styleElement);\n      //  If some elements are not created yet, we will register them in renderer\n      if (!renderer.stylesheets[stylesheetKey]) {\n        renderer.stylesheets[stylesheetKey] = createIsomorphicStyleSheetFromElement(styleElement);\n      }\n      const regex = regexps[bucketName] || STYLES_HYDRATOR;\n      let match;\n      while (match = regex.exec(styleElement.textContent)) {\n        // \"cacheKey\" is either a class name or an animation name\n        const [cssRule] = match;\n        renderer.insertionCache[cssRule] = bucketName;\n        if (process.env.NODE_ENV !== 'production' && isDevToolsEnabled) {\n          debugData.addCSSRule(cssRule);\n        }\n      }\n    });\n  }\n}\n\nexport { rehydrateRendererCache };\n//# sourceMappingURL=rehydrateRendererCache.esm.js.map\n","import _typeof from \"./typeof.js\";\nexport default function _toPrimitive(input, hint) {\n  if (_typeof(input) !== \"object\" || input === null) return input;\n  var prim = input[Symbol.toPrimitive];\n  if (prim !== undefined) {\n    var res = prim.call(input, hint || \"default\");\n    if (_typeof(res) !== \"object\") return res;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (hint === \"string\" ? String : Number)(input);\n}","function getDirectionalClassName(classes, direction) {\n  return Array.isArray(classes) ? direction === 'rtl' ? classes[1] : classes[0] : classes || '';\n}\nfunction getDebugClassNames(lookupItem, parentLookupItem, parentDebugClassNames, overridingSiblings) {\n  const classesMapping = lookupItem[0];\n  const direction = lookupItem[1];\n  return Object.entries(classesMapping).map(([propertyHash, classes]) => {\n    const className = getDirectionalClassName(classes, direction);\n    let overriddenBy;\n    if (parentDebugClassNames && parentLookupItem) {\n      const matching = parentDebugClassNames.find(({\n        className: parentClassName\n      }) => parentClassName === className);\n      if (!matching && parentLookupItem[0][propertyHash]) {\n        // parent node does not have current className (style), but has current selector:\n        // style is overriden in current merging by another rule in sibling node\n        overriddenBy = getDirectionalClassName(parentLookupItem[0][propertyHash], parentLookupItem[1]);\n      } else if (matching && parentLookupItem[0][propertyHash]) {\n        // parent node has current className (style), and has current selector:\n        // case 1. style is not overriden during current merging; it may be overriden in higher level of merging\n        // case 2. style is overriden in current merging by exactly the same rule in sibling nodes\n        const siblingHasSameRule = overridingSiblings ? overridingSiblings.filter(({\n          debugClassNames\n        }) => debugClassNames.filter(({\n          className: siblingClassName\n        }) => siblingClassName === className).length > 0).length > 0 : false;\n        overriddenBy = siblingHasSameRule ? matching.className // case 2\n        : matching.overriddenBy; // case 1\n      } else if (!matching && !parentLookupItem[0][propertyHash]) {\n        // parent node does not have current className (style), and does not have current selector:\n        // this case is not possible\n        overriddenBy = undefined;\n      } else if (matching && !parentLookupItem[0][propertyHash]) {\n        // parent node has current className (style), but does not have current selector:\n        // this case is not possible\n        overriddenBy = undefined;\n      }\n    }\n    return {\n      className,\n      overriddenBy\n    };\n  });\n}\n\nexport { getDebugClassNames };\n//# sourceMappingURL=utils.esm.js.map\n","/** PURE_IMPORTS_START  PURE_IMPORTS_END */\nexport var observable = /*@__PURE__*/ (function () { return typeof Symbol === 'function' && Symbol.observable || '@@observable'; })();\n//# sourceMappingURL=observable.js.map\n","// Do not modify this file; it is generated as part of publish.\n// The checked in version is a placeholder only and will not be updated.\nimport { setVersion } from '@fluentui/set-version';\nsetVersion('@fluentui/style-utilities', '8.10.21');\n//# sourceMappingURL=version.js.map","import * as React from 'react';\n\nconst useInsertionEffect =\n// @ts-expect-error Hack to make sure that `useInsertionEffect` will not cause bundling issues in older React versions\n// eslint-disable-next-line no-useless-concat\nReact['useInsertion' + 'Effect'] ? React['useInsertion' + 'Effect'] : undefined;\n\nexport { useInsertionEffect };\n//# sourceMappingURL=useInsertionEffect.esm.js.map\n","import { Extension } from '@tiptap/core';\nimport { dropCursor } from '@tiptap/pm/dropcursor';\n\n/**\n * This extension allows you to add a drop cursor to your editor.\n * A drop cursor is a line that appears when you drag and drop content\n * inbetween nodes.\n * @see https://tiptap.dev/api/extensions/dropcursor\n */\nconst Dropcursor = Extension.create({\n    name: 'dropCursor',\n    addOptions() {\n        return {\n            color: 'currentColor',\n            width: 1,\n            class: undefined,\n        };\n    },\n    addProseMirrorPlugins() {\n        return [\n            dropCursor(this.options),\n        ];\n    },\n});\n\nexport { Dropcursor, Dropcursor as default };\n//# sourceMappingURL=index.js.map\n","export default function mergeByName(modifiers) {\n  var merged = modifiers.reduce(function (merged, current) {\n    var existing = merged[current.name];\n    merged[current.name] = existing ? Object.assign({}, existing, current, {\n      options: Object.assign({}, existing.options, current.options),\n      data: Object.assign({}, existing.data, current.data)\n    }) : current;\n    return merged;\n  }, {}); // IE11 does not support Object.values\n\n  return Object.keys(merged).map(function (key) {\n    return merged[key];\n  });\n}","import { Node, mergeAttributes, textblockTypeInputRule } from '@tiptap/core';\n\n/**\n * This extension allows you to create headings.\n * @see https://www.tiptap.dev/api/nodes/heading\n */\nconst Heading = Node.create({\n    name: 'heading',\n    addOptions() {\n        return {\n            levels: [1, 2, 3, 4, 5, 6],\n            HTMLAttributes: {},\n        };\n    },\n    content: 'inline*',\n    group: 'block',\n    defining: true,\n    addAttributes() {\n        return {\n            level: {\n                default: 1,\n                rendered: false,\n            },\n        };\n    },\n    parseHTML() {\n        return this.options.levels\n            .map((level) => ({\n            tag: `h${level}`,\n            attrs: { level },\n        }));\n    },\n    renderHTML({ node, HTMLAttributes }) {\n        const hasLevel = this.options.levels.includes(node.attrs.level);\n        const level = hasLevel\n            ? node.attrs.level\n            : this.options.levels[0];\n        return [`h${level}`, mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];\n    },\n    addCommands() {\n        return {\n            setHeading: attributes => ({ commands }) => {\n                if (!this.options.levels.includes(attributes.level)) {\n                    return false;\n                }\n                return commands.setNode(this.name, attributes);\n            },\n            toggleHeading: attributes => ({ commands }) => {\n                if (!this.options.levels.includes(attributes.level)) {\n                    return false;\n                }\n                return commands.toggleNode(this.name, 'paragraph', attributes);\n            },\n        };\n    },\n    addKeyboardShortcuts() {\n        return this.options.levels.reduce((items, level) => ({\n            ...items,\n            ...{\n                [`Mod-Alt-${level}`]: () => this.editor.commands.toggleHeading({ level }),\n            },\n        }), {});\n    },\n    addInputRules() {\n        return this.options.levels.map(level => {\n            return textblockTypeInputRule({\n                find: new RegExp(`^(#{1,${level}})\\\\s$`),\n                type: this.type,\n                getAttributes: {\n                    level,\n                },\n            });\n        });\n    },\n});\n\nexport { Heading, Heading as default };\n//# sourceMappingURL=index.js.map\n","export default function _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}","import { Node, mergeAttributes, Mark, getMarkAttributes, wrappingInputRule } from '@tiptap/core';\n\n/**\n * This extension allows you to create list items.\n * @see https://www.tiptap.dev/api/nodes/list-item\n */\nconst ListItem = Node.create({\n    name: 'listItem',\n    addOptions() {\n        return {\n            HTMLAttributes: {},\n            bulletListTypeName: 'bulletList',\n            orderedListTypeName: 'orderedList',\n        };\n    },\n    content: 'paragraph block*',\n    defining: true,\n    parseHTML() {\n        return [\n            {\n                tag: 'li',\n            },\n        ];\n    },\n    renderHTML({ HTMLAttributes }) {\n        return ['li', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];\n    },\n    addKeyboardShortcuts() {\n        return {\n            Enter: () => this.editor.commands.splitListItem(this.name),\n            Tab: () => this.editor.commands.sinkListItem(this.name),\n            'Shift-Tab': () => this.editor.commands.liftListItem(this.name),\n        };\n    },\n});\n\n/**\n * This extension allows you to create text styles. It is required by default\n * for the `textColor` and `backgroundColor` extensions.\n * @see https://www.tiptap.dev/api/marks/text-style\n */\nconst TextStyle = Mark.create({\n    name: 'textStyle',\n    addOptions() {\n        return {\n            HTMLAttributes: {},\n        };\n    },\n    parseHTML() {\n        return [\n            {\n                tag: 'span',\n                getAttrs: element => {\n                    const hasStyles = element.hasAttribute('style');\n                    if (!hasStyles) {\n                        return false;\n                    }\n                    return {};\n                },\n            },\n        ];\n    },\n    renderHTML({ HTMLAttributes }) {\n        return ['span', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];\n    },\n    addCommands() {\n        return {\n            removeEmptyTextStyle: () => ({ state, commands }) => {\n                const attributes = getMarkAttributes(state, this.type);\n                const hasStyles = Object.entries(attributes).some(([, value]) => !!value);\n                if (hasStyles) {\n                    return true;\n                }\n                return commands.unsetMark(this.name);\n            },\n        };\n    },\n});\n\n/**\n * Matches a bullet list to a dash or asterisk.\n */\nconst inputRegex = /^\\s*([-+*])\\s$/;\n/**\n * This extension allows you to create bullet lists.\n * This requires the ListItem extension\n * @see https://tiptap.dev/api/nodes/bullet-list\n * @see https://tiptap.dev/api/nodes/list-item.\n */\nconst BulletList = Node.create({\n    name: 'bulletList',\n    addOptions() {\n        return {\n            itemTypeName: 'listItem',\n            HTMLAttributes: {},\n            keepMarks: false,\n            keepAttributes: false,\n        };\n    },\n    group: 'block list',\n    content() {\n        return `${this.options.itemTypeName}+`;\n    },\n    parseHTML() {\n        return [\n            { tag: 'ul' },\n        ];\n    },\n    renderHTML({ HTMLAttributes }) {\n        return ['ul', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];\n    },\n    addCommands() {\n        return {\n            toggleBulletList: () => ({ commands, chain }) => {\n                if (this.options.keepAttributes) {\n                    return chain().toggleList(this.name, this.options.itemTypeName, this.options.keepMarks).updateAttributes(ListItem.name, this.editor.getAttributes(TextStyle.name)).run();\n                }\n                return commands.toggleList(this.name, this.options.itemTypeName, this.options.keepMarks);\n            },\n        };\n    },\n    addKeyboardShortcuts() {\n        return {\n            'Mod-Shift-8': () => this.editor.commands.toggleBulletList(),\n        };\n    },\n    addInputRules() {\n        let inputRule = wrappingInputRule({\n            find: inputRegex,\n            type: this.type,\n        });\n        if (this.options.keepMarks || this.options.keepAttributes) {\n            inputRule = wrappingInputRule({\n                find: inputRegex,\n                type: this.type,\n                keepMarks: this.options.keepMarks,\n                keepAttributes: this.options.keepAttributes,\n                getAttributes: () => { return this.editor.getAttributes(TextStyle.name); },\n                editor: this.editor,\n            });\n        }\n        return [\n            inputRule,\n        ];\n    },\n});\n\nexport { BulletList, BulletList as default, inputRegex };\n//# sourceMappingURL=index.js.map\n","export var TimeConstants = {\n    MillisecondsInOneDay: 86400000,\n    MillisecondsIn1Sec: 1000,\n    MillisecondsIn1Min: 60000,\n    MillisecondsIn30Mins: 1800000,\n    MillisecondsIn1Hour: 3600000,\n    MinutesInOneDay: 1440,\n    MinutesInOneHour: 60,\n    DaysInOneWeek: 7,\n    MonthInOneYear: 12,\n    HoursInOneDay: 24,\n    SecondsInOneMinute: 60,\n    OffsetTo24HourFormat: 12,\n    /**\n     * Matches a time string. Groups:\n     * 1. hours (with or without leading 0)\n     * 2. minutes\n     * 3. seconds (optional)\n     * 4. meridiem (am/pm, case-insensitive, optional)\n     */\n    TimeFormatRegex: /^(\\d\\d?):(\\d\\d):?(\\d\\d)? ?([ap]m)?/i,\n};\n//# sourceMappingURL=timeConstants.js.map","import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport React from 'react';\nvar defaultOptions = {\n  bindI18n: 'languageChanged',\n  bindI18nStore: '',\n  transEmptyNodeValue: '',\n  transSupportBasicHtmlNodes: true,\n  transWrapTextNodes: '',\n  transKeepBasicHtmlNodesFor: ['br', 'strong', 'i', 'p'],\n  useSuspense: true\n};\nvar i18nInstance;\nexport var I18nContext = React.createContext();\nexport function setDefaults() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  defaultOptions = _objectSpread(_objectSpread({}, defaultOptions), options);\n}\nexport function getDefaults() {\n  return defaultOptions;\n}\nexport var ReportNamespaces = function () {\n  function ReportNamespaces() {\n    _classCallCheck(this, ReportNamespaces);\n\n    this.usedNamespaces = {};\n  }\n\n  _createClass(ReportNamespaces, [{\n    key: \"addUsedNamespaces\",\n    value: function addUsedNamespaces(namespaces) {\n      var _this = this;\n\n      namespaces.forEach(function (ns) {\n        if (!_this.usedNamespaces[ns]) _this.usedNamespaces[ns] = true;\n      });\n    }\n  }, {\n    key: \"getUsedNamespaces\",\n    value: function getUsedNamespaces() {\n      return Object.keys(this.usedNamespaces);\n    }\n  }]);\n\n  return ReportNamespaces;\n}();\nexport function setI18n(instance) {\n  i18nInstance = instance;\n}\nexport function getI18n() {\n  return i18nInstance;\n}\nexport var initReactI18next = {\n  type: '3rdParty',\n  init: function init(instance) {\n    setDefaults(instance.options.react);\n    setI18n(instance);\n  }\n};\nexport function composeInitialProps(ForComponent) {\n  return function (ctx) {\n    return new Promise(function (resolve) {\n      var i18nInitialProps = getInitialProps();\n\n      if (ForComponent.getInitialProps) {\n        ForComponent.getInitialProps(ctx).then(function (componentsInitialProps) {\n          resolve(_objectSpread(_objectSpread({}, componentsInitialProps), i18nInitialProps));\n        });\n      } else {\n        resolve(i18nInitialProps);\n      }\n    });\n  };\n}\nexport function getInitialProps() {\n  var i18n = getI18n();\n  var namespaces = i18n.reportNamespaces ? i18n.reportNamespaces.getUsedNamespaces() : [];\n  var ret = {};\n  var initialI18nStore = {};\n  i18n.languages.forEach(function (l) {\n    initialI18nStore[l] = {};\n    namespaces.forEach(function (ns) {\n      initialI18nStore[l][ns] = i18n.getResourceBundle(l, ns) || {};\n    });\n  });\n  ret.initialI18nStore = initialI18nStore;\n  ret.initialLanguage = i18n.language;\n  return ret;\n}","/** PURE_IMPORTS_START  PURE_IMPORTS_END */\nexport var isArray = /*@__PURE__*/ (function () { return Array.isArray || (function (x) { return x && typeof x.length === 'number'; }); })();\n//# sourceMappingURL=isArray.js.map\n","export default function getHTMLElementScroll(element) {\n  return {\n    scrollLeft: element.scrollLeft,\n    scrollTop: element.scrollTop\n  };\n}","// view/index.ts\nexport * from \"prosemirror-view\";\n","import getClippingRect from \"../dom-utils/getClippingRect.js\";\nimport getDocumentElement from \"../dom-utils/getDocumentElement.js\";\nimport getBoundingClientRect from \"../dom-utils/getBoundingClientRect.js\";\nimport computeOffsets from \"./computeOffsets.js\";\nimport rectToClientRect from \"./rectToClientRect.js\";\nimport { clippingParents, reference, popper, bottom, top, right, basePlacements, viewport } from \"../enums.js\";\nimport { isElement } from \"../dom-utils/instanceOf.js\";\nimport mergePaddingObject from \"./mergePaddingObject.js\";\nimport expandToHashMap from \"./expandToHashMap.js\"; // eslint-disable-next-line import/no-unused-modules\n\nexport default function detectOverflow(state, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var _options = options,\n      _options$placement = _options.placement,\n      placement = _options$placement === void 0 ? state.placement : _options$placement,\n      _options$strategy = _options.strategy,\n      strategy = _options$strategy === void 0 ? state.strategy : _options$strategy,\n      _options$boundary = _options.boundary,\n      boundary = _options$boundary === void 0 ? clippingParents : _options$boundary,\n      _options$rootBoundary = _options.rootBoundary,\n      rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary,\n      _options$elementConte = _options.elementContext,\n      elementContext = _options$elementConte === void 0 ? popper : _options$elementConte,\n      _options$altBoundary = _options.altBoundary,\n      altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,\n      _options$padding = _options.padding,\n      padding = _options$padding === void 0 ? 0 : _options$padding;\n  var paddingObject = mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));\n  var altContext = elementContext === popper ? reference : popper;\n  var popperRect = state.rects.popper;\n  var element = state.elements[altBoundary ? altContext : elementContext];\n  var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);\n  var referenceClientRect = getBoundingClientRect(state.elements.reference);\n  var popperOffsets = computeOffsets({\n    reference: referenceClientRect,\n    element: popperRect,\n    strategy: 'absolute',\n    placement: placement\n  });\n  var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets));\n  var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect\n  // 0 or negative = within the clipping rect\n\n  var overflowOffsets = {\n    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,\n    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,\n    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,\n    right: elementClientRect.right - clippingClientRect.right + paddingObject.right\n  };\n  var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element\n\n  if (elementContext === popper && offsetData) {\n    var offset = offsetData[placement];\n    Object.keys(overflowOffsets).forEach(function (key) {\n      var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;\n      var axis = [top, bottom].indexOf(key) >= 0 ? 'y' : 'x';\n      overflowOffsets[key] += offset[axis] * multiply;\n    });\n  }\n\n  return overflowOffsets;\n}","import { __spreadArray } from \"tslib\";\nimport { compareDatePart } from '../dateMath/dateMath';\n/**\n * Generates a list of dates, bounded by min and max dates\n * @param dateRange - input date range\n * @param minDate - min date to limit the range\n * @param maxDate - max date to limit the range\n */\nexport var getBoundedDateRange = function (dateRange, minDate, maxDate) {\n    var boundedDateRange = __spreadArray([], dateRange, true);\n    if (minDate) {\n        boundedDateRange = boundedDateRange.filter(function (date) { return compareDatePart(date, minDate) >= 0; });\n    }\n    if (maxDate) {\n        boundedDateRange = boundedDateRange.filter(function (date) { return compareDatePart(date, maxDate) <= 0; });\n    }\n    return boundedDateRange;\n};\n//# sourceMappingURL=getBoundedDateRange.js.map","import { DATA_PRIORITY_ATTR, DATA_BUCKET_ATTR } from '../constants.esm.js';\n\nfunction createIsomorphicStyleSheet(styleElement, bucketName, priority, elementAttributes) {\n  // no CSSStyleSheet in SSR, just append rules here for server render\n  const __cssRulesForSSR = [];\n  elementAttributes[DATA_BUCKET_ATTR] = bucketName;\n  elementAttributes[DATA_PRIORITY_ATTR] = String(priority);\n  if (styleElement) {\n    for (const attrName in elementAttributes) {\n      styleElement.setAttribute(attrName, elementAttributes[attrName]);\n    }\n  }\n  function insertRule(rule) {\n    if (styleElement === null || styleElement === void 0 ? void 0 : styleElement.sheet) {\n      return styleElement.sheet.insertRule(rule, styleElement.sheet.cssRules.length);\n    }\n    return __cssRulesForSSR.push(rule);\n  }\n  return {\n    elementAttributes,\n    insertRule,\n    element: styleElement,\n    bucketName,\n    cssRules() {\n      if (styleElement === null || styleElement === void 0 ? void 0 : styleElement.sheet) {\n        return Array.from(styleElement.sheet.cssRules).map(cssRule => cssRule.cssText);\n      }\n      return __cssRulesForSSR;\n    }\n  };\n}\nfunction createIsomorphicStyleSheetFromElement(element) {\n  const elementAttributes = Array.from(element.attributes).reduce((acc, attr) => {\n    acc[attr.name] = attr.value;\n    return acc;\n  }, {});\n  const stylesheet = createIsomorphicStyleSheet(element, elementAttributes[DATA_BUCKET_ATTR], Number(elementAttributes[DATA_PRIORITY_ATTR]), elementAttributes);\n  return stylesheet;\n}\n\nexport { createIsomorphicStyleSheet, createIsomorphicStyleSheetFromElement };\n//# sourceMappingURL=createIsomorphicStyleSheet.esm.js.map\n","import { findElementRecursive } from './findElementRecursive';\n/**\n * Determines if an element, or any of its ancestors, contain the given attribute\n * @param element - element to start searching at\n * @param attribute - the attribute to search for\n * @returns the value of the first instance found\n */\nexport function elementContainsAttribute(element, attribute, doc) {\n    var elementMatch = findElementRecursive(element, function (testElement) { return testElement.hasAttribute(attribute); }, doc);\n    return elementMatch && elementMatch.getAttribute(attribute);\n}\n//# sourceMappingURL=elementContainsAttribute.js.map","export default function debounce(fn) {\n  var pending;\n  return function () {\n    if (!pending) {\n      pending = new Promise(function (resolve) {\n        Promise.resolve().then(function () {\n          pending = undefined;\n          resolve(fn());\n        });\n      });\n    }\n\n    return pending;\n  };\n}","import { rgba } from './rgba.js';\nimport { isColorString } from './utils.js';\n\nfunction parseHex(v) {\n    var r = '';\n    var g = '';\n    var b = '';\n    var a = '';\n    if (v.length > 5) {\n        r = v.substr(1, 2);\n        g = v.substr(3, 2);\n        b = v.substr(5, 2);\n        a = v.substr(7, 2);\n    }\n    else {\n        r = v.substr(1, 1);\n        g = v.substr(2, 1);\n        b = v.substr(3, 1);\n        a = v.substr(4, 1);\n        r += r;\n        g += g;\n        b += b;\n        a += a;\n    }\n    return {\n        red: parseInt(r, 16),\n        green: parseInt(g, 16),\n        blue: parseInt(b, 16),\n        alpha: a ? parseInt(a, 16) / 255 : 1,\n    };\n}\nvar hex = {\n    test: isColorString('#'),\n    parse: parseHex,\n    transform: rgba.transform,\n};\n\nexport { hex };\n","import * as React from 'react';\nimport { useConst } from './useConst';\nimport { useIsomorphicLayoutEffect } from '@fluentui/utilities';\n/**\n * Modified `useCallback` that returns the same function reference every time, but internally calls\n * the most-recently passed callback implementation. Can be useful in situations such as:\n * - Event handler dependencies change too frequently, such as user props which might change on\n *   every render, or volatile values such as useState/useDispatch\n * - Callback must be referenced in a captured context (such as a window event handler or unmount\n *   handler that's registered once) but needs access to the latest props\n *\n * In general, prefer `useCallback` unless you've encountered one of the problems above.\n *\n * https://reactjs.org/docs/hooks-faq.html#how-to-read-an-often-changing-value-from-usecallback\n *\n * @param fn - The callback function that will be used\n * @returns A function which is referentially stable but internally calls the most recently passed callback\n */\nexport function useEventCallback(fn) {\n    var callbackRef = React.useRef(function () {\n        throw new Error('Cannot call an event handler while rendering');\n    });\n    useIsomorphicLayoutEffect(function () {\n        callbackRef.current = fn;\n    }, [fn]);\n    // useConst rather than useCallback to ensure the reference is always stable\n    // (useCallback's deps list is an optimization, not a guarantee)\n    return useConst(function () { return function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        var callback = callbackRef.current;\n        return callback.apply(void 0, args);\n    }; });\n}\n//# sourceMappingURL=useEventCallback.js.map","import { getStyleOptions } from './StyleOptionsState';\nimport { Stylesheet } from './Stylesheet';\nimport { serializeRuleEntries } from './styleToClassName';\n/**\n * Registers keyframe definitions.\n *\n * @public\n */\nexport function keyframes(timeline) {\n    var stylesheet = Stylesheet.getInstance();\n    var rulesArray = [];\n    for (var prop in timeline) {\n        if (timeline.hasOwnProperty(prop)) {\n            rulesArray.push(prop, '{', serializeRuleEntries(getStyleOptions(), timeline[prop]), '}');\n        }\n    }\n    var rules = rulesArray.join('');\n    var className = stylesheet.classNameFromKey(rules);\n    if (className) {\n        return className;\n    }\n    var name = stylesheet.getClassName();\n    stylesheet.insertRule(\"@keyframes \".concat(name, \"{\").concat(rules, \"}\"), true);\n    stylesheet.cacheClassName(name, rules, [], ['keyframes', rules]);\n    return name;\n}\n//# sourceMappingURL=keyframes.js.map","import { compareDatePart } from '../dateMath/dateMath';\n/**\n * Checks if `date` happens later than max date\n * @param date - date to check\n * @param options - object with max date to check against\n */\nexport var isAfterMaxDate = function (date, options) {\n    var maxDate = options.maxDate;\n    return maxDate ? compareDatePart(date, maxDate) >= 1 : false;\n};\n//# sourceMappingURL=isAfterMaxDate.js.map","// transform/index.ts\nexport * from \"prosemirror-transform\";\n","import { warning } from 'hey-listen';\nimport { clamp } from '../../utils/clamp.js';\n\nvar safeMin = 0.001;\nvar minDuration = 0.01;\nvar maxDuration = 10.0;\nvar minDamping = 0.05;\nvar maxDamping = 1;\nfunction findSpring(_a) {\n    var _b = _a.duration, duration = _b === void 0 ? 800 : _b, _c = _a.bounce, bounce = _c === void 0 ? 0.25 : _c, _d = _a.velocity, velocity = _d === void 0 ? 0 : _d, _e = _a.mass, mass = _e === void 0 ? 1 : _e;\n    var envelope;\n    var derivative;\n    warning(duration <= maxDuration * 1000, \"Spring duration must be 10 seconds or less\");\n    var dampingRatio = 1 - bounce;\n    dampingRatio = clamp(minDamping, maxDamping, dampingRatio);\n    duration = clamp(minDuration, maxDuration, duration / 1000);\n    if (dampingRatio < 1) {\n        envelope = function (undampedFreq) {\n            var exponentialDecay = undampedFreq * dampingRatio;\n            var delta = exponentialDecay * duration;\n            var a = exponentialDecay - velocity;\n            var b = calcAngularFreq(undampedFreq, dampingRatio);\n            var c = Math.exp(-delta);\n            return safeMin - (a / b) * c;\n        };\n        derivative = function (undampedFreq) {\n            var exponentialDecay = undampedFreq * dampingRatio;\n            var delta = exponentialDecay * duration;\n            var d = delta * velocity + velocity;\n            var e = Math.pow(dampingRatio, 2) * Math.pow(undampedFreq, 2) * duration;\n            var f = Math.exp(-delta);\n            var g = calcAngularFreq(Math.pow(undampedFreq, 2), dampingRatio);\n            var factor = -envelope(undampedFreq) + safeMin > 0 ? -1 : 1;\n            return (factor * ((d - e) * f)) / g;\n        };\n    }\n    else {\n        envelope = function (undampedFreq) {\n            var a = Math.exp(-undampedFreq * duration);\n            var b = (undampedFreq - velocity) * duration + 1;\n            return -safeMin + a * b;\n        };\n        derivative = function (undampedFreq) {\n            var a = Math.exp(-undampedFreq * duration);\n            var b = (velocity - undampedFreq) * (duration * duration);\n            return a * b;\n        };\n    }\n    var initialGuess = 5 / duration;\n    var undampedFreq = approximateRoot(envelope, derivative, initialGuess);\n    duration = duration * 1000;\n    if (isNaN(undampedFreq)) {\n        return {\n            stiffness: 100,\n            damping: 10,\n            duration: duration,\n        };\n    }\n    else {\n        var stiffness = Math.pow(undampedFreq, 2) * mass;\n        return {\n            stiffness: stiffness,\n            damping: dampingRatio * 2 * Math.sqrt(mass * stiffness),\n            duration: duration,\n        };\n    }\n}\nvar rootIterations = 12;\nfunction approximateRoot(envelope, derivative, initialGuess) {\n    var result = initialGuess;\n    for (var i = 1; i < rootIterations; i++) {\n        result = result - envelope(result) / derivative(result);\n    }\n    return result;\n}\nfunction calcAngularFreq(undampedFreq, dampingRatio) {\n    return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);\n}\n\nexport { calcAngularFreq, findSpring, maxDamping, maxDuration, minDamping, minDuration };\n","import getBasePlacement from \"../utils/getBasePlacement.js\";\nimport { top, left, right, placements } from \"../enums.js\"; // eslint-disable-next-line import/no-unused-modules\n\nexport function distanceAndSkiddingToXY(placement, rects, offset) {\n  var basePlacement = getBasePlacement(placement);\n  var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;\n\n  var _ref = typeof offset === 'function' ? offset(Object.assign({}, rects, {\n    placement: placement\n  })) : offset,\n      skidding = _ref[0],\n      distance = _ref[1];\n\n  skidding = skidding || 0;\n  distance = (distance || 0) * invertDistance;\n  return [left, right].indexOf(basePlacement) >= 0 ? {\n    x: distance,\n    y: skidding\n  } : {\n    x: skidding,\n    y: distance\n  };\n}\n\nfunction offset(_ref2) {\n  var state = _ref2.state,\n      options = _ref2.options,\n      name = _ref2.name;\n  var _options$offset = options.offset,\n      offset = _options$offset === void 0 ? [0, 0] : _options$offset;\n  var data = placements.reduce(function (acc, placement) {\n    acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);\n    return acc;\n  }, {});\n  var _data$state$placement = data[state.placement],\n      x = _data$state$placement.x,\n      y = _data$state$placement.y;\n\n  if (state.modifiersData.popperOffsets != null) {\n    state.modifiersData.popperOffsets.x += x;\n    state.modifiersData.popperOffsets.y += y;\n  }\n\n  state.modifiersData[name] = data;\n} // eslint-disable-next-line import/no-unused-modules\n\n\nexport default {\n  name: 'offset',\n  enabled: true,\n  phase: 'main',\n  requires: ['popperOffsets'],\n  fn: offset\n};","export default function getVariation(placement) {\n  return placement.split('-')[1];\n}","import { __assign, __spreadArray } from \"tslib\";\nimport * as React from 'react';\nimport { mergeCss } from '@fluentui/merge-styles';\nimport { getRTL, memoizeFunction } from '@fluentui/utilities';\nimport { assign } from './utilities';\n/**\n * This function is required for any module that uses slots.\n *\n * This function is a slot resolver that automatically evaluates slot functions to generate React elements.\n * A byproduct of this resolver is that it removes slots from the React hierarchy by bypassing React.createElement.\n *\n * To use this function on a per-file basis, use the jsx directive targeting withSlots.\n * This directive must be the FIRST LINE in the file to work correctly.\n * Usage of this pragma also requires withSlots import statement.\n *\n * See React.createElement\n */\n// Can't use typeof on React.createElement since it's overloaded. Approximate createElement's signature for now\n// and widen as needed.\nexport function withSlots(type, props) {\n    var children = [];\n    for (var _i = 2; _i < arguments.length; _i++) {\n        children[_i - 2] = arguments[_i];\n    }\n    var slotType = type;\n    if (slotType.isSlot) {\n        // Since we are bypassing createElement, use React.Children.toArray to make sure children are\n        // properly assigned keys.\n        // TODO: should this be mutating? does React mutate children subprop with createElement?\n        // TODO: will toArray clobber existing keys?\n        // TODO: React generates warnings because it doesn't detect hidden member _store that is set in createElement.\n        //        Even children passed to createElement without keys don't generate this warning.\n        //        Is there a better way to prevent slots from appearing in hierarchy? toArray doesn't address root issue.\n        children = React.Children.toArray(children);\n        // TODO: There is something weird going on here with children embedded in props vs. rest args.\n        // Comment out these lines to see. Make sure this function is doing the right things.\n        if (children.length === 0) {\n            return slotType(props);\n        }\n        return slotType(__assign(__assign({}, props), { children: children }));\n    }\n    else {\n        // TODO: Are there some cases where children should NOT be spread? Also, spreading reraises perf question.\n        //        Children had to be spread to avoid breaking KeytipData in Toggle.view:\n        //        react-dom.development.js:18931 Uncaught TypeError: children is not a function\n        //        Without spread, function child is a child array of one element\n        // TODO: is there a reason this can't be:\n        // return React.createElement.apply(this, arguments);\n        return React.createElement.apply(React, __spreadArray([type, props], children, false));\n    }\n}\n/**\n * This function creates factories that render ouput depending on the user ISlotProp props passed in.\n * @param DefaultComponent - Base component to render when not overridden by user props.\n * @param options - Factory options, including defaultProp value for shorthand prop mapping.\n * @returns ISlotFactory function used for rendering slots.\n */\nexport function createFactory(DefaultComponent, options) {\n    if (options === void 0) { options = {}; }\n    var _a = options.defaultProp, defaultProp = _a === void 0 ? 'children' : _a;\n    var result = function (componentProps, userProps, userSlotOptions, defaultStyles, theme) {\n        // If they passed in raw JSX, just return that.\n        if (React.isValidElement(userProps)) {\n            return userProps;\n        }\n        var flattenedUserProps = _translateShorthand(defaultProp, userProps);\n        var finalProps = _constructFinalProps(defaultStyles, theme, componentProps, flattenedUserProps);\n        if (userSlotOptions) {\n            if (userSlotOptions.component) {\n                // TODO: Remove cast if possible. This cast is needed because TS errors on the intrinsic portion of ReactType.\n                // return <userSlotOptions.component {...finalProps} />;\n                var UserComponent = userSlotOptions.component;\n                return React.createElement(UserComponent, __assign({}, finalProps));\n            }\n            if (userSlotOptions.render) {\n                return userSlotOptions.render(finalProps, DefaultComponent);\n            }\n        }\n        return React.createElement(DefaultComponent, __assign({}, finalProps));\n    };\n    return result;\n}\n/**\n * Default factory for components without explicit factories.\n */\nvar defaultFactory = memoizeFunction(function (type) { return createFactory(type); });\n/**\n * This function generates slots that can be used in JSX given a definition of slots and their corresponding types.\n * @param userProps - Props as pass to component.\n * @param slots - Slot definition object defining the default slot component for each slot.\n * @returns A set of created slots that components can render in JSX.\n */\nexport function getSlots(userProps, slots) {\n    var result = {};\n    // userProps already has default props mixed in by createComponent. Recast here to gain typing for this function.\n    var mixedProps = userProps;\n    var _loop_1 = function (name_1) {\n        if (slots.hasOwnProperty(name_1)) {\n            // This closure method requires the use of withSlots to prevent unnecessary rerenders. This is because React\n            // detects each closure as a different component (since it is a new instance) from the previous one and then\n            // forces a rerender of the entire slot subtree. For now, the only way to avoid this is to use withSlots, which\n            // bypasses the call to React.createElement.\n            var slot = function (componentProps) {\n                var args = [];\n                for (var _i = 1; _i < arguments.length; _i++) {\n                    args[_i - 1] = arguments[_i];\n                }\n                if (args.length > 0) {\n                    // If React.createElement is being incorrectly used with slots, there will be additional arguments.\n                    // We can detect these additional arguments and error on their presence.\n                    throw new Error('Any module using getSlots must use withSlots. Please see withSlots javadoc for more info.');\n                }\n                // TODO: having TS infer types here seems to cause infinite loop.\n                //   use explicit types or casting to preserve typing if possible.\n                // TODO: this should be a lookup on TProps property instead of being TProps directly, which is probably\n                //   causing the infinite loop\n                return _renderSlot(slots[name_1], \n                // TODO: this cast to any is hiding a relationship issue between the first two args\n                componentProps, mixedProps[name_1], mixedProps.slots && mixedProps.slots[name_1], \n                // _defaultStyles should always be present, but a check for existence is added to make view tests\n                // easier to use.\n                mixedProps._defaultStyles && mixedProps._defaultStyles[name_1], mixedProps.theme);\n            };\n            slot.isSlot = true;\n            result[name_1] = slot;\n        }\n    };\n    for (var name_1 in slots) {\n        _loop_1(name_1);\n    }\n    return result;\n}\n/**\n * Helper function that translates shorthand as needed.\n * @param defaultProp\n * @param slotProps\n */\nfunction _translateShorthand(defaultProp, slotProps) {\n    var _a;\n    var transformedProps;\n    if (typeof slotProps === 'string' || typeof slotProps === 'number' || typeof slotProps === 'boolean') {\n        transformedProps = (_a = {},\n            _a[defaultProp] = slotProps,\n            _a);\n    }\n    else {\n        transformedProps = slotProps;\n    }\n    return transformedProps;\n}\n/**\n * Helper function that constructs final styles and props given a series of props ordered by increasing priority.\n */\nfunction _constructFinalProps(defaultStyles, theme) {\n    var allProps = [];\n    for (var _i = 2; _i < arguments.length; _i++) {\n        allProps[_i - 2] = arguments[_i];\n    }\n    var finalProps = {};\n    var classNames = [];\n    for (var _a = 0, allProps_1 = allProps; _a < allProps_1.length; _a++) {\n        var props = allProps_1[_a];\n        classNames.push(props && props.className);\n        assign(finalProps, props);\n    }\n    finalProps.className = mergeCss([defaultStyles, classNames], { rtl: getRTL(theme) });\n    return finalProps;\n}\n/**\n * Render a slot given component and user props. Uses component factory if available, otherwise falls back\n * to default factory.\n * @param ComponentType Factory component type.\n * @param componentProps The properties passed into slot from within the component.\n * @param userProps The user properties passed in from outside of the component.\n */\nfunction _renderSlot(ComponentType, componentProps, userProps, slotOptions, defaultStyles, theme) {\n    if (ComponentType.create !== undefined) {\n        return ComponentType.create(componentProps, userProps, slotOptions, defaultStyles);\n    }\n    else {\n        // TODO: need to resolve typing / generic issues passing through memoizeFunction. for now, cast to 'unknown'\n        return defaultFactory(ComponentType)(componentProps, userProps, slotOptions, defaultStyles, theme);\n    }\n}\n//# sourceMappingURL=slots.js.map","function decay(_a) {\n    var _b = _a.velocity, velocity = _b === void 0 ? 0 : _b, _c = _a.from, from = _c === void 0 ? 0 : _c, _d = _a.power, power = _d === void 0 ? 0.8 : _d, _e = _a.timeConstant, timeConstant = _e === void 0 ? 350 : _e, _f = _a.restDelta, restDelta = _f === void 0 ? 0.5 : _f, modifyTarget = _a.modifyTarget;\n    var state = { done: false, value: from };\n    var amplitude = power * velocity;\n    var ideal = from + amplitude;\n    var target = modifyTarget === undefined ? ideal : modifyTarget(ideal);\n    if (target !== ideal)\n        amplitude = target - from;\n    return {\n        next: function (t) {\n            var delta = -amplitude * Math.exp(-t / timeConstant);\n            state.done = !(delta > restDelta || delta < -restDelta);\n            state.value = state.done ? target : target + delta;\n            return state;\n        },\n        flipTarget: function () { },\n    };\n}\n\nexport { decay };\n","import getUAString from \"../utils/userAgent.js\";\nexport default function isLayoutViewport() {\n  return !/^((?!chrome|android).)*safari/i.test(getUAString());\n}","import { DATA_BUCKET_ATTR, DATA_PRIORITY_ATTR } from '../constants.esm.js';\nimport { createIsomorphicStyleSheet } from './createIsomorphicStyleSheet.esm.js';\n\n/**\n * Ordered style buckets using their short pseudo name.\n *\n * @internal\n */\nconst styleBucketOrdering = [\n// reset styles\n'r',\n// catch-all\n'd',\n// link\n'l',\n// visited\n'v',\n// focus-within\n'w',\n// focus\n'f',\n// focus-visible\n'i',\n// hover\n'h',\n// active\n'a',\n// at rules for reset styles\n's',\n// keyframes\n'k',\n// at-rules\n't',\n// @media rules\n'm',\n// @container rules\n'c'];\n// avoid repeatedly calling `indexOf` to determine order during new insertions\nconst styleBucketOrderingMap = /*#__PURE__*/styleBucketOrdering.reduce((acc, cur, j) => {\n  acc[cur] = j;\n  return acc;\n}, {});\nfunction getStyleSheetKey(bucketName, media, priority) {\n  return (bucketName === 'm' ? bucketName + media : bucketName) + priority;\n}\nfunction getStyleSheetKeyFromElement(styleEl) {\n  var _a;\n  const bucketName = styleEl.getAttribute(DATA_BUCKET_ATTR);\n  const priority = (_a = styleEl.getAttribute(DATA_PRIORITY_ATTR)) !== null && _a !== void 0 ? _a : '0';\n  return getStyleSheetKey(bucketName, styleEl.media, priority);\n}\n/**\n * Lazily adds a `<style>` bucket to the `<head>`. This will ensure that the style buckets are ordered.\n */\nfunction getStyleSheetForBucket(bucketName, targetDocument, insertionPoint, renderer, metadata = {}) {\n  var _a, _b;\n  const isMediaBucket = bucketName === 'm';\n  const media = (_a = metadata['m']) !== null && _a !== void 0 ? _a : '0';\n  const priority = (_b = metadata['p']) !== null && _b !== void 0 ? _b : 0;\n  const stylesheetKey = getStyleSheetKey(bucketName, media, priority);\n  if (!renderer.stylesheets[stylesheetKey]) {\n    const tag = targetDocument && targetDocument.createElement('style');\n    const stylesheet = createIsomorphicStyleSheet(tag, bucketName, priority, Object.assign({}, renderer.styleElementAttributes, isMediaBucket && {\n      media\n    }));\n    renderer.stylesheets[stylesheetKey] = stylesheet;\n    if (targetDocument && tag) {\n      targetDocument.head.insertBefore(tag, findInsertionPoint(targetDocument, insertionPoint, bucketName, renderer, metadata));\n    }\n  }\n  return renderer.stylesheets[stylesheetKey];\n}\nfunction isSameInsertionKey(element, bucketName, metadata) {\n  var _a, _b;\n  const targetKey = bucketName + ((_a = metadata['m']) !== null && _a !== void 0 ? _a : '');\n  const elementKey = element.getAttribute(DATA_BUCKET_ATTR) + ((_b = element.media) !== null && _b !== void 0 ? _b : '');\n  return targetKey === elementKey;\n}\n/**\n * Finds an element before which the new bucket style element should be inserted following the bucket sort order.\n *\n * @param targetDocument - A document\n * @param insertionPoint - An element that will be used as an initial insertion point\n * @param targetBucket - The bucket that should be inserted to DOM\n * @param renderer - Griffel renderer\n * @param metadata - metadata for CSS rule\n * @returns - Smallest style element with greater sort order than the current bucket\n */\nfunction findInsertionPoint(targetDocument, insertionPoint, targetBucket, renderer, metadata = {}) {\n  var _a, _b;\n  const targetOrder = styleBucketOrderingMap[targetBucket];\n  const media = (_a = metadata['m']) !== null && _a !== void 0 ? _a : '';\n  const priority = (_b = metadata['p']) !== null && _b !== void 0 ? _b : 0;\n  // Similar to javascript sort comparators where\n  // a positive value is increasing sort order\n  // a negative value is decreasing sort order\n  let comparer = el => targetOrder - styleBucketOrderingMap[el.getAttribute(DATA_BUCKET_ATTR)];\n  let styleElements = targetDocument.head.querySelectorAll(`[${DATA_BUCKET_ATTR}]`);\n  if (targetBucket === 'm') {\n    const mediaElements = targetDocument.head.querySelectorAll(`[${DATA_BUCKET_ATTR}=\"${targetBucket}\"]`);\n    // only reduce the scope of the search and change comparer\n    // if there are other media buckets already on the page\n    if (mediaElements.length) {\n      styleElements = mediaElements;\n      comparer = el => renderer.compareMediaQueries(media, el.media);\n    }\n  }\n  const comparerWithPriority = el => {\n    if (isSameInsertionKey(el, targetBucket, metadata)) {\n      return priority - Number(el.getAttribute('data-priority'));\n    }\n    return comparer(el);\n  };\n  const length = styleElements.length;\n  let index = length - 1;\n  while (index >= 0) {\n    const styleElement = styleElements.item(index);\n    if (comparerWithPriority(styleElement) > 0) {\n      return styleElement.nextSibling;\n    }\n    index--;\n  }\n  if (length > 0) {\n    return styleElements.item(0);\n  }\n  return insertionPoint ? insertionPoint.nextSibling : null;\n}\n\nexport { getStyleSheetForBucket, getStyleSheetKey, getStyleSheetKeyFromElement, styleBucketOrdering };\n//# sourceMappingURL=getStyleSheetForBucket.esm.js.map\n","import { addDays, compareDates, getDateRangeArray, isInDateRangeArray } from '../dateMath/dateMath';\nimport { DAYS_IN_WEEK } from '../dateValues/dateValues';\nimport { getDateRangeTypeToUse } from './getDateRangeTypeToUse';\nimport { getBoundedDateRange } from './getBoundedDateRange';\nimport { isRestrictedDate } from './isRestrictedDate';\n/**\n * Generates a grid of days, given the `options`.\n * Returns one additional week at the begining from the previous range\n * and one at the end from the future range\n * @param options - parameters to specify date related restrictions for the resulting grid\n */\nexport var getDayGrid = function (options) {\n    var selectedDate = options.selectedDate, dateRangeType = options.dateRangeType, firstDayOfWeek = options.firstDayOfWeek, today = options.today, minDate = options.minDate, maxDate = options.maxDate, weeksToShow = options.weeksToShow, workWeekDays = options.workWeekDays, daysToSelectInDayView = options.daysToSelectInDayView, restrictedDates = options.restrictedDates, markedDays = options.markedDays;\n    var restrictedDateOptions = { minDate: minDate, maxDate: maxDate, restrictedDates: restrictedDates };\n    var todaysDate = today || new Date();\n    var navigatedDate = options.navigatedDate ? options.navigatedDate : todaysDate;\n    var date;\n    if (weeksToShow && weeksToShow <= 4) {\n        // if showing less than a full month, just use date == navigatedDate\n        date = new Date(navigatedDate.getFullYear(), navigatedDate.getMonth(), navigatedDate.getDate());\n    }\n    else {\n        date = new Date(navigatedDate.getFullYear(), navigatedDate.getMonth(), 1);\n    }\n    var weeks = [];\n    // Cycle the date backwards to get to the first day of the week.\n    while (date.getDay() !== firstDayOfWeek) {\n        date.setDate(date.getDate() - 1);\n    }\n    // add the transition week as last week of previous range\n    date = addDays(date, -DAYS_IN_WEEK);\n    // a flag to indicate whether all days of the week are outside the month\n    var isAllDaysOfWeekOutOfMonth = false;\n    // in work week view if the days aren't contiguous we use week view instead\n    var selectedDateRangeType = getDateRangeTypeToUse(dateRangeType, workWeekDays, firstDayOfWeek);\n    var selectedDates = [];\n    if (selectedDate) {\n        selectedDates = getDateRangeArray(selectedDate, selectedDateRangeType, firstDayOfWeek, workWeekDays, daysToSelectInDayView);\n        selectedDates = getBoundedDateRange(selectedDates, minDate, maxDate);\n    }\n    var shouldGetWeeks = true;\n    for (var weekIndex = 0; shouldGetWeeks; weekIndex++) {\n        var week = [];\n        isAllDaysOfWeekOutOfMonth = true;\n        var _loop_1 = function (dayIndex) {\n            var originalDate = new Date(date.getTime());\n            var dayInfo = {\n                key: date.toString(),\n                date: date.getDate().toString(),\n                originalDate: originalDate,\n                isInMonth: date.getMonth() === navigatedDate.getMonth(),\n                isToday: compareDates(todaysDate, date),\n                isSelected: isInDateRangeArray(date, selectedDates),\n                isInBounds: !isRestrictedDate(date, restrictedDateOptions),\n                isMarked: (markedDays === null || markedDays === void 0 ? void 0 : markedDays.some(function (markedDay) { return compareDates(originalDate, markedDay); })) || false,\n            };\n            week.push(dayInfo);\n            if (dayInfo.isInMonth) {\n                isAllDaysOfWeekOutOfMonth = false;\n            }\n            date.setDate(date.getDate() + 1);\n        };\n        for (var dayIndex = 0; dayIndex < DAYS_IN_WEEK; dayIndex++) {\n            _loop_1(dayIndex);\n        }\n        // We append the condition of the loop depending upon the showSixWeeksByDefault prop.\n        shouldGetWeeks = weeksToShow ? weekIndex < weeksToShow + 1 : !isAllDaysOfWeekOutOfMonth || weekIndex === 0;\n        // we don't check shouldGetWeeks before pushing because we want to add one extra week for transition state\n        weeks.push(week);\n    }\n    return weeks;\n};\n//# sourceMappingURL=getDayGrid.js.map","import { __assign } from 'tslib';\nimport { clamp } from '../utils.js';\n\nvar number = {\n    test: function (v) { return typeof v === 'number'; },\n    parse: parseFloat,\n    transform: function (v) { return v; },\n};\nvar alpha = __assign(__assign({}, number), { transform: clamp(0, 1) });\nvar scale = __assign(__assign({}, number), { default: 1 });\n\nexport { alpha, number, scale };\n","/** PURE_IMPORTS_START _Subscriber PURE_IMPORTS_END */\nimport { Subscriber } from '../Subscriber';\nexport function canReportError(observer) {\n    while (observer) {\n        var _a = observer, closed_1 = _a.closed, destination = _a.destination, isStopped = _a.isStopped;\n        if (closed_1 || isStopped) {\n            return false;\n        }\n        else if (destination && destination instanceof Subscriber) {\n            observer = destination;\n        }\n        else {\n            observer = null;\n        }\n    }\n    return true;\n}\n//# sourceMappingURL=canReportError.js.map\n","import { DateRangeType } from '../dateValues/dateValues';\nimport { isContiguous } from './isContiguous';\n/**\n * Return corrected date range type, given `dateRangeType` and list of working days.\n * For non-contiguous working days and working week range type, returns general week range type.\n * For other cases returns input date range type.\n * @param dateRangeType - input type of range\n * @param workWeekDays - list of working days in a week\n */\nexport var getDateRangeTypeToUse = function (dateRangeType, workWeekDays, firstDayOfWeek) {\n    if (workWeekDays && dateRangeType === DateRangeType.WorkWeek) {\n        if (!isContiguous(workWeekDays, true, firstDayOfWeek) || workWeekDays.length === 0) {\n            return DateRangeType.Week;\n        }\n    }\n    return dateRangeType;\n};\n//# sourceMappingURL=getDateRangeTypeToUse.js.map","/**\n * Verifies if an application can use DOM.\n */\nfunction canUseDOM() {\n  return typeof window !== 'undefined' && !!(window.document && window.document.createElement);\n}\n\nexport { canUseDOM };\n//# sourceMappingURL=canUseDOM.esm.js.map\n","import { buildClassMap } from '../utilities/index';\nimport { AnimationStyles } from '../styles/index';\n/**\n * {@docCategory AnimationClassNames}\n */\nexport var AnimationClassNames = buildClassMap(AnimationStyles);\n//# sourceMappingURL=AnimationClassNames.js.map","/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Subscriber } from '../Subscriber';\nexport function filter(predicate, thisArg) {\n    return function filterOperatorFunction(source) {\n        return source.lift(new FilterOperator(predicate, thisArg));\n    };\n}\nvar FilterOperator = /*@__PURE__*/ (function () {\n    function FilterOperator(predicate, thisArg) {\n        this.predicate = predicate;\n        this.thisArg = thisArg;\n    }\n    FilterOperator.prototype.call = function (subscriber, source) {\n        return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));\n    };\n    return FilterOperator;\n}());\nvar FilterSubscriber = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(FilterSubscriber, _super);\n    function FilterSubscriber(destination, predicate, thisArg) {\n        var _this = _super.call(this, destination) || this;\n        _this.predicate = predicate;\n        _this.thisArg = thisArg;\n        _this.count = 0;\n        return _this;\n    }\n    FilterSubscriber.prototype._next = function (value) {\n        var result;\n        try {\n            result = this.predicate.call(this.thisArg, value, this.count++);\n        }\n        catch (err) {\n            this.destination.error(err);\n            return;\n        }\n        if (result) {\n            this.destination.next(value);\n        }\n    };\n    return FilterSubscriber;\n}(Subscriber));\n//# sourceMappingURL=filter.js.map\n","/** PURE_IMPORTS_START  PURE_IMPORTS_END */\nexport function hostReportError(err) {\n    setTimeout(function () { throw err; }, 0);\n}\n//# sourceMappingURL=hostReportError.js.map\n","import { modifierPhases } from \"../enums.js\"; // source: https://stackoverflow.com/questions/49875255\n\nfunction order(modifiers) {\n  var map = new Map();\n  var visited = new Set();\n  var result = [];\n  modifiers.forEach(function (modifier) {\n    map.set(modifier.name, modifier);\n  }); // On visiting object, check for its dependencies and visit them recursively\n\n  function sort(modifier) {\n    visited.add(modifier.name);\n    var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);\n    requires.forEach(function (dep) {\n      if (!visited.has(dep)) {\n        var depModifier = map.get(dep);\n\n        if (depModifier) {\n          sort(depModifier);\n        }\n      }\n    });\n    result.push(modifier);\n  }\n\n  modifiers.forEach(function (modifier) {\n    if (!visited.has(modifier.name)) {\n      // check for visited object\n      sort(modifier);\n    }\n  });\n  return result;\n}\n\nexport default function orderModifiers(modifiers) {\n  // order based on dependencies\n  var orderedModifiers = order(modifiers); // order based on phase\n\n  return modifierPhases.reduce(function (acc, phase) {\n    return acc.concat(orderedModifiers.filter(function (modifier) {\n      return modifier.phase === phase;\n    }));\n  }, []);\n}","import toPropertyKey from \"./toPropertyKey.js\";\nexport default function _defineProperty(obj, key, value) {\n  key = toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}"],"mappings":";;;;;;;;;;;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACRA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC7IA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACdA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACxBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AClRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC9DA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACvCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AChRA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACXA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACtCA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACPA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAsDA;;;;;;;;;;;;;;ACt4EA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACPA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACNA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACzFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACrEA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACPA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC9BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACzNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACpFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACznBA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AChBA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACrEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClJA;AAAA;AACA;AACA;;;;;;;;;;;;;ACFA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC5CA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjDA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACxCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACzDA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACjDA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC/CA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClBA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACRA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACdA;AAAA;AACA;AACA;;;;;;;;;;;;;ACFA;AAAA;AAAA;AACA;AACA;;;;;;;;;;;;;ACFA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtBA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACbA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACfA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;ACDA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACjEA;AAAA;;;;;;;;;;;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACzBA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACvDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC1jEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACrCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC3BA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACbA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACtBA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACtBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACvrCA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClBA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACJA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC5BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtIA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtBA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC5BA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjFA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACpGA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnWA;;;;;;;;;;;;;ACAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACrDA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACjBA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACLA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC7FA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACXA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC3FA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC7DA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;ACDA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACfA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACpDA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AClBA;AAAA;AAAA;AACA;AACA;AACA;;;;;;;;;;;;;ACHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACjXA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACJA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACLA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACNA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC1+BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACxOA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC3EA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnBA;AACA;AACA,aAEA;AACA;AACA;;;;;;;;;;;;;;ACNA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC1DA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnBA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACdA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnFA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACvLA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACrCA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC9BA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC9BA;AAAA;AACA;AACA;AACA;;;;;;;;;;;;;ACHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACpKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC5vDA;AACA;AACA,WACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACvBA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC7jBA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC56BA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACRA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACzBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACnHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC5DA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACbA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AChFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACjBA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC5BA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;ACDA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AClDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACzVA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACNA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACPA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC5CA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACfA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACTA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACxxBA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACfA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACzCA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACTA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACxBA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC3BA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AClEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC3IA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC1CA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC1CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClFA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACZA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACpDA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnXA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AClLA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;ACDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC5BA;AAAA;AAAA;AACA;AACA;AACA;;;;;;;;;;;;;ACHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC7bA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACpDA;AAAA;AAAA;AAAA;AACA;AACA;;;;;;;;;;;;;ACFA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACLA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC9CA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACnBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AChEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACpBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC7NA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACNA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACVA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACrCA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjBA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC/EA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACzHA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACRA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACtDA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;ACDA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC9BA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACRA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACrBA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACxBA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC3BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC5xBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACp0BA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACTA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACVA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACr7EA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC1CA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACrEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACxGA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC9MA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACj6CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AClBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC3BA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACZA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACxFA;AAAA;AACA;AACA;;;;;;;;;;;;;ACFA;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACLA;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACLA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC9BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC5OA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtuCA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACLA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACxBA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACpEA;AAAA;AACA;AACA;;;;;;;;;;;;;ACFA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACNA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACxGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACxKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtGA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC3BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACxmCA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC7CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACrxBA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC9BA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACjBA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACVA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACZA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjCA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACzBA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACnEA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC9CA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACzBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC5FA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACPA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AChCA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACpNA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACVA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACxKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACxBA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACfA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACZA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACPA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC/DA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtDA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC5xEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACrJA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACPA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;ACDA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACxBA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACJA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACjBA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACTA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACRA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACr9DA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AChDA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACnCA;AACA;AACA;AACA;;;;;;;;;;;;;ACHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACvCA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACrBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC7JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACnBA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACxJA;AACA;AACA;AACA;;;;;;;;;;;;;ACHA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC/EA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC/JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACzLA;AAAA;AAAA;AACA;AACA;AACA;;;;;;;;;;;;;ACHA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACnEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;ACDA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACZA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACvBA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACZA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACxDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AChEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACxIA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC/BA;;;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACLA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACTA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC3BA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjFA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC/EA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC5HA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACJA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC9FA;AAAA;AACA;;;;;;;;;;;;;;ACDA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACzKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC5EA;AAAA;AACA;AACA;;;;;;;;;;;;;ACFA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AClBA;AAAA;AACA;AACA;;;;;;;;;;;;;ACFA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACbA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACzDA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClDA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACvFA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AChCA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACjBA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACJA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC1SA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AChBA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC1BA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC3DA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AChDA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC/CA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC1BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC9CA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACzFA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACXA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACtDA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC1BA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACVA;AAAA;AAAA;AAAA;AACA;AACA;AACA;;;;;;;;;;;;;ACHA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACPA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACPA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtBA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACVA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACfA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACZA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC7BA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACfA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC1IA;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACTA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtBA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC5DA;AACA;AACA;AACA;;;;;;;;;;;;;ACHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACrMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC9LA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACXA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC3OA;AAAA;AACA;;;;;;;;;;;;;ACDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC9QA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACpBA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACPA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AChCA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC/CA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACVA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC9CA;AAAA;AACA;AACA;;;;;;;;;;;;;ACFA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACJA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACRA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC1BA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACbA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC7EA;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACLA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACpJA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC9FA;AAAA;AACA;AACA;;;;;;;;;;;;;;ACFA;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACLA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;ACDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AChEA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClBA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACzCA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACXA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACdA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACrCA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACpCA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC1BA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACVA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;ACDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC/EA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACrDA;AAAA;AACA;AACA;;;;;;;;;;;;;ACFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACxLA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACnBA;AAAA;AAAA;AACA;AACA;AACA;;;;;;;;;;;;;ACHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACjIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACxEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACXA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACjBA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjBA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACRA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACNA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC1CA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACJA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC3CA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;A","sourceRoot":""}